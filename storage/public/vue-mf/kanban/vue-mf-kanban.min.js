var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __vite_style__ = document.createElement("style");
__vite_style__.innerHTML = `.kanban-row .kanban-row-title[data-v-743da1a3] {
  display: flex;
  justify-content: center;
  background-color: rgba(203, 216, 253, 0.5);
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
  font-weight: 500;
  text-transform: uppercase;
}
.kanban-row .kanban-row-title:hover .kanban-row-controls[data-v-743da1a3] {
  display: block;
}
.kanban-row .kanban-row-title .kanban-row-controls[data-v-743da1a3] {
  display: none;
}
.kanban-row .kanban-row-title .kanban-row-controls button[data-v-743da1a3] {
  vertical-align: baseline;
}.kanban-card {
  position: relative;
  margin-bottom: 10px;
  border: none;
  border-radius: 8px;
  background: #fff;
  box-shadow: 0px 3px 20px -12px #b5b6ba;
}
.kanban-card .kanban-card-menu {
  position: absolute;
  top: 0;
  right: 0;
  padding: 0.4rem;
}
.kanban-card .kanban-card-body {
  padding: 0.85rem;
}
.kanban-card .kanban-card-title {
  font-weight: 500;
  line-height: 1.4;
}
.kanban-card .kanban-card-text {
  color: #5c5c5c;
  line-height: 1.4;
  font-size: 0.95rem;
}
.slide-fade-enter-active {
  transition: all 0.15s ease-out;
}
.slide-fade-leave-active {
  transition: all 0.2s cubic-bezier(1, 0.5, 0.8, 1);
}
.slide-fade-enter-from,
.slide-fade-leave-to {
  transform: translateX(20px);
  opacity: 0;
}[data-v-5f909173] .card-body {
  padding: 3px;
}
.btn-default[data-v-5f909173]:hover {
  background-color: rgba(9, 30, 66, 0.08);
}.button-container[data-v-62c53c17] {
  width: 18rem;
  min-width: 18rem;
}
.btn-default[data-v-62c53c17]:hover {
  background-color: rgba(9, 30, 66, 0.08);
}[data-v-01b8ad26] .card-body {
  padding: 0;
}
.add-cart-container[data-v-01b8ad26] {
  padding: 10px;
}
.btn-default[data-v-01b8ad26]:hover {
  background-color: rgba(9, 30, 66, 0.08);
}.btn-default[data-v-bfeaa5de]:hover {
  background-color: rgba(9, 30, 66, 0.08);
}.kanban-column[data-v-35b181c6] {
  display: flex;
  flex-direction: column;
  min-width: 18rem;
  width: 18rem;
  flex-grow: 1;
  margin: 0 1px;
}
.kanban-column[data-v-35b181c6]:first-child {
  margin-left: 0;
}
.kanban-column[data-v-35b181c6]:last-child {
  margin-right: 0;
}
.kanban-column .kanban-column-header[data-v-35b181c6] {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 5px 5px 5px 10px;
  border-bottom: 1px solid #fff;
  background: rgba(219, 218, 241, 0.65);
}
.kanban-column .kanban-column-header h6 span[data-v-35b181c6] {
  font-size: 1.05rem;
}
.kanban-column .kanban-column-body[data-v-35b181c6] {
  background-color: rgba(246, 251, 255, 0.7);
}.btn-default[data-v-7ce40aac]:hover {
  background-color: rgba(9, 30, 66, 0.08);
}
.editable-container[data-v-7ce40aac] {
  position: relative;
}
.editable-container .form-control[data-v-7ce40aac] {
  font-weight: 500;
  line-height: 1.2;
}
.editable-controls[data-v-7ce40aac] {
  position: absolute;
  right: 0;
}.container-cards[data-v-50651a6c] {
  flex-grow: 1;
  position: relative;
  max-height: 800px;
  padding: 10px;
}
.dragging-card[data-v-50651a6c] {
  opacity: 1 !important;
}
.dragging-card.kanban-card[data-v-50651a6c] {
  transform: rotate(4deg);
}
.card-menu a[data-v-50651a6c] {
  background-color: rgba(255, 255, 255, 0.75);
  color: #383838;
  font-size: 1.5rem;
}
.card-menu a[data-v-50651a6c]:hover {
  color: #007bff;
}
[data-v-50651a6c] .kanban-card {
  cursor: pointer;
}
.ghost-card[data-v-50651a6c] {
  position: relative;
}
.ghost-card.kanban-card[data-v-50651a6c]::after {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  background-color: #e8e9f3;
  border-radius: 8px;
}.btn-default[data-v-d4a11364]:hover {
  background-color: rgba(9, 30, 66, 0.08);
}
.editable-container[data-v-d4a11364] {
  position: relative;
}
.editable-container .form-control[data-v-d4a11364] {
  font-size: 1.5rem;
  font-weight: 500;
  line-height: 1.2;
}
.editable-controls[data-v-d4a11364] {
  position: absolute;
  right: 0;
}.container-cells[data-v-792774b4] {
  display: flex;
}
.dragging-cell[data-v-792774b4] {
  cursor: pointer;
  transform: rotate(4deg);
  opacity: 1 !important;
}
.ghost-cell .container-cards[data-v-792774b4]::after {
  content: "";
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
  background-color: rgba(233, 231, 255, 0.45);
  border-radius: 8px;
}
[data-v-792774b4] .f-modal-container {
  width: 100%;
  overflow-x: hidden;
  overflow-y: auto;
}
[data-v-792774b4] .f-modal-container .f-modal-close {
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
}
[data-v-792774b4] .f-modal-content {
  position: relative;
  display: flex;
  flex-direction: column;
  max-width: 960px;
  width: 100%;
  min-height: 75%;
  margin: 48px auto 80px auto;
  padding: 1rem;
  border: 1px solid #e2e8f0;
  border-radius: 0.25rem;
  background: #fff;
}
.modal__title[data-v-792774b4] {
  font-size: 1.5rem;
  font-weight: 700;
}.kanban-container[data-v-0390af22] {
  border-radius: 6px;
  background-size: cover;
  background-color: rgba(115, 155, 183, 0.18);
}
.board-container[data-v-0390af22] {
  flex-grow: 1;
}
.navbar[data-v-0390af22] {
  border-top-left-radius: 6px;
  border-top-right-radius: 6px;
  background: rgba(212, 225, 255, 0.45);
}.bee-angle{transform:rotate(90deg)}.bee-angle>*{display:inline-block;vertical-align:middle}.bee-angle.zero-right{transform:rotate(180deg)}.bee-angle.zero-bottom{transform:rotate(270deg)}.bee-angle__round{position:relative;margin-left:8px;width:16px;height:16px;border:1px solid #666;border-radius:50%;cursor:pointer;display:inline-block;vertical-align:middle}.bee-angle__round:before{content:"";position:absolute;top:50%;left:0;transform:translateY(-50%);width:50%;height:1px;background-color:#666}
/*
 * Container style
 */
.ps {
  overflow: hidden !important;
  overflow-anchor: none;
  -ms-overflow-style: none;
  touch-action: auto;
  -ms-touch-action: auto;
}
/*
 * Scrollbar rail styles
 */
.ps__rail-x {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  height: 15px;
  /* there must be 'bottom' or 'top' for ps__rail-x */
  bottom: 0px;
  /* please don't change 'position' */
  position: absolute;
}
.ps__rail-y {
  display: none;
  opacity: 0;
  transition: background-color .2s linear, opacity .2s linear;
  -webkit-transition: background-color .2s linear, opacity .2s linear;
  width: 15px;
  /* there must be 'right' or 'left' for ps__rail-y */
  right: 0;
  /* please don't change 'position' */
  position: absolute;
}
.ps--active-x > .ps__rail-x,
.ps--active-y > .ps__rail-y {
  display: block;
  background-color: transparent;
}
.ps:hover > .ps__rail-x,
.ps:hover > .ps__rail-y,
.ps--focus > .ps__rail-x,
.ps--focus > .ps__rail-y,
.ps--scrolling-x > .ps__rail-x,
.ps--scrolling-y > .ps__rail-y {
  opacity: 0.6;
}
.ps .ps__rail-x:hover,
.ps .ps__rail-y:hover,
.ps .ps__rail-x:focus,
.ps .ps__rail-y:focus,
.ps .ps__rail-x.ps--clicking,
.ps .ps__rail-y.ps--clicking {
  background-color: #eee;
  opacity: 0.9;
}
/*
 * Scrollbar thumb styles
 */
.ps__thumb-x {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, height .2s ease-in-out;
  -webkit-transition: background-color .2s linear, height .2s ease-in-out;
  height: 6px;
  /* there must be 'bottom' for ps__thumb-x */
  bottom: 2px;
  /* please don't change 'position' */
  position: absolute;
}
.ps__thumb-y {
  background-color: #aaa;
  border-radius: 6px;
  transition: background-color .2s linear, width .2s ease-in-out;
  -webkit-transition: background-color .2s linear, width .2s ease-in-out;
  width: 6px;
  /* there must be 'right' for ps__thumb-y */
  right: 2px;
  /* please don't change 'position' */
  position: absolute;
}
.ps__rail-x:hover > .ps__thumb-x,
.ps__rail-x:focus > .ps__thumb-x,
.ps__rail-x.ps--clicking .ps__thumb-x {
  background-color: #999;
  height: 11px;
}
.ps__rail-y:hover > .ps__thumb-y,
.ps__rail-y:focus > .ps__thumb-y,
.ps__rail-y.ps--clicking .ps__thumb-y {
  background-color: #999;
  width: 11px;
}
/* MS supports */
@supports (-ms-overflow-style: none) {
  .ps {
    overflow: auto !important;
  }
}
@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
  .ps {
    overflow: auto !important;
  }
}
.ps {
    position: relative;
}/* sass-plugin-1:/Users/maronato/Developer/vue-toastification/src/scss/index.scss */
.Vue-Toastification__container {
  z-index: 9999;
  position: fixed;
  padding: 4px;
  width: 600px;
  box-sizing: border-box;
  display: flex;
  min-height: 100%;
  color: #fff;
  flex-direction: column;
  pointer-events: none;
}
@media only screen and (min-width : 600px) {
  .Vue-Toastification__container.top-left,
  .Vue-Toastification__container.top-right,
  .Vue-Toastification__container.top-center {
    top: 1em;
  }
  .Vue-Toastification__container.bottom-left,
  .Vue-Toastification__container.bottom-right,
  .Vue-Toastification__container.bottom-center {
    bottom: 1em;
    flex-direction: column-reverse;
  }
  .Vue-Toastification__container.top-left,
  .Vue-Toastification__container.bottom-left {
    left: 1em;
  }
  .Vue-Toastification__container.top-left .Vue-Toastification__toast,
  .Vue-Toastification__container.bottom-left .Vue-Toastification__toast {
    margin-right: auto;
  }
  @supports not (-moz-appearance: none) {
    .Vue-Toastification__container.top-left .Vue-Toastification__toast--rtl,
    .Vue-Toastification__container.bottom-left .Vue-Toastification__toast--rtl {
      margin-right: unset;
      margin-left: auto;
    }
  }
  .Vue-Toastification__container.top-right,
  .Vue-Toastification__container.bottom-right {
    right: 1em;
  }
  .Vue-Toastification__container.top-right .Vue-Toastification__toast,
  .Vue-Toastification__container.bottom-right .Vue-Toastification__toast {
    margin-left: auto;
  }
  @supports not (-moz-appearance: none) {
    .Vue-Toastification__container.top-right .Vue-Toastification__toast--rtl,
    .Vue-Toastification__container.bottom-right .Vue-Toastification__toast--rtl {
      margin-left: unset;
      margin-right: auto;
    }
  }
  .Vue-Toastification__container.top-center,
  .Vue-Toastification__container.bottom-center {
    left: 50%;
    margin-left: -300px;
  }
  .Vue-Toastification__container.top-center .Vue-Toastification__toast,
  .Vue-Toastification__container.bottom-center .Vue-Toastification__toast {
    margin-left: auto;
    margin-right: auto;
  }
}
@media only screen and (max-width : 600px) {
  .Vue-Toastification__container {
    width: 100vw;
    padding: 0;
    left: 0;
    margin: 0;
  }
  .Vue-Toastification__container .Vue-Toastification__toast {
    width: 100%;
  }
  .Vue-Toastification__container.top-left,
  .Vue-Toastification__container.top-right,
  .Vue-Toastification__container.top-center {
    top: 0;
  }
  .Vue-Toastification__container.bottom-left,
  .Vue-Toastification__container.bottom-right,
  .Vue-Toastification__container.bottom-center {
    bottom: 0;
    flex-direction: column-reverse;
  }
}
.Vue-Toastification__toast {
  display: inline-flex;
  position: relative;
  max-height: 800px;
  min-height: 64px;
  box-sizing: border-box;
  margin-bottom: 1rem;
  padding: 22px 24px;
  border-radius: 8px;
  box-shadow: 0 1px 10px 0 rgba(0, 0, 0, 0.1), 0 2px 15px 0 rgba(0, 0, 0, 0.05);
  justify-content: space-between;
  font-family:
    "Lato",
    Helvetica,
    "Roboto",
    Arial,
    sans-serif;
  max-width: 600px;
  min-width: 326px;
  pointer-events: auto;
  overflow: hidden;
  transform: translateZ(0);
  direction: ltr;
}
.Vue-Toastification__toast--rtl {
  direction: rtl;
}
.Vue-Toastification__toast--default {
  background-color: #1976d2;
  color: #fff;
}
.Vue-Toastification__toast--info {
  background-color: #2196f3;
  color: #fff;
}
.Vue-Toastification__toast--success {
  background-color: #4caf50;
  color: #fff;
}
.Vue-Toastification__toast--error {
  background-color: #ff5252;
  color: #fff;
}
.Vue-Toastification__toast--warning {
  background-color: #ffc107;
  color: #fff;
}
@media only screen and (max-width : 600px) {
  .Vue-Toastification__toast {
    border-radius: 0px;
    margin-bottom: 0.5rem;
  }
}
.Vue-Toastification__toast-body {
  flex: 1;
  line-height: 24px;
  font-size: 16px;
  word-break: break-word;
  white-space: pre-wrap;
}
.Vue-Toastification__toast-component-body {
  flex: 1;
}
.Vue-Toastification__toast.disable-transition {
  animation: none !important;
}
.Vue-Toastification__close-button {
  font-weight: bold;
  font-size: 24px;
  line-height: 24px;
  background: transparent;
  outline: none;
  border: none;
  padding: 0;
  padding-left: 10px;
  cursor: pointer;
  transition: 0.3s ease;
  align-items: center;
  color: #fff;
  opacity: 0.3;
  transition: visibility 0s, opacity 0.2s linear;
}
.Vue-Toastification__close-button:hover,
.Vue-Toastification__close-button:focus {
  opacity: 1;
}
.Vue-Toastification__toast:not(:hover) .Vue-Toastification__close-button.show-on-hover {
  opacity: 0;
}
.Vue-Toastification__toast--rtl .Vue-Toastification__close-button {
  padding-left: unset;
  padding-right: 10px;
}
@keyframes scale-x-frames {
  0% {
    transform: scaleX(1);
  }
  100% {
    transform: scaleX(0);
  }
}
.Vue-Toastification__progress-bar {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 5px;
  z-index: 10000;
  background-color: rgba(255, 255, 255, 0.7);
  transform-origin: left;
  animation: scale-x-frames linear 1 forwards;
}
.Vue-Toastification__toast--rtl .Vue-Toastification__progress-bar {
  right: 0;
  left: unset;
  transform-origin: right;
}
.Vue-Toastification__icon {
  margin: auto 18px auto 0px;
  background: transparent;
  outline: none;
  border: none;
  padding: 0;
  transition: 0.3s ease;
  align-items: center;
  width: 20px;
  height: 100%;
}
.Vue-Toastification__toast--rtl .Vue-Toastification__icon {
  margin: auto 0px auto 18px;
}
@keyframes bounceInRight {
  from, 60%, 75%, 90%, to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }
  from {
    opacity: 0;
    transform: translate3d(3000px, 0, 0);
  }
  60% {
    opacity: 1;
    transform: translate3d(-25px, 0, 0);
  }
  75% {
    transform: translate3d(10px, 0, 0);
  }
  90% {
    transform: translate3d(-5px, 0, 0);
  }
  to {
    transform: none;
  }
}
@keyframes bounceOutRight {
  40% {
    opacity: 1;
    transform: translate3d(-20px, 0, 0);
  }
  to {
    opacity: 0;
    transform: translate3d(1000px, 0, 0);
  }
}
@keyframes bounceInLeft {
  from, 60%, 75%, 90%, to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }
  0% {
    opacity: 0;
    transform: translate3d(-3000px, 0, 0);
  }
  60% {
    opacity: 1;
    transform: translate3d(25px, 0, 0);
  }
  75% {
    transform: translate3d(-10px, 0, 0);
  }
  90% {
    transform: translate3d(5px, 0, 0);
  }
  to {
    transform: none;
  }
}
@keyframes bounceOutLeft {
  20% {
    opacity: 1;
    transform: translate3d(20px, 0, 0);
  }
  to {
    opacity: 0;
    transform: translate3d(-2000px, 0, 0);
  }
}
@keyframes bounceInUp {
  from, 60%, 75%, 90%, to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }
  from {
    opacity: 0;
    transform: translate3d(0, 3000px, 0);
  }
  60% {
    opacity: 1;
    transform: translate3d(0, -20px, 0);
  }
  75% {
    transform: translate3d(0, 10px, 0);
  }
  90% {
    transform: translate3d(0, -5px, 0);
  }
  to {
    transform: translate3d(0, 0, 0);
  }
}
@keyframes bounceOutUp {
  20% {
    transform: translate3d(0, -10px, 0);
  }
  40%, 45% {
    opacity: 1;
    transform: translate3d(0, 20px, 0);
  }
  to {
    opacity: 0;
    transform: translate3d(0, -2000px, 0);
  }
}
@keyframes bounceInDown {
  from, 60%, 75%, 90%, to {
    animation-timing-function: cubic-bezier(0.215, 0.61, 0.355, 1);
  }
  0% {
    opacity: 0;
    transform: translate3d(0, -3000px, 0);
  }
  60% {
    opacity: 1;
    transform: translate3d(0, 25px, 0);
  }
  75% {
    transform: translate3d(0, -10px, 0);
  }
  90% {
    transform: translate3d(0, 5px, 0);
  }
  to {
    transform: none;
  }
}
@keyframes bounceOutDown {
  20% {
    transform: translate3d(0, 10px, 0);
  }
  40%, 45% {
    opacity: 1;
    transform: translate3d(0, -20px, 0);
  }
  to {
    opacity: 0;
    transform: translate3d(0, 2000px, 0);
  }
}
.Vue-Toastification__bounce-enter-active.top-left,
.Vue-Toastification__bounce-enter-active.bottom-left {
  animation-name: bounceInLeft;
}
.Vue-Toastification__bounce-enter-active.top-right,
.Vue-Toastification__bounce-enter-active.bottom-right {
  animation-name: bounceInRight;
}
.Vue-Toastification__bounce-enter-active.top-center {
  animation-name: bounceInDown;
}
.Vue-Toastification__bounce-enter-active.bottom-center {
  animation-name: bounceInUp;
}
.Vue-Toastification__bounce-leave-active:not(.disable-transition).top-left,
.Vue-Toastification__bounce-leave-active:not(.disable-transition).bottom-left {
  animation-name: bounceOutLeft;
}
.Vue-Toastification__bounce-leave-active:not(.disable-transition).top-right,
.Vue-Toastification__bounce-leave-active:not(.disable-transition).bottom-right {
  animation-name: bounceOutRight;
}
.Vue-Toastification__bounce-leave-active:not(.disable-transition).top-center {
  animation-name: bounceOutUp;
}
.Vue-Toastification__bounce-leave-active:not(.disable-transition).bottom-center {
  animation-name: bounceOutDown;
}
.Vue-Toastification__bounce-leave-active,
.Vue-Toastification__bounce-enter-active {
  animation-duration: 750ms;
  animation-fill-mode: both;
}
.Vue-Toastification__bounce-move {
  transition-timing-function: ease-in-out;
  transition-property: all;
  transition-duration: 400ms;
}
@keyframes fadeOutTop {
  0% {
    transform: translateY(0);
    opacity: 1;
  }
  100% {
    transform: translateY(-50px);
    opacity: 0;
  }
}
@keyframes fadeOutLeft {
  0% {
    transform: translateX(0);
    opacity: 1;
  }
  100% {
    transform: translateX(-50px);
    opacity: 0;
  }
}
@keyframes fadeOutBottom {
  0% {
    transform: translateY(0);
    opacity: 1;
  }
  100% {
    transform: translateY(50px);
    opacity: 0;
  }
}
@keyframes fadeOutRight {
  0% {
    transform: translateX(0);
    opacity: 1;
  }
  100% {
    transform: translateX(50px);
    opacity: 0;
  }
}
@keyframes fadeInLeft {
  0% {
    transform: translateX(-50px);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}
@keyframes fadeInRight {
  0% {
    transform: translateX(50px);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}
@keyframes fadeInTop {
  0% {
    transform: translateY(-50px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}
@keyframes fadeInBottom {
  0% {
    transform: translateY(50px);
    opacity: 0;
  }
  100% {
    transform: translateY(0);
    opacity: 1;
  }
}
.Vue-Toastification__fade-enter-active.top-left,
.Vue-Toastification__fade-enter-active.bottom-left {
  animation-name: fadeInLeft;
}
.Vue-Toastification__fade-enter-active.top-right,
.Vue-Toastification__fade-enter-active.bottom-right {
  animation-name: fadeInRight;
}
.Vue-Toastification__fade-enter-active.top-center {
  animation-name: fadeInTop;
}
.Vue-Toastification__fade-enter-active.bottom-center {
  animation-name: fadeInBottom;
}
.Vue-Toastification__fade-leave-active:not(.disable-transition).top-left,
.Vue-Toastification__fade-leave-active:not(.disable-transition).bottom-left {
  animation-name: fadeOutLeft;
}
.Vue-Toastification__fade-leave-active:not(.disable-transition).top-right,
.Vue-Toastification__fade-leave-active:not(.disable-transition).bottom-right {
  animation-name: fadeOutRight;
}
.Vue-Toastification__fade-leave-active:not(.disable-transition).top-center {
  animation-name: fadeOutTop;
}
.Vue-Toastification__fade-leave-active:not(.disable-transition).bottom-center {
  animation-name: fadeOutBottom;
}
.Vue-Toastification__fade-leave-active,
.Vue-Toastification__fade-enter-active {
  animation-duration: 750ms;
  animation-fill-mode: both;
}
.Vue-Toastification__fade-move {
  transition-timing-function: ease-in-out;
  transition-property: all;
  transition-duration: 400ms;
}
@keyframes slideInBlurredLeft {
  0% {
    transform: translateX(-1000px) scaleX(2.5) scaleY(0.2);
    transform-origin: 100% 50%;
    filter: blur(40px);
    opacity: 0;
  }
  100% {
    transform: translateX(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
}
@keyframes slideInBlurredTop {
  0% {
    transform: translateY(-1000px) scaleY(2.5) scaleX(0.2);
    transform-origin: 50% 0%;
    filter: blur(240px);
    opacity: 0;
  }
  100% {
    transform: translateY(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
}
@keyframes slideInBlurredRight {
  0% {
    transform: translateX(1000px) scaleX(2.5) scaleY(0.2);
    transform-origin: 0% 50%;
    filter: blur(40px);
    opacity: 0;
  }
  100% {
    transform: translateX(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
}
@keyframes slideInBlurredBottom {
  0% {
    transform: translateY(1000px) scaleY(2.5) scaleX(0.2);
    transform-origin: 50% 100%;
    filter: blur(240px);
    opacity: 0;
  }
  100% {
    transform: translateY(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
}
@keyframes slideOutBlurredTop {
  0% {
    transform: translateY(0) scaleY(1) scaleX(1);
    transform-origin: 50% 0%;
    filter: blur(0);
    opacity: 1;
  }
  100% {
    transform: translateY(-1000px) scaleY(2) scaleX(0.2);
    transform-origin: 50% 0%;
    filter: blur(240px);
    opacity: 0;
  }
}
@keyframes slideOutBlurredBottom {
  0% {
    transform: translateY(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
  100% {
    transform: translateY(1000px) scaleY(2) scaleX(0.2);
    transform-origin: 50% 100%;
    filter: blur(240px);
    opacity: 0;
  }
}
@keyframes slideOutBlurredLeft {
  0% {
    transform: translateX(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
  100% {
    transform: translateX(-1000px) scaleX(2) scaleY(0.2);
    transform-origin: 100% 50%;
    filter: blur(40px);
    opacity: 0;
  }
}
@keyframes slideOutBlurredRight {
  0% {
    transform: translateX(0) scaleY(1) scaleX(1);
    transform-origin: 50% 50%;
    filter: blur(0);
    opacity: 1;
  }
  100% {
    transform: translateX(1000px) scaleX(2) scaleY(0.2);
    transform-origin: 0% 50%;
    filter: blur(40px);
    opacity: 0;
  }
}
.Vue-Toastification__slideBlurred-enter-active.top-left,
.Vue-Toastification__slideBlurred-enter-active.bottom-left {
  animation-name: slideInBlurredLeft;
}
.Vue-Toastification__slideBlurred-enter-active.top-right,
.Vue-Toastification__slideBlurred-enter-active.bottom-right {
  animation-name: slideInBlurredRight;
}
.Vue-Toastification__slideBlurred-enter-active.top-center {
  animation-name: slideInBlurredTop;
}
.Vue-Toastification__slideBlurred-enter-active.bottom-center {
  animation-name: slideInBlurredBottom;
}
.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).top-left,
.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).bottom-left {
  animation-name: slideOutBlurredLeft;
}
.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).top-right,
.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).bottom-right {
  animation-name: slideOutBlurredRight;
}
.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).top-center {
  animation-name: slideOutBlurredTop;
}
.Vue-Toastification__slideBlurred-leave-active:not(.disable-transition).bottom-center {
  animation-name: slideOutBlurredBottom;
}
.Vue-Toastification__slideBlurred-leave-active,
.Vue-Toastification__slideBlurred-enter-active {
  animation-duration: 750ms;
  animation-fill-mode: both;
}
.Vue-Toastification__slideBlurred-move {
  transition-timing-function: ease-in-out;
  transition-property: all;
  transition-duration: 400ms;
}
.small-alpha-slider{height:10px!important}.small-alpha-slider .small-bar{height:10px!important;width:10px!important}.small-alpha-slider .small-bar div{width:12px!important;height:12px!important;border-radius:5px!important;transform:translate(-6px,-2px);margin-top:1px!important}.bee-alpha-slider{position:relative;margin-bottom:15px;width:100%;height:14px;box-shadow:2px 0 8px #00000014;border-radius:15px}.bee-alpha-slider.is-vertical{width:14px;height:100%;display:inline-block;transform:rotate(180deg)}.bee-alpha-slider.transparent{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-alpha-slider__bar{position:relative;width:100%;height:100%;border-radius:15px}.bee-alpha-slider__bar-pointer{position:absolute;width:14px;height:14px}.bee-alpha-slider__bar-handle{width:14px;height:14px;border-radius:6px;transform:translate(-7px,-2px);background-color:#f8f8f8;margin-top:2px;box-shadow:0 1px 4px #0000005e;cursor:pointer}.bee-alpha-slider__bar-handle.vertical{transform:translateY(-7px);margin-top:0}.bee-compact{margin-bottom:15px;width:auto;box-shadow:3px 0 5px #00000014;display:inline-block}.bee-compact__row{position:relative;width:100%;margin:0}.bee-compact__row>*{display:inline-block;vertical-align:middle}.bee-compact__color_cube{width:100%;height:100%}.bee-compact__color_cube.transparent:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:white}.bee-compact__color_cube.transparent:after{content:"";position:absolute;top:100%;left:0;transform:rotate(-45deg);transform-origin:0 0;width:35px;height:1px;background:red}.bee-compact__color_cube.advance{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABqVJREFUeNrEl11yHDUQx1ua2Zlde2M7jqESqnjg45kjcBwOwQG4BY+8cwWK17xBUUARICQhTmI7tte7Ozs7o+bXLTleuACpKNJqJP3789+doKoSPxfVGxFZioS1iK5Yd0nCJko9iLTVVvZSlCOp5FBF7vP5RFTelyDHvmYvMPPtiP19fu+HIHPetrllX2TLMJAOgEehti3ZY/Axap51ZB5ZDEnGMUoCNCmDbRv+2Q4CDJ5Mymj4OmE0CNj6b5WJlkel3xkiGXjOc0imDH/JDid1AXQEfKgccHg3lN+uhh+v2WkkOvCUnT3GjP2WOfrJzjUNPq/ugPUej1TiwME3+DfVUhWkEQF6LZraJxsp6xHLIzW/DNyAW75PGJVrOxbQFSeWzOsdjQ/tZHTxtSgdzAimMfOAdbas7crUvIWAqZg5+gg8FBzYTOygbo1tAb1xTYMs/q1xAFgnvBx5JrKO2X9pzJrJhr+b5BaY8vjG3O+w7HFnypkZ+zP3K8AWL7FHiRsJappe4knA9fo/pj7WrIrdshBs8cukcu0ljhK2lZt1Q8B1msMj5WCQKoibd8q8p1J8i6aWJnrJCcDljDX2Cm8Jn2WJC9PtIHpYeowza125Dc3c6CQ1MbEdooxoPQw54Ak9jigaKcAMk9ddgUi68ZxMmNbNG8hTXXjOZrPf+vg4C+RpRRJqO0ps8FxtzhoJLiSIHCWtLi9u5LiZyqKv0UvlHmaccukoVjJLFu2YUy946FRidS7beCXN9i3gKzd1Yo53ps7ppTnqEYD0mYNldpuxnvIo2nZb/L+ay9tulA/sJpE/Tfchj1H2kW2KpsFYSK4YgI1vZDJe57XmIAu642N5kCxUJfQ8bA48IKpWGNKi/T7rPWRMBMkp5lhz5mUlV0O+fGAGC5XMkTzoG349I/D+Qis0jpeZBt0CXaZGnwtwdcS7A/4ycOIi3bNI0pzfxoVHQYYDIu+A9djJ5bKX+c2BVKnHS5Xcw8QTecWlXxi/khgvYMFzHlp4/g74WREshg3zpuS9mfowShxyrnv6wFS2Dl12QUDwaO54xIWTKZem8up7M0ojn5BzdftEdPMzII9ljE8kVde8Z5y89PSJYcACAJhWTigFOO1rpqRbWs0pKjp4Nkl6OMiGQiFnKsOnLQNqJNe33yV5iFml/4YLfzB+wwpvuNoT+eq0F+JWYtp50MlXLBvUAkLlXXbdloHkUsREDsc6y9LDvs2pTNJD6eM5+x/KAslqWK/pOo/WEIvw3PC3q8rZz3IzWBqqp2CpTvjAACIVyFhLMQmlwXPU9gYrC+lCZs0VtPkc0Jfc+Va+XK/lK3Pr10XhF8ToAjf1VKktAH0hd3srqesSMmCJaiNwJB/IzNviF9Uor8NnndSkyRBfExbPpdHfKRg/yqH8JCPxdvbZVE6+6GTzmCD9Af45RfhzLGZZtEaIVQVdDpLwVByAHeIu8DXWGTySUil8wSNw6fMoliZnfHsqfXiC2M+gjJXX7wuEOvm4gWUBa9h4xrAAtwy6hHyWo1QQGc9gDkD7sAt8VjqETSnUHaArd0Gupc8ZBv4n4ymUfiEPxEu4/A3eyayX+x+ZZjjoIEl6D+2zrJJgyOoKf68RCKJXOpt4B3xZQNclwVeSbXVd2hXzKXlpqsC3c0ttyR3La6rTW2yyP1dpSbdowUtBji1+aAioxTZXD+ORZcrs+A5YF9kWnnfWeJUSZgnswKeZ7FNHkaeXgjTmowVhkhuQ1pQxCE1aik2A16OVVwtvayxmW6fdeDNKKcs79Zhy5eaFwIOXsxu3grolVsUVS0y0pAKN3tpMStdlheJajZ1V5rxWHxoJjR6crr51frlg59K73AFWf7h3gs8BlWtpsHpqwrioa6nJj5lphgim1C3XdPGuuZm2hYIB90QCrKqxDnPkm81hN6pvAyqElRdvN3exjdXeYGQS8oXGmjgoICQjhUh6jdSYmvQdpakSFArIfg6bqiqZW6t3N6HaNbUX7M4Lt4NK8bX3SblJM9Mas+65xuodpVFRj58HfLyAdPZjftCittnLXaHWKQdczNE4trkfK8GFiT3RVqU523gaBbeC04/3zW3pp0yJWFqfofjZejBfw3bGE3WNO8jrmLtDt5ahVyHt+DiUDv/WtFpAQ+4MrDFvC3Bb+uXiI2f1TXGURfesNPc11mjacki1dK/JKTnsUmYGLnnM/2MycWRt7dCtedrSyhqPe39tPBecjV3rrTWDweqzSl2hsfVwM3lX+UL+f0CuTv/Hn38EGAAvCnNy1JKVIQAAAABJRU5ErkJggg==)}.bee-compact__color_cube .alpha{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-compact__color-cube--wrap{position:relative;width:25px;height:25px;cursor:pointer;overflow:hidden}.bee-compact__color-cube--wrap:hover{transform:scale(1.2);z-index:299;transition:transform .2s}.bee-colorPicker__record{display:flex;align-items:center;margin-top:20px}.bee-colorPicker__record .text{width:48px;margin-right:10px;text-align:right;font-size:12px;color:#666}.bee-colorPicker__record .color-list{width:auto;display:flex;position:relative;margin:0}.bee-colorPicker__record .color-list .color-item{position:relative;width:25px;height:25px;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle;margin-right:1px;box-shadow:3px 0 5px #00000014}.bee-colorPicker__record .color-list .color-item__round{border-radius:50%}.bee-colorPicker__record .color-list .color-item.transparent{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-colorPicker__record .color-list .color-item:hover{transform:scale(1.2);z-index:299;transition:transform .2s}.bee-colorPicker__record .color-list .color-item__display{width:100%;height:100%}.small-hue-slider{height:10px!important}.small-hue-slider .small-bar{height:10px!important;width:10px!important}.small-hue-slider .small-bar div{width:12px!important;height:12px!important;border-radius:5px!important;transform:translate(-6px,-2px);margin-top:1px!important}.bee-hue-colorPicker{position:relative;margin-bottom:15px;width:100%;height:14px;box-shadow:2px 0 8px #00000014;border-radius:15px}.bee-hue-colorPicker.is-vertical{width:14px;height:100%;display:inline-block;transform:rotate(180deg)}.bee-hue-colorPicker.transparent{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-hue-colorPicker__inner{position:relative;width:100%;height:100%;border-radius:15px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMkAAAAdCAYAAAAAaUg8AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAKtJREFUeNrs09EKgjAUgOGzEFfv/7CVBceiLiJiLnf7fSAbDoUj/iWnyKgRcXxf9Wtt7Vvntf8854jLY3uN19qzf67nH/e2nmmdZ8xjg2x+sI533qf9g4wM/3GvLPumOHVMWf/4SiWWsUG6/6bG+/NWDgE0iQREAiIBkYBIQCQgEhAJiAQQCYgERAIiAZGASEAkIBJAJCASEAmIBEQCIgGRgEgAkYBIYNAqwAD5oWo3bpsiKwAAAABJRU5ErkJggg==);background-size:100%}.bee-hue-colorPicker__inner-pointer{position:absolute;width:14px;height:14px}.bee-hue-colorPicker__inner-handle{width:14px;height:14px;border-radius:6px;transform:translate(-7px,-2px);background-color:#f8f8f8;margin-top:2px;box-shadow:0 1px 4px #0000005e;cursor:pointer}.bee-hue-colorPicker__inner-handle.vertical{transform:translate(-1px,-7px);margin-top:0}.small-light-slider{height:10px!important}.small-light-slider .small-bar{height:10px!important;width:10px!important}.small-light-slider .small-bar div{width:12px!important;height:12px!important;border-radius:5px!important;transform:translate(-6px,-2px);margin-top:1px!important}.bee-light-colorPicker{position:relative;margin-bottom:15px;width:100%;height:14px;box-shadow:2px 0 8px #00000014;border-radius:15px}.bee-light-colorPicker.is-vertical{width:14px;height:100%;display:inline-block;transform:rotate(180deg)}.bee-light-colorPicker.transparent{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-light-colorPicker__inner{position:relative;width:100%;height:100%;border-radius:15px}.bee-light-colorPicker__inner-pointer{position:absolute;width:14px;height:14px}.bee-light-colorPicker__inner-handle{width:14px;height:14px;border-radius:6px;transform:translate(-7px,-2px);background-color:#f8f8f8;margin-top:2px;box-shadow:0 1px 4px #0000005e;cursor:pointer}.bee-light-colorPicker__inner-handle.vertical{transform:translateY(-7px);margin-top:0}.bee-saturation{position:relative;margin-bottom:15px;width:100%;height:125px}.bee-saturation__chrome{border-top-left-radius:5px;border-top-right-radius:5px;border-color:transparent}.bee-saturation__hidden{overflow:hidden}.bee-saturation__white,.bee-saturation__black{position:absolute;top:0;left:0;right:0;bottom:0}.bee-saturation__black{background:linear-gradient(0deg,#000,transparent)}.bee-saturation__white{background:linear-gradient(90deg,#fff,rgba(255,255,255,0))}.bee-saturation__cursor{position:absolute}.bee-saturation__cursor div{transform:translate(-5px,-5px);box-shadow:0 1px 4px #0000005e;width:10px;height:10px;border:1px solid white;border-radius:50%;cursor:pointer}.inputs-controls{display:flex;font-size:16px;margin-bottom:5px}.inputs-controls .formatBtn{position:relative;display:inline-flex;justify-content:center;align-items:center;padding:1px;border:0;text-align:center;cursor:pointer;background-color:transparent;font-weight:700;outline:none;margin-right:5px}.inputs-controls .formatBtn:hover{color:#1a3aff}.inputs-controls .format-group{display:flex;flex-grow:1}.inputs-controls .format-group input{padding:5px;margin:0 3px;min-width:0;text-align:center;border-width:0 0 1px 0;-webkit-appearance:none;appearance:none;-moz-appearance:textfield;outline:none;flex:1}.inputs-controls .format-group input::-webkit-outer-spin-button,.inputs-controls .format-group input::-webkit-inner-spin-button{-webkit-appearance:none!important;margin:0}.bee-fk-colorPicker{position:relative;box-sizing:border-box;border-radius:3px;box-shadow:0 0 10px #00000026;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#fff;width:249px;padding-bottom:10px}.bee-fk-colorPicker__inner{padding:12px}.bee-fk-colorPicker__header{margin-bottom:12px;z-index:999;text-align:left}.bee-fk-colorPicker__header .back{border:solid black;border-width:0 1px 1px 0;display:inline-block;padding:4px;margin-left:2px;transform:rotate(135deg);-webkit-transform:rotate(135deg)}.bee-fk-colorPicker__display{position:relative;width:100%;margin:0;text-align:left}.bee-fk-colorPicker__display .transparent{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-fk-colorPicker__display .current-color{margin-right:10px;width:50px;height:24px;box-shadow:3px 0 5px #00000014;position:relative;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle}.bee-fk-colorPicker__display .current-color .color-cube{width:100%;height:100%}.bee-fk-colorPicker__display .hexColor-prefix{position:relative;padding:0 4px;font-size:14px;display:inline-block;vertical-align:middle}.bee-fk-colorPicker__display input{width:25px;text-align:center;outline:0;border-top:0;border-right:0;border-left:none;display:inline-block;vertical-align:middle;padding-bottom:3px;border-bottom:1px solid #e3e2e8}.bee-fk-colorPicker__display .hexColor-input{width:64px}.bee-fk-colorPicker__display .action{float:right;vertical-align:middle}.bee-fk-colorPicker__display .action .clear-btn{border-color:transparent;color:#409eff;background:transparent;padding-left:0;padding-right:0;display:inline-block;vertical-align:middle;cursor:pointer}.bee-fk-colorPicker__display .action .copy-btn{border-color:transparent;color:#13ce66cc;background:transparent;padding-left:0;padding-right:0;display:inline-block;margin-left:10px;vertical-align:middle;cursor:pointer}.bee-ele-colorPicker{position:relative;box-sizing:border-box;border-radius:3px;box-shadow:0 0 10px #00000026;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#fff;padding:10px;width:300px}.bee-ele-colorPicker .bee-ele-row{display:flex}.bee-ele-colorPicker .bee-ele-row .bee-ele-saturation{width:280px;height:180px}.bee-ele-colorPicker .bee-ele-row .bee-ele-hue{margin-left:10px;height:180px}.bee-chrome-colorPicker{position:relative;box-sizing:border-box;border-radius:3px;box-shadow:0 0 10px #00000026;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-color:#fff;width:250px;padding-bottom:20px}.bee-chrome-colorPicker-body{padding:0 12px;background-color:#fff}.bee-chrome-colorPicker-body .chrome-controls{display:flex}.bee-chrome-colorPicker-body .chrome-controls .chrome-color-wrap{position:relative;width:36px;height:36px;border-radius:50%;overflow:hidden;z-index:1}.bee-chrome-colorPicker-body .chrome-controls .chrome-color-wrap .current-color{width:100%;height:100%}.bee-chrome-colorPicker-body .chrome-controls .chrome-sliders{flex:1;margin-left:10px}.bee-color-wrap{margin-right:10px;width:50px;height:24px;box-shadow:3px 0 5px #00000014;position:relative;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle}.bee-color-wrap.transparent{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.bee-color-wrap.round{width:22px;height:22px;border-radius:50%;border:1px solid #d8d8d8}.bee-color-wrap .current-color{width:100%;height:100%}.vc-alpha-slider[data-v-18925ba6]{position:relative;margin-bottom:15px;width:100%;height:14px;box-shadow:2px 0 8px #00000014;border-radius:15px}.vc-alpha-slider.is-vertical[data-v-18925ba6]{width:14px;height:100%;display:inline-block;transform:rotate(180deg)}.vc-alpha-slider.transparent[data-v-18925ba6]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-alpha-slider__bar[data-v-18925ba6]{position:relative;width:100%;height:100%;border-radius:15px}.vc-alpha-slider__bar-pointer[data-v-18925ba6]{position:absolute;width:14px;height:14px}.vc-alpha-slider__bar-handle[data-v-18925ba6]{width:14px;height:14px;border-radius:6px;transform:translate(-7px,-2px);background-color:#f8f8f8;margin-top:2px;box-shadow:0 1px 4px #0000005e;cursor:pointer}.vc-alpha-slider__bar-handle.vertical[data-v-18925ba6]{transform:translateY(-7px);margin-top:0}.vc-alpha-slider.small-slider[data-v-18925ba6]{height:10px!important}.vc-alpha-slider.small-slider .small-bar[data-v-18925ba6]{height:10px!important;width:10px!important}.vc-alpha-slider.small-slider .small-bar div[data-v-18925ba6]{width:12px!important;height:12px!important;border-radius:5px!important;transform:translate(-6px,-2px);margin-top:1px!important}.vc-compact[data-v-b969fd48]{margin-bottom:15px;width:auto;box-shadow:3px 0 5px #00000014;display:inline-block}.vc-compact__row[data-v-b969fd48]{position:relative;width:100%;margin:0;height:27px}.vc-compact__row>*[data-v-b969fd48]{display:inline-block;vertical-align:middle}.vc-compact__color_cube[data-v-b969fd48]{width:100%;height:100%}.vc-compact__color_cube.transparent[data-v-b969fd48]:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:white}.vc-compact__color_cube.transparent[data-v-b969fd48]:after{content:"";position:absolute;top:100%;left:0;transform:rotate(-45deg);transform-origin:0 0;width:35px;height:1px;background:red}.vc-compact__color_cube.advance[data-v-b969fd48]{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAdCAYAAAC9pNwMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABqVJREFUeNrEl11yHDUQx1ua2Zlde2M7jqESqnjg45kjcBwOwQG4BY+8cwWK17xBUUARICQhTmI7tte7Ozs7o+bXLTleuACpKNJqJP3789+doKoSPxfVGxFZioS1iK5Yd0nCJko9iLTVVvZSlCOp5FBF7vP5RFTelyDHvmYvMPPtiP19fu+HIHPetrllX2TLMJAOgEehti3ZY/Axap51ZB5ZDEnGMUoCNCmDbRv+2Q4CDJ5Mymj4OmE0CNj6b5WJlkel3xkiGXjOc0imDH/JDid1AXQEfKgccHg3lN+uhh+v2WkkOvCUnT3GjP2WOfrJzjUNPq/ugPUej1TiwME3+DfVUhWkEQF6LZraJxsp6xHLIzW/DNyAW75PGJVrOxbQFSeWzOsdjQ/tZHTxtSgdzAimMfOAdbas7crUvIWAqZg5+gg8FBzYTOygbo1tAb1xTYMs/q1xAFgnvBx5JrKO2X9pzJrJhr+b5BaY8vjG3O+w7HFnypkZ+zP3K8AWL7FHiRsJappe4knA9fo/pj7WrIrdshBs8cukcu0ljhK2lZt1Q8B1msMj5WCQKoibd8q8p1J8i6aWJnrJCcDljDX2Cm8Jn2WJC9PtIHpYeowza125Dc3c6CQ1MbEdooxoPQw54Ak9jigaKcAMk9ddgUi68ZxMmNbNG8hTXXjOZrPf+vg4C+RpRRJqO0ps8FxtzhoJLiSIHCWtLi9u5LiZyqKv0UvlHmaccukoVjJLFu2YUy946FRidS7beCXN9i3gKzd1Yo53ps7ppTnqEYD0mYNldpuxnvIo2nZb/L+ay9tulA/sJpE/Tfchj1H2kW2KpsFYSK4YgI1vZDJe57XmIAu642N5kCxUJfQ8bA48IKpWGNKi/T7rPWRMBMkp5lhz5mUlV0O+fGAGC5XMkTzoG349I/D+Qis0jpeZBt0CXaZGnwtwdcS7A/4ycOIi3bNI0pzfxoVHQYYDIu+A9djJ5bKX+c2BVKnHS5Xcw8QTecWlXxi/khgvYMFzHlp4/g74WREshg3zpuS9mfowShxyrnv6wFS2Dl12QUDwaO54xIWTKZem8up7M0ojn5BzdftEdPMzII9ljE8kVde8Z5y89PSJYcACAJhWTigFOO1rpqRbWs0pKjp4Nkl6OMiGQiFnKsOnLQNqJNe33yV5iFml/4YLfzB+wwpvuNoT+eq0F+JWYtp50MlXLBvUAkLlXXbdloHkUsREDsc6y9LDvs2pTNJD6eM5+x/KAslqWK/pOo/WEIvw3PC3q8rZz3IzWBqqp2CpTvjAACIVyFhLMQmlwXPU9gYrC+lCZs0VtPkc0Jfc+Va+XK/lK3Pr10XhF8ToAjf1VKktAH0hd3srqesSMmCJaiNwJB/IzNviF9Uor8NnndSkyRBfExbPpdHfKRg/yqH8JCPxdvbZVE6+6GTzmCD9Af45RfhzLGZZtEaIVQVdDpLwVByAHeIu8DXWGTySUil8wSNw6fMoliZnfHsqfXiC2M+gjJXX7wuEOvm4gWUBa9h4xrAAtwy6hHyWo1QQGc9gDkD7sAt8VjqETSnUHaArd0Gupc8ZBv4n4ymUfiEPxEu4/A3eyayX+x+ZZjjoIEl6D+2zrJJgyOoKf68RCKJXOpt4B3xZQNclwVeSbXVd2hXzKXlpqsC3c0ttyR3La6rTW2yyP1dpSbdowUtBji1+aAioxTZXD+ORZcrs+A5YF9kWnnfWeJUSZgnswKeZ7FNHkaeXgjTmowVhkhuQ1pQxCE1aik2A16OVVwtvayxmW6fdeDNKKcs79Zhy5eaFwIOXsxu3grolVsUVS0y0pAKN3tpMStdlheJajZ1V5rxWHxoJjR6crr51frlg59K73AFWf7h3gs8BlWtpsHpqwrioa6nJj5lphgim1C3XdPGuuZm2hYIB90QCrKqxDnPkm81hN6pvAyqElRdvN3exjdXeYGQS8oXGmjgoICQjhUh6jdSYmvQdpakSFArIfg6bqiqZW6t3N6HaNbUX7M4Lt4NK8bX3SblJM9Mas+65xuodpVFRj58HfLyAdPZjftCittnLXaHWKQdczNE4trkfK8GFiT3RVqU523gaBbeC04/3zW3pp0yJWFqfofjZejBfw3bGE3WNO8jrmLtDt5ahVyHt+DiUDv/WtFpAQ+4MrDFvC3Bb+uXiI2f1TXGURfesNPc11mjacki1dK/JKTnsUmYGLnnM/2MycWRt7dCtedrSyhqPe39tPBecjV3rrTWDweqzSl2hsfVwM3lX+UL+f0CuTv/Hn38EGAAvCnNy1JKVIQAAAABJRU5ErkJggg==)}.vc-compact__color_cube .alpha[data-v-b969fd48]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-compact__color-cube--wrap[data-v-b969fd48]{position:relative;width:27px;height:27px;cursor:pointer;overflow:hidden}.vc-compact__color-cube--wrap[data-v-b969fd48]:hover{transform:scale(1.2);z-index:299;transition:transform .2s}.vc-saturation[data-v-63803390]{position:relative;margin-bottom:15px;width:100%;height:125px}.vc-saturation__chrome[data-v-63803390]{border-top-left-radius:5px;border-top-right-radius:5px;border-color:transparent}.vc-saturation__hidden[data-v-63803390]{overflow:hidden}.vc-saturation__white[data-v-63803390],.vc-saturation__black[data-v-63803390]{position:absolute;top:0;left:0;right:0;bottom:0}.vc-saturation__black[data-v-63803390]{background:linear-gradient(0deg,#000,transparent)}.vc-saturation__white[data-v-63803390]{background:linear-gradient(90deg,#fff,rgba(255,255,255,0))}.vc-saturation__cursor[data-v-63803390]{position:absolute}.vc-saturation__cursor div[data-v-63803390]{transform:translate(-5px,-5px);box-shadow:0 1px 4px #0000005e;width:10px;height:10px;border:1px solid white;border-radius:50%;cursor:pointer}.vc-hue-slider[data-v-5c4cae5b]{position:relative;margin-bottom:15px;width:100%;height:14px;box-shadow:2px 0 8px #00000014;border-radius:15px}.vc-hue-slider.is-vertical[data-v-5c4cae5b]{width:14px;height:100%;display:inline-block;transform:rotate(180deg)}.vc-hue-slider.transparent[data-v-5c4cae5b]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-hue-slider__bar[data-v-5c4cae5b]{position:relative;width:100%;height:100%;border-radius:15px;background:-webkit-linear-gradient(left,red 0%,yellow 16.66%,lime 33.33%,aqua 50%,blue 66.66%,fuchsia 83.33%,red 100%);background:-moz-linear-gradient(left,red 0%,yellow 16.66%,lime 33.33%,aqua 50%,blue 66.66%,fuchsia 83.33%,red 100%);background:-ms-linear-gradient(left,red 0%,yellow 16.66%,lime 33.33%,aqua 50%,blue 66.66%,fuchsia 83.33%,red 100%)}.vc-hue-slider__bar-pointer[data-v-5c4cae5b]{position:absolute;width:14px;height:14px}.vc-hue-slider__bar-handle[data-v-5c4cae5b]{width:14px;height:14px;border-radius:6px;transform:translate(-7px,-2px);background-color:#f8f8f8;margin-top:2px;box-shadow:0 1px 4px #0000005e;cursor:pointer}.vc-hue-slider__bar-handle.vertical[data-v-5c4cae5b]{transform:translateY(-7px);margin-top:0}.vc-hue-slider.small-slider[data-v-5c4cae5b]{height:10px!important}.vc-hue-slider.small-slider .small-bar[data-v-5c4cae5b]{height:10px!important;width:10px!important}.vc-hue-slider.small-slider .small-bar div[data-v-5c4cae5b]{width:12px!important;height:12px!important;border-radius:5px!important;transform:translate(-6px,-2px);margin-top:1px!important}.vc-lightness-slider[data-v-6156acb7]{position:relative;margin-bottom:15px;width:100%;height:14px;box-shadow:2px 0 8px #00000014;border-radius:15px}.vc-lightness-slider.is-vertical[data-v-6156acb7]{width:14px;height:100%;display:inline-block;transform:rotate(180deg)}.vc-lightness-slider.transparent[data-v-6156acb7]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-lightness-slider__bar[data-v-6156acb7]{position:relative;width:100%;height:100%;border-radius:15px}.vc-lightness-slider__bar-pointer[data-v-6156acb7]{position:absolute;width:14px;height:14px}.vc-lightness-slider__bar-handle[data-v-6156acb7]{width:14px;height:14px;border-radius:6px;transform:translate(-7px,-2px);background-color:#f8f8f8;margin-top:2px;box-shadow:0 1px 4px #0000005e;cursor:pointer}.vc-lightness-slider__bar-handle.vertical[data-v-6156acb7]{transform:translateY(-7px);margin-top:0}.vc-lightness-slider.small-slider[data-v-6156acb7]{height:10px!important}.vc-lightness-slider.small-slider .small-bar[data-v-6156acb7]{height:10px!important;width:10px!important}.vc-lightness-slider.small-slider .small-bar div[data-v-6156acb7]{width:12px!important;height:12px!important;border-radius:5px!important;transform:translate(-6px,-2px);margin-top:1px!important}.vc-colorPicker__record[data-v-7e6b67ca]{display:flex;align-items:center;margin-top:15px}.vc-colorPicker__record .text[data-v-7e6b67ca]{width:48px;margin-right:10px;text-align:right;font-size:12px;color:#666}.vc-colorPicker__record .color-list[data-v-7e6b67ca]{width:auto;display:flex;position:relative;margin:0}.vc-colorPicker__record .color-list .color-item[data-v-7e6b67ca]{position:relative;width:26px;height:26px;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle;margin-right:1px;box-shadow:3px 0 5px #00000014}.vc-colorPicker__record .color-list .color-item__round[data-v-7e6b67ca]{border-radius:50%}.vc-colorPicker__record .color-list .color-item.transparent[data-v-7e6b67ca]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-colorPicker__record .color-list .color-item[data-v-7e6b67ca]:hover{transform:scale(1.2);z-index:299;transition:transform .2s}.vc-colorPicker__record .color-list .color-item__display[data-v-7e6b67ca]{width:100%;height:100%}.vc-display[data-v-0067da1d]{margin-top:16px;height:28px;display:flex;align-items:center}.vc-display .vc-current-color[data-v-0067da1d]{margin-right:10px;width:50px;height:100%;box-shadow:3px 0 5px #00000014;position:relative;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle}.vc-display .vc-current-color.vc-transparent[data-v-0067da1d]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-display .vc-current-color .color-cube[data-v-0067da1d]{width:100%;height:100%}.vc-display .vc-color-input[data-v-0067da1d]{height:100%;flex:1;flex-shrink:0;box-sizing:border-box;position:relative}.vc-display .vc-color-input input[data-v-0067da1d]{padding:0;border:0;outline:none;cursor:pointer;color:#33383e;font-size:14px;text-align:center;box-sizing:border-box;background-color:#f1f2f4;border-radius:4px;height:100%;width:100%}.vc-display .vc-alpha-input[data-v-0067da1d]{margin-left:8px;width:56px;height:100%;border:none;display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;background-color:#f1f2f4;border-radius:4px;font-size:14px}.vc-display .vc-alpha-input>input[data-v-0067da1d]{width:100%;padding:0;text-align:center;color:inherit;font-size:inherit}.vc-display .vc-alpha-input__inner[data-v-0067da1d]{padding:10px 16px;border-radius:4px;color:#000;font-size:14px;line-height:20px;background:transparent;outline:none;border:none;display:block;box-sizing:border-box;cursor:pointer}.vc-fk-colorPicker[data-v-592a5ec3]{position:relative;box-sizing:border-box;border-radius:3px;user-select:none;background-color:#fff}.vc-fk-colorPicker__inner[data-v-592a5ec3]{position:relative}.vc-fk-colorPicker__header[data-v-592a5ec3]{margin-bottom:12px;z-index:999;text-align:left}.vc-fk-colorPicker__header .back[data-v-592a5ec3]{border:solid black;border-width:0 1px 1px 0;display:inline-block;padding:4px;margin-left:2px;transform:rotate(135deg)}.vc-fk-colorPicker__display[data-v-592a5ec3]{position:relative;width:100%;margin:0;text-align:left}.vc-fk-colorPicker__display .transparent[data-v-592a5ec3]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-fk-colorPicker__display .current-color[data-v-592a5ec3]{margin-right:10px;width:50px;height:24px;box-shadow:3px 0 5px #00000014;position:relative;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle}.vc-fk-colorPicker__display .current-color .color-cube[data-v-592a5ec3]{width:100%;height:100%}.vc-fk-colorPicker__display .hexColor-prefix[data-v-592a5ec3]{position:relative;padding:0 4px;font-size:14px;display:inline-block;vertical-align:middle}.vc-fk-colorPicker__display input[data-v-592a5ec3]{width:25px;text-align:center;outline:0;border-top:0;border-right:0;border-left:none;display:inline-block;vertical-align:middle;padding-bottom:3px;border-bottom:1px solid #e3e2e8}.vc-fk-colorPicker__display .hexColor-input[data-v-592a5ec3]{width:64px}.vc-fk-colorPicker__display .action[data-v-592a5ec3]{float:right;vertical-align:middle}.vc-fk-colorPicker__display .action .clear-btn[data-v-592a5ec3]{border-color:transparent;color:#409eff;background:transparent;padding-left:0;padding-right:0;display:inline-block;vertical-align:middle;cursor:pointer}.vc-fk-colorPicker__display .action .copy-btn[data-v-592a5ec3]{border-color:transparent;color:#13ce66cc;background:transparent;padding-left:0;padding-right:0;display:inline-block;margin-left:10px;vertical-align:middle;cursor:pointer}.vc-chrome-colorPicker[data-v-61d7303b]{position:relative;box-sizing:border-box;border-radius:3px;user-select:none;background-color:#fff}.vc-chrome-colorPicker-body[data-v-61d7303b]{position:relative;background-color:#fff}.vc-chrome-colorPicker-body .chrome-controls[data-v-61d7303b]{display:flex}.vc-chrome-colorPicker-body .chrome-controls .chrome-color-wrap[data-v-61d7303b]{position:relative;width:36px;height:36px;border-radius:50%;overflow:hidden;z-index:1}.vc-chrome-colorPicker-body .chrome-controls .chrome-color-wrap.transparent[data-v-61d7303b]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-chrome-colorPicker-body .chrome-controls .chrome-color-wrap .current-color[data-v-61d7303b]{width:100%;height:100%}.vc-chrome-colorPicker-body .chrome-controls .chrome-sliders[data-v-61d7303b]{flex:1;margin-left:10px}.vc-gradient-picker[data-v-f63daa7a]{position:relative}.vc-gradient-picker__header[data-v-f63daa7a]{margin-bottom:20px;z-index:999;text-align:left}.vc-gradient-picker__header .back[data-v-f63daa7a]{border:solid black;border-width:0 1px 1px 0;display:inline-block;padding:4px;margin-left:2px;transform:rotate(135deg)}.vc-gradient-picker__body[data-v-f63daa7a]{margin-bottom:12px;display:-ms-flexbox;display:flex;align-items:center}.vc-gradient-picker__body .vc-color-range[data-v-f63daa7a]{flex:1}.vc-gradient-picker__body .vc-color-range__container[data-v-f63daa7a]{position:relative;height:16px;border-radius:5px}.vc-gradient-picker__body .vc-color-range__container .vc-background[data-v-f63daa7a]{height:100%;border-radius:4px;box-shadow:inset 0 0 0 1px #0000000f}.vc-gradient-picker__body .vc-color-range__container .vc-gradient__stop__container[data-v-f63daa7a]{position:absolute;width:100%;top:0;height:100%;left:0}.vc-gradient-picker__body .vc-color-range__container .vc-gradient__stop__container .vc-gradient__stop[data-v-f63daa7a]{position:absolute;top:-2px;width:14px;height:16px;overflow:hidden;border:2px solid #fff;border-radius:2px;cursor:pointer;box-shadow:0 0 2px #00000059;box-sizing:content-box;transform:translate(-9px)}.vc-gradient-picker__body .vc-color-range__container .vc-gradient__stop__container .vc-gradient__stop--inner[data-v-f63daa7a]{display:inline-block;height:100%}.vc-gradient-picker__body .vc-color-range__container .vc-gradient__stop__container .vc-gradient__stop--current[data-v-f63daa7a]{position:relative;z-index:1;box-shadow:0 0 4px #0003,0 0 0 1.2px #2254f4}.vc-gradient-picker__body .vc-degree-input[data-v-f63daa7a]{position:relative;z-index:2;font-size:12px;background-color:#f6f7f9;border-radius:4px}.vc-gradient-picker__body .vc-degree-input:hover .vc-degree-input__panel[data-v-f63daa7a]{display:block}.vc-gradient-picker__body .vc-degree-input__control[data-v-f63daa7a]{width:100%;height:100%;display:flex;justify-content:center;align-items:center;border-radius:4px;background-color:inherit}.vc-gradient-picker__body .vc-degree-input__control input[data-v-f63daa7a]{max-width:28px;text-align:center;border:none;outline:none;background-color:initial;color:#33383e;font-size:inherit;overflow:visible}.vc-gradient-picker__body .vc-degree-input__panel[data-v-f63daa7a]{display:none;padding-top:4px;z-index:10}.vc-gradient-picker__body .vc-degree-input__panel .vc-degree-input__disk[data-v-f63daa7a]{width:64px;height:64px;background-color:#fff;box-shadow:0 0 2px #00000029,0 1px 8px #0000000f,0 4px 12px #00000014;border-radius:4px;display:flex;justify-content:center;align-items:center;position:relative;transform:translate(0)}.vc-gradient-picker__body .vc-picker-degree-input[data-v-f63daa7a]{margin-left:8px;width:64px;height:28px}.vc-colorpicker[data-v-4afdf3bb]{position:relative;box-sizing:border-box;border-radius:3px;box-shadow:0 0 10px #00000026;user-select:none;background-color:#fff;width:276px;padding-bottom:10px;z-index:10000}.vc-colorpicker *[data-v-4afdf3bb]{outline:none;line-height:1}.vc-colorpicker--container[data-v-4afdf3bb]{padding:16px}.vc-colorpicker--tabs[data-v-4afdf3bb]{padding:2px;background:#f6f7f9;border-radius:6px;position:relative;margin-bottom:12px}.vc-colorpicker--tabs__inner[data-v-4afdf3bb]{display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;padding:0;background:#f6f7f9;border-bottom:none;position:relative;box-sizing:border-box}.vc-colorpicker--tabs__btn[data-v-4afdf3bb]{-ms-flex:1;flex:1;z-index:2;color:#636c78;font-size:14px;border-radius:4px;cursor:pointer}.vc-colorpicker--tabs__btn.vc-btn-active[data-v-4afdf3bb]{color:#33383e;font-weight:600}.vc-colorpicker--tabs__btn button[data-v-4afdf3bb]{width:100%;background-color:initial;padding:6px 0;font-size:14px;line-height:20px;color:#636c78;border:0;border-radius:0;outline:0;cursor:pointer;-webkit-appearance:none;font-weight:inherit}.vc-colorpicker--tabs__btn button .vc-btn__content[data-v-4afdf3bb]{position:relative;white-space:nowrap}.vc-colorpicker--tabs__bg[data-v-4afdf3bb]{position:absolute;top:0;bottom:0;background:#fff;box-shadow:0 1px 4px #0000001f;border-radius:4px;z-index:1;transition:left .2s ease-in-out}.vc-color-wrap[data-v-0aa3a75d]{margin-right:10px;width:50px;height:24px;box-shadow:3px 0 5px #00000014;position:relative;cursor:pointer;overflow:hidden;display:inline-block;vertical-align:middle}.vc-color-wrap.transparent[data-v-0aa3a75d]{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVQYV2M4gwH+YwCGIasIUwhT25BVBADtzYNYrHvv4gAAAABJRU5ErkJggg==);background-repeat:repeat}.vc-color-wrap.round[data-v-0aa3a75d]{width:22px;height:22px;border-radius:50%;border:1px solid #d8d8d8}.vc-color-wrap .current-color[data-v-0aa3a75d]{width:100%;height:100%}
.ps__thumb-x {
  background-color: #e5e6ec;
}

.ps__thumb-x {
  background-color: #d7d8df;
  height: 6px;
  /* there must be 'bottom' for ps__thumb-x */
  bottom: 2px;
}

.ps__thumb-y {
  background-color: #d7d8df;
  width: 6px;
  /* there must be 'right' for ps__thumb-y */
  right: 2px;
}

.ps__rail-x {
  border-radius: 6px;
  height: 12px;
}

.ps__rail-y {
  border-radius: 6px;
  width: 12px;
}

.ps__rail-x:hover > .ps__thumb-x,
.ps__rail-x:focus > .ps__thumb-x,
.ps__rail-x.ps--clicking .ps__thumb-x {
  background-color: #d7d8df;
  height: 8px;
}

.ps__rail-y:hover > .ps__thumb-y,
.ps__rail-y:focus > .ps__thumb-y,
.ps__rail-y.ps--clicking .ps__thumb-y {
  background-color: #d7d8df;
  width: 8px;
}

.bg-color-transparent {
  background-color: rgba(255, 255, 255, 0.5) !important;
}

.bg-color-grey {
  background-color: #f3f4fa !important;
}

.kanban-avatar {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 27px;
  width: 27px;
  overflow: hidden;
  background-color: #f3f4fa;
  border-radius: 50%;
}
.kanban-avatar span {
  font-size: 0.85em;
  font-weight: 700;
  color: #808080;
}
.kanban-avatar img {
  height: 27px;
}`;
document.head.appendChild(__vite_style__);
System.register(["vue", "@vue-mf/styleguide"], function(exports) {
  "use strict";
  var h$5, reactive, computed, openBlock, createBlock, createVNode, resolveComponent, renderSlot, toDisplayString, Fragment, renderList, Transition, withCtx, createCommentVNode, createTextVNode, mergeProps, pushScopeId, popScopeId, withModifiers, withScopeId, defineComponent, toRaw, unref, createElementBlock, normalizeStyle, normalizeClass, resolveDynamicComponent, createElementVNode, toHandlers, TransitionGroup, getCurrentInstance, inject, nextTick, createApp, toRef, watch, onMounted, provide, isRef, onBeforeUnmount, ref, warn$1, watchEffect, readonly, onUnmounted, markRaw, resolveDirective, withDirectives, vShow, vModelText, withKeys, createSlots, shallowReactive, onBeforeMount, getCurrentScope, onScopeDispose, shallowRef, Teleport, Button;
  return {
    setters: [function(module2) {
      h$5 = module2.h;
      reactive = module2.reactive;
      computed = module2.computed;
      openBlock = module2.openBlock;
      createBlock = module2.createBlock;
      createVNode = module2.createVNode;
      resolveComponent = module2.resolveComponent;
      renderSlot = module2.renderSlot;
      toDisplayString = module2.toDisplayString;
      Fragment = module2.Fragment;
      renderList = module2.renderList;
      Transition = module2.Transition;
      withCtx = module2.withCtx;
      createCommentVNode = module2.createCommentVNode;
      createTextVNode = module2.createTextVNode;
      mergeProps = module2.mergeProps;
      pushScopeId = module2.pushScopeId;
      popScopeId = module2.popScopeId;
      withModifiers = module2.withModifiers;
      withScopeId = module2.withScopeId;
      defineComponent = module2.defineComponent;
      toRaw = module2.toRaw;
      unref = module2.unref;
      createElementBlock = module2.createElementBlock;
      normalizeStyle = module2.normalizeStyle;
      normalizeClass = module2.normalizeClass;
      resolveDynamicComponent = module2.resolveDynamicComponent;
      createElementVNode = module2.createElementVNode;
      toHandlers = module2.toHandlers;
      TransitionGroup = module2.TransitionGroup;
      getCurrentInstance = module2.getCurrentInstance;
      inject = module2.inject;
      nextTick = module2.nextTick;
      createApp = module2.createApp;
      toRef = module2.toRef;
      watch = module2.watch;
      onMounted = module2.onMounted;
      provide = module2.provide;
      isRef = module2.isRef;
      onBeforeUnmount = module2.onBeforeUnmount;
      ref = module2.ref;
      warn$1 = module2.warn;
      watchEffect = module2.watchEffect;
      readonly = module2.readonly;
      onUnmounted = module2.onUnmounted;
      markRaw = module2.markRaw;
      resolveDirective = module2.resolveDirective;
      withDirectives = module2.withDirectives;
      vShow = module2.vShow;
      vModelText = module2.vModelText;
      withKeys = module2.withKeys;
      createSlots = module2.createSlots;
      shallowReactive = module2.shallowReactive;
      onBeforeMount = module2.onBeforeMount;
      getCurrentScope = module2.getCurrentScope;
      onScopeDispose = module2.onScopeDispose;
      shallowRef = module2.shallowRef;
      Teleport = module2.Teleport;
    }, function(module2) {
      Button = module2.Button;
    }],
    execute: function() {
      var e$4, n$4, t$5 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function r$4(e2, n2) {
        var t2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var r2 = Object.getOwnPropertySymbols(e2);
          n2 && (r2 = r2.filter(function(n3) {
            return Object.getOwnPropertyDescriptor(e2, n3).enumerable;
          })), t2.push.apply(t2, r2);
        }
        return t2;
      }
      function o$5(e2) {
        for (var n2 = 1; n2 < arguments.length; n2++) {
          var t2 = arguments[n2] != null ? arguments[n2] : {};
          n2 % 2 ? r$4(Object(t2), true).forEach(function(n3) {
            a$5(e2, n3, t2[n3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : r$4(Object(t2)).forEach(function(n3) {
            Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t2, n3));
          });
        }
        return e2;
      }
      function a$5(e2, n2, t2) {
        return n2 in e2 ? Object.defineProperty(e2, n2, { value: t2, enumerable: true, configurable: true, writable: true }) : e2[n2] = t2, e2;
      }
      function i$5(e2) {
        return (i$5 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        })(e2);
      }
      (function(e2, n2) {
        var r2;
        r2 = t$5, e2.exports = function(e3) {
          if (e3.CSS && e3.CSS.escape)
            return e3.CSS.escape;
          var n3 = function(e4) {
            if (arguments.length == 0)
              throw new TypeError("`CSS.escape` requires an argument.");
            for (var n4, t2 = String(e4), r3 = t2.length, o2 = -1, a2 = "", i2 = t2.charCodeAt(0); ++o2 < r3; )
              (n4 = t2.charCodeAt(o2)) != 0 ? a2 += n4 >= 1 && n4 <= 31 || n4 == 127 || o2 == 0 && n4 >= 48 && n4 <= 57 || o2 == 1 && n4 >= 48 && n4 <= 57 && i2 == 45 ? "\\" + n4.toString(16) + " " : o2 == 0 && r3 == 1 && n4 == 45 || !(n4 >= 128 || n4 == 45 || n4 == 95 || n4 >= 48 && n4 <= 57 || n4 >= 65 && n4 <= 90 || n4 >= 97 && n4 <= 122) ? "\\" + t2.charAt(o2) : t2.charAt(o2) : a2 += "\uFFFD";
            return a2;
          };
          return e3.CSS || (e3.CSS = {}), e3.CSS.escape = n3, n3;
        }(r2);
      })(n$4 = { path: e$4, exports: {}, require: function(e2, t2) {
        return function() {
          throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
        }(t2 == null && n$4.path);
      } }, n$4.exports), n$4.exports;
      var p$6 = { appOptions: null, template: null, Vue: null, createApp: null, handleInstance: null };
      function u$5(e2) {
        if (i$5(e2) !== "object")
          throw new Error("single-spa-vue requires a configuration object");
        var n2 = o$5(o$5({}, p$6), e2);
        if (!n2.Vue && !n2.createApp)
          throw Error("single-spa-vue must be passed opts.Vue or opts.createApp");
        if (!n2.appOptions)
          throw Error("single-spa-vue must be passed opts.appOptions");
        if (n2.appOptions.el && typeof n2.appOptions.el != "string" && !(n2.appOptions.el instanceof HTMLElement))
          throw Error("single-spa-vue: appOptions.el must be a string CSS selector, an HTMLElement, or not provided at all. Was given ".concat(i$5(n2.appOptions.el)));
        n2.createApp = n2.createApp || n2.Vue && n2.Vue.createApp;
        var t2 = {};
        return { bootstrap: c$6.bind(null, n2, t2), mount: l$6.bind(null, n2, t2), unmount: f$5.bind(null, n2, t2), update: s$5.bind(null, n2, t2) };
      }
      function c$6(e2) {
        return e2.loadRootComponent ? e2.loadRootComponent().then(function(n2) {
          return e2.rootComponent = n2;
        }) : Promise.resolve();
      }
      function l$6(e2, n2, t2) {
        var r2 = {};
        return Promise.resolve().then(function() {
          return function(e3, n3) {
            return typeof e3.appOptions == "function" ? e3.appOptions(n3) : Promise.resolve(o$5({}, e3.appOptions));
          }(e2, t2).then(function(a2) {
            var i2;
            if (t2.domElement && !a2.el && (a2.el = t2.domElement), a2.el)
              if (typeof a2.el == "string") {
                if (!(i2 = document.querySelector(a2.el)))
                  throw Error("If appOptions.el is provided to single-spa-vue, the dom element must exist in the dom. Was provided as ".concat(a2.el));
              } else
                (i2 = a2.el).id || (i2.id = "single-spa-application:".concat(t2.name)), a2.el = "#".concat(CSS.escape(i2.id));
            else {
              var p2 = "single-spa-application:".concat(t2.name);
              a2.el = "#".concat(CSS.escape(p2)), (i2 = document.getElementById(p2)) || ((i2 = document.createElement("div")).id = p2, document.body.appendChild(i2));
            }
            if (e2.replaceMode || (a2.el = a2.el + " .single-spa-container"), !i2.querySelector(".single-spa-container")) {
              var u2 = document.createElement("div");
              u2.className = "single-spa-container", i2.appendChild(u2);
            }
            if (r2.domEl = i2, a2.render || a2.template || !e2.rootComponent || (a2.render = function(n3) {
              return n3(e2.rootComponent);
            }), a2.data || (a2.data = {}), a2.data = function() {
              return o$5(o$5({}, a2.data), t2);
            }, e2.createApp) {
              if (r2.vueInstance = e2.createApp(a2), e2.handleInstance)
                return Promise.resolve(e2.handleInstance(r2.vueInstance, t2)).then(function() {
                  return r2.root = r2.vueInstance.mount(a2.el), n2[t2.name] = r2, r2.vueInstance;
                });
              r2.root = r2.vueInstance.mount(a2.el);
            } else if (r2.vueInstance = new e2.Vue(a2), r2.vueInstance.bind && (r2.vueInstance = r2.vueInstance.bind(r2.vueInstance)), e2.handleInstance)
              return Promise.resolve(e2.handleInstance(r2.vueInstance, t2)).then(function() {
                return n2[t2.name] = r2, r2.vueInstance;
              });
            return n2[t2.name] = r2, r2.vueInstance;
          });
        });
      }
      function s$5(e2, n2, t2) {
        return Promise.resolve().then(function() {
          var r2 = n2[t2.name], a2 = o$5(o$5({}, e2.appOptions.data || {}), t2), i2 = r2.root || r2.vueInstance;
          for (var p2 in a2)
            i2[p2] = a2[p2];
        });
      }
      function f$5(e2, n2, t2) {
        return Promise.resolve().then(function() {
          var r2 = n2[t2.name];
          e2.createApp ? r2.vueInstance.unmount(r2.domEl) : (r2.vueInstance.$destroy(), r2.vueInstance.$el.innerHTML = ""), delete r2.vueInstance, r2.domEl && (r2.domEl.innerHTML = "", delete r2.domEl);
        });
      }
      /*!
       * perfect-scrollbar v1.5.3
       * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
       * Licensed under MIT
       */
      function get$1(element) {
        return getComputedStyle(element);
      }
      function set$2(element, obj) {
        for (var key in obj) {
          var val = obj[key];
          if (typeof val === "number") {
            val = val + "px";
          }
          element.style[key] = val;
        }
        return element;
      }
      function div(className) {
        var div2 = document.createElement("div");
        div2.className = className;
        return div2;
      }
      var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
      function matches$1(element, query) {
        if (!elMatches) {
          throw new Error("No element matching method supported");
        }
        return elMatches.call(element, query);
      }
      function remove(element) {
        if (element.remove) {
          element.remove();
        } else {
          if (element.parentNode) {
            element.parentNode.removeChild(element);
          }
        }
      }
      function queryChildren(element, selector) {
        return Array.prototype.filter.call(element.children, function(child) {
          return matches$1(child, selector);
        });
      }
      var cls = {
        main: "ps",
        rtl: "ps__rtl",
        element: {
          thumb: function(x2) {
            return "ps__thumb-" + x2;
          },
          rail: function(x2) {
            return "ps__rail-" + x2;
          },
          consuming: "ps__child--consume"
        },
        state: {
          focus: "ps--focus",
          clicking: "ps--clicking",
          active: function(x2) {
            return "ps--active-" + x2;
          },
          scrolling: function(x2) {
            return "ps--scrolling-" + x2;
          }
        }
      };
      var scrollingClassTimeout = { x: null, y: null };
      function addScrollingClass(i2, x2) {
        var classList = i2.element.classList;
        var className = cls.state.scrolling(x2);
        if (classList.contains(className)) {
          clearTimeout(scrollingClassTimeout[x2]);
        } else {
          classList.add(className);
        }
      }
      function removeScrollingClass(i2, x2) {
        scrollingClassTimeout[x2] = setTimeout(function() {
          return i2.isAlive && i2.element.classList.remove(cls.state.scrolling(x2));
        }, i2.settings.scrollingThreshold);
      }
      function setScrollingClassInstantly(i2, x2) {
        addScrollingClass(i2, x2);
        removeScrollingClass(i2, x2);
      }
      var EventElement = function EventElement2(element) {
        this.element = element;
        this.handlers = {};
      };
      var prototypeAccessors$2 = { isEmpty: { configurable: true } };
      EventElement.prototype.bind = function bind2(eventName, handler) {
        if (typeof this.handlers[eventName] === "undefined") {
          this.handlers[eventName] = [];
        }
        this.handlers[eventName].push(handler);
        this.element.addEventListener(eventName, handler, false);
      };
      EventElement.prototype.unbind = function unbind(eventName, target) {
        var this$1$1 = this;
        this.handlers[eventName] = this.handlers[eventName].filter(function(handler) {
          if (target && handler !== target) {
            return true;
          }
          this$1$1.element.removeEventListener(eventName, handler, false);
          return false;
        });
      };
      EventElement.prototype.unbindAll = function unbindAll() {
        for (var name in this.handlers) {
          this.unbind(name);
        }
      };
      prototypeAccessors$2.isEmpty.get = function() {
        var this$1$1 = this;
        return Object.keys(this.handlers).every(function(key) {
          return this$1$1.handlers[key].length === 0;
        });
      };
      Object.defineProperties(EventElement.prototype, prototypeAccessors$2);
      var EventManager = function EventManager2() {
        this.eventElements = [];
      };
      EventManager.prototype.eventElement = function eventElement(element) {
        var ee2 = this.eventElements.filter(function(ee3) {
          return ee3.element === element;
        })[0];
        if (!ee2) {
          ee2 = new EventElement(element);
          this.eventElements.push(ee2);
        }
        return ee2;
      };
      EventManager.prototype.bind = function bind2(element, eventName, handler) {
        this.eventElement(element).bind(eventName, handler);
      };
      EventManager.prototype.unbind = function unbind(element, eventName, handler) {
        var ee2 = this.eventElement(element);
        ee2.unbind(eventName, handler);
        if (ee2.isEmpty) {
          this.eventElements.splice(this.eventElements.indexOf(ee2), 1);
        }
      };
      EventManager.prototype.unbindAll = function unbindAll() {
        this.eventElements.forEach(function(e2) {
          return e2.unbindAll();
        });
        this.eventElements = [];
      };
      EventManager.prototype.once = function once(element, eventName, handler) {
        var ee2 = this.eventElement(element);
        var onceHandler = function(evt) {
          ee2.unbind(eventName, onceHandler);
          handler(evt);
        };
        ee2.bind(eventName, onceHandler);
      };
      function createEvent(name) {
        if (typeof window.CustomEvent === "function") {
          return new CustomEvent(name);
        } else {
          var evt = document.createEvent("CustomEvent");
          evt.initCustomEvent(name, false, false, void 0);
          return evt;
        }
      }
      function processScrollDiff(i2, axis, diff, useScrollingClass, forceFireReachEvent) {
        if (useScrollingClass === void 0)
          useScrollingClass = true;
        if (forceFireReachEvent === void 0)
          forceFireReachEvent = false;
        var fields;
        if (axis === "top") {
          fields = [
            "contentHeight",
            "containerHeight",
            "scrollTop",
            "y",
            "up",
            "down"
          ];
        } else if (axis === "left") {
          fields = [
            "contentWidth",
            "containerWidth",
            "scrollLeft",
            "x",
            "left",
            "right"
          ];
        } else {
          throw new Error("A proper axis should be provided");
        }
        processScrollDiff$1(i2, diff, fields, useScrollingClass, forceFireReachEvent);
      }
      function processScrollDiff$1(i2, diff, ref2, useScrollingClass, forceFireReachEvent) {
        var contentHeight = ref2[0];
        var containerHeight = ref2[1];
        var scrollTop = ref2[2];
        var y2 = ref2[3];
        var up = ref2[4];
        var down = ref2[5];
        if (useScrollingClass === void 0)
          useScrollingClass = true;
        if (forceFireReachEvent === void 0)
          forceFireReachEvent = false;
        var element = i2.element;
        i2.reach[y2] = null;
        if (element[scrollTop] < 1) {
          i2.reach[y2] = "start";
        }
        if (element[scrollTop] > i2[contentHeight] - i2[containerHeight] - 1) {
          i2.reach[y2] = "end";
        }
        if (diff) {
          element.dispatchEvent(createEvent("ps-scroll-" + y2));
          if (diff < 0) {
            element.dispatchEvent(createEvent("ps-scroll-" + up));
          } else if (diff > 0) {
            element.dispatchEvent(createEvent("ps-scroll-" + down));
          }
          if (useScrollingClass) {
            setScrollingClassInstantly(i2, y2);
          }
        }
        if (i2.reach[y2] && (diff || forceFireReachEvent)) {
          element.dispatchEvent(createEvent("ps-" + y2 + "-reach-" + i2.reach[y2]));
        }
      }
      function toInt(x2) {
        return parseInt(x2, 10) || 0;
      }
      function isEditable(el) {
        return matches$1(el, "input,[contenteditable]") || matches$1(el, "select,[contenteditable]") || matches$1(el, "textarea,[contenteditable]") || matches$1(el, "button,[contenteditable]");
      }
      function outerWidth(element) {
        var styles = get$1(element);
        return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
      }
      var env = {
        isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
        supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
        supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
        isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
      };
      function updateGeometry(i2) {
        var element = i2.element;
        var roundedScrollTop = Math.floor(element.scrollTop);
        var rect = element.getBoundingClientRect();
        i2.containerWidth = Math.round(rect.width);
        i2.containerHeight = Math.round(rect.height);
        i2.contentWidth = element.scrollWidth;
        i2.contentHeight = element.scrollHeight;
        if (!element.contains(i2.scrollbarXRail)) {
          queryChildren(element, cls.element.rail("x")).forEach(function(el) {
            return remove(el);
          });
          element.appendChild(i2.scrollbarXRail);
        }
        if (!element.contains(i2.scrollbarYRail)) {
          queryChildren(element, cls.element.rail("y")).forEach(function(el) {
            return remove(el);
          });
          element.appendChild(i2.scrollbarYRail);
        }
        if (!i2.settings.suppressScrollX && i2.containerWidth + i2.settings.scrollXMarginOffset < i2.contentWidth) {
          i2.scrollbarXActive = true;
          i2.railXWidth = i2.containerWidth - i2.railXMarginWidth;
          i2.railXRatio = i2.containerWidth / i2.railXWidth;
          i2.scrollbarXWidth = getThumbSize(i2, toInt(i2.railXWidth * i2.containerWidth / i2.contentWidth));
          i2.scrollbarXLeft = toInt((i2.negativeScrollAdjustment + element.scrollLeft) * (i2.railXWidth - i2.scrollbarXWidth) / (i2.contentWidth - i2.containerWidth));
        } else {
          i2.scrollbarXActive = false;
        }
        if (!i2.settings.suppressScrollY && i2.containerHeight + i2.settings.scrollYMarginOffset < i2.contentHeight) {
          i2.scrollbarYActive = true;
          i2.railYHeight = i2.containerHeight - i2.railYMarginHeight;
          i2.railYRatio = i2.containerHeight / i2.railYHeight;
          i2.scrollbarYHeight = getThumbSize(i2, toInt(i2.railYHeight * i2.containerHeight / i2.contentHeight));
          i2.scrollbarYTop = toInt(roundedScrollTop * (i2.railYHeight - i2.scrollbarYHeight) / (i2.contentHeight - i2.containerHeight));
        } else {
          i2.scrollbarYActive = false;
        }
        if (i2.scrollbarXLeft >= i2.railXWidth - i2.scrollbarXWidth) {
          i2.scrollbarXLeft = i2.railXWidth - i2.scrollbarXWidth;
        }
        if (i2.scrollbarYTop >= i2.railYHeight - i2.scrollbarYHeight) {
          i2.scrollbarYTop = i2.railYHeight - i2.scrollbarYHeight;
        }
        updateCss(element, i2);
        if (i2.scrollbarXActive) {
          element.classList.add(cls.state.active("x"));
        } else {
          element.classList.remove(cls.state.active("x"));
          i2.scrollbarXWidth = 0;
          i2.scrollbarXLeft = 0;
          element.scrollLeft = i2.isRtl === true ? i2.contentWidth : 0;
        }
        if (i2.scrollbarYActive) {
          element.classList.add(cls.state.active("y"));
        } else {
          element.classList.remove(cls.state.active("y"));
          i2.scrollbarYHeight = 0;
          i2.scrollbarYTop = 0;
          element.scrollTop = 0;
        }
      }
      function getThumbSize(i2, thumbSize) {
        if (i2.settings.minScrollbarLength) {
          thumbSize = Math.max(thumbSize, i2.settings.minScrollbarLength);
        }
        if (i2.settings.maxScrollbarLength) {
          thumbSize = Math.min(thumbSize, i2.settings.maxScrollbarLength);
        }
        return thumbSize;
      }
      function updateCss(element, i2) {
        var xRailOffset = { width: i2.railXWidth };
        var roundedScrollTop = Math.floor(element.scrollTop);
        if (i2.isRtl) {
          xRailOffset.left = i2.negativeScrollAdjustment + element.scrollLeft + i2.containerWidth - i2.contentWidth;
        } else {
          xRailOffset.left = element.scrollLeft;
        }
        if (i2.isScrollbarXUsingBottom) {
          xRailOffset.bottom = i2.scrollbarXBottom - roundedScrollTop;
        } else {
          xRailOffset.top = i2.scrollbarXTop + roundedScrollTop;
        }
        set$2(i2.scrollbarXRail, xRailOffset);
        var yRailOffset = { top: roundedScrollTop, height: i2.railYHeight };
        if (i2.isScrollbarYUsingRight) {
          if (i2.isRtl) {
            yRailOffset.right = i2.contentWidth - (i2.negativeScrollAdjustment + element.scrollLeft) - i2.scrollbarYRight - i2.scrollbarYOuterWidth - 9;
          } else {
            yRailOffset.right = i2.scrollbarYRight - element.scrollLeft;
          }
        } else {
          if (i2.isRtl) {
            yRailOffset.left = i2.negativeScrollAdjustment + element.scrollLeft + i2.containerWidth * 2 - i2.contentWidth - i2.scrollbarYLeft - i2.scrollbarYOuterWidth;
          } else {
            yRailOffset.left = i2.scrollbarYLeft + element.scrollLeft;
          }
        }
        set$2(i2.scrollbarYRail, yRailOffset);
        set$2(i2.scrollbarX, {
          left: i2.scrollbarXLeft,
          width: i2.scrollbarXWidth - i2.railBorderXWidth
        });
        set$2(i2.scrollbarY, {
          top: i2.scrollbarYTop,
          height: i2.scrollbarYHeight - i2.railBorderYWidth
        });
      }
      function clickRail(i2) {
        i2.element;
        i2.event.bind(i2.scrollbarY, "mousedown", function(e2) {
          return e2.stopPropagation();
        });
        i2.event.bind(i2.scrollbarYRail, "mousedown", function(e2) {
          var positionTop = e2.pageY - window.pageYOffset - i2.scrollbarYRail.getBoundingClientRect().top;
          var direction = positionTop > i2.scrollbarYTop ? 1 : -1;
          i2.element.scrollTop += direction * i2.containerHeight;
          updateGeometry(i2);
          e2.stopPropagation();
        });
        i2.event.bind(i2.scrollbarX, "mousedown", function(e2) {
          return e2.stopPropagation();
        });
        i2.event.bind(i2.scrollbarXRail, "mousedown", function(e2) {
          var positionLeft = e2.pageX - window.pageXOffset - i2.scrollbarXRail.getBoundingClientRect().left;
          var direction = positionLeft > i2.scrollbarXLeft ? 1 : -1;
          i2.element.scrollLeft += direction * i2.containerWidth;
          updateGeometry(i2);
          e2.stopPropagation();
        });
      }
      function dragThumb(i2) {
        bindMouseScrollHandler(i2, [
          "containerWidth",
          "contentWidth",
          "pageX",
          "railXWidth",
          "scrollbarX",
          "scrollbarXWidth",
          "scrollLeft",
          "x",
          "scrollbarXRail"
        ]);
        bindMouseScrollHandler(i2, [
          "containerHeight",
          "contentHeight",
          "pageY",
          "railYHeight",
          "scrollbarY",
          "scrollbarYHeight",
          "scrollTop",
          "y",
          "scrollbarYRail"
        ]);
      }
      function bindMouseScrollHandler(i2, ref2) {
        var containerHeight = ref2[0];
        var contentHeight = ref2[1];
        var pageY = ref2[2];
        var railYHeight = ref2[3];
        var scrollbarY = ref2[4];
        var scrollbarYHeight = ref2[5];
        var scrollTop = ref2[6];
        var y2 = ref2[7];
        var scrollbarYRail = ref2[8];
        var element = i2.element;
        var startingScrollTop = null;
        var startingMousePageY = null;
        var scrollBy2 = null;
        function mouseMoveHandler(e2) {
          if (e2.touches && e2.touches[0]) {
            e2[pageY] = e2.touches[0].pageY;
          }
          element[scrollTop] = startingScrollTop + scrollBy2 * (e2[pageY] - startingMousePageY);
          addScrollingClass(i2, y2);
          updateGeometry(i2);
          e2.stopPropagation();
          if (e2.type.startsWith("touch") && e2.changedTouches.length > 1) {
            e2.preventDefault();
          }
        }
        function mouseUpHandler() {
          removeScrollingClass(i2, y2);
          i2[scrollbarYRail].classList.remove(cls.state.clicking);
          i2.event.unbind(i2.ownerDocument, "mousemove", mouseMoveHandler);
        }
        function bindMoves(e2, touchMode) {
          startingScrollTop = element[scrollTop];
          if (touchMode && e2.touches) {
            e2[pageY] = e2.touches[0].pageY;
          }
          startingMousePageY = e2[pageY];
          scrollBy2 = (i2[contentHeight] - i2[containerHeight]) / (i2[railYHeight] - i2[scrollbarYHeight]);
          if (!touchMode) {
            i2.event.bind(i2.ownerDocument, "mousemove", mouseMoveHandler);
            i2.event.once(i2.ownerDocument, "mouseup", mouseUpHandler);
            e2.preventDefault();
          } else {
            i2.event.bind(i2.ownerDocument, "touchmove", mouseMoveHandler);
          }
          i2[scrollbarYRail].classList.add(cls.state.clicking);
          e2.stopPropagation();
        }
        i2.event.bind(i2[scrollbarY], "mousedown", function(e2) {
          bindMoves(e2);
        });
        i2.event.bind(i2[scrollbarY], "touchstart", function(e2) {
          bindMoves(e2, true);
        });
      }
      function keyboard(i2) {
        var element = i2.element;
        var elementHovered = function() {
          return matches$1(element, ":hover");
        };
        var scrollbarFocused = function() {
          return matches$1(i2.scrollbarX, ":focus") || matches$1(i2.scrollbarY, ":focus");
        };
        function shouldPreventDefault(deltaX, deltaY) {
          var scrollTop = Math.floor(element.scrollTop);
          if (deltaX === 0) {
            if (!i2.scrollbarYActive) {
              return false;
            }
            if (scrollTop === 0 && deltaY > 0 || scrollTop >= i2.contentHeight - i2.containerHeight && deltaY < 0) {
              return !i2.settings.wheelPropagation;
            }
          }
          var scrollLeft = element.scrollLeft;
          if (deltaY === 0) {
            if (!i2.scrollbarXActive) {
              return false;
            }
            if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i2.contentWidth - i2.containerWidth && deltaX > 0) {
              return !i2.settings.wheelPropagation;
            }
          }
          return true;
        }
        i2.event.bind(i2.ownerDocument, "keydown", function(e2) {
          if (e2.isDefaultPrevented && e2.isDefaultPrevented() || e2.defaultPrevented) {
            return;
          }
          if (!elementHovered() && !scrollbarFocused()) {
            return;
          }
          var activeElement = document.activeElement ? document.activeElement : i2.ownerDocument.activeElement;
          if (activeElement) {
            if (activeElement.tagName === "IFRAME") {
              activeElement = activeElement.contentDocument.activeElement;
            } else {
              while (activeElement.shadowRoot) {
                activeElement = activeElement.shadowRoot.activeElement;
              }
            }
            if (isEditable(activeElement)) {
              return;
            }
          }
          var deltaX = 0;
          var deltaY = 0;
          switch (e2.which) {
            case 37:
              if (e2.metaKey) {
                deltaX = -i2.contentWidth;
              } else if (e2.altKey) {
                deltaX = -i2.containerWidth;
              } else {
                deltaX = -30;
              }
              break;
            case 38:
              if (e2.metaKey) {
                deltaY = i2.contentHeight;
              } else if (e2.altKey) {
                deltaY = i2.containerHeight;
              } else {
                deltaY = 30;
              }
              break;
            case 39:
              if (e2.metaKey) {
                deltaX = i2.contentWidth;
              } else if (e2.altKey) {
                deltaX = i2.containerWidth;
              } else {
                deltaX = 30;
              }
              break;
            case 40:
              if (e2.metaKey) {
                deltaY = -i2.contentHeight;
              } else if (e2.altKey) {
                deltaY = -i2.containerHeight;
              } else {
                deltaY = -30;
              }
              break;
            case 32:
              if (e2.shiftKey) {
                deltaY = i2.containerHeight;
              } else {
                deltaY = -i2.containerHeight;
              }
              break;
            case 33:
              deltaY = i2.containerHeight;
              break;
            case 34:
              deltaY = -i2.containerHeight;
              break;
            case 36:
              deltaY = i2.contentHeight;
              break;
            case 35:
              deltaY = -i2.contentHeight;
              break;
            default:
              return;
          }
          if (i2.settings.suppressScrollX && deltaX !== 0) {
            return;
          }
          if (i2.settings.suppressScrollY && deltaY !== 0) {
            return;
          }
          element.scrollTop -= deltaY;
          element.scrollLeft += deltaX;
          updateGeometry(i2);
          if (shouldPreventDefault(deltaX, deltaY)) {
            e2.preventDefault();
          }
        });
      }
      function wheel(i2) {
        var element = i2.element;
        function shouldPreventDefault(deltaX, deltaY) {
          var roundedScrollTop = Math.floor(element.scrollTop);
          var isTop = element.scrollTop === 0;
          var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
          var isLeft = element.scrollLeft === 0;
          var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
          var hitsBound;
          if (Math.abs(deltaY) > Math.abs(deltaX)) {
            hitsBound = isTop || isBottom;
          } else {
            hitsBound = isLeft || isRight;
          }
          return hitsBound ? !i2.settings.wheelPropagation : true;
        }
        function getDeltaFromEvent(e2) {
          var deltaX = e2.deltaX;
          var deltaY = -1 * e2.deltaY;
          if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
            deltaX = -1 * e2.wheelDeltaX / 6;
            deltaY = e2.wheelDeltaY / 6;
          }
          if (e2.deltaMode && e2.deltaMode === 1) {
            deltaX *= 10;
            deltaY *= 10;
          }
          if (deltaX !== deltaX && deltaY !== deltaY) {
            deltaX = 0;
            deltaY = e2.wheelDelta;
          }
          if (e2.shiftKey) {
            return [-deltaY, -deltaX];
          }
          return [deltaX, deltaY];
        }
        function shouldBeConsumedByChild(target, deltaX, deltaY) {
          if (!env.isWebKit && element.querySelector("select:focus")) {
            return true;
          }
          if (!element.contains(target)) {
            return false;
          }
          var cursor = target;
          while (cursor && cursor !== element) {
            if (cursor.classList.contains(cls.element.consuming)) {
              return true;
            }
            var style2 = get$1(cursor);
            if (deltaY && style2.overflowY.match(/(scroll|auto)/)) {
              var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
              if (maxScrollTop > 0) {
                if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
                  return true;
                }
              }
            }
            if (deltaX && style2.overflowX.match(/(scroll|auto)/)) {
              var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
              if (maxScrollLeft > 0) {
                if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
                  return true;
                }
              }
            }
            cursor = cursor.parentNode;
          }
          return false;
        }
        function mousewheelHandler(e2) {
          var ref2 = getDeltaFromEvent(e2);
          var deltaX = ref2[0];
          var deltaY = ref2[1];
          if (shouldBeConsumedByChild(e2.target, deltaX, deltaY)) {
            return;
          }
          var shouldPrevent = false;
          if (!i2.settings.useBothWheelAxes) {
            element.scrollTop -= deltaY * i2.settings.wheelSpeed;
            element.scrollLeft += deltaX * i2.settings.wheelSpeed;
          } else if (i2.scrollbarYActive && !i2.scrollbarXActive) {
            if (deltaY) {
              element.scrollTop -= deltaY * i2.settings.wheelSpeed;
            } else {
              element.scrollTop += deltaX * i2.settings.wheelSpeed;
            }
            shouldPrevent = true;
          } else if (i2.scrollbarXActive && !i2.scrollbarYActive) {
            if (deltaX) {
              element.scrollLeft += deltaX * i2.settings.wheelSpeed;
            } else {
              element.scrollLeft -= deltaY * i2.settings.wheelSpeed;
            }
            shouldPrevent = true;
          }
          updateGeometry(i2);
          shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
          if (shouldPrevent && !e2.ctrlKey) {
            e2.stopPropagation();
            e2.preventDefault();
          }
        }
        if (typeof window.onwheel !== "undefined") {
          i2.event.bind(element, "wheel", mousewheelHandler);
        } else if (typeof window.onmousewheel !== "undefined") {
          i2.event.bind(element, "mousewheel", mousewheelHandler);
        }
      }
      function touch$1(i2) {
        if (!env.supportsTouch && !env.supportsIePointer) {
          return;
        }
        var element = i2.element;
        function shouldPrevent(deltaX, deltaY) {
          var scrollTop = Math.floor(element.scrollTop);
          var scrollLeft = element.scrollLeft;
          var magnitudeX = Math.abs(deltaX);
          var magnitudeY = Math.abs(deltaY);
          if (magnitudeY > magnitudeX) {
            if (deltaY < 0 && scrollTop === i2.contentHeight - i2.containerHeight || deltaY > 0 && scrollTop === 0) {
              return window.scrollY === 0 && deltaY > 0 && env.isChrome;
            }
          } else if (magnitudeX > magnitudeY) {
            if (deltaX < 0 && scrollLeft === i2.contentWidth - i2.containerWidth || deltaX > 0 && scrollLeft === 0) {
              return true;
            }
          }
          return true;
        }
        function applyTouchMove(differenceX, differenceY) {
          element.scrollTop -= differenceY;
          element.scrollLeft -= differenceX;
          updateGeometry(i2);
        }
        var startOffset = {};
        var startTime = 0;
        var speed = {};
        var easingLoop = null;
        function getTouch(e2) {
          if (e2.targetTouches) {
            return e2.targetTouches[0];
          } else {
            return e2;
          }
        }
        function shouldHandle(e2) {
          if (e2.pointerType && e2.pointerType === "pen" && e2.buttons === 0) {
            return false;
          }
          if (e2.targetTouches && e2.targetTouches.length === 1) {
            return true;
          }
          if (e2.pointerType && e2.pointerType !== "mouse" && e2.pointerType !== e2.MSPOINTER_TYPE_MOUSE) {
            return true;
          }
          return false;
        }
        function touchStart(e2) {
          if (!shouldHandle(e2)) {
            return;
          }
          var touch2 = getTouch(e2);
          startOffset.pageX = touch2.pageX;
          startOffset.pageY = touch2.pageY;
          startTime = new Date().getTime();
          if (easingLoop !== null) {
            clearInterval(easingLoop);
          }
        }
        function shouldBeConsumedByChild(target, deltaX, deltaY) {
          if (!element.contains(target)) {
            return false;
          }
          var cursor = target;
          while (cursor && cursor !== element) {
            if (cursor.classList.contains(cls.element.consuming)) {
              return true;
            }
            var style2 = get$1(cursor);
            if (deltaY && style2.overflowY.match(/(scroll|auto)/)) {
              var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
              if (maxScrollTop > 0) {
                if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
                  return true;
                }
              }
            }
            if (deltaX && style2.overflowX.match(/(scroll|auto)/)) {
              var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
              if (maxScrollLeft > 0) {
                if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
                  return true;
                }
              }
            }
            cursor = cursor.parentNode;
          }
          return false;
        }
        function touchMove(e2) {
          if (shouldHandle(e2)) {
            var touch2 = getTouch(e2);
            var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
            var differenceX = currentOffset.pageX - startOffset.pageX;
            var differenceY = currentOffset.pageY - startOffset.pageY;
            if (shouldBeConsumedByChild(e2.target, differenceX, differenceY)) {
              return;
            }
            applyTouchMove(differenceX, differenceY);
            startOffset = currentOffset;
            var currentTime = new Date().getTime();
            var timeGap = currentTime - startTime;
            if (timeGap > 0) {
              speed.x = differenceX / timeGap;
              speed.y = differenceY / timeGap;
              startTime = currentTime;
            }
            if (shouldPrevent(differenceX, differenceY)) {
              e2.preventDefault();
            }
          }
        }
        function touchEnd() {
          if (i2.settings.swipeEasing) {
            clearInterval(easingLoop);
            easingLoop = setInterval(function() {
              if (i2.isInitialized) {
                clearInterval(easingLoop);
                return;
              }
              if (!speed.x && !speed.y) {
                clearInterval(easingLoop);
                return;
              }
              if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
                clearInterval(easingLoop);
                return;
              }
              if (!i2.element) {
                clearInterval(easingLoop);
                return;
              }
              applyTouchMove(speed.x * 30, speed.y * 30);
              speed.x *= 0.8;
              speed.y *= 0.8;
            }, 10);
          }
        }
        if (env.supportsTouch) {
          i2.event.bind(element, "touchstart", touchStart);
          i2.event.bind(element, "touchmove", touchMove);
          i2.event.bind(element, "touchend", touchEnd);
        } else if (env.supportsIePointer) {
          if (window.PointerEvent) {
            i2.event.bind(element, "pointerdown", touchStart);
            i2.event.bind(element, "pointermove", touchMove);
            i2.event.bind(element, "pointerup", touchEnd);
          } else if (window.MSPointerEvent) {
            i2.event.bind(element, "MSPointerDown", touchStart);
            i2.event.bind(element, "MSPointerMove", touchMove);
            i2.event.bind(element, "MSPointerUp", touchEnd);
          }
        }
      }
      var defaultSettings = function() {
        return {
          handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
          maxScrollbarLength: null,
          minScrollbarLength: null,
          scrollingThreshold: 1e3,
          scrollXMarginOffset: 0,
          scrollYMarginOffset: 0,
          suppressScrollX: false,
          suppressScrollY: false,
          swipeEasing: true,
          useBothWheelAxes: false,
          wheelPropagation: true,
          wheelSpeed: 1
        };
      };
      var handlers = {
        "click-rail": clickRail,
        "drag-thumb": dragThumb,
        keyboard,
        wheel,
        touch: touch$1
      };
      var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
        var this$1$1 = this;
        if (userSettings === void 0)
          userSettings = {};
        if (typeof element === "string") {
          element = document.querySelector(element);
        }
        if (!element || !element.nodeName) {
          throw new Error("no element is specified to initialize PerfectScrollbar");
        }
        this.element = element;
        element.classList.add(cls.main);
        this.settings = defaultSettings();
        for (var key in userSettings) {
          this.settings[key] = userSettings[key];
        }
        this.containerWidth = null;
        this.containerHeight = null;
        this.contentWidth = null;
        this.contentHeight = null;
        var focus = function() {
          return element.classList.add(cls.state.focus);
        };
        var blur = function() {
          return element.classList.remove(cls.state.focus);
        };
        this.isRtl = get$1(element).direction === "rtl";
        if (this.isRtl === true) {
          element.classList.add(cls.rtl);
        }
        this.isNegativeScroll = function() {
          var originalScrollLeft = element.scrollLeft;
          var result = null;
          element.scrollLeft = -1;
          result = element.scrollLeft < 0;
          element.scrollLeft = originalScrollLeft;
          return result;
        }();
        this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
        this.event = new EventManager();
        this.ownerDocument = element.ownerDocument || document;
        this.scrollbarXRail = div(cls.element.rail("x"));
        element.appendChild(this.scrollbarXRail);
        this.scrollbarX = div(cls.element.thumb("x"));
        this.scrollbarXRail.appendChild(this.scrollbarX);
        this.scrollbarX.setAttribute("tabindex", 0);
        this.event.bind(this.scrollbarX, "focus", focus);
        this.event.bind(this.scrollbarX, "blur", blur);
        this.scrollbarXActive = null;
        this.scrollbarXWidth = null;
        this.scrollbarXLeft = null;
        var railXStyle = get$1(this.scrollbarXRail);
        this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
        if (isNaN(this.scrollbarXBottom)) {
          this.isScrollbarXUsingBottom = false;
          this.scrollbarXTop = toInt(railXStyle.top);
        } else {
          this.isScrollbarXUsingBottom = true;
        }
        this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
        set$2(this.scrollbarXRail, { display: "block" });
        this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
        set$2(this.scrollbarXRail, { display: "" });
        this.railXWidth = null;
        this.railXRatio = null;
        this.scrollbarYRail = div(cls.element.rail("y"));
        element.appendChild(this.scrollbarYRail);
        this.scrollbarY = div(cls.element.thumb("y"));
        this.scrollbarYRail.appendChild(this.scrollbarY);
        this.scrollbarY.setAttribute("tabindex", 0);
        this.event.bind(this.scrollbarY, "focus", focus);
        this.event.bind(this.scrollbarY, "blur", blur);
        this.scrollbarYActive = null;
        this.scrollbarYHeight = null;
        this.scrollbarYTop = null;
        var railYStyle = get$1(this.scrollbarYRail);
        this.scrollbarYRight = parseInt(railYStyle.right, 10);
        if (isNaN(this.scrollbarYRight)) {
          this.isScrollbarYUsingRight = false;
          this.scrollbarYLeft = toInt(railYStyle.left);
        } else {
          this.isScrollbarYUsingRight = true;
        }
        this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
        this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
        set$2(this.scrollbarYRail, { display: "block" });
        this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
        set$2(this.scrollbarYRail, { display: "" });
        this.railYHeight = null;
        this.railYRatio = null;
        this.reach = {
          x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
          y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
        };
        this.isAlive = true;
        this.settings.handlers.forEach(function(handlerName) {
          return handlers[handlerName](this$1$1);
        });
        this.lastScrollTop = Math.floor(element.scrollTop);
        this.lastScrollLeft = element.scrollLeft;
        this.event.bind(this.element, "scroll", function(e2) {
          return this$1$1.onScroll(e2);
        });
        updateGeometry(this);
      };
      PerfectScrollbar.prototype.update = function update2() {
        if (!this.isAlive) {
          return;
        }
        this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
        set$2(this.scrollbarXRail, { display: "block" });
        set$2(this.scrollbarYRail, { display: "block" });
        this.railXMarginWidth = toInt(get$1(this.scrollbarXRail).marginLeft) + toInt(get$1(this.scrollbarXRail).marginRight);
        this.railYMarginHeight = toInt(get$1(this.scrollbarYRail).marginTop) + toInt(get$1(this.scrollbarYRail).marginBottom);
        set$2(this.scrollbarXRail, { display: "none" });
        set$2(this.scrollbarYRail, { display: "none" });
        updateGeometry(this);
        processScrollDiff(this, "top", 0, false, true);
        processScrollDiff(this, "left", 0, false, true);
        set$2(this.scrollbarXRail, { display: "" });
        set$2(this.scrollbarYRail, { display: "" });
      };
      PerfectScrollbar.prototype.onScroll = function onScroll(e2) {
        if (!this.isAlive) {
          return;
        }
        updateGeometry(this);
        processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
        processScrollDiff(this, "left", this.element.scrollLeft - this.lastScrollLeft);
        this.lastScrollTop = Math.floor(this.element.scrollTop);
        this.lastScrollLeft = this.element.scrollLeft;
      };
      PerfectScrollbar.prototype.destroy = function destroy() {
        if (!this.isAlive) {
          return;
        }
        this.event.unbindAll();
        remove(this.scrollbarX);
        remove(this.scrollbarY);
        remove(this.scrollbarXRail);
        remove(this.scrollbarYRail);
        this.removePsClasses();
        this.element = null;
        this.scrollbarX = null;
        this.scrollbarY = null;
        this.scrollbarXRail = null;
        this.scrollbarYRail = null;
        this.isAlive = false;
      };
      PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
        this.element.className = this.element.className.split(" ").filter(function(name) {
          return !name.match(/^ps([-_].+|)$/);
        }).join(" ");
      };
      const eventNames = [
        "scroll",
        "ps-scroll-y",
        "ps-scroll-x",
        "ps-scroll-up",
        "ps-scroll-down",
        "ps-scroll-left",
        "ps-scroll-right",
        "ps-y-reach-start",
        "ps-y-reach-end",
        "ps-x-reach-start",
        "ps-x-reach-end"
      ];
      var PerfectScrollbar$1 = {
        name: "PerfectScrollbar",
        props: {
          options: {
            type: Object,
            required: false,
            default: () => {
            }
          },
          tag: {
            type: String,
            required: false,
            default: "div"
          },
          watchOptions: {
            type: Boolean,
            required: false,
            default: false
          }
        },
        emits: eventNames,
        data() {
          return {
            ps: null
          };
        },
        watch: {
          watchOptions(shouldWatch) {
            if (!shouldWatch && this.watcher) {
              this.watcher();
            } else {
              this.createWatcher();
            }
          }
        },
        mounted() {
          this.create();
          if (this.watchOptions) {
            this.createWatcher();
          }
        },
        updated() {
          this.$nextTick(() => {
            this.update();
          });
        },
        beforeUnmount() {
          this.destroy();
        },
        methods: {
          create() {
            if (!(this.ps && this.$isServer)) {
              this.ps = new PerfectScrollbar(this.$el, this.options);
              eventNames.forEach((eventName) => {
                this.ps.element.addEventListener(eventName, (event) => this.$emit(eventName, event));
              });
            }
          },
          createWatcher() {
            this.watcher = this.$watch("options", () => {
              this.destroy();
              this.create();
            }, {
              deep: true
            });
          },
          update() {
            if (this.ps) {
              this.ps.update();
            }
          },
          destroy() {
            if (this.ps) {
              this.ps.destroy();
              this.ps = null;
            }
          }
        },
        render() {
          return h$5(this.tag, {
            class: "ps"
          }, this.$slots.default && this.$slots.default());
        }
      };
      var index$2 = {
        install: (Vue, settings) => {
          if (settings) {
            if (settings.name && typeof settings.name === "string") {
              PerfectScrollbar$1.name = settings.name;
            }
            if (settings.options && typeof settings.options === "object") {
              PerfectScrollbar$1.props.options.default = () => {
                return settings.options;
              };
            }
            if (settings.tag && typeof settings.tag === "string") {
              PerfectScrollbar$1.props.tag.default = settings.tag;
            }
            if (settings.watchOptions && typeof settings.watchOptions === "boolean") {
              PerfectScrollbar$1.props.watchOptions = settings.watchOptions;
            }
          }
          Vue.component(PerfectScrollbar$1.name, PerfectScrollbar$1);
        }
      };
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props2) {
        for (var i2 = 0; i2 < props2.length; i2++) {
          var descriptor = props2[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _defineProperty$1(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function ownKeys$1(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly)
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread2$1(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? arguments[i2] : {};
          if (i2 % 2) {
            ownKeys$1(Object(source), true).forEach(function(key) {
              _defineProperty$1(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys$1(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _objectWithoutPropertiesLoose$1(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function _objectWithoutProperties$1(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose$1(source, excluded);
        var key, i2;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
            key = sourceSymbolKeys[i2];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      function _slicedToArray(arr, i2) {
        return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
      }
      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr))
          return _arrayLikeToArray(arr);
      }
      function _arrayWithHoles(arr) {
        if (Array.isArray(arr))
          return arr;
      }
      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
          return Array.from(iter);
      }
      function _iterableToArrayLimit(arr, i2) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
          return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e2 = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i2 && _arr.length === i2)
              break;
          }
        } catch (err) {
          _d = true;
          _e2 = err;
        } finally {
          try {
            if (!_n && _i["return"] != null)
              _i["return"]();
          } finally {
            if (_d)
              throw _e2;
          }
        }
        return _arr;
      }
      function _unsupportedIterableToArray(o2, minLen) {
        if (!o2)
          return;
        if (typeof o2 === "string")
          return _arrayLikeToArray(o2, minLen);
        var n2 = Object.prototype.toString.call(o2).slice(8, -1);
        if (n2 === "Object" && o2.constructor)
          n2 = o2.constructor.name;
        if (n2 === "Map" || n2 === "Set")
          return Array.from(o2);
        if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
          return _arrayLikeToArray(o2, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
          arr2[i2] = arr[i2];
        return arr2;
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      function createCommonjsModule(fn2, basedir, module2) {
        return module2 = {
          path: basedir,
          exports: {},
          require: function(path, base) {
            return commonjsRequire(path, base === void 0 || base === null ? module2.path : base);
          }
        }, fn2(module2, module2.exports), module2.exports;
      }
      function commonjsRequire() {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
      }
      var freeGlobal$2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var _freeGlobal = freeGlobal$2;
      var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
      var root$2 = _freeGlobal || freeSelf$1 || Function("return this")();
      var _root = root$2;
      var Symbol$1$1 = _root.Symbol;
      var _Symbol = Symbol$1$1;
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      var nativeObjectToString$2 = objectProto$b.toString;
      var symToStringTag$2 = _Symbol ? _Symbol.toStringTag : void 0;
      function getRawTag$1(value) {
        var isOwn = hasOwnProperty$9.call(value, symToStringTag$2), tag = value[symToStringTag$2];
        try {
          value[symToStringTag$2] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$2.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$2] = tag;
          } else {
            delete value[symToStringTag$2];
          }
        }
        return result;
      }
      var _getRawTag = getRawTag$1;
      var objectProto$1$1 = Object.prototype;
      var nativeObjectToString$1$1 = objectProto$1$1.toString;
      function objectToString$2(value) {
        return nativeObjectToString$1$1.call(value);
      }
      var _objectToString = objectToString$2;
      var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
      var symToStringTag$1$1 = _Symbol ? _Symbol.toStringTag : void 0;
      function baseGetTag$1(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag$1 : nullTag$1;
        }
        return symToStringTag$1$1 && symToStringTag$1$1 in Object(value) ? _getRawTag(value) : _objectToString(value);
      }
      var _baseGetTag = baseGetTag$1;
      function isObjectLike$1(value) {
        return value != null && typeof value == "object";
      }
      var isObjectLike_1 = isObjectLike$1;
      var isArray$7 = Array.isArray;
      var isArray_1 = isArray$7;
      function isObject$6(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var isObject_1 = isObject$6;
      var asyncTag$1 = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
      function isFunction$3(value) {
        if (!isObject_1(value)) {
          return false;
        }
        var tag = _baseGetTag(value);
        return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
      }
      var isFunction_1 = isFunction$3;
      var MAX_SAFE_INTEGER$2 = 9007199254740991;
      function isLength$1(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
      }
      var isLength_1 = isLength$1;
      function isArrayLike$1(value) {
        return value != null && isLength_1(value.length) && !isFunction_1(value);
      }
      var isArrayLike_1 = isArrayLike$1;
      function isArrayLikeObject$1(value) {
        return isObjectLike_1(value) && isArrayLike_1(value);
      }
      var isArrayLikeObject_1 = isArrayLikeObject$1;
      var dateTag$1 = "[object Date]";
      function baseIsDate(value) {
        return isObjectLike_1(value) && _baseGetTag(value) == dateTag$1;
      }
      var _baseIsDate = baseIsDate;
      function baseUnary$1(func) {
        return function(value) {
          return func(value);
        };
      }
      var _baseUnary = baseUnary$1;
      var _nodeUtil = createCommonjsModule(function(module2, exports2) {
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var freeProcess2 = moduleExports2 && _freeGlobal.process;
        var nodeUtil2 = function() {
          try {
            var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e2) {
          }
        }();
        module2.exports = nodeUtil2;
      });
      var nodeIsDate = _nodeUtil && _nodeUtil.isDate;
      var isDate$2 = nodeIsDate ? _baseUnary(nodeIsDate) : _baseIsDate;
      var isDate_1 = isDate$2;
      var symbolTag = "[object Symbol]";
      function isSymbol$1(value) {
        return typeof value == "symbol" || isObjectLike_1(value) && _baseGetTag(value) == symbolTag;
      }
      var isSymbol_1 = isSymbol$1;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray_1(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_1(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var _isKey = isKey;
      var coreJsData$2 = _root["__core-js_shared__"];
      var _coreJsData = coreJsData$2;
      var maskSrcKey$1 = function() {
        var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked$1(func) {
        return !!maskSrcKey$1 && maskSrcKey$1 in func;
      }
      var _isMasked = isMasked$1;
      var funcProto$3 = Function.prototype;
      var funcToString$3 = funcProto$3.toString;
      function toSource$1(func) {
        if (func != null) {
          try {
            return funcToString$3.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var _toSource = toSource$1;
      var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
      var funcProto$1$1 = Function.prototype, objectProto$2$1 = Object.prototype;
      var funcToString$1$1 = funcProto$1$1.toString;
      var hasOwnProperty$1$1 = objectProto$2$1.hasOwnProperty;
      var reIsNative$1 = RegExp("^" + funcToString$1$1.call(hasOwnProperty$1$1).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function baseIsNative$1(value) {
        if (!isObject_1(value) || _isMasked(value)) {
          return false;
        }
        var pattern = isFunction_1(value) ? reIsNative$1 : reIsHostCtor$1;
        return pattern.test(_toSource(value));
      }
      var _baseIsNative = baseIsNative$1;
      function getValue$1(object, key) {
        return object == null ? void 0 : object[key];
      }
      var _getValue = getValue$1;
      function getNative$1(object, key) {
        var value = _getValue(object, key);
        return _baseIsNative(value) ? value : void 0;
      }
      var _getNative = getNative$1;
      var nativeCreate$2 = _getNative(Object, "create");
      var _nativeCreate = nativeCreate$2;
      function hashClear$1() {
        this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
        this.size = 0;
      }
      var _hashClear = hashClear$1;
      function hashDelete$1(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var _hashDelete = hashDelete$1;
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$3$1 = Object.prototype;
      var hasOwnProperty$2$1 = objectProto$3$1.hasOwnProperty;
      function hashGet$1(key) {
        var data2 = this.__data__;
        if (_nativeCreate) {
          var result = data2[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$2$1.call(data2, key) ? data2[key] : void 0;
      }
      var _hashGet = hashGet$1;
      var objectProto$4$1 = Object.prototype;
      var hasOwnProperty$3$1 = objectProto$4$1.hasOwnProperty;
      function hashHas$1(key) {
        var data2 = this.__data__;
        return _nativeCreate ? data2[key] !== void 0 : hasOwnProperty$3$1.call(data2, key);
      }
      var _hashHas = hashHas$1;
      var HASH_UNDEFINED$1$1 = "__lodash_hash_undefined__";
      function hashSet$1(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = _nativeCreate && value === void 0 ? HASH_UNDEFINED$1$1 : value;
        return this;
      }
      var _hashSet = hashSet$1;
      function Hash$1(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash$1.prototype.clear = _hashClear;
      Hash$1.prototype["delete"] = _hashDelete;
      Hash$1.prototype.get = _hashGet;
      Hash$1.prototype.has = _hashHas;
      Hash$1.prototype.set = _hashSet;
      var _Hash = Hash$1;
      function listCacheClear$1() {
        this.__data__ = [];
        this.size = 0;
      }
      var _listCacheClear = listCacheClear$1;
      function eq$1(value, other) {
        return value === other || value !== value && other !== other;
      }
      var eq_1 = eq$1;
      function assocIndexOf$1(array, key) {
        var length = array.length;
        while (length--) {
          if (eq_1(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var _assocIndexOf = assocIndexOf$1;
      var arrayProto$1 = Array.prototype;
      var splice$1 = arrayProto$1.splice;
      function listCacheDelete$1(key) {
        var data2 = this.__data__, index2 = _assocIndexOf(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice$1.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      var _listCacheDelete = listCacheDelete$1;
      function listCacheGet$1(key) {
        var data2 = this.__data__, index2 = _assocIndexOf(data2, key);
        return index2 < 0 ? void 0 : data2[index2][1];
      }
      var _listCacheGet = listCacheGet$1;
      function listCacheHas$1(key) {
        return _assocIndexOf(this.__data__, key) > -1;
      }
      var _listCacheHas = listCacheHas$1;
      function listCacheSet$1(key, value) {
        var data2 = this.__data__, index2 = _assocIndexOf(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      var _listCacheSet = listCacheSet$1;
      function ListCache$1(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache$1.prototype.clear = _listCacheClear;
      ListCache$1.prototype["delete"] = _listCacheDelete;
      ListCache$1.prototype.get = _listCacheGet;
      ListCache$1.prototype.has = _listCacheHas;
      ListCache$1.prototype.set = _listCacheSet;
      var _ListCache = ListCache$1;
      var Map$3 = _getNative(_root, "Map");
      var _Map = Map$3;
      function mapCacheClear$1() {
        this.size = 0;
        this.__data__ = {
          "hash": new _Hash(),
          "map": new (_Map || _ListCache)(),
          "string": new _Hash()
        };
      }
      var _mapCacheClear = mapCacheClear$1;
      function isKeyable$1(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      var _isKeyable = isKeyable$1;
      function getMapData$1(map2, key) {
        var data2 = map2.__data__;
        return _isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      var _getMapData = getMapData$1;
      function mapCacheDelete$1(key) {
        var result = _getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      var _mapCacheDelete = mapCacheDelete$1;
      function mapCacheGet$1(key) {
        return _getMapData(this, key).get(key);
      }
      var _mapCacheGet = mapCacheGet$1;
      function mapCacheHas$1(key) {
        return _getMapData(this, key).has(key);
      }
      var _mapCacheHas = mapCacheHas$1;
      function mapCacheSet$1(key, value) {
        var data2 = _getMapData(this, key), size = data2.size;
        data2.set(key, value);
        this.size += data2.size == size ? 0 : 1;
        return this;
      }
      var _mapCacheSet = mapCacheSet$1;
      function MapCache$1(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache$1.prototype.clear = _mapCacheClear;
      MapCache$1.prototype["delete"] = _mapCacheDelete;
      MapCache$1.prototype.get = _mapCacheGet;
      MapCache$1.prototype.has = _mapCacheHas;
      MapCache$1.prototype.set = _mapCacheSet;
      var _MapCache = MapCache$1;
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize.Cache || _MapCache)();
        return memoized;
      }
      memoize.Cache = _MapCache;
      var memoize_1 = memoize;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize_1(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      var _memoizeCapped = memoizeCapped;
      var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar$1 = /\\(\\)?/g;
      var stringToPath$1 = _memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName$1, function(match, number, quote2, subString) {
          result.push(quote2 ? subString.replace(reEscapeChar$1, "$1") : number || match);
        });
        return result;
      });
      var _stringToPath = stringToPath$1;
      function arrayMap(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index2 < length) {
          result[index2] = iteratee(array[index2], index2, array);
        }
        return result;
      }
      var _arrayMap = arrayMap;
      var INFINITY = 1 / 0;
      var symbolProto = _Symbol ? _Symbol.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray_1(value)) {
          return _arrayMap(value, baseToString) + "";
        }
        if (isSymbol_1(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      var _baseToString = baseToString;
      function toString$1(value) {
        return value == null ? "" : _baseToString(value);
      }
      var toString_1 = toString$1;
      function castPath(value, object) {
        if (isArray_1(value)) {
          return value;
        }
        return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
      }
      var _castPath = castPath;
      var INFINITY$1 = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol_1(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
      }
      var _toKey = toKey;
      function baseGet(object, path) {
        path = _castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[_toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : void 0;
      }
      var _baseGet = baseGet;
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : _baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      var get_1 = get;
      var defineProperty$2 = function() {
        try {
          var func = _getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var _defineProperty$1$1 = defineProperty$2;
      function baseAssignValue$1(object, key, value) {
        if (key == "__proto__" && _defineProperty$1$1) {
          _defineProperty$1$1(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      var _baseAssignValue = baseAssignValue$1;
      var objectProto$5$1 = Object.prototype;
      var hasOwnProperty$4$1 = objectProto$5$1.hasOwnProperty;
      function assignValue$1(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$4$1.call(object, key) && eq_1(objValue, value)) || value === void 0 && !(key in object)) {
          _baseAssignValue(object, key, value);
        }
      }
      var _assignValue = assignValue$1;
      var MAX_SAFE_INTEGER$1$1 = 9007199254740991;
      var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
      function isIndex$2(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      var _isIndex = isIndex$2;
      function baseSet(object, path, value, customizer) {
        if (!isObject_1(object)) {
          return object;
        }
        path = _castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = _toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject_1(objValue) ? objValue : _isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          _assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var _baseSet = baseSet;
      function createBaseFor$1(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
          while (length--) {
            var key = props2[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var _createBaseFor = createBaseFor$1;
      var baseFor$2 = _createBaseFor();
      var _baseFor = baseFor$2;
      function baseTimes$1(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      var _baseTimes = baseTimes$1;
      var argsTag$2 = "[object Arguments]";
      function baseIsArguments$1(value) {
        return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
      }
      var _baseIsArguments = baseIsArguments$1;
      var objectProto$6$1 = Object.prototype;
      var hasOwnProperty$5$1 = objectProto$6$1.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$6$1.propertyIsEnumerable;
      var isArguments$2 = _baseIsArguments(function() {
        return arguments;
      }()) ? _baseIsArguments : function(value) {
        return isObjectLike_1(value) && hasOwnProperty$5$1.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      var isArguments_1 = isArguments$2;
      function stubFalse$1() {
        return false;
      }
      var stubFalse_1 = stubFalse$1;
      var isBuffer_1 = createCommonjsModule(function(module2, exports2) {
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var Buffer3 = moduleExports2 ? _root.Buffer : void 0;
        var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
        var isBuffer2 = nativeIsBuffer2 || stubFalse_1;
        module2.exports = isBuffer2;
      });
      var argsTag$1$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1$1 = "[object Function]", mapTag$2 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
      var typedArrayTags$1 = {};
      typedArrayTags$1[float32Tag$1] = typedArrayTags$1[float64Tag$1] = typedArrayTags$1[int8Tag$1] = typedArrayTags$1[int16Tag$1] = typedArrayTags$1[int32Tag$1] = typedArrayTags$1[uint8Tag$1] = typedArrayTags$1[uint8ClampedTag$1] = typedArrayTags$1[uint16Tag$1] = typedArrayTags$1[uint32Tag$1] = true;
      typedArrayTags$1[argsTag$1$1] = typedArrayTags$1[arrayTag$1] = typedArrayTags$1[arrayBufferTag$1] = typedArrayTags$1[boolTag$2] = typedArrayTags$1[dataViewTag$1] = typedArrayTags$1[dateTag$1$1] = typedArrayTags$1[errorTag$1] = typedArrayTags$1[funcTag$1$1] = typedArrayTags$1[mapTag$2] = typedArrayTags$1[numberTag$2] = typedArrayTags$1[objectTag$2] = typedArrayTags$1[regexpTag$1] = typedArrayTags$1[setTag$2] = typedArrayTags$1[stringTag$2] = typedArrayTags$1[weakMapTag$1] = false;
      function baseIsTypedArray$1(value) {
        return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags$1[_baseGetTag(value)];
      }
      var _baseIsTypedArray = baseIsTypedArray$1;
      var nodeIsTypedArray$1 = _nodeUtil && _nodeUtil.isTypedArray;
      var isTypedArray$2 = nodeIsTypedArray$1 ? _baseUnary(nodeIsTypedArray$1) : _baseIsTypedArray;
      var isTypedArray_1 = isTypedArray$2;
      var objectProto$7$1 = Object.prototype;
      var hasOwnProperty$6$1 = objectProto$7$1.hasOwnProperty;
      function arrayLikeKeys$1(value, inherited) {
        var isArr = isArray_1(value), isArg = !isArr && isArguments_1(value), isBuff = !isArr && !isArg && isBuffer_1(value), isType = !isArr && !isArg && !isBuff && isTypedArray_1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$6$1.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || _isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      var _arrayLikeKeys = arrayLikeKeys$1;
      var objectProto$8$1 = Object.prototype;
      function isPrototype$1(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8$1;
        return value === proto;
      }
      var _isPrototype = isPrototype$1;
      function overArg$1(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var _overArg = overArg$1;
      var nativeKeys = _overArg(Object.keys, Object);
      var _nativeKeys = nativeKeys;
      var objectProto$9$1 = Object.prototype;
      var hasOwnProperty$7$1 = objectProto$9$1.hasOwnProperty;
      function baseKeys(object) {
        if (!_isPrototype(object)) {
          return _nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$7$1.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      var _baseKeys = baseKeys;
      function keys(object) {
        return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
      }
      var keys_1 = keys;
      function baseForOwn(object, iteratee) {
        return object && _baseFor(object, iteratee, keys_1);
      }
      var _baseForOwn = baseForOwn;
      function stackClear$1() {
        this.__data__ = new _ListCache();
        this.size = 0;
      }
      var _stackClear = stackClear$1;
      function stackDelete$1(key) {
        var data2 = this.__data__, result = data2["delete"](key);
        this.size = data2.size;
        return result;
      }
      var _stackDelete = stackDelete$1;
      function stackGet$1(key) {
        return this.__data__.get(key);
      }
      var _stackGet = stackGet$1;
      function stackHas$1(key) {
        return this.__data__.has(key);
      }
      var _stackHas = stackHas$1;
      var LARGE_ARRAY_SIZE$1 = 200;
      function stackSet$1(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof _ListCache) {
          var pairs = data2.__data__;
          if (!_Map || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new _MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      var _stackSet = stackSet$1;
      function Stack$1(entries) {
        var data2 = this.__data__ = new _ListCache(entries);
        this.size = data2.size;
      }
      Stack$1.prototype.clear = _stackClear;
      Stack$1.prototype["delete"] = _stackDelete;
      Stack$1.prototype.get = _stackGet;
      Stack$1.prototype.has = _stackHas;
      Stack$1.prototype.set = _stackSet;
      var _Stack = Stack$1;
      var HASH_UNDEFINED$2$1 = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED$2$1);
        return this;
      }
      var _setCacheAdd = setCacheAdd;
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      var _setCacheHas = setCacheHas;
      function SetCache(values) {
        var index2 = -1, length = values == null ? 0 : values.length;
        this.__data__ = new _MapCache();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
      SetCache.prototype.has = _setCacheHas;
      var _SetCache = SetCache;
      function arraySome(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      var _arraySome = arraySome;
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      var _cacheHas = cacheHas;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!_arraySome(other, function(othValue2, othIndex) {
              if (!_cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      var _equalArrays = equalArrays;
      var Uint8Array$3 = _root.Uint8Array;
      var _Uint8Array = Uint8Array$3;
      function mapToArray(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      var _mapToArray = mapToArray;
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var _setToArray = setToArray;
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      var boolTag$1$1 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1$1 = "[object Error]", mapTag$1$1 = "[object Map]", numberTag$1$1 = "[object Number]", regexpTag$1$1 = "[object RegExp]", setTag$1$1 = "[object Set]", stringTag$1$1 = "[object String]", symbolTag$1 = "[object Symbol]";
      var arrayBufferTag$1$1 = "[object ArrayBuffer]", dataViewTag$1$1 = "[object DataView]";
      var symbolProto$1 = _Symbol ? _Symbol.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag$1$1:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag$1$1:
            if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
              return false;
            }
            return true;
          case boolTag$1$1:
          case dateTag$2:
          case numberTag$1$1:
            return eq_1(+object, +other);
          case errorTag$1$1:
            return object.name == other.name && object.message == other.message;
          case regexpTag$1$1:
          case stringTag$1$1:
            return object == other + "";
          case mapTag$1$1:
            var convert = _mapToArray;
          case setTag$1$1:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
            convert || (convert = _setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$1;
            stack.set(object, other);
            var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag$1:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var _equalByTag = equalByTag;
      function arrayPush(array, values) {
        var index2 = -1, length = values.length, offset2 = array.length;
        while (++index2 < length) {
          array[offset2 + index2] = values[index2];
        }
        return array;
      }
      var _arrayPush = arrayPush;
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
      }
      var _baseGetAllKeys = baseGetAllKeys;
      function arrayFilter(array, predicate) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      var _arrayFilter = arrayFilter;
      function stubArray() {
        return [];
      }
      var stubArray_1 = stubArray;
      var objectProto$a$1 = Object.prototype;
      var propertyIsEnumerable$1$1 = objectProto$a$1.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return _arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable$1$1.call(object, symbol);
        });
      };
      var _getSymbols = getSymbols;
      function getAllKeys(object) {
        return _baseGetAllKeys(object, keys_1, _getSymbols);
      }
      var _getAllKeys = getAllKeys;
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var objectProto$b$1 = Object.prototype;
      var hasOwnProperty$8$1 = objectProto$b$1.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2, objProps = _getAllKeys(object), objLength = objProps.length, othProps = _getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty$8$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      var _equalObjects = equalObjects;
      var DataView$1 = _getNative(_root, "DataView");
      var _DataView = DataView$1;
      var Promise$1 = _getNative(_root, "Promise");
      var _Promise = Promise$1;
      var Set$1 = _getNative(_root, "Set");
      var _Set = Set$1;
      var WeakMap$1 = _getNative(_root, "WeakMap");
      var _WeakMap = WeakMap$1;
      var mapTag$2$1 = "[object Map]", objectTag$1$1 = "[object Object]", promiseTag = "[object Promise]", setTag$2$1 = "[object Set]", weakMapTag$1$1 = "[object WeakMap]";
      var dataViewTag$2 = "[object DataView]";
      var dataViewCtorString = _toSource(_DataView), mapCtorString = _toSource(_Map), promiseCtorString = _toSource(_Promise), setCtorString = _toSource(_Set), weakMapCtorString = _toSource(_WeakMap);
      var getTag = _baseGetTag;
      if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2 || _Map && getTag(new _Map()) != mapTag$2$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$2$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1$1) {
        getTag = function(value) {
          var result = _baseGetTag(value), Ctor = result == objectTag$1$1 ? value.constructor : void 0, ctorString = Ctor ? _toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$2;
              case mapCtorString:
                return mapTag$2$1;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$2$1;
              case weakMapCtorString:
                return weakMapTag$1$1;
            }
          }
          return result;
        };
      }
      var _getTag = getTag;
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var argsTag$2$1 = "[object Arguments]", arrayTag$1$1 = "[object Array]", objectTag$2$1 = "[object Object]";
      var objectProto$c = Object.prototype;
      var hasOwnProperty$9$1 = objectProto$c.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray_1(object), othIsArr = isArray_1(other), objTag = objIsArr ? arrayTag$1$1 : _getTag(object), othTag = othIsArr ? arrayTag$1$1 : _getTag(other);
        objTag = objTag == argsTag$2$1 ? objectTag$2$1 : objTag;
        othTag = othTag == argsTag$2$1 ? objectTag$2$1 : othTag;
        var objIsObj = objTag == objectTag$2$1, othIsObj = othTag == objectTag$2$1, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer_1(object)) {
          if (!isBuffer_1(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new _Stack());
          return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
          var objIsWrapped = objIsObj && hasOwnProperty$9$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$9$1.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new _Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new _Stack());
        return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      var _baseIsEqualDeep = baseIsEqualDeep;
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike_1(value) && !isObjectLike_1(other)) {
          return value !== value && other !== other;
        }
        return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      var _baseIsEqual = baseIsEqual;
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index2--) {
          var data2 = matchData[index2];
          if (noCustomizer && data2[2] ? data2[1] !== object[data2[0]] : !(data2[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data2 = matchData[index2];
          var key = data2[0], objValue = object[key], srcValue = data2[1];
          if (noCustomizer && data2[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new _Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      var _baseIsMatch = baseIsMatch;
      function isStrictComparable(value) {
        return value === value && !isObject_1(value);
      }
      var _isStrictComparable = isStrictComparable;
      function getMatchData(object) {
        var result = keys_1(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, _isStrictComparable(value)];
        }
        return result;
      }
      var _getMatchData = getMatchData;
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      var _matchesStrictComparable = matchesStrictComparable;
      function baseMatches(source) {
        var matchData = _getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || _baseIsMatch(object, source, matchData);
        };
      }
      var _baseMatches = baseMatches;
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      var _baseHasIn = baseHasIn;
      function hasPath(object, path, hasFunc) {
        path = _castPath(path, object);
        var index2 = -1, length = path.length, result = false;
        while (++index2 < length) {
          var key = _toKey(path[index2]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index2 != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
      }
      var _hasPath = hasPath;
      function hasIn(object, path) {
        return object != null && _hasPath(object, path, _baseHasIn);
      }
      var hasIn_1 = hasIn;
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function baseMatchesProperty(path, srcValue) {
        if (_isKey(path) && _isStrictComparable(srcValue)) {
          return _matchesStrictComparable(_toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get_1(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
        };
      }
      var _baseMatchesProperty = baseMatchesProperty;
      function identity$1(value) {
        return value;
      }
      var identity_1 = identity$1;
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      var _baseProperty = baseProperty;
      function basePropertyDeep(path) {
        return function(object) {
          return _baseGet(object, path);
        };
      }
      var _basePropertyDeep = basePropertyDeep;
      function property(path) {
        return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
      }
      var property_1 = property;
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity_1;
        }
        if (typeof value == "object") {
          return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
        }
        return property_1(value);
      }
      var _baseIteratee = baseIteratee;
      function apply$1(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      var _apply = apply$1;
      var nativeMax$1 = Math.max;
      function overRest$1(func, start2, transform) {
        start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax$1(args.length - start2, 0), array = Array(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform(array);
          return _apply(func, this, otherArgs);
        };
      }
      var _overRest = overRest$1;
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      var constant_1 = constant$1;
      var baseSetToString$2 = !_defineProperty$1$1 ? identity_1 : function(func, string) {
        return _defineProperty$1$1(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant_1(string),
          "writable": true
        });
      };
      var _baseSetToString = baseSetToString$2;
      var HOT_COUNT$1 = 800, HOT_SPAN$1 = 16;
      var nativeNow$1 = Date.now;
      function shortOut$1(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow$1(), remaining = HOT_SPAN$1 - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT$1) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      var _shortOut = shortOut$1;
      var setToString$2 = _shortOut(_baseSetToString);
      var _setToString = setToString$2;
      function baseRest$1(func, start2) {
        return _setToString(_overRest(func, start2, identity_1), func + "");
      }
      var _baseRest = baseRest$1;
      function isIterateeCall$1(value, index2, object) {
        if (!isObject_1(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike_1(object) && _isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq_1(object[index2], value);
        }
        return false;
      }
      var _isIterateeCall = isIterateeCall$1;
      function nativeKeysIn$1(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var _nativeKeysIn = nativeKeysIn$1;
      var objectProto$d = Object.prototype;
      var hasOwnProperty$a = objectProto$d.hasOwnProperty;
      function baseKeysIn$1(object) {
        if (!isObject_1(object)) {
          return _nativeKeysIn(object);
        }
        var isProto = _isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$a.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      var _baseKeysIn = baseKeysIn$1;
      function keysIn$1(object) {
        return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
      }
      var keysIn_1 = keysIn$1;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var defaults$8 = _baseRest(function(object, sources) {
        object = Object(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : void 0;
        if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props2 = keysIn_1(source);
          var propsIndex = -1;
          var propsLength = props2.length;
          while (++propsIndex < propsLength) {
            var key = props2[propsIndex];
            var value = object[key];
            if (value === void 0 || eq_1(value, objectProto$e[key]) && !hasOwnProperty$b.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaults_1$1 = defaults$8;
      function assignMergeValue$1(object, key, value) {
        if (value !== void 0 && !eq_1(object[key], value) || value === void 0 && !(key in object)) {
          _baseAssignValue(object, key, value);
        }
      }
      var _assignMergeValue = assignMergeValue$1;
      var _cloneBuffer = createCommonjsModule(function(module2, exports2) {
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var Buffer3 = moduleExports2 ? _root.Buffer : void 0, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0;
        function cloneBuffer2(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
          buffer.copy(result);
          return result;
        }
        module2.exports = cloneBuffer2;
      });
      function cloneArrayBuffer$1(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
        return result;
      }
      var _cloneArrayBuffer = cloneArrayBuffer$1;
      function cloneTypedArray$1(typedArray, isDeep) {
        var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      var _cloneTypedArray = cloneTypedArray$1;
      function copyArray$1(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      var _copyArray = copyArray$1;
      var objectCreate$1 = Object.create;
      var baseCreate$2 = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject_1(proto)) {
            return {};
          }
          if (objectCreate$1) {
            return objectCreate$1(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      var _baseCreate = baseCreate$2;
      var getPrototype$2 = _overArg(Object.getPrototypeOf, Object);
      var _getPrototype = getPrototype$2;
      function initCloneObject$1(object) {
        return typeof object.constructor == "function" && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
      }
      var _initCloneObject = initCloneObject$1;
      var objectTag$3 = "[object Object]";
      var funcProto$2$1 = Function.prototype, objectProto$f = Object.prototype;
      var funcToString$2$1 = funcProto$2$1.toString;
      var hasOwnProperty$c = objectProto$f.hasOwnProperty;
      var objectCtorString$1 = funcToString$2$1.call(Object);
      function isPlainObject$3(value) {
        if (!isObjectLike_1(value) || _baseGetTag(value) != objectTag$3) {
          return false;
        }
        var proto = _getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$c.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2$1.call(Ctor) == objectCtorString$1;
      }
      var isPlainObject_1 = isPlainObject$3;
      function safeGet$1(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var _safeGet = safeGet$1;
      function copyObject$1(source, props2, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props2.length;
        while (++index2 < length) {
          var key = props2[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            _baseAssignValue(object, key, newValue);
          } else {
            _assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var _copyObject = copyObject$1;
      function toPlainObject$1(value) {
        return _copyObject(value, keysIn_1(value));
      }
      var toPlainObject_1 = toPlainObject$1;
      function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = _safeGet(object, key), srcValue = _safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          _assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray_1(srcValue), isBuff = !isArr && isBuffer_1(srcValue), isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray_1(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject_1(objValue)) {
              newValue = _copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = _cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = _cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
            newValue = objValue;
            if (isArguments_1(objValue)) {
              newValue = toPlainObject_1(objValue);
            } else if (!isObject_1(objValue) || isFunction_1(objValue)) {
              newValue = _initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        _assignMergeValue(object, key, newValue);
      }
      var _baseMergeDeep = baseMergeDeep$1;
      function baseMerge$1(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        _baseFor(source, function(srcValue, key) {
          stack || (stack = new _Stack());
          if (isObject_1(srcValue)) {
            _baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
          } else {
            var newValue = customizer ? customizer(_safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            _assignMergeValue(object, key, newValue);
          }
        }, keysIn_1);
      }
      var _baseMerge = baseMerge$1;
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject_1(objValue) && isObject_1(srcValue)) {
          stack.set(srcValue, objValue);
          _baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      var _customDefaultsMerge = customDefaultsMerge;
      function createAssigner$1(assigner) {
        return _baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      var _createAssigner = createAssigner$1;
      var mergeWith = _createAssigner(function(object, source, srcIndex, customizer) {
        _baseMerge(object, source, srcIndex, customizer);
      });
      var mergeWith_1 = mergeWith;
      var defaultsDeep = _baseRest(function(args) {
        args.push(void 0, _customDefaultsMerge);
        return _apply(mergeWith_1, void 0, args);
      });
      var defaultsDeep_1 = defaultsDeep;
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result = {};
        while (++index2 < length) {
          var path = paths[index2], value = _baseGet(object, path);
          if (predicate(value, path)) {
            _baseSet(result, _castPath(path, object), value);
          }
        }
        return result;
      }
      var _basePickBy = basePickBy;
      function basePick(object, paths) {
        return _basePickBy(object, paths, function(value, path) {
          return hasIn_1(object, path);
        });
      }
      var _basePick = basePick;
      var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      var _isFlattenable = isFlattenable;
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index2 = -1, length = array.length;
        predicate || (predicate = _isFlattenable);
        result || (result = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              _arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      var _baseFlatten = baseFlatten;
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? _baseFlatten(array, 1) : [];
      }
      var flatten_1 = flatten;
      function flatRest(func) {
        return _setToString(_overRest(func, void 0, flatten_1), func + "");
      }
      var _flatRest = flatRest;
      var pick = _flatRest(function(object, paths) {
        return object == null ? {} : _basePick(object, paths);
      });
      var pick_1 = pick;
      function arrayEach(array, iteratee) {
        var index2 = -1, length = array == null ? 0 : array.length;
        while (++index2 < length) {
          if (iteratee(array[index2], index2, array) === false) {
            break;
          }
        }
        return array;
      }
      var _arrayEach = arrayEach;
      function baseAssign(object, source) {
        return object && _copyObject(source, keys_1(source), object);
      }
      var _baseAssign = baseAssign;
      function baseAssignIn(object, source) {
        return object && _copyObject(source, keysIn_1(source), object);
      }
      var _baseAssignIn = baseAssignIn;
      function copySymbols(source, object) {
        return _copyObject(source, _getSymbols(source), object);
      }
      var _copySymbols = copySymbols;
      var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
        var result = [];
        while (object) {
          _arrayPush(result, _getSymbols(object));
          object = _getPrototype(object);
        }
        return result;
      };
      var _getSymbolsIn = getSymbolsIn;
      function copySymbolsIn(source, object) {
        return _copyObject(source, _getSymbolsIn(source), object);
      }
      var _copySymbolsIn = copySymbolsIn;
      function getAllKeysIn(object) {
        return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
      }
      var _getAllKeysIn = getAllKeysIn;
      var objectProto$g = Object.prototype;
      var hasOwnProperty$d = objectProto$g.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty$d.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      var _initCloneArray = initCloneArray;
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      var _cloneDataView = cloneDataView;
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      var _cloneRegExp = cloneRegExp;
      var symbolProto$2 = _Symbol ? _Symbol.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
      }
      var _cloneSymbol = cloneSymbol;
      var boolTag$2$1 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2$1 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2$1 = "[object String]", symbolTag$2 = "[object Symbol]";
      var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1$1 = "[object Float32Array]", float64Tag$1$1 = "[object Float64Array]", int8Tag$1$1 = "[object Int8Array]", int16Tag$1$1 = "[object Int16Array]", int32Tag$1$1 = "[object Int32Array]", uint8Tag$1$1 = "[object Uint8Array]", uint8ClampedTag$1$1 = "[object Uint8ClampedArray]", uint16Tag$1$1 = "[object Uint16Array]", uint32Tag$1$1 = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag$2:
            return _cloneArrayBuffer(object);
          case boolTag$2$1:
          case dateTag$3:
            return new Ctor(+object);
          case dataViewTag$3:
            return _cloneDataView(object, isDeep);
          case float32Tag$1$1:
          case float64Tag$1$1:
          case int8Tag$1$1:
          case int16Tag$1$1:
          case int32Tag$1$1:
          case uint8Tag$1$1:
          case uint8ClampedTag$1$1:
          case uint16Tag$1$1:
          case uint32Tag$1$1:
            return _cloneTypedArray(object, isDeep);
          case mapTag$3:
            return new Ctor();
          case numberTag$2$1:
          case stringTag$2$1:
            return new Ctor(object);
          case regexpTag$2:
            return _cloneRegExp(object);
          case setTag$3:
            return new Ctor();
          case symbolTag$2:
            return _cloneSymbol(object);
        }
      }
      var _initCloneByTag = initCloneByTag;
      var mapTag$4 = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike_1(value) && _getTag(value) == mapTag$4;
      }
      var _baseIsMap = baseIsMap;
      var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
      var isMap$1 = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
      var isMap_1 = isMap$1;
      var setTag$4 = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike_1(value) && _getTag(value) == setTag$4;
      }
      var _baseIsSet = baseIsSet;
      var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
      var isSet$1 = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
      var isSet_1 = isSet$1;
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2$1 = "[object Function]", genTag$1$1 = "[object GeneratorFunction]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
      var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] = cloneableTags[boolTag$3] = cloneableTags[dateTag$4] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$5] = cloneableTags[numberTag$3] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$3] = cloneableTags[setTag$5] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$3] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
      cloneableTags[errorTag$2] = cloneableTags[funcTag$2$1] = cloneableTags[weakMapTag$2] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject_1(value)) {
          return value;
        }
        var isArr = isArray_1(value);
        if (isArr) {
          result = _initCloneArray(value);
          if (!isDeep) {
            return _copyArray(value, result);
          }
        } else {
          var tag = _getTag(value), isFunc = tag == funcTag$2$1 || tag == genTag$1$1;
          if (isBuffer_1(value)) {
            return _cloneBuffer(value, isDeep);
          }
          if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object) {
            result = isFlat || isFunc ? {} : _initCloneObject(value);
            if (!isDeep) {
              return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = _initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new _Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet_1(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap_1(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn_1 : keys_1;
        var props2 = isArr ? void 0 : keysFunc(value);
        _arrayEach(props2 || value, function(subValue, key2) {
          if (props2) {
            key2 = subValue;
            subValue = value[key2];
          }
          _assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      var _baseClone = baseClone;
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      var last_1 = last;
      function baseSlice(array, start2, end2) {
        var index2 = -1, length = array.length;
        if (start2 < 0) {
          start2 = -start2 > length ? 0 : length + start2;
        }
        end2 = end2 > length ? length : end2;
        if (end2 < 0) {
          end2 += length;
        }
        length = start2 > end2 ? 0 : end2 - start2 >>> 0;
        start2 >>>= 0;
        var result = Array(length);
        while (++index2 < length) {
          result[index2] = array[index2 + start2];
        }
        return result;
      }
      var _baseSlice = baseSlice;
      function parent(object, path) {
        return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
      }
      var _parent = parent;
      function baseUnset(object, path) {
        path = _castPath(path, object);
        object = _parent(object, path);
        return object == null || delete object[_toKey(last_1(path))];
      }
      var _baseUnset = baseUnset;
      function customOmitClone(value) {
        return isPlainObject_1(value) ? void 0 : value;
      }
      var _customOmitClone = customOmitClone;
      var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$1 = 4;
      var omit = _flatRest(function(object, paths) {
        var result = {};
        if (object == null) {
          return result;
        }
        var isDeep = false;
        paths = _arrayMap(paths, function(path) {
          path = _castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        _copyObject(object, _getAllKeysIn(object), result);
        if (isDeep) {
          result = _baseClone(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG$1 | CLONE_SYMBOLS_FLAG$1, _customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          _baseUnset(result, paths[length]);
        }
        return result;
      });
      var omit_1 = omit;
      var objectProto$h = Object.prototype;
      var hasOwnProperty$e = objectProto$h.hasOwnProperty;
      function baseHas(object, key) {
        return object != null && hasOwnProperty$e.call(object, key);
      }
      var _baseHas = baseHas;
      function has$4(object, path) {
        return object != null && _hasPath(object, path, _baseHas);
      }
      var has_1 = has$4;
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike_1(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var _createBaseEach = createBaseEach;
      var baseEach = _createBaseEach(_baseForOwn);
      var _baseEach = baseEach;
      function baseSome(collection, predicate) {
        var result;
        _baseEach(collection, function(value, index2, collection2) {
          result = predicate(value, index2, collection2);
          return !result;
        });
        return !!result;
      }
      var _baseSome = baseSome;
      function some(collection, predicate, guard) {
        var func = isArray_1(collection) ? _arraySome : _baseSome;
        if (guard && _isIterateeCall(collection, predicate, guard)) {
          predicate = void 0;
        }
        return func(collection, _baseIteratee(predicate));
      }
      var some_1 = some;
      const getType = (value) => Object.prototype.toString.call(value).slice(8, -1);
      const isDate$1$1 = (value) => isDate_1(value) && !isNaN(value.getTime());
      const isObject$1$1 = (value) => getType(value) === "Object";
      const has$1$1 = has_1;
      const hasAny = (obj, props2) => some_1(props2, (p2) => has_1(obj, p2));
      const some$1 = some_1;
      const pad$1 = (val, len, char = "0") => {
        val = val !== null && val !== void 0 ? String(val) : "";
        len = len || 2;
        while (val.length < len) {
          val = `${char}${val}`;
        }
        return val;
      };
      const mergeEvents = (...args) => {
        const result = {};
        args.forEach((e2) => Object.entries(e2).forEach(([key, value]) => {
          if (!result[key]) {
            result[key] = value;
          } else if (isArrayLikeObject_1(result[key])) {
            result[key].push(value);
          } else {
            result[key] = [result[key], value];
          }
        }));
        return result;
      };
      const pageIsValid = (page) => !!(page && page.month && page.year);
      const pageIsBeforePage = (page, comparePage) => {
        if (!pageIsValid(page) || !pageIsValid(comparePage))
          return false;
        if (page.year === comparePage.year)
          return page.month < comparePage.month;
        return page.year < comparePage.year;
      };
      const pageIsAfterPage = (page, comparePage) => {
        if (!pageIsValid(page) || !pageIsValid(comparePage))
          return false;
        if (page.year === comparePage.year)
          return page.month > comparePage.month;
        return page.year > comparePage.year;
      };
      const pageIsBetweenPages = (page, fromPage, toPage) => (page || false) && !pageIsBeforePage(page, fromPage) && !pageIsAfterPage(page, toPage);
      const pageIsEqualToPage = (aPage, bPage) => {
        if (!aPage && bPage)
          return false;
        if (aPage && !bPage)
          return false;
        if (!aPage && !bPage)
          return true;
        return aPage.month === bPage.month && aPage.year === bPage.year;
      };
      const addPages = ({ month, year }, count) => {
        const incr = count > 0 ? 1 : -1;
        for (let i2 = 0; i2 < Math.abs(count); i2++) {
          month += incr;
          if (month > 12) {
            month = 1;
            year++;
          } else if (month < 1) {
            month = 12;
            year--;
          }
        }
        return {
          month,
          year
        };
      };
      const pageRangeToArray = (from, to2) => {
        if (!pageIsValid(from) || !pageIsValid(to2))
          return [];
        const result = [];
        while (!pageIsAfterPage(from, to2)) {
          result.push(from);
          from = addPages(from, 1);
        }
        return result;
      };
      function datesAreEqual(a2, b2) {
        const aIsDate = isDate$1$1(a2);
        const bIsDate = isDate$1$1(b2);
        if (!aIsDate && !bIsDate)
          return true;
        if (aIsDate !== bIsDate)
          return false;
        return a2.getTime() === b2.getTime();
      }
      const arrayHasItems = (array) => isArrayLikeObject_1(array) && array.length > 0;
      const mixinOptionalProps = (source, target, props2) => {
        const assigned = [];
        props2.forEach((p2) => {
          const name = p2.name || p2.toString();
          const mixin = p2.mixin;
          const validate2 = p2.validate;
          if (Object.prototype.hasOwnProperty.call(source, name)) {
            const value = validate2 ? validate2(source[name]) : source[name];
            target[name] = mixin && isObject$1$1(value) ? __spreadValues(__spreadValues({}, mixin), value) : value;
            assigned.push(name);
          }
        });
        return {
          target,
          assigned: assigned.length ? assigned : null
        };
      };
      const on$2 = (element, event, handler, opts) => {
        if (element && event && handler) {
          element.addEventListener(event, handler, opts);
        }
      };
      const off$1 = (element, event, handler, opts) => {
        if (element && event) {
          element.removeEventListener(event, handler, opts);
        }
      };
      const elementContains = (element, child) => !!element && !!child && (element === child || element.contains(child));
      const onSpaceOrEnter = (event, handler) => {
        if (event.key === " " || event.key === "Enter") {
          handler(event);
          event.preventDefault();
        }
      };
      const createGuid = () => {
        function S4() {
          return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
        }
        return `${S4() + S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;
      };
      function hash$2(str) {
        let hashcode = 0;
        let i2 = 0;
        let chr;
        if (str.length === 0)
          return hashcode;
        for (i2 = 0; i2 < str.length; i2++) {
          chr = str.charCodeAt(i2);
          hashcode = (hashcode << 5) - hashcode + chr;
          hashcode |= 0;
        }
        return hashcode;
      }
      function toInteger(dirtyNumber) {
        if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
          return NaN;
        }
        var number = Number(dirtyNumber);
        if (isNaN(number)) {
          return number;
        }
        return number < 0 ? Math.ceil(number) : Math.floor(number);
      }
      function requiredArgs(required, args) {
        if (args.length < required) {
          throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
        }
      }
      function toDate(argument) {
        requiredArgs(1, arguments);
        var argStr = Object.prototype.toString.call(argument);
        if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
          return new Date(argument.getTime());
        } else if (typeof argument === "number" || argStr === "[object Number]") {
          return new Date(argument);
        } else {
          if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
            console.warn(new Error().stack);
          }
          return new Date(NaN);
        }
      }
      function addDays(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate);
        var amount = toInteger(dirtyAmount);
        if (isNaN(amount)) {
          return new Date(NaN);
        }
        if (!amount) {
          return date;
        }
        date.setDate(date.getDate() + amount);
        return date;
      }
      var numberTag$1 = "[object Number]";
      function isNumber$3(value) {
        return typeof value == "number" || isObjectLike_1(value) && _baseGetTag(value) == numberTag$1;
      }
      var isNumber_1 = isNumber$3;
      var stringTag$1 = "[object String]";
      function isString$4(value) {
        return typeof value == "string" || !isArray_1(value) && isObjectLike_1(value) && _baseGetTag(value) == stringTag$1;
      }
      var isString_1 = isString$4;
      function isUndefined$2(value) {
        return value === void 0;
      }
      var isUndefined_1 = isUndefined$2;
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== void 0) {
            number = number <= upper ? number : upper;
          }
          if (lower !== void 0) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      var _baseClamp = baseClamp;
      var NAN = 0 / 0;
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber$1(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol_1(value)) {
          return NAN;
        }
        if (isObject_1(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject_1(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      var toNumber_1 = toNumber$1;
      function clamp$1(number, lower, upper) {
        if (upper === void 0) {
          upper = lower;
          lower = void 0;
        }
        if (upper !== void 0) {
          upper = toNumber_1(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== void 0) {
          lower = toNumber_1(lower);
          lower = lower === lower ? lower : 0;
        }
        return _baseClamp(toNumber_1(number), lower, upper);
      }
      var clamp_1 = clamp$1;
      function set$1(object, path, value) {
        return object == null ? object : _baseSet(object, path, value);
      }
      var set_1 = set$1;
      function mapValues(object, iteratee) {
        var result = {};
        iteratee = _baseIteratee(iteratee);
        _baseForOwn(object, function(value, key, object2) {
          _baseAssignValue(result, key, iteratee(value, key, object2));
        });
        return result;
      }
      var mapValues_1 = mapValues;
      function baseToPairs(object, props2) {
        return _arrayMap(props2, function(key) {
          return [key, object[key]];
        });
      }
      var _baseToPairs = baseToPairs;
      function setToPairs(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      var _setToPairs = setToPairs;
      var mapTag$1 = "[object Map]", setTag$1 = "[object Set]";
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = _getTag(object);
          if (tag == mapTag$1) {
            return _mapToArray(object);
          }
          if (tag == setTag$1) {
            return _setToPairs(object);
          }
          return _baseToPairs(object, keysFunc(object));
        };
      }
      var _createToPairs = createToPairs;
      var toPairs = _createToPairs(keys_1);
      var toPairs_1 = toPairs;
      var childMixin = {
        inject: ["sharedState"],
        computed: {
          masks: function masks2() {
            return this.sharedState.masks;
          },
          theme: function theme() {
            return this.sharedState.theme;
          },
          locale: function locale() {
            return this.sharedState.locale;
          },
          dayPopoverId: function dayPopoverId() {
            return this.sharedState.dayPopoverId;
          }
        },
        methods: {
          format: function format2(date, mask) {
            return this.locale.format(date, mask);
          },
          pageForDate: function pageForDate(date) {
            return this.locale.getDateParts(this.locale.normalizeDate(date));
          }
        }
      };
      var targetProps = ["base", "start", "end", "startEnd"];
      var displayProps = ["class", "contentClass", "style", "contentStyle", "color", "fillMode"];
      var defConfig = {
        color: "blue",
        isDark: false,
        highlight: {
          base: {
            fillMode: "light"
          },
          start: {
            fillMode: "solid"
          },
          end: {
            fillMode: "solid"
          }
        },
        dot: {
          base: {
            fillMode: "solid"
          },
          start: {
            fillMode: "solid"
          },
          end: {
            fillMode: "solid"
          }
        },
        bar: {
          base: {
            fillMode: "solid"
          },
          start: {
            fillMode: "solid"
          },
          end: {
            fillMode: "solid"
          }
        },
        content: {
          base: {},
          start: {},
          end: {}
        }
      };
      var Theme = /* @__PURE__ */ function() {
        function Theme2(config) {
          _classCallCheck(this, Theme2);
          Object.assign(this, defConfig, config);
        }
        _createClass(Theme2, [{
          key: "normalizeAttr",
          value: function normalizeAttr(_ref) {
            var config = _ref.config, type = _ref.type;
            var rootColor = this.color;
            var root2 = {};
            var normAttr = this[type];
            if (config === true || isString_1(config)) {
              rootColor = isString_1(config) ? config : rootColor;
              root2 = _objectSpread2$1({}, normAttr);
            } else if (isObject$1$1(config)) {
              if (hasAny(config, targetProps)) {
                root2 = _objectSpread2$1({}, config);
              } else {
                root2 = {
                  base: _objectSpread2$1({}, config),
                  start: _objectSpread2$1({}, config),
                  end: _objectSpread2$1({}, config)
                };
              }
            } else {
              return null;
            }
            defaults_1$1(root2, {
              start: root2.startEnd,
              end: root2.startEnd
            }, normAttr);
            toPairs_1(root2).forEach(function(_ref2) {
              var _ref3 = _slicedToArray(_ref2, 2), targetType = _ref3[0], targetConfig = _ref3[1];
              var targetColor = rootColor;
              if (targetConfig === true || isString_1(targetConfig)) {
                targetColor = isString_1(targetConfig) ? targetConfig : targetColor;
                root2[targetType] = {
                  color: targetColor
                };
              } else if (isObject$1$1(targetConfig)) {
                if (hasAny(targetConfig, displayProps)) {
                  root2[targetType] = _objectSpread2$1({}, targetConfig);
                } else {
                  root2[targetType] = {};
                }
              }
              if (!has$1$1(root2, "".concat(targetType, ".color"))) {
                set_1(root2, "".concat(targetType, ".color"), targetColor);
              }
            });
            return root2;
          }
        }, {
          key: "normalizeHighlight",
          value: function normalizeHighlight(config) {
            var _this = this;
            var highlight = this.normalizeAttr({
              config,
              type: "highlight"
            });
            toPairs_1(highlight).forEach(function(_ref4) {
              var _ref5 = _slicedToArray(_ref4, 2);
              _ref5[0];
              var targetConfig = _ref5[1];
              var c2 = defaults_1$1(targetConfig, {
                isDark: _this.isDark,
                color: _this.color
              });
              targetConfig.style = _objectSpread2$1(_objectSpread2$1({}, _this.getHighlightBgStyle(c2)), targetConfig.style);
              targetConfig.contentStyle = _objectSpread2$1(_objectSpread2$1({}, _this.getHighlightContentStyle(c2)), targetConfig.contentStyle);
            });
            return highlight;
          }
        }, {
          key: "getHighlightBgStyle",
          value: function getHighlightBgStyle(_ref6) {
            var fillMode = _ref6.fillMode, color = _ref6.color, isDark = _ref6.isDark;
            switch (fillMode) {
              case "outline":
              case "none":
                return {
                  backgroundColor: isDark ? "var(--gray-900)" : "var(--white)",
                  border: "2px solid",
                  borderColor: isDark ? "var(--".concat(color, "-200)") : "var(--".concat(color, "-700)"),
                  borderRadius: "var(--rounded-full)"
                };
              case "light":
                return {
                  backgroundColor: isDark ? "var(--".concat(color, "-800)") : "var(--".concat(color, "-200)"),
                  opacity: isDark ? 0.75 : 1,
                  borderRadius: "var(--rounded-full)"
                };
              case "solid":
                return {
                  backgroundColor: isDark ? "var(--".concat(color, "-500)") : "var(--".concat(color, "-600)"),
                  borderRadius: "var(--rounded-full)"
                };
              default:
                return {
                  borderRadius: "var(--rounded-full)"
                };
            }
          }
        }, {
          key: "getHighlightContentStyle",
          value: function getHighlightContentStyle(_ref7) {
            var fillMode = _ref7.fillMode, color = _ref7.color, isDark = _ref7.isDark;
            switch (fillMode) {
              case "outline":
              case "none":
                return {
                  fontWeight: "var(--font-bold)",
                  color: isDark ? "var(--".concat(color, "-100)") : "var(--".concat(color, "-900)")
                };
              case "light":
                return {
                  fontWeight: "var(--font-bold)",
                  color: isDark ? "var(--".concat(color, "-100)") : "var(--".concat(color, "-900)")
                };
              case "solid":
                return {
                  fontWeight: "var(--font-bold)",
                  color: "var(--white)"
                };
              default:
                return "";
            }
          }
        }, {
          key: "bgAccentHigh",
          value: function bgAccentHigh(_ref8) {
            var color = _ref8.color, isDark = _ref8.isDark;
            return {
              backgroundColor: isDark ? "var(--".concat(color, "-500)") : "var(--".concat(color, "-600)")
            };
          }
        }, {
          key: "contentAccent",
          value: function contentAccent(_ref9) {
            var color = _ref9.color, isDark = _ref9.isDark;
            if (!color)
              return null;
            return {
              fontWeight: "var(--font-bold)",
              color: isDark ? "var(--".concat(color, "-100)") : "var(--".concat(color, "-900)")
            };
          }
        }, {
          key: "normalizeDot",
          value: function normalizeDot(config) {
            return this.normalizeNonHighlight("dot", config, this.bgAccentHigh);
          }
        }, {
          key: "normalizeBar",
          value: function normalizeBar(config) {
            return this.normalizeNonHighlight("bar", config, this.bgAccentHigh);
          }
        }, {
          key: "normalizeContent",
          value: function normalizeContent(config) {
            return this.normalizeNonHighlight("content", config, this.contentAccent);
          }
        }, {
          key: "normalizeNonHighlight",
          value: function normalizeNonHighlight(type, config, styleFn) {
            var _this2 = this;
            var attr = this.normalizeAttr({
              type,
              config
            });
            toPairs_1(attr).forEach(function(_ref10) {
              var _ref11 = _slicedToArray(_ref10, 2);
              _ref11[0];
              var targetConfig = _ref11[1];
              defaults_1$1(targetConfig, {
                isDark: _this2.isDark,
                color: _this2.color
              });
              targetConfig.style = _objectSpread2$1(_objectSpread2$1({}, styleFn(targetConfig)), targetConfig.style);
            });
            return attr;
          }
        }]);
        return Theme2;
      }();
      var MILLISECONDS_IN_MINUTE = 6e4;
      function getDateMillisecondsPart(date) {
        return date.getTime() % MILLISECONDS_IN_MINUTE;
      }
      function getTimezoneOffsetInMilliseconds(dirtyDate) {
        var date = new Date(dirtyDate.getTime());
        var baseTimezoneOffset = Math.ceil(date.getTimezoneOffset());
        date.setSeconds(0, 0);
        var hasNegativeUTCOffset = baseTimezoneOffset > 0;
        var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE + getDateMillisecondsPart(date)) % MILLISECONDS_IN_MINUTE : getDateMillisecondsPart(date);
        return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
      }
      function tzTokenizeDate(date, timeZone) {
        var dtf = getDateTimeFormat(timeZone);
        return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      }
      var typeToPos = {
        year: 0,
        month: 1,
        day: 2,
        hour: 3,
        minute: 4,
        second: 5
      };
      function partsOffset(dtf, date) {
        var formatted = dtf.formatToParts(date);
        var filled = [];
        for (var i2 = 0; i2 < formatted.length; i2++) {
          var pos = typeToPos[formatted[i2].type];
          if (pos >= 0) {
            filled[pos] = parseInt(formatted[i2].value, 10);
          }
        }
        return filled;
      }
      function hackyOffset(dtf, date) {
        var formatted = dtf.format(date).replace(/\u200E/g, "");
        var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
        return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
      }
      var dtfCache = {};
      function getDateTimeFormat(timeZone) {
        if (!dtfCache[timeZone]) {
          var testDateFormatted = new Intl.DateTimeFormat("en-US", {
            hour12: false,
            timeZone: "America/New_York",
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          }).format(new Date("2014-06-25T04:00:00.123Z"));
          var hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
          dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
            hour12: false,
            timeZone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          }) : new Intl.DateTimeFormat("en-US", {
            hourCycle: "h23",
            timeZone,
            year: "numeric",
            month: "2-digit",
            day: "2-digit",
            hour: "2-digit",
            minute: "2-digit",
            second: "2-digit"
          });
        }
        return dtfCache[timeZone];
      }
      var MILLISECONDS_IN_HOUR = 36e5;
      var MILLISECONDS_IN_MINUTE$1 = 6e4;
      var patterns = {
        timezone: /([Z+-].*)$/,
        timezoneZ: /^(Z)$/,
        timezoneHH: /^([+-])(\d{2})$/,
        timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
        timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      };
      function tzParseTimezone(timezoneString, date) {
        var token2;
        var absoluteOffset;
        token2 = patterns.timezoneZ.exec(timezoneString);
        if (token2) {
          return 0;
        }
        var hours;
        token2 = patterns.timezoneHH.exec(timezoneString);
        if (token2) {
          hours = parseInt(token2[2], 10);
          if (!validateTimezone()) {
            return NaN;
          }
          absoluteOffset = hours * MILLISECONDS_IN_HOUR;
          return token2[1] === "+" ? -absoluteOffset : absoluteOffset;
        }
        token2 = patterns.timezoneHHMM.exec(timezoneString);
        if (token2) {
          hours = parseInt(token2[2], 10);
          var minutes = parseInt(token2[3], 10);
          if (!validateTimezone(hours, minutes)) {
            return NaN;
          }
          absoluteOffset = hours * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE$1;
          return token2[1] === "+" ? -absoluteOffset : absoluteOffset;
        }
        token2 = patterns.timezoneIANA.exec(timezoneString);
        if (token2) {
          var tokens = tzTokenizeDate(date, timezoneString);
          var asUTC = Date.UTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3], tokens[4], tokens[5]);
          var timestampWithMsZeroed = date.getTime() - date.getTime() % 1e3;
          return -(asUTC - timestampWithMsZeroed);
        }
        return 0;
      }
      function validateTimezone(hours, minutes) {
        if (minutes != null && (minutes < 0 || minutes > 59)) {
          return false;
        }
        return true;
      }
      var MILLISECONDS_IN_HOUR$1 = 36e5;
      var MILLISECONDS_IN_MINUTE$2 = 6e4;
      var DEFAULT_ADDITIONAL_DIGITS = 2;
      var patterns$1 = {
        dateTimeDelimeter: /[T ]/,
        plainTime: /:/,
        timeZoneDelimeter: /[Z ]/i,
        YY: /^(\d{2})$/,
        YYY: [
          /^([+-]\d{2})$/,
          /^([+-]\d{3})$/,
          /^([+-]\d{4})$/
        ],
        YYYY: /^(\d{4})/,
        YYYYY: [
          /^([+-]\d{4})/,
          /^([+-]\d{5})/,
          /^([+-]\d{6})/
        ],
        MM: /^-(\d{2})$/,
        DDD: /^-?(\d{3})$/,
        MMDD: /^-?(\d{2})-?(\d{2})$/,
        Www: /^-?W(\d{2})$/,
        WwwD: /^-?W(\d{2})-?(\d{1})$/,
        HH: /^(\d{2}([.,]\d*)?)$/,
        HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
        HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
        timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
      };
      function toDate$1(argument, dirtyOptions) {
        if (arguments.length < 1) {
          throw new TypeError("1 argument required, but only " + arguments.length + " present");
        }
        if (argument === null) {
          return new Date(NaN);
        }
        var options = dirtyOptions || {};
        var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);
        if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
          throw new RangeError("additionalDigits must be 0, 1 or 2");
        }
        if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
          return new Date(argument.getTime());
        } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
          return new Date(argument);
        } else if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
          return new Date(NaN);
        }
        var dateStrings = splitDateString(argument);
        var parseYearResult = parseYear(dateStrings.date, additionalDigits);
        var year = parseYearResult.year;
        var restDateString = parseYearResult.restDateString;
        var date = parseDate(restDateString, year);
        if (isNaN(date)) {
          return new Date(NaN);
        }
        if (date) {
          var timestamp = date.getTime();
          var time = 0;
          var offset2;
          if (dateStrings.time) {
            time = parseTime(dateStrings.time);
            if (isNaN(time)) {
              return new Date(NaN);
            }
          }
          if (dateStrings.timezone || options.timeZone) {
            offset2 = tzParseTimezone(dateStrings.timezone || options.timeZone, new Date(timestamp + time));
            if (isNaN(offset2)) {
              return new Date(NaN);
            }
            offset2 = tzParseTimezone(dateStrings.timezone || options.timeZone, new Date(timestamp + time + offset2));
            if (isNaN(offset2)) {
              return new Date(NaN);
            }
          } else {
            offset2 = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
            offset2 = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset2));
          }
          return new Date(timestamp + time + offset2);
        } else {
          return new Date(NaN);
        }
      }
      function splitDateString(dateString) {
        var dateStrings = {};
        var array = dateString.split(patterns$1.dateTimeDelimeter);
        var timeString;
        if (patterns$1.plainTime.test(array[0])) {
          dateStrings.date = null;
          timeString = array[0];
        } else {
          dateStrings.date = array[0];
          timeString = array[1];
          dateStrings.timezone = array[2];
          if (patterns$1.timeZoneDelimeter.test(dateStrings.date)) {
            dateStrings.date = dateString.split(patterns$1.timeZoneDelimeter)[0];
            timeString = dateString.substr(dateStrings.date.length, dateString.length);
          }
        }
        if (timeString) {
          var token2 = patterns$1.timezone.exec(timeString);
          if (token2) {
            dateStrings.time = timeString.replace(token2[1], "");
            dateStrings.timezone = token2[1];
          } else {
            dateStrings.time = timeString;
          }
        }
        return dateStrings;
      }
      function parseYear(dateString, additionalDigits) {
        var patternYYY = patterns$1.YYY[additionalDigits];
        var patternYYYYY = patterns$1.YYYYY[additionalDigits];
        var token2;
        token2 = patterns$1.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
        if (token2) {
          var yearString = token2[1];
          return {
            year: parseInt(yearString, 10),
            restDateString: dateString.slice(yearString.length)
          };
        }
        token2 = patterns$1.YY.exec(dateString) || patternYYY.exec(dateString);
        if (token2) {
          var centuryString = token2[1];
          return {
            year: parseInt(centuryString, 10) * 100,
            restDateString: dateString.slice(centuryString.length)
          };
        }
        return {
          year: null
        };
      }
      function parseDate(dateString, year) {
        if (year === null) {
          return null;
        }
        var token2;
        var date;
        var month;
        var week;
        if (dateString.length === 0) {
          date = new Date(0);
          date.setUTCFullYear(year);
          return date;
        }
        token2 = patterns$1.MM.exec(dateString);
        if (token2) {
          date = new Date(0);
          month = parseInt(token2[1], 10) - 1;
          if (!validateDate(year, month)) {
            return new Date(NaN);
          }
          date.setUTCFullYear(year, month);
          return date;
        }
        token2 = patterns$1.DDD.exec(dateString);
        if (token2) {
          date = new Date(0);
          var dayOfYear = parseInt(token2[1], 10);
          if (!validateDayOfYearDate(year, dayOfYear)) {
            return new Date(NaN);
          }
          date.setUTCFullYear(year, 0, dayOfYear);
          return date;
        }
        token2 = patterns$1.MMDD.exec(dateString);
        if (token2) {
          date = new Date(0);
          month = parseInt(token2[1], 10) - 1;
          var day = parseInt(token2[2], 10);
          if (!validateDate(year, month, day)) {
            return new Date(NaN);
          }
          date.setUTCFullYear(year, month, day);
          return date;
        }
        token2 = patterns$1.Www.exec(dateString);
        if (token2) {
          week = parseInt(token2[1], 10) - 1;
          if (!validateWeekDate(year, week)) {
            return new Date(NaN);
          }
          return dayOfISOWeekYear(year, week);
        }
        token2 = patterns$1.WwwD.exec(dateString);
        if (token2) {
          week = parseInt(token2[1], 10) - 1;
          var dayOfWeek = parseInt(token2[2], 10) - 1;
          if (!validateWeekDate(year, week, dayOfWeek)) {
            return new Date(NaN);
          }
          return dayOfISOWeekYear(year, week, dayOfWeek);
        }
        return null;
      }
      function parseTime(timeString) {
        var token2;
        var hours;
        var minutes;
        token2 = patterns$1.HH.exec(timeString);
        if (token2) {
          hours = parseFloat(token2[1].replace(",", "."));
          if (!validateTime(hours)) {
            return NaN;
          }
          return hours % 24 * MILLISECONDS_IN_HOUR$1;
        }
        token2 = patterns$1.HHMM.exec(timeString);
        if (token2) {
          hours = parseInt(token2[1], 10);
          minutes = parseFloat(token2[2].replace(",", "."));
          if (!validateTime(hours, minutes)) {
            return NaN;
          }
          return hours % 24 * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
        }
        token2 = patterns$1.HHMMSS.exec(timeString);
        if (token2) {
          hours = parseInt(token2[1], 10);
          minutes = parseInt(token2[2], 10);
          var seconds = parseFloat(token2[3].replace(",", "."));
          if (!validateTime(hours, minutes, seconds)) {
            return NaN;
          }
          return hours % 24 * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2 + seconds * 1e3;
        }
        return null;
      }
      function dayOfISOWeekYear(isoWeekYear, week, day) {
        week = week || 0;
        day = day || 0;
        var date = new Date(0);
        date.setUTCFullYear(isoWeekYear, 0, 4);
        var fourthOfJanuaryDay = date.getUTCDay() || 7;
        var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
        date.setUTCDate(date.getUTCDate() + diff);
        return date;
      }
      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function isLeapYearIndex(year) {
        return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
      }
      function validateDate(year, month, date) {
        if (month < 0 || month > 11) {
          return false;
        }
        if (date != null) {
          if (date < 1) {
            return false;
          }
          var isLeapYear = isLeapYearIndex(year);
          if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
            return false;
          }
          if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
            return false;
          }
        }
        return true;
      }
      function validateDayOfYearDate(year, dayOfYear) {
        if (dayOfYear < 1) {
          return false;
        }
        var isLeapYear = isLeapYearIndex(year);
        if (isLeapYear && dayOfYear > 366) {
          return false;
        }
        if (!isLeapYear && dayOfYear > 365) {
          return false;
        }
        return true;
      }
      function validateWeekDate(year, week, day) {
        if (week < 0 || week > 52) {
          return false;
        }
        if (day != null && (day < 0 || day > 6)) {
          return false;
        }
        return true;
      }
      function validateTime(hours, minutes, seconds) {
        if (hours != null && (hours < 0 || hours >= 25)) {
          return false;
        }
        if (minutes != null && (minutes < 0 || minutes >= 60)) {
          return false;
        }
        if (seconds != null && (seconds < 0 || seconds >= 60)) {
          return false;
        }
        return true;
      }
      function startOfWeek(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {};
        var locale = options.locale;
        var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
        var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
        var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
        if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
          throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
        }
        var date = toDate(dirtyDate);
        var day = date.getDay();
        var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
        date.setDate(date.getDate() - diff);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      function startOfISOWeek(dirtyDate) {
        requiredArgs(1, arguments);
        return startOfWeek(dirtyDate, {
          weekStartsOn: 1
        });
      }
      function getISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        var year = date.getFullYear();
        var fourthOfJanuaryOfNextYear = new Date(0);
        fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
        fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
        var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
        var fourthOfJanuaryOfThisYear = new Date(0);
        fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
        fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
        var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
        if (date.getTime() >= startOfNextYear.getTime()) {
          return year + 1;
        } else if (date.getTime() >= startOfThisYear.getTime()) {
          return year;
        } else {
          return year - 1;
        }
      }
      function startOfISOWeekYear(dirtyDate) {
        requiredArgs(1, arguments);
        var year = getISOWeekYear(dirtyDate);
        var fourthOfJanuary = new Date(0);
        fourthOfJanuary.setFullYear(year, 0, 4);
        fourthOfJanuary.setHours(0, 0, 0, 0);
        var date = startOfISOWeek(fourthOfJanuary);
        return date;
      }
      var MILLISECONDS_IN_WEEK = 6048e5;
      function getISOWeek(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
        return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
      }
      function getWeekYear(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        var year = date.getFullYear();
        var options = dirtyOptions || {};
        var locale = options.locale;
        var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
        var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
        var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
        if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
          throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
        }
        var firstWeekOfNextYear = new Date(0);
        firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
        firstWeekOfNextYear.setHours(0, 0, 0, 0);
        var startOfNextYear = startOfWeek(firstWeekOfNextYear, dirtyOptions);
        var firstWeekOfThisYear = new Date(0);
        firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
        firstWeekOfThisYear.setHours(0, 0, 0, 0);
        var startOfThisYear = startOfWeek(firstWeekOfThisYear, dirtyOptions);
        if (date.getTime() >= startOfNextYear.getTime()) {
          return year + 1;
        } else if (date.getTime() >= startOfThisYear.getTime()) {
          return year;
        } else {
          return year - 1;
        }
      }
      function startOfWeekYear(dirtyDate, dirtyOptions) {
        requiredArgs(1, arguments);
        var options = dirtyOptions || {};
        var locale = options.locale;
        var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
        var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
        var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
        var year = getWeekYear(dirtyDate, dirtyOptions);
        var firstWeek = new Date(0);
        firstWeek.setFullYear(year, 0, firstWeekContainsDate);
        firstWeek.setHours(0, 0, 0, 0);
        var date = startOfWeek(firstWeek, dirtyOptions);
        return date;
      }
      var MILLISECONDS_IN_WEEK$1 = 6048e5;
      function getWeek(dirtyDate, options) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime();
        return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
      }
      var MILLISECONDS_IN_WEEK$2 = 6048e5;
      function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, dirtyOptions) {
        requiredArgs(2, arguments);
        var startOfWeekLeft = startOfWeek(dirtyDateLeft, dirtyOptions);
        var startOfWeekRight = startOfWeek(dirtyDateRight, dirtyOptions);
        var timestampLeft = startOfWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
        var timestampRight = startOfWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekRight);
        return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK$2);
      }
      function lastDayOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        var month = date.getMonth();
        date.setFullYear(date.getFullYear(), month + 1, 0);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      function startOfMonth(dirtyDate) {
        requiredArgs(1, arguments);
        var date = toDate(dirtyDate);
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      function getWeeksInMonth(date, options) {
        requiredArgs(1, arguments);
        return differenceInCalendarWeeks(lastDayOfMonth(date), startOfMonth(date), options) + 1;
      }
      var millisecondsPerDay = 24 * 60 * 60 * 1e3;
      var DateInfo = /* @__PURE__ */ function() {
        function DateInfo2(config) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$order = _ref.order, order2 = _ref$order === void 0 ? 0 : _ref$order, locale = _ref.locale, isFullDay = _ref.isFullDay;
          _classCallCheck(this, DateInfo2);
          this.isDateInfo = true;
          this.order = order2;
          this.locale = locale instanceof Locale ? locale : new Locale(locale);
          this.firstDayOfWeek = this.locale.firstDayOfWeek;
          if (!isObject$1$1(config)) {
            var date = this.locale.normalizeDate(config);
            if (isFullDay) {
              config = {
                start: date,
                end: date
              };
            } else {
              config = {
                startOn: date,
                endOn: date
              };
            }
          }
          var start2 = null;
          var end2 = null;
          if (config.start) {
            start2 = this.locale.normalizeDate(config.start, _objectSpread2$1(_objectSpread2$1({}, this.opts), {}, {
              time: "00:00:00"
            }));
          } else if (config.startOn) {
            start2 = this.locale.normalizeDate(config.startOn, this.opts);
          }
          if (config.end) {
            end2 = this.locale.normalizeDate(config.end, _objectSpread2$1(_objectSpread2$1({}, this.opts), {}, {
              time: "23:59:59"
            }));
          } else if (config.endOn) {
            end2 = this.locale.normalizeDate(config.endOn, this.opts);
          }
          if (start2 && end2 && start2 > end2) {
            var temp = start2;
            start2 = end2;
            end2 = temp;
          } else if (start2 && config.span >= 1) {
            end2 = addDays(start2, config.span - 1);
          }
          this.start = start2;
          this.startTime = start2 ? start2.getTime() : NaN;
          this.end = end2;
          this.endTime = end2 ? end2.getTime() : NaN;
          this.isDate = this.startTime && this.startTime === this.endTime;
          this.isRange = !this.isDate;
          var andOpt = mixinOptionalProps(config, {}, DateInfo2.patternProps);
          if (andOpt.assigned) {
            this.on = {
              and: andOpt.target
            };
          }
          if (config.on) {
            var or2 = (isArrayLikeObject_1(config.on) ? config.on : [config.on]).map(function(o2) {
              if (isFunction_1(o2))
                return o2;
              var opt = mixinOptionalProps(o2, {}, DateInfo2.patternProps);
              return opt.assigned ? opt.target : null;
            }).filter(function(o2) {
              return o2;
            });
            if (or2.length)
              this.on = _objectSpread2$1(_objectSpread2$1({}, this.on), {}, {
                or: or2
              });
          }
          this.isComplex = !!this.on;
        }
        _createClass(DateInfo2, [{
          key: "toDateInfo",
          value: function toDateInfo(date) {
            return date.isDateInfo ? date : new DateInfo2(date, this.opts);
          }
        }, {
          key: "startOfWeek",
          value: function startOfWeek2(date) {
            var day = date.getDay() + 1;
            var daysToAdd = day >= this.firstDayOfWeek ? this.firstDayOfWeek - day : -(7 - (this.firstDayOfWeek - day));
            return addDays(date, daysToAdd);
          }
        }, {
          key: "diffInDays",
          value: function diffInDays(d1, d2) {
            return Math.round((d2 - d1) / millisecondsPerDay);
          }
        }, {
          key: "diffInWeeks",
          value: function diffInWeeks(d1, d2) {
            return this.diffInDays(this.startOfWeek(d1), this.startOfWeek(d2));
          }
        }, {
          key: "diffInYears",
          value: function diffInYears(d1, d2) {
            return d2.getUTCFullYear() - d1.getUTCFullYear();
          }
        }, {
          key: "diffInMonths",
          value: function diffInMonths(d1, d2) {
            return this.diffInYears(d1, d2) * 12 + (d2.getMonth() - d1.getMonth());
          }
        }, {
          key: "iterateDatesInRange",
          value: function iterateDatesInRange(_ref2, fn2) {
            var start2 = _ref2.start, end2 = _ref2.end;
            if (!start2 || !end2 || !isFunction_1(fn2))
              return null;
            start2 = this.locale.normalizeDate(start2, _objectSpread2$1(_objectSpread2$1({}, this.opts), {}, {
              time: "00:00:00"
            }));
            var state2 = {
              i: 0,
              date: start2,
              day: this.locale.getDateParts(start2),
              finished: false
            };
            var result = null;
            for (; !state2.finished && state2.date <= end2; state2.i++) {
              result = fn2(state2);
              state2.date = addDays(state2.date, 1);
              state2.day = this.locale.getDateParts(state2.date);
            }
            return result;
          }
        }, {
          key: "shallowIntersectingRange",
          value: function shallowIntersectingRange(other) {
            return this.rangeShallowIntersectingRange(this, this.toDateInfo(other));
          }
        }, {
          key: "rangeShallowIntersectingRange",
          value: function rangeShallowIntersectingRange(date1, date2) {
            if (!this.dateShallowIntersectsDate(date1, date2)) {
              return null;
            }
            var thisRange = date1.toRange();
            var otherRange = date2.toRange();
            var start2 = null;
            var end2 = null;
            if (thisRange.start) {
              if (!otherRange.start) {
                start2 = thisRange.start;
              } else {
                start2 = thisRange.start > otherRange.start ? thisRange.start : otherRange.start;
              }
            } else if (otherRange.start) {
              start2 = otherRange.start;
            }
            if (thisRange.end) {
              if (!otherRange.end) {
                end2 = thisRange.end;
              } else {
                end2 = thisRange.end < otherRange.end ? thisRange.end : otherRange.end;
              }
            } else if (otherRange.end) {
              end2 = otherRange.end;
            }
            return {
              start: start2,
              end: end2
            };
          }
        }, {
          key: "intersectsDate",
          value: function intersectsDate(other) {
            var _this = this;
            var date = this.toDateInfo(other);
            if (!this.shallowIntersectsDate(date))
              return null;
            if (!this.on)
              return this;
            var range = this.rangeShallowIntersectingRange(this, date);
            var result = false;
            this.iterateDatesInRange(range, function(state2) {
              if (_this.matchesDay(state2.day)) {
                result = result || date.matchesDay(state2.day);
                state2.finished = result;
              }
            });
            return result;
          }
        }, {
          key: "shallowIntersectsDate",
          value: function shallowIntersectsDate(other) {
            return this.dateShallowIntersectsDate(this, this.toDateInfo(other));
          }
        }, {
          key: "dateShallowIntersectsDate",
          value: function dateShallowIntersectsDate(date1, date2) {
            if (date1.isDate) {
              return date2.isDate ? date1.startTime === date2.startTime : this.dateShallowIncludesDate(date2, date1);
            }
            if (date2.isDate) {
              return this.dateShallowIncludesDate(date1, date2);
            }
            if (date1.start && date2.end && date1.start > date2.end) {
              return false;
            }
            if (date1.end && date2.start && date1.end < date2.start) {
              return false;
            }
            return true;
          }
        }, {
          key: "includesDate",
          value: function includesDate(other) {
            var _this2 = this;
            var date = this.toDateInfo(other);
            if (!this.shallowIncludesDate(date)) {
              return false;
            }
            if (!this.on) {
              return true;
            }
            var range = this.rangeShallowIntersectingRange(this, date);
            var result = true;
            this.iterateDatesInRange(range, function(state2) {
              if (_this2.matchesDay(state2.day)) {
                result = result && date.matchesDay(state2.day);
                state2.finished = !result;
              }
            });
            return result;
          }
        }, {
          key: "shallowIncludesDate",
          value: function shallowIncludesDate(other) {
            return this.dateShallowIncludesDate(this, other.isDate ? other : new DateInfo2(other, this.opts));
          }
        }, {
          key: "dateShallowIncludesDate",
          value: function dateShallowIncludesDate(date1, date2) {
            if (date1.isDate) {
              if (date2.isDate) {
                return date1.startTime === date2.startTime;
              }
              if (!date2.startTime || !date2.endTime) {
                return false;
              }
              return date1.startTime === date2.startTime && date1.startTime === date2.endTime;
            }
            if (date2.isDate) {
              if (date1.start && date2.start < date1.start) {
                return false;
              }
              if (date1.end && date2.start > date1.end) {
                return false;
              }
              return true;
            }
            if (date1.start && (!date2.start || date2.start < date1.start)) {
              return false;
            }
            if (date1.end && (!date2.end || date2.end > date1.end)) {
              return false;
            }
            return true;
          }
        }, {
          key: "intersectsDay",
          value: function intersectsDay(day) {
            if (!this.shallowIntersectsDate(day.range))
              return null;
            return this.matchesDay(day) ? this : null;
          }
        }, {
          key: "matchesDay",
          value: function matchesDay(day) {
            var _this3 = this;
            if (!this.on)
              return true;
            if (this.on.and && !DateInfo2.testConfig(this.on.and, day, this)) {
              return false;
            }
            if (this.on.or && !this.on.or.some(function(or2) {
              return DateInfo2.testConfig(or2, day, _this3);
            })) {
              return false;
            }
            return true;
          }
        }, {
          key: "toRange",
          value: function toRange() {
            return new DateInfo2({
              start: this.start,
              end: this.end
            }, this.opts);
          }
        }, {
          key: "compare",
          value: function compare(other) {
            if (this.order !== other.order)
              return this.order - other.order;
            if (this.isDate !== other.isDate)
              return this.isDate ? 1 : -1;
            if (this.isDate)
              return 0;
            var diff = this.start - other.start;
            return diff !== 0 ? diff : this.end - other.end;
          }
        }, {
          key: "opts",
          get: function get2() {
            return {
              order: this.order,
              locale: this.locale
            };
          }
        }], [{
          key: "testConfig",
          value: function testConfig(config, day, dateInfo) {
            if (isFunction_1(config))
              return config(day);
            if (isObject$1$1(config)) {
              return Object.keys(config).every(function(k2) {
                return DateInfo2.patterns[k2].test(day, config[k2], dateInfo);
              });
            }
            return null;
          }
        }, {
          key: "patterns",
          get: function get2() {
            return {
              dailyInterval: {
                test: function test(day, interval, di) {
                  return di.diffInDays(di.start || new Date(), day.date) % interval === 0;
                }
              },
              weeklyInterval: {
                test: function test(day, interval, di) {
                  return di.diffInWeeks(di.start || new Date(), day.date) % interval === 0;
                }
              },
              monthlyInterval: {
                test: function test(day, interval, di) {
                  return di.diffInMonths(di.start || new Date(), day.date) % interval === 0;
                }
              },
              yearlyInterval: {
                test: function test() {
                  return function(day, interval, di) {
                    return di.diffInYears(di.start || new Date(), day.date) % interval === 0;
                  };
                }
              },
              days: {
                validate: function validate2(days) {
                  return isArrayLikeObject_1(days) ? days : [parseInt(days, 10)];
                },
                test: function test(day, days) {
                  return days.includes(day.day) || days.includes(-day.dayFromEnd);
                }
              },
              weekdays: {
                validate: function validate2(weekdays2) {
                  return isArrayLikeObject_1(weekdays2) ? weekdays2 : [parseInt(weekdays2, 10)];
                },
                test: function test(day, weekdays2) {
                  return weekdays2.includes(day.weekday);
                }
              },
              ordinalWeekdays: {
                validate: function validate2(ordinalWeekdays) {
                  return Object.keys(ordinalWeekdays).reduce(function(obj, ck) {
                    var weekdays2 = ordinalWeekdays[ck];
                    if (!weekdays2)
                      return obj;
                    obj[ck] = isArrayLikeObject_1(weekdays2) ? weekdays2 : [parseInt(weekdays2, 10)];
                    return obj;
                  }, {});
                },
                test: function test(day, ordinalWeekdays) {
                  return Object.keys(ordinalWeekdays).map(function(k2) {
                    return parseInt(k2, 10);
                  }).find(function(k2) {
                    return ordinalWeekdays[k2].includes(day.weekday) && (k2 === day.weekdayOrdinal || k2 === -day.weekdayOrdinalFromEnd);
                  });
                }
              },
              weekends: {
                validate: function validate2(config) {
                  return config;
                },
                test: function test(day) {
                  return day.weekday === 1 || day.weekday === 7;
                }
              },
              workweek: {
                validate: function validate2(config) {
                  return config;
                },
                test: function test(day) {
                  return day.weekday >= 2 && day.weekday <= 6;
                }
              },
              weeks: {
                validate: function validate2(weeks) {
                  return isArrayLikeObject_1(weeks) ? weeks : [parseInt(weeks, 10)];
                },
                test: function test(day, weeks) {
                  return weeks.includes(day.week) || weeks.includes(-day.weekFromEnd);
                }
              },
              months: {
                validate: function validate2(months) {
                  return isArrayLikeObject_1(months) ? months : [parseInt(months, 10)];
                },
                test: function test(day, months) {
                  return months.includes(day.month);
                }
              },
              years: {
                validate: function validate2(years) {
                  return isArrayLikeObject_1(years) ? years : [parseInt(years, 10)];
                },
                test: function test(day, years) {
                  return years.includes(day.year);
                }
              }
            };
          }
        }, {
          key: "patternProps",
          get: function get2() {
            return Object.keys(DateInfo2.patterns).map(function(k2) {
              return {
                name: k2,
                validate: DateInfo2.patterns[k2].validate
              };
            });
          }
        }]);
        return DateInfo2;
      }();
      const locales = {
        ar: { dow: 7, L: "D/\u200FM/\u200FYYYY" },
        bg: { dow: 2, L: "D.MM.YYYY" },
        ca: { dow: 2, L: "DD/MM/YYYY" },
        "zh-CN": { dow: 2, L: "YYYY/MM/DD" },
        "zh-TW": { dow: 1, L: "YYYY/MM/DD" },
        hr: { dow: 2, L: "DD.MM.YYYY" },
        cs: { dow: 2, L: "DD.MM.YYYY" },
        da: { dow: 2, L: "DD.MM.YYYY" },
        nl: { dow: 2, L: "DD-MM-YYYY" },
        "en-US": { dow: 1, L: "MM/DD/YYYY" },
        "en-AU": { dow: 2, L: "DD/MM/YYYY" },
        "en-CA": { dow: 1, L: "YYYY-MM-DD" },
        "en-GB": { dow: 2, L: "DD/MM/YYYY" },
        "en-IE": { dow: 2, L: "DD-MM-YYYY" },
        "en-NZ": { dow: 2, L: "DD/MM/YYYY" },
        "en-ZA": { dow: 1, L: "YYYY/MM/DD" },
        eo: { dow: 2, L: "YYYY-MM-DD" },
        et: { dow: 2, L: "DD.MM.YYYY" },
        fi: { dow: 2, L: "DD.MM.YYYY" },
        fr: { dow: 2, L: "DD/MM/YYYY" },
        "fr-CA": { dow: 1, L: "YYYY-MM-DD" },
        "fr-CH": { dow: 2, L: "DD.MM.YYYY" },
        de: { dow: 2, L: "DD.MM.YYYY" },
        he: { dow: 1, L: "DD.MM.YYYY" },
        id: { dow: 2, L: "DD/MM/YYYY" },
        it: { dow: 2, L: "DD/MM/YYYY" },
        ja: { dow: 1, L: "YYYY\u5E74M\u6708D\u65E5" },
        ko: { dow: 1, L: "YYYY.MM.DD" },
        lv: { dow: 2, L: "DD.MM.YYYY" },
        lt: { dow: 2, L: "DD.MM.YYYY" },
        mk: { dow: 2, L: "D.MM.YYYY" },
        nb: { dow: 2, L: "D. MMMM YYYY" },
        nn: { dow: 2, L: "D. MMMM YYYY" },
        pl: { dow: 2, L: "DD.MM.YYYY" },
        pt: { dow: 2, L: "DD/MM/YYYY" },
        ro: { dow: 2, L: "DD.MM.YYYY" },
        ru: { dow: 2, L: "DD.MM.YYYY" },
        sk: { dow: 2, L: "DD.MM.YYYY" },
        "es-ES": { dow: 2, L: "DD/MM/YYYY" },
        "es-MX": { dow: 2, L: "DD/MM/YYYY" },
        sv: { dow: 2, L: "YYYY-MM-DD" },
        th: { dow: 1, L: "DD/MM/YYYY" },
        tr: { dow: 2, L: "DD.MM.YYYY" },
        uk: { dow: 2, L: "DD.MM.YYYY" },
        vi: { dow: 2, L: "DD/MM/YYYY" }
      };
      locales.en = locales["en-US"];
      locales.es = locales["es-ES"];
      locales.no = locales.nb;
      locales.zh = locales["zh-CN"];
      toPairs_1(locales).forEach(([id, { dow, L: L2 }]) => {
        locales[id] = {
          id,
          firstDayOfWeek: dow,
          masks: { L: L2 }
        };
      });
      var PATCH = {
        DATE_TIME: 1,
        DATE: 2,
        TIME: 3
      };
      var PATCH_KEYS = {
        1: ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds"],
        2: ["year", "month", "day"],
        3: ["hours", "minutes", "seconds", "milliseconds"]
      };
      var token = /d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|Z{1,4}|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
      var twoDigits = /\d\d?/;
      var threeDigits = /\d{3}/;
      var fourDigits = /\d{4}/;
      var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
      var literal = /\[([^]*?)\]/gm;
      var noop$1 = function noop2() {
      };
      var monthUpdate = function monthUpdate2(arrName) {
        return function(d2, v2, l2) {
          var index2 = l2[arrName].indexOf(v2.charAt(0).toUpperCase() + v2.substr(1).toLowerCase());
          if (~index2) {
            d2.month = index2;
          }
        };
      };
      var maskMacros = ["L", "iso"];
      var daysInWeek = 7;
      var daysInMonths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      var formatFlags = {
        D: function D2(d2) {
          return d2.day;
        },
        DD: function DD(d2) {
          return pad$1(d2.day);
        },
        Do: function Do2(d2, l2) {
          return l2.DoFn(d2.day);
        },
        d: function d2(_d) {
          return _d.weekday - 1;
        },
        dd: function dd(d2) {
          return pad$1(d2.weekday - 1);
        },
        W: function W2(d2, l2) {
          return l2.dayNamesNarrow[d2.weekday - 1];
        },
        WW: function WW(d2, l2) {
          return l2.dayNamesShorter[d2.weekday - 1];
        },
        WWW: function WWW(d2, l2) {
          return l2.dayNamesShort[d2.weekday - 1];
        },
        WWWW: function WWWW(d2, l2) {
          return l2.dayNames[d2.weekday - 1];
        },
        M: function M2(d2) {
          return d2.month;
        },
        MM: function MM(d2) {
          return pad$1(d2.month);
        },
        MMM: function MMM(d2, l2) {
          return l2.monthNamesShort[d2.month - 1];
        },
        MMMM: function MMMM(d2, l2) {
          return l2.monthNames[d2.month - 1];
        },
        YY: function YY(d2) {
          return String(d2.year).substr(2);
        },
        YYYY: function YYYY(d2) {
          return pad$1(d2.year, 4);
        },
        h: function h2(d2) {
          return d2.hours % 12 || 12;
        },
        hh: function hh(d2) {
          return pad$1(d2.hours % 12 || 12);
        },
        H: function H2(d2) {
          return d2.hours;
        },
        HH: function HH(d2) {
          return pad$1(d2.hours);
        },
        m: function m2(d2) {
          return d2.minutes;
        },
        mm: function mm(d2) {
          return pad$1(d2.minutes);
        },
        s: function s2(d2) {
          return d2.seconds;
        },
        ss: function ss(d2) {
          return pad$1(d2.seconds);
        },
        S: function S2(d2) {
          return Math.round(d2.milliseconds / 100);
        },
        SS: function SS(d2) {
          return pad$1(Math.round(d2.milliseconds / 10), 2);
        },
        SSS: function SSS(d2) {
          return pad$1(d2.milliseconds, 3);
        },
        a: function a2(d2, l2) {
          return d2.hours < 12 ? l2.amPm[0] : l2.amPm[1];
        },
        A: function A2(d2, l2) {
          return d2.hours < 12 ? l2.amPm[0].toUpperCase() : l2.amPm[1].toUpperCase();
        },
        Z: function Z2() {
          return "Z";
        },
        ZZ: function ZZ(d2) {
          var o2 = d2.timezoneOffset;
          return "".concat(o2 > 0 ? "-" : "+").concat(pad$1(Math.floor(Math.abs(o2) / 60), 2));
        },
        ZZZ: function ZZZ(d2) {
          var o2 = d2.timezoneOffset;
          return "".concat(o2 > 0 ? "-" : "+").concat(pad$1(Math.floor(Math.abs(o2) / 60) * 100 + Math.abs(o2) % 60, 4));
        },
        ZZZZ: function ZZZZ(d2) {
          var o2 = d2.timezoneOffset;
          return "".concat(o2 > 0 ? "-" : "+").concat(pad$1(Math.floor(Math.abs(o2) / 60), 2), ":").concat(pad$1(Math.abs(o2) % 60, 2));
        }
      };
      var parseFlags = {
        D: [twoDigits, function(d2, v2) {
          d2.day = v2;
        }],
        Do: [new RegExp(twoDigits.source + word.source), function(d2, v2) {
          d2.day = parseInt(v2, 10);
        }],
        d: [twoDigits, noop$1],
        W: [word, noop$1],
        M: [twoDigits, function(d2, v2) {
          d2.month = v2 - 1;
        }],
        MMM: [word, monthUpdate("monthNamesShort")],
        MMMM: [word, monthUpdate("monthNames")],
        YY: [twoDigits, function(d2, v2) {
          var da = new Date();
          var cent = +da.getFullYear().toString().substr(0, 2);
          d2.year = "".concat(v2 > 68 ? cent - 1 : cent).concat(v2);
        }],
        YYYY: [fourDigits, function(d2, v2) {
          d2.year = v2;
        }],
        S: [/\d/, function(d2, v2) {
          d2.millisecond = v2 * 100;
        }],
        SS: [/\d{2}/, function(d2, v2) {
          d2.millisecond = v2 * 10;
        }],
        SSS: [threeDigits, function(d2, v2) {
          d2.millisecond = v2;
        }],
        h: [twoDigits, function(d2, v2) {
          d2.hour = v2;
        }],
        m: [twoDigits, function(d2, v2) {
          d2.minute = v2;
        }],
        s: [twoDigits, function(d2, v2) {
          d2.second = v2;
        }],
        a: [word, function(d2, v2, l2) {
          var val = v2.toLowerCase();
          if (val === l2.amPm[0]) {
            d2.isPm = false;
          } else if (val === l2.amPm[1]) {
            d2.isPm = true;
          }
        }],
        Z: [/[^\s]*?[+-]\d\d:?\d\d|[^\s]*?Z?/, function(d2, v2) {
          if (v2 === "Z")
            v2 = "+00:00";
          var parts = "".concat(v2).match(/([+-]|\d\d)/gi);
          if (parts) {
            var minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
            d2.timezoneOffset = parts[0] === "+" ? minutes : -minutes;
          }
        }]
      };
      parseFlags.DD = parseFlags.D;
      parseFlags.dd = parseFlags.d;
      parseFlags.WWWW = parseFlags.WWW = parseFlags.WW = parseFlags.W;
      parseFlags.MM = parseFlags.M;
      parseFlags.mm = parseFlags.m;
      parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
      parseFlags.ss = parseFlags.s;
      parseFlags.A = parseFlags.a;
      parseFlags.ZZZZ = parseFlags.ZZZ = parseFlags.ZZ = parseFlags.Z;
      function resolveConfig(config, locales2) {
        var detLocale = new Intl.DateTimeFormat().resolvedOptions().locale;
        var id;
        if (isString_1(config)) {
          id = config;
        } else if (has$1$1(config, "id")) {
          id = config.id;
        }
        id = (id || detLocale).toLowerCase();
        var localeKeys = Object.keys(locales2);
        var validKey = function validKey2(k2) {
          return localeKeys.find(function(lk) {
            return lk.toLowerCase() === k2;
          });
        };
        id = validKey(id) || validKey(id.substring(0, 2)) || detLocale;
        var defLocale = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, locales2["en-IE"]), locales2[id]), {}, {
          id
        });
        config = isObject$1$1(config) ? defaultsDeep_1(config, defLocale) : defLocale;
        return config;
      }
      var Locale = /* @__PURE__ */ function() {
        function Locale2(config) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$locales = _ref.locales, locales$1 = _ref$locales === void 0 ? locales : _ref$locales, timezone = _ref.timezone;
          _classCallCheck(this, Locale2);
          var _resolveConfig = resolveConfig(config, locales$1), id = _resolveConfig.id, firstDayOfWeek = _resolveConfig.firstDayOfWeek, masks2 = _resolveConfig.masks;
          this.id = id;
          this.daysInWeek = daysInWeek;
          this.firstDayOfWeek = clamp_1(firstDayOfWeek, 1, daysInWeek);
          this.masks = masks2;
          this.timezone = timezone || void 0;
          this.dayNames = this.getDayNames("long");
          this.dayNamesShort = this.getDayNames("short");
          this.dayNamesShorter = this.dayNamesShort.map(function(s2) {
            return s2.substring(0, 2);
          });
          this.dayNamesNarrow = this.getDayNames("narrow");
          this.monthNames = this.getMonthNames("long");
          this.monthNamesShort = this.getMonthNames("short");
          this.amPm = ["am", "pm"];
          this.monthData = {};
          this.getMonthComps = this.getMonthComps.bind(this);
          this.parse = this.parse.bind(this);
          this.format = this.format.bind(this);
          this.toPage = this.toPage.bind(this);
        }
        _createClass(Locale2, [{
          key: "format",
          value: function format2(date, mask) {
            var _this = this;
            date = this.normalizeDate(date);
            if (!date)
              return "";
            mask = this.normalizeMasks(mask)[0];
            var literals = [];
            mask = mask.replace(literal, function($0, $1) {
              literals.push($1);
              return "??";
            });
            var timezone = /Z$/.test(mask) ? "utc" : this.timezone;
            var dateParts = this.getDateParts(date, timezone);
            mask = mask.replace(token, function($0) {
              return $0 in formatFlags ? formatFlags[$0](dateParts, _this) : $0.slice(1, $0.length - 1);
            });
            return mask.replace(/\?\?/g, function() {
              return literals.shift();
            });
          }
        }, {
          key: "parse",
          value: function parse2(dateString, mask) {
            var _this2 = this;
            var masks2 = this.normalizeMasks(mask);
            return masks2.map(function(m2) {
              if (typeof m2 !== "string") {
                throw new Error("Invalid mask in fecha.parse");
              }
              var str = dateString;
              if (str.length > 1e3) {
                return false;
              }
              var isValid = true;
              var dateInfo = {};
              m2.replace(token, function($0) {
                if (parseFlags[$0]) {
                  var info = parseFlags[$0];
                  var index2 = str.search(info[0]);
                  if (!~index2) {
                    isValid = false;
                  } else {
                    str.replace(info[0], function(result) {
                      info[1](dateInfo, result, _this2);
                      str = str.substr(index2 + result.length);
                      return result;
                    });
                  }
                }
                return parseFlags[$0] ? "" : $0.slice(1, $0.length - 1);
              });
              if (!isValid) {
                return false;
              }
              var today = new Date();
              if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
                dateInfo.hour = +dateInfo.hour + 12;
              } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
                dateInfo.hour = 0;
              }
              var date;
              if (dateInfo.timezoneOffset != null) {
                dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
                date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
              } else {
                date = _this2.getDateFromParts({
                  year: dateInfo.year || today.getFullYear(),
                  month: (dateInfo.month || 0) + 1,
                  day: dateInfo.day || 1,
                  hours: dateInfo.hour || 0,
                  minutes: dateInfo.minute || 0,
                  seconds: dateInfo.second || 0,
                  milliseconds: dateInfo.millisecond || 0
                });
              }
              return date;
            }).find(function(d2) {
              return d2;
            }) || new Date(dateString);
          }
        }, {
          key: "normalizeMasks",
          value: function normalizeMasks(masks2) {
            var _this3 = this;
            return (arrayHasItems(masks2) && masks2 || [isString_1(masks2) && masks2 || "YYYY-MM-DD"]).map(function(m2) {
              return maskMacros.reduce(function(prev, curr) {
                return prev.replace(curr, _this3.masks[curr] || "");
              }, m2);
            });
          }
        }, {
          key: "normalizeDate",
          value: function normalizeDate(d2) {
            var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var result = null;
            var type = config.type, fillDate = config.fillDate;
            var mask = config.mask, patch = config.patch, time = config.time;
            var auto2 = type === "auto" || !type;
            if (isNumber_1(d2)) {
              type = "number";
              result = new Date(+d2);
            } else if (isString_1(d2)) {
              type = "string";
              result = d2 ? this.parse(d2, mask || "iso") : null;
            } else if (isObject$1$1(d2)) {
              type = "object";
              result = this.getDateFromParts(d2);
            } else {
              type = "date";
              result = isDate$1$1(d2) ? new Date(d2.getTime()) : null;
            }
            if (result && patch) {
              fillDate = fillDate == null ? new Date() : this.normalizeDate(fillDate);
              var parts = _objectSpread2$1(_objectSpread2$1({}, this.getDateParts(fillDate)), pick_1(this.getDateParts(result), PATCH_KEYS[patch]));
              result = this.getDateFromParts(parts);
            }
            if (auto2)
              config.type = type;
            if (result && !isNaN(result.getTime())) {
              if (time) {
                result = this.adjustTimeForDate(result, {
                  timeAdjust: time
                });
              }
              return result;
            }
            return null;
          }
        }, {
          key: "denormalizeDate",
          value: function denormalizeDate(date) {
            var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, type = _ref2.type, mask = _ref2.mask;
            switch (type) {
              case "number":
                return date ? date.getTime() : NaN;
              case "string":
                return date ? this.format(date, mask || "iso") : "";
              default:
                return date ? new Date(date) : null;
            }
          }
        }, {
          key: "adjustTimeForDate",
          value: function adjustTimeForDate(date, _ref3) {
            var timeAdjust = _ref3.timeAdjust;
            if (timeAdjust) {
              var dateParts = this.getDateParts(date);
              if (timeAdjust === "now") {
                var timeParts = this.getDateParts(new Date());
                dateParts.hours = timeParts.hours;
                dateParts.minutes = timeParts.minutes;
                dateParts.seconds = timeParts.seconds;
                dateParts.milliseconds = timeParts.milliseconds;
              } else {
                var d2 = new Date("2000-01-01T".concat(timeAdjust, "Z"));
                dateParts.hours = d2.getUTCHours();
                dateParts.minutes = d2.getUTCMinutes();
                dateParts.seconds = d2.getUTCSeconds();
                dateParts.milliseconds = d2.getUTCMilliseconds();
              }
              date = this.getDateFromParts(dateParts);
            }
            return date;
          }
        }, {
          key: "normalizeDates",
          value: function normalizeDates(dates, opts) {
            opts = opts || {};
            opts.locale = this;
            return (isArrayLikeObject_1(dates) ? dates : [dates]).map(function(d2) {
              return d2 && (d2 instanceof DateInfo ? d2 : new DateInfo(d2, opts));
            }).filter(function(d2) {
              return d2;
            });
          }
        }, {
          key: "getDateParts",
          value: function getDateParts(date) {
            var timezone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.timezone;
            if (!date)
              return null;
            var tzDate = date;
            if (timezone) {
              var normDate = new Date(date.toLocaleString("en-US", {
                timeZone: timezone
              }));
              normDate.setMilliseconds(date.getMilliseconds());
              var diff = normDate.getTime() - date.getTime();
              tzDate = new Date(date.getTime() + diff);
            }
            var milliseconds = tzDate.getMilliseconds();
            var seconds = tzDate.getSeconds();
            var minutes = tzDate.getMinutes();
            var hours = tzDate.getHours();
            var month = tzDate.getMonth() + 1;
            var year = tzDate.getFullYear();
            var comps = this.getMonthComps(month, year);
            var day = tzDate.getDate();
            var dayFromEnd = comps.days - day + 1;
            var weekday = tzDate.getDay() + 1;
            var weekdayOrdinal = Math.floor((day - 1) / 7 + 1);
            var weekdayOrdinalFromEnd = Math.floor((comps.days - day) / 7 + 1);
            var week = Math.ceil((day + Math.abs(comps.firstWeekday - comps.firstDayOfWeek)) / 7);
            var weekFromEnd = comps.weeks - week + 1;
            var parts = {
              milliseconds,
              seconds,
              minutes,
              hours,
              day,
              dayFromEnd,
              weekday,
              weekdayOrdinal,
              weekdayOrdinalFromEnd,
              week,
              weekFromEnd,
              month,
              year,
              date,
              isValid: true
            };
            parts.timezoneOffset = this.getTimezoneOffset(parts);
            return parts;
          }
        }, {
          key: "getDateFromParts",
          value: function getDateFromParts(parts) {
            if (!parts)
              return null;
            var d2 = new Date();
            var _parts$year = parts.year, year = _parts$year === void 0 ? d2.getFullYear() : _parts$year, _parts$month = parts.month, month = _parts$month === void 0 ? d2.getMonth() + 1 : _parts$month, _parts$day = parts.day, day = _parts$day === void 0 ? d2.getDate() : _parts$day, _parts$hours = parts.hours, hrs = _parts$hours === void 0 ? 0 : _parts$hours, _parts$minutes = parts.minutes, min2 = _parts$minutes === void 0 ? 0 : _parts$minutes, _parts$seconds = parts.seconds, sec = _parts$seconds === void 0 ? 0 : _parts$seconds, _parts$milliseconds = parts.milliseconds, ms = _parts$milliseconds === void 0 ? 0 : _parts$milliseconds;
            if (this.timezone) {
              var dateString = "".concat(pad$1(year, 4), "-").concat(pad$1(month, 2), "-").concat(pad$1(day, 2), "T").concat(pad$1(hrs, 2), ":").concat(pad$1(min2, 2), ":").concat(pad$1(sec, 2), ".").concat(pad$1(ms, 3));
              return toDate$1(dateString, {
                timeZone: this.timezone
              });
            }
            return new Date(year, month - 1, day, hrs, min2, sec, ms);
          }
        }, {
          key: "getTimezoneOffset",
          value: function getTimezoneOffset(parts) {
            var y2 = parts.year, m2 = parts.month, d2 = parts.day, _parts$hours2 = parts.hours, hrs = _parts$hours2 === void 0 ? 0 : _parts$hours2, _parts$minutes2 = parts.minutes, min2 = _parts$minutes2 === void 0 ? 0 : _parts$minutes2, _parts$seconds2 = parts.seconds, sec = _parts$seconds2 === void 0 ? 0 : _parts$seconds2, _parts$milliseconds2 = parts.milliseconds, ms = _parts$milliseconds2 === void 0 ? 0 : _parts$milliseconds2;
            var date;
            var utcDate = new Date(Date.UTC(y2, m2 - 1, d2, hrs, min2, sec, ms));
            if (this.timezone) {
              var dateString = "".concat(pad$1(y2, 4), "-").concat(pad$1(m2, 2), "-").concat(pad$1(d2, 2), "T").concat(pad$1(hrs, 2), ":").concat(pad$1(min2, 2), ":").concat(pad$1(sec, 2), ".").concat(pad$1(ms, 3));
              date = toDate$1(dateString, {
                timeZone: this.timezone
              });
            } else {
              date = new Date(y2, m2 - 1, d2, hrs, min2, sec, ms);
            }
            return (date - utcDate) / 6e4;
          }
        }, {
          key: "toPage",
          value: function toPage(arg, fromPage) {
            if (isNumber_1(arg)) {
              return addPages(fromPage, arg);
            }
            if (isString_1(arg)) {
              return this.getDateParts(this.normalizeDate(arg));
            }
            if (isDate$1$1(arg)) {
              return this.getDateParts(arg);
            }
            if (isObject$1$1(arg)) {
              return arg;
            }
            return null;
          }
        }, {
          key: "getMonthDates",
          value: function getMonthDates() {
            var year = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2e3;
            var dates = [];
            for (var i2 = 0; i2 < 12; i2++) {
              dates.push(new Date(year, i2, 15));
            }
            return dates;
          }
        }, {
          key: "getMonthNames",
          value: function getMonthNames(length) {
            var dtf = new Intl.DateTimeFormat(this.id, {
              month: length,
              timezome: "UTC"
            });
            return this.getMonthDates().map(function(d2) {
              return dtf.format(d2);
            });
          }
        }, {
          key: "getWeekdayDates",
          value: function getWeekdayDates() {
            var firstDayOfWeek = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.firstDayOfWeek;
            var dates = [];
            var year = 2020;
            var month = 1;
            var day = 5 + firstDayOfWeek - 1;
            for (var i2 = 0; i2 < daysInWeek; i2++) {
              dates.push(this.getDateFromParts({
                year,
                month,
                day: day + i2,
                hours: 12
              }));
            }
            return dates;
          }
        }, {
          key: "getDayNames",
          value: function getDayNames(length) {
            var dtf = new Intl.DateTimeFormat(this.id, {
              weekday: length,
              timeZone: this.timezone
            });
            return this.getWeekdayDates(1).map(function(d2) {
              return dtf.format(d2);
            });
          }
        }, {
          key: "getMonthComps",
          value: function getMonthComps(month, year) {
            var key = "".concat(month, "-").concat(year);
            var comps = this.monthData[key];
            if (!comps) {
              var inLeapYear = year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
              var firstDayOfMonth = new Date(year, month - 1, 1);
              var firstWeekday = firstDayOfMonth.getDay() + 1;
              var days = month === 2 && inLeapYear ? 29 : daysInMonths[month - 1];
              var weekStartsOn = this.firstDayOfWeek - 1;
              var weeks = getWeeksInMonth(firstDayOfMonth, {
                weekStartsOn
              });
              var weeknumbers = [];
              var isoWeeknumbers = [];
              for (var i2 = 0; i2 < weeks; i2++) {
                var date = addDays(firstDayOfMonth, i2 * 7);
                weeknumbers.push(getWeek(date, {
                  weekStartsOn
                }));
                isoWeeknumbers.push(getISOWeek(date));
              }
              comps = {
                firstDayOfWeek: this.firstDayOfWeek,
                inLeapYear,
                firstWeekday,
                days,
                weeks,
                month,
                year,
                weeknumbers,
                isoWeeknumbers
              };
              this.monthData[key] = comps;
            }
            return comps;
          }
        }, {
          key: "getThisMonthComps",
          value: function getThisMonthComps() {
            var _this$getDateParts = this.getDateParts(new Date()), month = _this$getDateParts.month, year = _this$getDateParts.year;
            return this.getMonthComps(month, year);
          }
        }, {
          key: "getPrevMonthComps",
          value: function getPrevMonthComps(month, year) {
            if (month === 1)
              return this.getMonthComps(12, year - 1);
            return this.getMonthComps(month - 1, year);
          }
        }, {
          key: "getNextMonthComps",
          value: function getNextMonthComps(month, year) {
            if (month === 12)
              return this.getMonthComps(1, year + 1);
            return this.getMonthComps(month + 1, year);
          }
        }, {
          key: "getDayId",
          value: function getDayId(date) {
            return this.format(date, "YYYY-MM-DD");
          }
        }, {
          key: "getCalendarDays",
          value: function getCalendarDays(_ref4) {
            var _this4 = this;
            var weeks = _ref4.weeks, monthComps = _ref4.monthComps, prevMonthComps = _ref4.prevMonthComps, nextMonthComps = _ref4.nextMonthComps;
            var days = [];
            var firstDayOfWeek = monthComps.firstDayOfWeek, firstWeekday = monthComps.firstWeekday, isoWeeknumbers = monthComps.isoWeeknumbers, weeknumbers = monthComps.weeknumbers;
            var prevMonthDaysToShow = firstWeekday + (firstWeekday < firstDayOfWeek ? daysInWeek : 0) - firstDayOfWeek;
            var prevMonth = true;
            var thisMonth = false;
            var nextMonth = false;
            var formatter = new Intl.DateTimeFormat(this.id, {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric"
            });
            var day = prevMonthComps.days - prevMonthDaysToShow + 1;
            var dayFromEnd = prevMonthComps.days - day + 1;
            var weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);
            var weekdayOrdinalFromEnd = 1;
            var week = prevMonthComps.weeks;
            var weekFromEnd = 1;
            var month = prevMonthComps.month;
            var year = prevMonthComps.year;
            var today = new Date();
            var todayDay = today.getDate();
            var todayMonth = today.getMonth() + 1;
            var todayYear = today.getFullYear();
            var dft = function dft2(y2, m2, d2) {
              return function(hours, minutes, seconds, milliseconds) {
                return _this4.normalizeDate({
                  year: y2,
                  month: m2,
                  day: d2,
                  hours,
                  minutes,
                  seconds,
                  milliseconds
                });
              };
            };
            for (var w2 = 1; w2 <= weeks; w2++) {
              for (var i2 = 1, weekday = firstDayOfWeek; i2 <= daysInWeek; i2++, weekday += weekday === daysInWeek ? 1 - daysInWeek : 1) {
                if (prevMonth && weekday === firstWeekday) {
                  day = 1;
                  dayFromEnd = monthComps.days;
                  weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);
                  weekdayOrdinalFromEnd = Math.floor((monthComps.days - day) / daysInWeek + 1);
                  week = 1;
                  weekFromEnd = monthComps.weeks;
                  month = monthComps.month;
                  year = monthComps.year;
                  prevMonth = false;
                  thisMonth = true;
                }
                var dateFromTime = dft(year, month, day);
                var range = {
                  start: dateFromTime(0, 0, 0),
                  end: dateFromTime(23, 59, 59, 999)
                };
                var date = range.start;
                var id = "".concat(pad$1(year, 4), "-").concat(pad$1(month, 2), "-").concat(pad$1(day, 2));
                var weekdayPosition = i2;
                var weekdayPositionFromEnd = daysInWeek - i2;
                var weeknumber = weeknumbers[w2 - 1];
                var isoWeeknumber = isoWeeknumbers[w2 - 1];
                var isToday = day === todayDay && month === todayMonth && year === todayYear;
                var isFirstDay = thisMonth && day === 1;
                var isLastDay = thisMonth && day === monthComps.days;
                var onTop = w2 === 1;
                var onBottom = w2 === weeks;
                var onLeft = i2 === 1;
                var onRight = i2 === daysInWeek;
                days.push({
                  id,
                  label: day.toString(),
                  ariaLabel: formatter.format(new Date(year, month - 1, day)),
                  day,
                  dayFromEnd,
                  weekday,
                  weekdayPosition,
                  weekdayPositionFromEnd,
                  weekdayOrdinal,
                  weekdayOrdinalFromEnd,
                  week,
                  weekFromEnd,
                  weeknumber,
                  isoWeeknumber,
                  month,
                  year,
                  dateFromTime,
                  date,
                  range,
                  isToday,
                  isFirstDay,
                  isLastDay,
                  inMonth: thisMonth,
                  inPrevMonth: prevMonth,
                  inNextMonth: nextMonth,
                  onTop,
                  onBottom,
                  onLeft,
                  onRight,
                  classes: ["id-".concat(id), "day-".concat(day), "day-from-end-".concat(dayFromEnd), "weekday-".concat(weekday), "weekday-position-".concat(weekdayPosition), "weekday-ordinal-".concat(weekdayOrdinal), "weekday-ordinal-from-end-".concat(weekdayOrdinalFromEnd), "week-".concat(week), "week-from-end-".concat(weekFromEnd), {
                    "is-today": isToday,
                    "is-first-day": isFirstDay,
                    "is-last-day": isLastDay,
                    "in-month": thisMonth,
                    "in-prev-month": prevMonth,
                    "in-next-month": nextMonth,
                    "on-top": onTop,
                    "on-bottom": onBottom,
                    "on-left": onLeft,
                    "on-right": onRight
                  }]
                });
                if (thisMonth && isLastDay) {
                  thisMonth = false;
                  nextMonth = true;
                  day = 1;
                  dayFromEnd = nextMonthComps.days;
                  weekdayOrdinal = 1;
                  weekdayOrdinalFromEnd = Math.floor((nextMonthComps.days - day) / daysInWeek + 1);
                  week = 1;
                  weekFromEnd = nextMonthComps.weeks;
                  month = nextMonthComps.month;
                  year = nextMonthComps.year;
                } else {
                  day++;
                  dayFromEnd--;
                  weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);
                  weekdayOrdinalFromEnd = Math.floor((monthComps.days - day) / daysInWeek + 1);
                }
              }
              week++;
              weekFromEnd--;
            }
            return days;
          }
        }]);
        return Locale2;
      }();
      var Attribute = /* @__PURE__ */ function() {
        function Attribute2(_ref, theme, locale) {
          var key = _ref.key, hashcode = _ref.hashcode, highlight = _ref.highlight, content = _ref.content, dot = _ref.dot, bar = _ref.bar, popover = _ref.popover, dates = _ref.dates, excludeDates = _ref.excludeDates, excludeMode = _ref.excludeMode, customData = _ref.customData, order2 = _ref.order, pinPage = _ref.pinPage;
          _classCallCheck(this, Attribute2);
          this.key = isUndefined_1(key) ? createGuid() : key;
          this.hashcode = hashcode;
          this.customData = customData;
          this.order = order2 || 0;
          this.dateOpts = {
            order: order2,
            locale
          };
          this.pinPage = pinPage;
          if (highlight) {
            this.highlight = theme.normalizeHighlight(highlight);
          }
          if (content) {
            this.content = theme.normalizeContent(content);
          }
          if (dot) {
            this.dot = theme.normalizeDot(dot);
          }
          if (bar) {
            this.bar = theme.normalizeBar(bar);
          }
          if (popover) {
            this.popover = popover;
          }
          this.dates = locale.normalizeDates(dates, this.dateOpts);
          this.hasDates = !!arrayHasItems(this.dates);
          this.excludeDates = locale.normalizeDates(excludeDates, this.dateOpts);
          this.hasExcludeDates = !!arrayHasItems(this.excludeDates);
          this.excludeMode = excludeMode || "intersects";
          if (this.hasExcludeDates && !this.hasDates) {
            this.dates.push(new DateInfo({}, this.dateOpts));
            this.hasDates = true;
          }
          this.isComplex = some$1(this.dates, function(d2) {
            return d2.isComplex;
          });
        }
        _createClass(Attribute2, [{
          key: "intersectsDate",
          value: function intersectsDate(date) {
            date = date instanceof DateInfo ? date : new DateInfo(date, this.dateOpts);
            return !this.excludesDate(date) && (this.dates.find(function(d2) {
              return d2.intersectsDate(date);
            }) || false);
          }
        }, {
          key: "includesDate",
          value: function includesDate(date) {
            date = date instanceof DateInfo ? date : new DateInfo(date, this.dateOpts);
            return !this.excludesDate(date) && (this.dates.find(function(d2) {
              return d2.includesDate(date);
            }) || false);
          }
        }, {
          key: "excludesDate",
          value: function excludesDate(date) {
            var _this = this;
            date = date instanceof DateInfo ? date : new DateInfo(date, this.dateOpts);
            return this.hasExcludeDates && this.excludeDates.find(function(ed) {
              return _this.excludeMode === "intersects" && ed.intersectsDate(date) || _this.excludeMode === "includes" && ed.includesDate(date);
            });
          }
        }, {
          key: "intersectsDay",
          value: function intersectsDay(day) {
            return !this.excludesDay(day) && (this.dates.find(function(d2) {
              return d2.intersectsDay(day);
            }) || false);
          }
        }, {
          key: "excludesDay",
          value: function excludesDay(day) {
            return this.hasExcludeDates && this.excludeDates.find(function(ed) {
              return ed.intersectsDay(day);
            });
          }
        }]);
        return Attribute2;
      }();
      var maxSwipeTime = 300;
      var minHorizontalSwipeDistance = 60;
      var maxVerticalSwipeDistance = 80;
      var touch = {
        maxSwipeTime,
        minHorizontalSwipeDistance,
        maxVerticalSwipeDistance
      };
      var title = "MMMM YYYY";
      var weekdays = "W";
      var navMonths = "MMM";
      var input = [
        "L",
        "YYYY-MM-DD",
        "YYYY/MM/DD"
      ];
      var inputDateTime = [
        "L h:mm A",
        "YYYY-MM-DD h:mm A",
        "YYYY/MM/DD h:mm A"
      ];
      var inputDateTime24hr = [
        "L HH:mm",
        "YYYY-MM-DD HH:mm",
        "YYYY/MM/DD HH:mm"
      ];
      var inputTime = [
        "h:mm A"
      ];
      var inputTime24hr = [
        "HH:mm"
      ];
      var dayPopover = "WWW, MMM D, YYYY";
      var data$1 = [
        "L",
        "YYYY-MM-DD",
        "YYYY/MM/DD"
      ];
      var model = "iso";
      var iso = "YYYY-MM-DDTHH:mm:ssXXX";
      var masks = {
        title,
        weekdays,
        navMonths,
        input,
        inputDateTime,
        inputDateTime24hr,
        inputTime,
        inputTime24hr,
        dayPopover,
        data: data$1,
        model,
        iso
      };
      var sm = "640px";
      var md = "768px";
      var lg = "1024px";
      var xl = "1280px";
      var defaultScreens = {
        sm,
        md,
        lg,
        xl
      };
      const defaultConfig = {
        componentPrefix: "v",
        color: "blue",
        isDark: false,
        navVisibility: "click",
        titlePosition: "center",
        transition: "slide-h",
        touch,
        masks,
        screens: defaultScreens,
        locales,
        datePicker: {
          updateOnInput: true,
          inputDebounce: 1e3,
          popover: {
            visibility: "hover-focus",
            placement: "bottom-start",
            keepVisibleOnInput: false,
            isInteractive: true
          }
        }
      };
      const state = reactive(defaultConfig);
      const computedLocales = computed(() => {
        return mapValues_1(state.locales, (v2) => {
          v2.masks = defaultsDeep_1(v2.masks, state.masks);
          return v2;
        });
      });
      const getDefault = (path) => {
        if (window && has$1$1(window.__vcalendar__, path)) {
          return get_1(window.__vcalendar__, path);
        }
        return get_1(state, path);
      };
      const setup$1 = (userDefaults) => {
        return defaultsDeep_1(state, userDefaults);
      };
      var rootMixin = {
        props: {
          color: {
            type: String,
            default: getDefault("color")
          },
          isDark: {
            type: Boolean,
            default: getDefault("isDark")
          },
          firstDayOfWeek: Number,
          masks: Object,
          locale: [String, Object],
          timezone: String,
          minDate: null,
          maxDate: null,
          minDateExact: null,
          maxDateExact: null,
          disabledDates: null,
          availableDates: null,
          theme: null
        },
        computed: {
          $theme: function $theme() {
            if (this.theme instanceof Theme)
              return this.theme;
            return new Theme({
              color: this.color,
              isDark: this.isDark
            });
          },
          $locale: function $locale() {
            if (this.locale instanceof Locale)
              return this.locale;
            var config = isObject$1$1(this.locale) ? this.locale : {
              id: this.locale,
              firstDayOfWeek: this.firstDayOfWeek,
              masks: this.masks
            };
            return new Locale(config, {
              locales: computedLocales.value,
              timezone: this.timezone
            });
          },
          disabledDates_: function disabledDates_() {
            var dates = this.normalizeDates(this.disabledDates);
            var minDate = this.minDate, minDateExact = this.minDateExact, maxDate = this.maxDate, maxDateExact = this.maxDateExact;
            if (minDateExact || minDate) {
              var end2 = minDateExact ? this.normalizeDate(minDateExact) : this.normalizeDate(minDate, {
                time: "00:00:00"
              });
              dates.push({
                start: null,
                end: new Date(end2.getTime() - 1e3)
              });
            }
            if (maxDateExact || maxDate) {
              var start2 = maxDateExact ? this.normalizeDate(maxDateExact) : this.normalizeDate(maxDate, {
                time: "23:59:59"
              });
              dates.push({
                start: new Date(start2.getTime() + 1e3),
                end: null
              });
            }
            return dates;
          },
          availableDates_: function availableDates_() {
            return this.normalizeDates(this.availableDates);
          },
          disabledAttribute: function disabledAttribute() {
            return new Attribute({
              key: "disabled",
              dates: this.disabledDates_,
              excludeDates: this.availableDates_,
              excludeMode: "includes",
              order: 100
            }, this.$theme, this.$locale);
          }
        },
        methods: {
          formatDate: function formatDate(date, mask) {
            return this.$locale ? this.$locale.format(date, mask) : "";
          },
          parseDate: function parseDate2(text, mask) {
            if (!this.$locale)
              return null;
            var value = this.$locale.parse(text, mask);
            return isDate$1$1(value) ? value : null;
          },
          normalizeDate: function normalizeDate(date, config) {
            return this.$locale ? this.$locale.normalizeDate(date, config) : date;
          },
          normalizeDates: function normalizeDates(dates) {
            return this.$locale.normalizeDates(dates, {
              isFullDay: true
            });
          },
          pageForDate: function pageForDate(date) {
            return this.$locale.getDateParts(this.normalizeDate(date));
          },
          pageForThisMonth: function pageForThisMonth() {
            return this.pageForDate(new Date());
          }
        }
      };
      var slotMixin = {
        methods: {
          safeSlot: function safeSlot(name, args) {
            var def = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            return isFunction_1(this.$slots[name]) ? this.$slots[name](args) : def;
          }
        }
      };
      var childMixin$1 = childMixin;
      var rootMixin$1 = rootMixin;
      var slotMixin$1 = slotMixin;
      function styleInject(css2, ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var insertAt = ref2.insertAt;
        if (!css2 || typeof document === "undefined") {
          return;
        }
        var head2 = document.head || document.getElementsByTagName("head")[0];
        var style2 = document.createElement("style");
        style2.type = "text/css";
        if (insertAt === "top") {
          if (head2.firstChild) {
            head2.insertBefore(style2, head2.firstChild);
          } else {
            head2.appendChild(style2);
          }
        } else {
          head2.appendChild(style2);
        }
        if (style2.styleSheet) {
          style2.styleSheet.cssText = css2;
        } else {
          style2.appendChild(document.createTextNode(css2));
        }
      }
      function showPopover(opts) {
        if (document) {
          document.dispatchEvent(new CustomEvent("show-popover", {
            detail: opts
          }));
        }
      }
      function hidePopover(opts) {
        if (document) {
          document.dispatchEvent(new CustomEvent("hide-popover", {
            detail: opts
          }));
        }
      }
      function togglePopover(opts) {
        if (document) {
          document.dispatchEvent(new CustomEvent("toggle-popover", {
            detail: opts
          }));
        }
      }
      function updatePopover(opts) {
        if (document) {
          document.dispatchEvent(new CustomEvent("update-popover", {
            detail: opts
          }));
        }
      }
      function getPopoverTriggerEvents(opts) {
        var _ref;
        var visibility = opts.visibility;
        var click = visibility === "click";
        var hover = visibility === "hover";
        var hoverFocus = visibility === "hover-focus";
        var focus = visibility === "focus";
        opts.autoHide = !click;
        var hovered = false;
        var focused = false;
        var isRenderFn = opts.isRenderFn;
        var events2 = {
          click: isRenderFn ? "onClick" : "click",
          mousemove: isRenderFn ? "onMousemove" : "mousemove",
          mouseleave: isRenderFn ? "onMouseleave" : "mouseleave",
          focusin: isRenderFn ? "onFocusin" : "focusin",
          focusout: isRenderFn ? "onFocusout" : "focusout"
        };
        return _ref = {}, _defineProperty$1(_ref, events2.click, function(e2) {
          if (click) {
            opts.ref = e2.target;
            togglePopover(opts);
            e2.stopPropagation();
          }
        }), _defineProperty$1(_ref, events2.mousemove, function(e2) {
          opts.ref = e2.currentTarget;
          if (!hovered) {
            hovered = true;
            if (hover || hoverFocus) {
              showPopover(opts);
            }
          }
        }), _defineProperty$1(_ref, events2.mouseleave, function(e2) {
          opts.ref = e2.target;
          if (hovered) {
            hovered = false;
            if (hover || hoverFocus && !focused) {
              hidePopover(opts);
            }
          }
        }), _defineProperty$1(_ref, events2.focusin, function(e2) {
          opts.ref = e2.currentTarget;
          if (!focused) {
            focused = true;
            if (focus || hoverFocus) {
              showPopover(opts);
            }
          }
        }), _defineProperty$1(_ref, events2.focusout, function(e2) {
          opts.ref = e2.currentTarget;
          if (focused && !elementContains(opts.ref, e2.relatedTarget)) {
            focused = false;
            if (focus || hoverFocus && !hovered) {
              hidePopover(opts);
            }
          }
        }), _ref;
      }
      var script$a = {
        name: "CalendarDay",
        emits: ["dayclick", "daymouseenter", "daymouseleave", "dayfocusin", "dayfocusout", "daykeydown"],
        mixins: [childMixin$1, slotMixin$1],
        inheritAttrs: false,
        render: function render11() {
          var _this = this;
          var backgroundsLayer = function backgroundsLayer2() {
            return _this.hasBackgrounds && h$5("div", {
              class: "vc-highlights vc-day-layer"
            }, _this.backgrounds.map(function(_ref) {
              var key = _ref.key, wrapperClass = _ref.wrapperClass, bgClass = _ref.class, style2 = _ref.style;
              return h$5("div", {
                key,
                class: wrapperClass
              }, [h$5("div", {
                class: bgClass,
                style: style2
              })]);
            }));
          };
          var contentLayer = function contentLayer2() {
            return _this.safeSlot("day-content", {
              day: _this.day,
              attributes: _this.day.attributes,
              attributesMap: _this.day.attributesMap,
              dayProps: _this.dayContentProps,
              dayEvents: _this.dayContentEvents
            }) || h$5("span", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.dayContentProps), {}, {
              class: _this.dayContentClass,
              style: _this.dayContentStyle
            }, _this.dayContentEvents), {}, {
              ref: "content"
            }), [_this.day.label]);
          };
          var dotsLayer = function dotsLayer2() {
            return _this.hasDots && h$5("div", {
              class: "vc-day-layer vc-day-box-center-bottom"
            }, [h$5("div", {
              class: "vc-dots"
            }, _this.dots.map(function(_ref2) {
              var key = _ref2.key, bgClass = _ref2.class, style2 = _ref2.style;
              return h$5("span", {
                key,
                class: bgClass,
                style: style2
              });
            }))]);
          };
          var barsLayer = function barsLayer2() {
            return _this.hasBars && h$5("div", {
              class: "vc-day-layer vc-day-box-center-bottom"
            }, [h$5("div", {
              class: "vc-bars"
            }, _this.bars.map(function(_ref3) {
              var key = _ref3.key, bgClass = _ref3.class, style2 = _ref3.style;
              return h$5("span", {
                key,
                class: bgClass,
                style: style2
              });
            }))]);
          };
          return h$5("div", {
            class: ["vc-day"].concat(_toConsumableArray(this.day.classes), [{
              "vc-day-box-center-center": !this.$slots["day-content"]
            }, {
              "is-not-in-month": !this.inMonth
            }])
          }, [backgroundsLayer(), contentLayer(), dotsLayer(), barsLayer()]);
        },
        inject: ["sharedState"],
        props: {
          day: {
            type: Object,
            required: true
          }
        },
        data: function data2() {
          return {
            glyphs: {},
            dayContentEvents: {}
          };
        },
        computed: {
          label: function label() {
            return this.day.label;
          },
          startTime: function startTime() {
            return this.day.range.start.getTime();
          },
          endTime: function endTime() {
            return this.day.range.end.getTime();
          },
          inMonth: function inMonth() {
            return this.day.inMonth;
          },
          isDisabled: function isDisabled() {
            return this.day.isDisabled;
          },
          backgrounds: function backgrounds() {
            return this.glyphs.backgrounds;
          },
          hasBackgrounds: function hasBackgrounds() {
            return !!arrayHasItems(this.backgrounds);
          },
          content: function content() {
            return this.glyphs.content;
          },
          dots: function dots() {
            return this.glyphs.dots;
          },
          hasDots: function hasDots() {
            return !!arrayHasItems(this.dots);
          },
          bars: function bars() {
            return this.glyphs.bars;
          },
          hasBars: function hasBars() {
            return !!arrayHasItems(this.bars);
          },
          popovers: function popovers() {
            return this.glyphs.popovers;
          },
          hasPopovers: function hasPopovers() {
            return !!arrayHasItems(this.popovers);
          },
          dayContentClass: function dayContentClass() {
            return ["vc-day-content vc-focusable", {
              "is-disabled": this.isDisabled
            }, get_1(last_1(this.content), "class") || ""];
          },
          dayContentStyle: function dayContentStyle() {
            return get_1(last_1(this.content), "style");
          },
          dayContentProps: function dayContentProps() {
            var tabindex;
            if (this.day.isFocusable) {
              tabindex = "0";
            } else if (this.day.inMonth) {
              tabindex = "-1";
            }
            return {
              tabindex,
              "aria-label": this.day.ariaLabel,
              "aria-disabled": this.day.isDisabled ? "true" : "false",
              role: "button"
            };
          },
          dayEvent: function dayEvent() {
            return _objectSpread2$1(_objectSpread2$1({}, this.day), {}, {
              el: this.$refs.content,
              popovers: this.popovers
            });
          }
        },
        watch: {
          theme: function theme() {
            this.refresh();
          },
          popovers: function popovers() {
            this.refreshPopovers();
          },
          "day.shouldRefresh": function dayShouldRefresh() {
            this.refresh();
          }
        },
        mounted: function mounted() {
          this.refreshPopovers();
          this.refresh();
        },
        methods: {
          getDayEvent: function getDayEvent(origEvent) {
            return _objectSpread2$1(_objectSpread2$1({}, this.dayEvent), {}, {
              event: origEvent
            });
          },
          click: function click(e2) {
            this.$emit("dayclick", this.getDayEvent(e2));
          },
          mouseenter: function mouseenter(e2) {
            this.$emit("daymouseenter", this.getDayEvent(e2));
          },
          mouseleave: function mouseleave(e2) {
            this.$emit("daymouseleave", this.getDayEvent(e2));
          },
          focusin: function focusin(e2) {
            this.$emit("dayfocusin", this.getDayEvent(e2));
          },
          focusout: function focusout(e2) {
            this.$emit("dayfocusout", this.getDayEvent(e2));
          },
          keydown: function keydown(e2) {
            this.$emit("daykeydown", this.getDayEvent(e2));
          },
          refresh: function refresh() {
            var _this2 = this;
            if (!this.day.shouldRefresh)
              return;
            this.day.shouldRefresh = false;
            var glyphs = {
              backgrounds: [],
              dots: [],
              bars: [],
              popovers: [],
              content: []
            };
            this.day.attributes = Object.values(this.day.attributesMap || {}).sort(function(a2, b2) {
              return a2.order - b2.order;
            });
            this.day.attributes.forEach(function(attr) {
              var targetDate = attr.targetDate;
              var isDate2 = targetDate.isDate, isComplex = targetDate.isComplex, startTime = targetDate.startTime, endTime = targetDate.endTime;
              var onStart = _this2.startTime <= startTime;
              var onEnd = _this2.endTime >= endTime;
              var onStartAndEnd = onStart && onEnd;
              var onStartOrEnd = onStart || onEnd;
              var dateInfo = {
                isDate: isDate2,
                isComplex,
                onStart,
                onEnd,
                onStartAndEnd,
                onStartOrEnd
              };
              _this2.processHighlight(attr, dateInfo, glyphs);
              _this2.processNonHighlight(attr, "content", dateInfo, glyphs.content);
              _this2.processNonHighlight(attr, "dot", dateInfo, glyphs.dots);
              _this2.processNonHighlight(attr, "bar", dateInfo, glyphs.bars);
              _this2.processPopover(attr, glyphs);
            });
            this.glyphs = glyphs;
          },
          processHighlight: function processHighlight(_ref4, _ref5, _ref6) {
            var key = _ref4.key, highlight = _ref4.highlight;
            var isDate2 = _ref5.isDate, isComplex = _ref5.isComplex, onStart = _ref5.onStart, onEnd = _ref5.onEnd, onStartAndEnd = _ref5.onStartAndEnd;
            var backgrounds = _ref6.backgrounds, content = _ref6.content;
            if (!highlight)
              return;
            var base = highlight.base, start2 = highlight.start, end2 = highlight.end;
            if (isDate2 || isComplex) {
              backgrounds.push({
                key,
                wrapperClass: "vc-day-layer vc-day-box-center-center",
                class: ["vc-highlight", start2.class],
                style: start2.style
              });
              content.push({
                key: "".concat(key, "-content"),
                class: start2.contentClass,
                style: start2.contentStyle
              });
            } else if (onStartAndEnd) {
              backgrounds.push({
                key,
                wrapperClass: "vc-day-layer vc-day-box-center-center",
                class: ["vc-highlight", start2.class],
                style: start2.style
              });
              content.push({
                key: "".concat(key, "-content"),
                class: start2.contentClass,
                style: start2.contentStyle
              });
            } else if (onStart) {
              backgrounds.push({
                key: "".concat(key, "-base"),
                wrapperClass: "vc-day-layer vc-day-box-right-center",
                class: ["vc-highlight vc-highlight-base-start", base.class],
                style: base.style
              });
              backgrounds.push({
                key,
                wrapperClass: "vc-day-layer vc-day-box-center-center",
                class: ["vc-highlight", start2.class],
                style: start2.style
              });
              content.push({
                key: "".concat(key, "-content"),
                class: start2.contentClass,
                style: start2.contentStyle
              });
            } else if (onEnd) {
              backgrounds.push({
                key: "".concat(key, "-base"),
                wrapperClass: "vc-day-layer vc-day-box-left-center",
                class: ["vc-highlight vc-highlight-base-end", base.class],
                style: base.style
              });
              backgrounds.push({
                key,
                wrapperClass: "vc-day-layer vc-day-box-center-center",
                class: ["vc-highlight", end2.class],
                style: end2.style
              });
              content.push({
                key: "".concat(key, "-content"),
                class: end2.contentClass,
                style: end2.contentStyle
              });
            } else {
              backgrounds.push({
                key: "".concat(key, "-middle"),
                wrapperClass: "vc-day-layer vc-day-box-center-center",
                class: ["vc-highlight vc-highlight-base-middle", base.class],
                style: base.style
              });
              content.push({
                key: "".concat(key, "-content"),
                class: base.contentClass,
                style: base.contentStyle
              });
            }
          },
          processNonHighlight: function processNonHighlight(attr, itemKey, _ref7, list) {
            var isDate2 = _ref7.isDate, onStart = _ref7.onStart, onEnd = _ref7.onEnd;
            if (!attr[itemKey])
              return;
            var key = attr.key;
            var className = "vc-".concat(itemKey);
            var _attr$itemKey = attr[itemKey], base = _attr$itemKey.base, start2 = _attr$itemKey.start, end2 = _attr$itemKey.end;
            if (isDate2 || onStart) {
              list.push({
                key,
                class: [className, start2.class],
                style: start2.style
              });
            } else if (onEnd) {
              list.push({
                key,
                class: [className, end2.class],
                style: end2.style
              });
            } else {
              list.push({
                key,
                class: [className, base.class],
                style: base.style
              });
            }
          },
          processPopover: function processPopover(attribute, _ref8) {
            var popovers = _ref8.popovers;
            var key = attribute.key, customData = attribute.customData, popover = attribute.popover;
            if (!popover)
              return;
            var resolvedPopover = defaults_1$1({
              key,
              customData,
              attribute
            }, _objectSpread2$1({}, popover), {
              visibility: popover.label ? "hover" : "click",
              placement: "bottom",
              isInteractive: !popover.label
            });
            popovers.splice(0, 0, resolvedPopover);
          },
          refreshPopovers: function refreshPopovers() {
            var popoverEvents = {};
            if (arrayHasItems(this.popovers)) {
              popoverEvents = getPopoverTriggerEvents(defaults_1$1.apply(void 0, [{
                id: this.dayPopoverId,
                data: this.day,
                isRenderFn: true
              }].concat(_toConsumableArray(this.popovers))));
            }
            this.dayContentEvents = mergeEvents({
              onClick: this.click,
              onMouseenter: this.mouseenter,
              onMouseleave: this.mouseleave,
              onFocusin: this.focusin,
              onFocusout: this.focusout,
              onKeydown: this.keydown
            }, popoverEvents);
            updatePopover({
              id: this.dayPopoverId,
              data: this.day
            });
          }
        }
      };
      var css_248z$9 = ".vc-day {\n  position: relative;\n  min-height: 32px;\n  z-index: 1;\n}\n.vc-day.is-not-in-month * {\n    opacity: 0;\n    pointer-events: none;\n}\n.vc-day-layer {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n}\n.vc-day-box-center-center {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-transform-origin: 50% 50%;\n          transform-origin: 50% 50%;\n}\n.vc-day-box-left-center {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: flex-start;\n      -ms-flex-pack: start;\n          justify-content: flex-start;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-transform-origin: 0% 50%;\n          transform-origin: 0% 50%;\n}\n.vc-day-box-right-center {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: flex-end;\n      -ms-flex-pack: end;\n          justify-content: flex-end;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-transform-origin: 100% 50%;\n          transform-origin: 100% 50%;\n}\n.vc-day-box-center-bottom {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: flex-end;\n      -ms-flex-align: end;\n          align-items: flex-end;\n}\n.vc-day-content {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  width: 28px;\n  height: 28px;\n  line-height: 28px;\n  border-radius: var(--rounded-full);\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  cursor: pointer;\n}\n.vc-day-content:hover {\n    background-color: hsla(211, 25%, 84%, 0.3);\n}\n.vc-day-content:focus {\n    font-weight: var(--font-bold);\n    background-color: hsla(211, 25%, 84%, 0.4);\n}\n.vc-day-content.is-disabled {\n    color: var(--gray-400);\n}\n.vc-is-dark .vc-day-content:hover {\n      background-color: hsla(216, 15%, 52%, 0.3);\n}\n.vc-is-dark .vc-day-content:focus {\n      background-color: hsla(216, 15%, 52%, 0.4);\n}\n.vc-is-dark .vc-day-content.is-disabled {\n      color: var(--gray-600);\n}\n.vc-highlights {\n  overflow: hidden;\n  pointer-events: none;\n  z-index: -1;\n}\n.vc-highlight {\n  width: 28px;\n  height: 28px;\n}\n.vc-highlight.vc-highlight-base-start {\n    width: 50% !important;\n    border-radius: 0 !important;\n    border-right-width: 0 !important;\n}\n.vc-highlight.vc-highlight-base-end {\n    width: 50% !important;\n    border-radius: 0 !important;\n    border-left-width: 0 !important;\n}\n.vc-highlight.vc-highlight-base-middle {\n    width: 100%;\n    border-radius: 0 !important;\n    border-left-width: 0 !important;\n    border-right-width: 0 !important;\n    margin: 0 -1px;\n}\n.vc-dots {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n.vc-dot {\n  width: 5px;\n  height: 5px;\n  border-radius: 50%;\n  transition: all var(--day-content-transition-time);\n}\n.vc-dot:not(:last-child) {\n    margin-right: 3px;\n}\n.vc-bars {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: flex-start;\n      -ms-flex-pack: start;\n          justify-content: flex-start;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  width: 75%;\n}\n.vc-bar {\n  -webkit-flex-grow: 1;\n      -ms-flex-positive: 1;\n          flex-grow: 1;\n  height: 3px;\n  transition: all var(--day-content-transition-time);\n}\n";
      styleInject(css_248z$9);
      var boolTag$1 = "[object Boolean]";
      function isBoolean$1(value) {
        return value === true || value === false || isObjectLike_1(value) && _baseGetTag(value) == boolTag$1;
      }
      var isBoolean_1 = isBoolean$1;
      var script$9 = {
        name: "CalendarPane",
        emits: ["update:page", "weeknumberclick"],
        mixins: [childMixin$1, slotMixin$1],
        inheritAttrs: false,
        render: function render11() {
          var _this = this;
          var header = this.safeSlot("header", this.page) || h$5("div", {
            class: "vc-header align-".concat(this.titlePosition)
          }, [
            h$5("div", _objectSpread2$1({
              class: "vc-title"
            }, this.navPopoverEvents), [this.safeSlot("header-title", this.page, this.page.title)])
          ]);
          var weekdayCells = this.weekdayLabels.map(function(wl, i2) {
            return h$5("div", {
              key: i2 + 1,
              class: "vc-weekday"
            }, [wl]);
          });
          var showWeeknumbersLeft = this.showWeeknumbers_.startsWith("left");
          var showWeeknumbersRight = this.showWeeknumbers_.startsWith("right");
          if (showWeeknumbersLeft) {
            weekdayCells.unshift(h$5("div", {
              class: "vc-weekday"
            }));
          } else if (showWeeknumbersRight) {
            weekdayCells.push(h$5("div", {
              class: "vc-weekday"
            }));
          }
          var getWeeknumberCell = function getWeeknumberCell2(weeknumber) {
            return h$5("div", {
              class: ["vc-weeknumber"]
            }, [h$5("span", {
              class: ["vc-weeknumber-content", "is-".concat(_this.showWeeknumbers_)],
              onClick: function onClick(event) {
                _this.$emit("weeknumberclick", {
                  weeknumber,
                  days: _this.page.days.filter(function(d2) {
                    return d2[_this.weeknumberKey] === weeknumber;
                  }),
                  event
                });
              }
            }, [weeknumber])]);
          };
          var dayCells = [];
          var daysInWeek2 = this.locale.daysInWeek;
          this.page.days.forEach(function(day, i2) {
            var mod = i2 % daysInWeek2;
            if (showWeeknumbersLeft && mod === 0 || showWeeknumbersRight && mod === daysInWeek2) {
              dayCells.push(getWeeknumberCell(day[_this.weeknumberKey]));
            }
            dayCells.push(h$5(script$a, _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
              day
            }), _this.$slots));
            if (showWeeknumbersRight && mod === daysInWeek2 - 1) {
              dayCells.push(getWeeknumberCell(day[_this.weeknumberKey]));
            }
          });
          var weeks = h$5("div", {
            class: {
              "vc-weeks": true,
              "vc-show-weeknumbers": this.showWeeknumbers_,
              "is-left": showWeeknumbersLeft,
              "is-right": showWeeknumbersRight
            }
          }, [weekdayCells, dayCells]);
          return h$5("div", {
            class: ["vc-pane", "row-from-end-".concat(this.rowFromEnd), "column-from-end-".concat(this.columnFromEnd)],
            ref: "pane"
          }, [header, weeks]);
        },
        props: {
          page: Object,
          position: Number,
          row: Number,
          rowFromEnd: Number,
          column: Number,
          columnFromEnd: Number,
          titlePosition: String,
          navVisibility: {
            type: String,
            default: getDefault("navVisibility")
          },
          showWeeknumbers: [Boolean, String],
          showIsoWeeknumbers: [Boolean, String]
        },
        computed: {
          weeknumberKey: function weeknumberKey() {
            return this.showWeeknumbers ? "weeknumber" : "isoWeeknumber";
          },
          showWeeknumbers_: function showWeeknumbers_() {
            var showWeeknumbers = this.showWeeknumbers || this.showIsoWeeknumbers;
            if (showWeeknumbers == null)
              return "";
            if (isBoolean_1(showWeeknumbers)) {
              return showWeeknumbers ? "left" : "";
            }
            if (showWeeknumbers.startsWith("right")) {
              return this.columnFromEnd > 1 ? "right" : showWeeknumbers;
            }
            return this.column > 1 ? "left" : showWeeknumbers;
          },
          navPlacement: function navPlacement() {
            switch (this.titlePosition) {
              case "left":
                return "bottom-start";
              case "right":
                return "bottom-end";
              default:
                return "bottom";
            }
          },
          navPopoverEvents: function navPopoverEvents() {
            var sharedState = this.sharedState, navVisibility = this.navVisibility, navPlacement = this.navPlacement, page = this.page, position = this.position;
            return getPopoverTriggerEvents({
              id: sharedState.navPopoverId,
              visibility: navVisibility,
              placement: navPlacement,
              modifiers: [{
                name: "flip",
                options: {
                  fallbackPlacements: ["bottom"]
                }
              }],
              data: {
                page,
                position
              },
              isInteractive: true,
              isRenderFn: true
            });
          },
          weekdayLabels: function weekdayLabels() {
            var _this2 = this;
            return this.locale.getWeekdayDates().map(function(d2) {
              return _this2.format(d2, _this2.masks.weekdays);
            });
          }
        }
      };
      var css_248z$8 = ".vc-pane {\n  min-width: 250px;\n}\n.vc-header {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  padding: 10px 16px 0px 16px;\n}\n.vc-header.align-left {\n    -webkit-justify-content: flex-start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n}\n.vc-header.align-right {\n    -webkit-justify-content: flex-end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n}\n.vc-title {\n  font-size: var(--text-lg);\n  color: var(--gray-800);\n  font-weight: var(--font-semibold);\n  line-height: 28px;\n  cursor: pointer;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  white-space: nowrap;\n}\n.vc-title:hover {\n    opacity: 0.75;\n}\n.vc-weeknumber {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  position: relative;\n}\n.vc-weeknumber-content {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  font-style: italic;\n  width: 28px;\n  height: 28px;\n  margin-top: 2px;\n  color: var(--gray-500);\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-weeknumber-content.is-left-outside {\n    position: absolute;\n    left: var(--weeknumber-offset);\n}\n.vc-weeknumber-content.is-right-outside {\n    position: absolute;\n    right: var(--weeknumber-offset);\n}\n.vc-weeks {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  position: relative;\n  /* overflow: auto; */\n  -webkit-overflow-scrolling: touch;\n  padding: 6px;\n  min-width: 250px;\n}\n.vc-weeks.vc-show-weeknumbers {\n    grid-template-columns: auto repeat(7, 1fr);\n}\n.vc-weeks.vc-show-weeknumbers.is-right {\n      grid-template-columns: repeat(7, 1fr) auto;\n}\n.vc-weekday {\n  text-align: center;\n  color: var(--gray-500);\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  line-height: 14px;\n  padding-top: 4px;\n  padding-bottom: 8px;\n  cursor: default;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-weekdays {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.vc-nav-popover-container {\n  color: var(--white);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  background-color: var(--gray-800);\n  border: 1px solid;\n  border-color: var(--gray-700);\n  border-radius: var(--rounded-lg);\n  padding: 4px;\n  box-shadow: var(--shadow);\n}\n.vc-is-dark .vc-header {\n    color: var(--gray-200);\n}\n.vc-is-dark .vc-title {\n    color: var(--gray-100);\n}\n.vc-is-dark .vc-weekday {\n    color: var(--accent-200);\n}\n.vc-is-dark .vc-nav-popover-container {\n    color: var(--gray-800);\n    background-color: var(--white);\n    border-color: var(--gray-100);\n}\n";
      styleInject(css_248z$8);
      var _defSize = "26px";
      var _defViewBox = "0 0 32 32";
      var icons = {
        "left-arrow": {
          viewBox: "0 -1 16 34",
          path: "M11.196 10c0 0.143-0.071 0.304-0.179 0.411l-7.018 7.018 7.018 7.018c0.107 0.107 0.179 0.268 0.179 0.411s-0.071 0.304-0.179 0.411l-0.893 0.893c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-8.321-8.321c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l8.321-8.321c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l0.893 0.893c0.107 0.107 0.179 0.25 0.179 0.411z"
        },
        "right-arrow": {
          viewBox: "-5 -1 16 34",
          path: "M10.625 17.429c0 0.143-0.071 0.304-0.179 0.411l-8.321 8.321c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-0.893-0.893c-0.107-0.107-0.179-0.25-0.179-0.411 0-0.143 0.071-0.304 0.179-0.411l7.018-7.018-7.018-7.018c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l0.893-0.893c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l8.321 8.321c0.107 0.107 0.179 0.268 0.179 0.411z"
        }
      };
      var script$8 = {
        props: ["name"],
        data: function data2() {
          return {
            width: _defSize,
            height: _defSize,
            viewBox: _defViewBox,
            path: "",
            isBaseline: false
          };
        },
        mounted: function mounted() {
          this.updateIcon();
        },
        watch: {
          name: function name() {
            this.updateIcon();
          }
        },
        methods: {
          updateIcon: function updateIcon() {
            var icon = icons[this.name];
            if (icon) {
              this.width = icon.width || _defSize;
              this.height = icon.height || _defSize;
              this.viewBox = icon.viewBox;
              this.path = icon.path;
            }
          }
        }
      };
      function render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createBlock("svg", {
          class: "vc-svg-icon",
          width: $data.width,
          height: $data.height,
          viewBox: $data.viewBox
        }, [createVNode("path", {
          d: $data.path
        }, null, 8, ["d"])], 8, ["width", "height", "viewBox"]);
      }
      var css_248z$7 = ".vc-svg-icon {\n  display: inline-block;\n  stroke: currentColor;\n  stroke-width: 0;\n}\n.vc-svg-icon path {\n    fill: currentColor;\n}\n";
      styleInject(css_248z$7);
      script$8.render = render$6;
      function head(array) {
        return array && array.length ? array[0] : void 0;
      }
      var head_1 = head;
      var _yearGroupCount = 12;
      var script$7 = {
        name: "CalendarNav",
        emits: ["input"],
        components: {
          SvgIcon: script$8
        },
        mixins: [childMixin$1],
        props: {
          value: {
            type: Object,
            default: function _default() {
              return {
                month: 0,
                year: 0
              };
            }
          },
          validator: {
            type: Function,
            default: function _default() {
              return function() {
                return true;
              };
            }
          }
        },
        data: function data2() {
          return {
            monthMode: true,
            yearIndex: 0,
            yearGroupIndex: 0,
            onSpaceOrEnter
          };
        },
        computed: {
          month: function month() {
            return this.value ? this.value.month || 0 : 0;
          },
          year: function year() {
            return this.value ? this.value.year || 0 : 0;
          },
          title: function title2() {
            return this.monthMode ? this.yearIndex : "".concat(this.firstYear, " - ").concat(this.lastYear);
          },
          monthItems: function monthItems() {
            return this.getMonthItems(this.yearIndex);
          },
          yearItems: function yearItems() {
            return this.getYearItems(this.yearGroupIndex);
          },
          prevItemsEnabled: function prevItemsEnabled() {
            return this.monthMode ? this.prevMonthItemsEnabled : this.prevYearItemsEnabled;
          },
          nextItemsEnabled: function nextItemsEnabled() {
            return this.monthMode ? this.nextMonthItemsEnabled : this.nextYearItemsEnabled;
          },
          prevMonthItemsEnabled: function prevMonthItemsEnabled() {
            return this.getMonthItems(this.yearIndex - 1).some(function(i2) {
              return !i2.isDisabled;
            });
          },
          nextMonthItemsEnabled: function nextMonthItemsEnabled() {
            return this.getMonthItems(this.yearIndex + 1).some(function(i2) {
              return !i2.isDisabled;
            });
          },
          prevYearItemsEnabled: function prevYearItemsEnabled() {
            return this.getYearItems(this.yearGroupIndex - 1).some(function(i2) {
              return !i2.isDisabled;
            });
          },
          nextYearItemsEnabled: function nextYearItemsEnabled() {
            return this.getYearItems(this.yearGroupIndex + 1).some(function(i2) {
              return !i2.isDisabled;
            });
          },
          activeItems: function activeItems() {
            return this.monthMode ? this.monthItems : this.yearItems;
          },
          firstYear: function firstYear() {
            return head_1(this.yearItems.map(function(i2) {
              return i2.year;
            }));
          },
          lastYear: function lastYear() {
            return last_1(this.yearItems.map(function(i2) {
              return i2.year;
            }));
          }
        },
        watch: {
          year: function year() {
            this.yearIndex = this.year;
          },
          yearIndex: function yearIndex(val) {
            this.yearGroupIndex = this.getYearGroupIndex(val);
          },
          value: function value() {
            this.focusFirstItem();
          }
        },
        created: function created() {
          this.yearIndex = this.year;
        },
        mounted: function mounted() {
          this.focusFirstItem();
        },
        methods: {
          focusFirstItem: function focusFirstItem() {
            var _this = this;
            this.$nextTick(function() {
              var focusableEl = _this.$refs.navContainer.querySelector(".vc-nav-item:not(.is-disabled)");
              if (focusableEl) {
                focusableEl.focus();
              }
            });
          },
          getItemClasses: function getItemClasses(_ref) {
            var isActive = _ref.isActive, isCurrent = _ref.isCurrent, isDisabled = _ref.isDisabled;
            var classes = ["vc-nav-item"];
            if (isActive) {
              classes.push("is-active");
            } else if (isCurrent) {
              classes.push("is-current");
            }
            if (isDisabled) {
              classes.push("is-disabled");
            }
            return classes;
          },
          getYearGroupIndex: function getYearGroupIndex(year) {
            return Math.floor(year / _yearGroupCount);
          },
          getMonthItems: function getMonthItems(year) {
            var _this2 = this;
            var _this$pageForDate = this.pageForDate(new Date()), thisMonth = _this$pageForDate.month, thisYear = _this$pageForDate.year;
            return this.locale.getMonthDates().map(function(d2, i2) {
              var month = i2 + 1;
              return {
                month,
                year,
                id: "".concat(year, ".").concat(pad$1(month, 2)),
                label: _this2.locale.format(d2, _this2.masks.navMonths),
                ariaLabel: _this2.locale.format(d2, "MMMM YYYY"),
                isActive: month === _this2.month && year === _this2.year,
                isCurrent: month === thisMonth && year === thisYear,
                isDisabled: !_this2.validator({
                  month,
                  year
                }),
                click: function click() {
                  return _this2.monthClick(month, year);
                }
              };
            });
          },
          getYearItems: function getYearItems(yearGroupIndex) {
            var _this3 = this;
            var _this$pageForDate2 = this.pageForDate(new Date());
            _this$pageForDate2._;
            var thisYear = _this$pageForDate2.year;
            var startYear = yearGroupIndex * _yearGroupCount;
            var endYear = startYear + _yearGroupCount;
            var items = [];
            var _loop = function _loop2(year2) {
              var enabled = false;
              for (var month = 1; month < 12; month++) {
                enabled = _this3.validator({
                  month,
                  year: year2
                });
                if (enabled)
                  break;
              }
              items.push({
                year: year2,
                id: year2,
                label: year2,
                ariaLabel: year2,
                isActive: year2 === _this3.year,
                isCurrent: year2 === thisYear,
                isDisabled: !enabled,
                click: function click() {
                  return _this3.yearClick(year2);
                }
              });
            };
            for (var year = startYear; year < endYear; year += 1) {
              _loop(year);
            }
            return items;
          },
          monthClick: function monthClick(month, year) {
            if (this.validator({
              month,
              year
            })) {
              this.$emit("input", {
                month,
                year
              });
            }
          },
          yearClick: function yearClick(year) {
            this.yearIndex = year;
            this.monthMode = true;
            this.focusFirstItem();
          },
          toggleMode: function toggleMode() {
            this.monthMode = !this.monthMode;
          },
          movePrev: function movePrev() {
            if (!this.prevItemsEnabled)
              return;
            if (this.monthMode) {
              this.movePrevYear();
            }
            this.movePrevYearGroup();
          },
          moveNext: function moveNext() {
            if (!this.nextItemsEnabled)
              return;
            if (this.monthMode) {
              this.moveNextYear();
            }
            this.moveNextYearGroup();
          },
          movePrevYear: function movePrevYear() {
            this.yearIndex--;
          },
          moveNextYear: function moveNextYear() {
            this.yearIndex++;
          },
          movePrevYearGroup: function movePrevYearGroup() {
            this.yearGroupIndex--;
          },
          moveNextYearGroup: function moveNextYearGroup() {
            this.yearGroupIndex++;
          }
        }
      };
      var _hoisted_1$o = {
        class: "vc-nav-container",
        ref: "navContainer"
      };
      var _hoisted_2$n = {
        class: "vc-nav-header"
      };
      var _hoisted_3$g = {
        class: "vc-nav-items"
      };
      function render$5(_ctx, _cache, $props, $setup, $data, $options) {
        var _component_svg_icon = resolveComponent("svg-icon");
        return openBlock(), createBlock("div", _hoisted_1$o, [createVNode("div", _hoisted_2$n, [createVNode("span", {
          role: "button",
          class: ["vc-nav-arrow is-left", {
            "is-disabled": !$options.prevItemsEnabled
          }],
          tabindex: $options.prevItemsEnabled ? 0 : void 0,
          onClick: _cache[1] || (_cache[1] = function() {
            return $options.movePrev.apply($options, arguments);
          }),
          onKeydown: _cache[2] || (_cache[2] = function(e2) {
            return $data.onSpaceOrEnter(e2, $options.movePrev);
          })
        }, [renderSlot(_ctx.$slots, "nav-left-button", {}, function() {
          return [createVNode(_component_svg_icon, {
            name: "left-arrow",
            width: "20px",
            height: "24px"
          })];
        })], 42, ["tabindex"]), createVNode("span", {
          role: "button",
          class: ["vc-nav-title vc-grid-focus", {
            "is-disabled": !$options.nextItemsEnabled
          }],
          style: {
            whiteSpace: "nowrap"
          },
          tabindex: $options.nextItemsEnabled ? 0 : void 0,
          onClick: _cache[3] || (_cache[3] = function() {
            return $options.toggleMode.apply($options, arguments);
          }),
          onKeydown: _cache[4] || (_cache[4] = function(e2) {
            return $data.onSpaceOrEnter(e2, $options.toggleMode);
          })
        }, toDisplayString($options.title), 43, ["tabindex"]), createVNode("span", {
          role: "button",
          class: "vc-nav-arrow is-right",
          tabindex: "0",
          onClick: _cache[5] || (_cache[5] = function() {
            return $options.moveNext.apply($options, arguments);
          }),
          onKeydown: _cache[6] || (_cache[6] = function(e2) {
            return $data.onSpaceOrEnter(e2, $options.moveNext);
          })
        }, [renderSlot(_ctx.$slots, "nav-right-button", {}, function() {
          return [createVNode(_component_svg_icon, {
            name: "right-arrow",
            width: "20px",
            height: "24px"
          })];
        })], 32)]), createVNode("div", _hoisted_3$g, [(openBlock(true), createBlock(Fragment, null, renderList($options.activeItems, function(item) {
          return openBlock(), createBlock("span", {
            key: item.label,
            role: "button",
            "data-id": item.id,
            "aria-label": item.ariaLabel,
            class: $options.getItemClasses(item),
            tabindex: item.isDisabled ? void 0 : 0,
            onClick: item.click,
            onKeydown: function onKeydown(e2) {
              return $data.onSpaceOrEnter(e2, item.click);
            }
          }, toDisplayString(item.label), 43, ["data-id", "aria-label", "tabindex", "onClick", "onKeydown"]);
        }), 128))])], 512);
      }
      var css_248z$6 = ".vc-nav-header {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: space-between;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n}\n.vc-nav-arrow {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  cursor: pointer;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  line-height: var(--leading-snug);\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: var(--rounded);\n}\n.vc-nav-arrow.is-left {\n    margin-right: auto;\n}\n.vc-nav-arrow.is-right {\n    margin-left: auto;\n}\n.vc-nav-arrow.is-disabled {\n    opacity: 0.25;\n    pointer-events: none;\n    cursor: not-allowed;\n}\n.vc-nav-arrow:hover {\n    background-color: var(--gray-900);\n}\n.vc-nav-arrow:focus {\n    border-color: var(--accent-600);\n}\n.vc-nav-title {\n  color: var(--accent-100);\n  font-weight: var(--font-bold);\n  line-height: var(--leading-snug);\n  padding: 4px 8px;\n  border-radius: var(--rounded);\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-nav-title:hover {\n    background-color: var(--gray-900);\n}\n.vc-nav-title:focus {\n    border-color: var(--accent-600);\n}\n.vc-nav-items {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-row-gap: 2px;\n  grid-column-gap: 5px;\n}\n.vc-nav-item {\n  width: 48px;\n  text-align: center;\n  line-height: var(--leading-snug);\n  font-weight: var(--font-semibold);\n  padding: 4px 0;\n  cursor: pointer;\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: var(--rounded);\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-nav-item:hover {\n    color: var(--white);\n    background-color: var(--gray-900);\n    box-shadow: var(--shadow-inner);\n}\n.vc-nav-item.is-active {\n    color: var(--accent-900);\n    background: var(--accent-100);\n    font-weight: var(--font-bold);\n    box-shadow: var(--shadow);\n}\n.vc-nav-item.is-current {\n    color: var(--accent-100);\n    font-weight: var(--bold);\n    border-color: var(--accent-100);\n}\n.vc-nav-item:focus {\n    border-color: var(--accent-600);\n}\n.vc-nav-item.is-disabled {\n    opacity: 0.25;\n    pointer-events: none;\n}\n.vc-is-dark .vc-nav-title {\n    color: var(--gray-900);\n}\n.vc-is-dark .vc-nav-title:hover {\n      background-color: var(--gray-200);\n}\n.vc-is-dark .vc-nav-title:focus {\n      border-color: var(--accent-400);\n}\n.vc-is-dark .vc-nav-arrow:hover {\n      background-color: var(--gray-200);\n}\n.vc-is-dark .vc-nav-arrow:focus {\n      border-color: var(--accent-400);\n}\n.vc-is-dark .vc-nav-item:hover {\n      color: var(--gray-900);\n      background-color: var(--gray-200);\n      box-shadow: none;\n}\n.vc-is-dark .vc-nav-item.is-active {\n      color: var(--white);\n      background: var(--accent-500);\n}\n.vc-is-dark .vc-nav-item.is-current {\n      color: var(--accent-600);\n      border-color: var(--accent-500);\n}\n.vc-is-dark .vc-nav-item:focus {\n      border-color: var(--accent-400);\n}\n";
      styleInject(css_248z$6);
      script$7.render = render$5;
      var script$6 = {
        name: "CustomTransition",
        emits: ["before-enter", "before-transition", "after-enter", "after-transition"],
        props: {
          name: String,
          appear: Boolean
        },
        computed: {
          name_: function name_() {
            return "vc-".concat(this.name || "none");
          }
        },
        methods: {
          beforeEnter: function beforeEnter(el) {
            this.$emit("before-enter", el);
            this.$emit("before-transition", el);
          },
          afterEnter: function afterEnter(el) {
            this.$emit("after-enter", el);
            this.$emit("after-transition", el);
          }
        }
      };
      function render$4(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createBlock(Transition, {
          name: $options.name_,
          appear: $props.appear,
          onBeforeEnter: $options.beforeEnter,
          onAfterEnter: $options.afterEnter
        }, {
          default: withCtx(function() {
            return [renderSlot(_ctx.$slots, "default")];
          }),
          _: 3
        }, 8, ["name", "appear", "onBeforeEnter", "onAfterEnter"]);
      }
      var css_248z$5 = ".vc-none-enter-active,\n.vc-none-leave-active {\n  transition-duration: 0s;\n}\n.vc-fade-enter-active,\n.vc-fade-leave-active,\n.vc-slide-left-enter-active,\n.vc-slide-left-leave-active,\n.vc-slide-right-enter-active,\n.vc-slide-right-leave-active,\n.vc-slide-up-enter-active,\n.vc-slide-up-leave-active,\n.vc-slide-down-enter-active,\n.vc-slide-down-leave-active,\n.vc-slide-fade-enter-active,\n.vc-slide-fade-leave-active {\n  transition: opacity var(--slide-duration) var(--slide-timing),\n    -webkit-transform var(--slide-duration) var(--slide-timing);\n  transition: transform var(--slide-duration) var(--slide-timing),\n    opacity var(--slide-duration) var(--slide-timing);\n  transition: transform var(--slide-duration) var(--slide-timing),\n    opacity var(--slide-duration) var(--slide-timing),\n    -webkit-transform var(--slide-duration) var(--slide-timing);\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  pointer-events: none;\n}\n.vc-none-leave-active,\n.vc-fade-leave-active,\n.vc-slide-left-leave-active,\n.vc-slide-right-leave-active,\n.vc-slide-up-leave-active,\n.vc-slide-down-leave-active {\n  position: absolute !important;\n  width: 100%;\n}\n.vc-none-enter-from,\n.vc-none-leave-to,\n.vc-fade-enter-from,\n.vc-fade-leave-to,\n.vc-slide-left-enter-from,\n.vc-slide-left-leave-to,\n.vc-slide-right-enter-from,\n.vc-slide-right-leave-to,\n.vc-slide-up-enter-from,\n.vc-slide-up-leave-to,\n.vc-slide-down-enter-from,\n.vc-slide-down-leave-to,\n.vc-slide-fade-enter-from,\n.vc-slide-fade-leave-to {\n  opacity: 0;\n}\n.vc-slide-left-enter-from,\n.vc-slide-right-leave-to,\n.vc-slide-fade-enter-from.direction-left,\n.vc-slide-fade-leave-to.direction-left {\n  -webkit-transform: translateX(var(--slide-translate));\n          transform: translateX(var(--slide-translate));\n}\n.vc-slide-right-enter-from,\n.vc-slide-left-leave-to,\n.vc-slide-fade-enter-from.direction-right,\n.vc-slide-fade-leave-to.direction-right {\n  -webkit-transform: translateX(calc(-1 * var(--slide-translate)));\n          transform: translateX(calc(-1 * var(--slide-translate)));\n}\n.vc-slide-up-enter-from,\n.vc-slide-down-leave-to,\n.vc-slide-fade-enter-from.direction-top,\n.vc-slide-fade-leave-to.direction-top {\n  -webkit-transform: translateY(var(--slide-translate));\n          transform: translateY(var(--slide-translate));\n}\n.vc-slide-down-enter-from,\n.vc-slide-up-leave-to,\n.vc-slide-fade-enter-from.direction-bottom,\n.vc-slide-fade-leave-to.direction-bottom {\n  -webkit-transform: translateY(calc(-1 * var(--slide-translate)));\n          transform: translateY(calc(-1 * var(--slide-translate)));\n}\n";
      styleInject(css_248z$5);
      script$6.render = render$4;
      var top = "top";
      var bottom = "bottom";
      var right = "right";
      var left = "left";
      var auto = "auto";
      var basePlacements = [top, bottom, right, left];
      var start = "start";
      var end = "end";
      var clippingParents = "clippingParents";
      var viewport = "viewport";
      var popper = "popper";
      var reference = "reference";
      var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
        return acc.concat([placement + "-" + start, placement + "-" + end]);
      }, []);
      var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
        return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
      }, []);
      var beforeRead = "beforeRead";
      var read = "read";
      var afterRead = "afterRead";
      var beforeMain = "beforeMain";
      var main = "main";
      var afterMain = "afterMain";
      var beforeWrite = "beforeWrite";
      var write = "write";
      var afterWrite = "afterWrite";
      var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
      function getNodeName(element) {
        return element ? (element.nodeName || "").toLowerCase() : null;
      }
      function getWindow(node) {
        if (node == null) {
          return window;
        }
        if (node.toString() !== "[object Window]") {
          var ownerDocument = node.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView || window : window;
        }
        return node;
      }
      function isElement$1(node) {
        var OwnElement = getWindow(node).Element;
        return node instanceof OwnElement || node instanceof Element;
      }
      function isHTMLElement(node) {
        var OwnElement = getWindow(node).HTMLElement;
        return node instanceof OwnElement || node instanceof HTMLElement;
      }
      function isShadowRoot(node) {
        if (typeof ShadowRoot === "undefined") {
          return false;
        }
        var OwnElement = getWindow(node).ShadowRoot;
        return node instanceof OwnElement || node instanceof ShadowRoot;
      }
      function applyStyles(_ref) {
        var state2 = _ref.state;
        Object.keys(state2.elements).forEach(function(name) {
          var style2 = state2.styles[name] || {};
          var attributes = state2.attributes[name] || {};
          var element = state2.elements[name];
          if (!isHTMLElement(element) || !getNodeName(element)) {
            return;
          }
          Object.assign(element.style, style2);
          Object.keys(attributes).forEach(function(name2) {
            var value = attributes[name2];
            if (value === false) {
              element.removeAttribute(name2);
            } else {
              element.setAttribute(name2, value === true ? "" : value);
            }
          });
        });
      }
      function effect$2(_ref2) {
        var state2 = _ref2.state;
        var initialStyles = {
          popper: {
            position: state2.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
          },
          arrow: {
            position: "absolute"
          },
          reference: {}
        };
        Object.assign(state2.elements.popper.style, initialStyles.popper);
        state2.styles = initialStyles;
        if (state2.elements.arrow) {
          Object.assign(state2.elements.arrow.style, initialStyles.arrow);
        }
        return function() {
          Object.keys(state2.elements).forEach(function(name) {
            var element = state2.elements[name];
            var attributes = state2.attributes[name] || {};
            var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
            var style2 = styleProperties.reduce(function(style3, property2) {
              style3[property2] = "";
              return style3;
            }, {});
            if (!isHTMLElement(element) || !getNodeName(element)) {
              return;
            }
            Object.assign(element.style, style2);
            Object.keys(attributes).forEach(function(attribute) {
              element.removeAttribute(attribute);
            });
          });
        };
      }
      var applyStyles$1 = {
        name: "applyStyles",
        enabled: true,
        phase: "write",
        fn: applyStyles,
        effect: effect$2,
        requires: ["computeStyles"]
      };
      function getBasePlacement(placement) {
        return placement.split("-")[0];
      }
      var max = Math.max;
      var min = Math.min;
      var round = Math.round;
      function getBoundingClientRect(element, includeScale) {
        if (includeScale === void 0) {
          includeScale = false;
        }
        var rect = element.getBoundingClientRect();
        var scaleX = 1;
        var scaleY = 1;
        if (isHTMLElement(element) && includeScale) {
          var offsetHeight = element.offsetHeight;
          var offsetWidth = element.offsetWidth;
          if (offsetWidth > 0) {
            scaleX = round(rect.width) / offsetWidth || 1;
          }
          if (offsetHeight > 0) {
            scaleY = round(rect.height) / offsetHeight || 1;
          }
        }
        return {
          width: rect.width / scaleX,
          height: rect.height / scaleY,
          top: rect.top / scaleY,
          right: rect.right / scaleX,
          bottom: rect.bottom / scaleY,
          left: rect.left / scaleX,
          x: rect.left / scaleX,
          y: rect.top / scaleY
        };
      }
      function getLayoutRect(element) {
        var clientRect = getBoundingClientRect(element);
        var width = element.offsetWidth;
        var height = element.offsetHeight;
        if (Math.abs(clientRect.width - width) <= 1) {
          width = clientRect.width;
        }
        if (Math.abs(clientRect.height - height) <= 1) {
          height = clientRect.height;
        }
        return {
          x: element.offsetLeft,
          y: element.offsetTop,
          width,
          height
        };
      }
      function contains(parent2, child) {
        var rootNode = child.getRootNode && child.getRootNode();
        if (parent2.contains(child)) {
          return true;
        } else if (rootNode && isShadowRoot(rootNode)) {
          var next = child;
          do {
            if (next && parent2.isSameNode(next)) {
              return true;
            }
            next = next.parentNode || next.host;
          } while (next);
        }
        return false;
      }
      function getComputedStyle$1(element) {
        return getWindow(element).getComputedStyle(element);
      }
      function isTableElement(element) {
        return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
      }
      function getDocumentElement(element) {
        return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement;
      }
      function getParentNode(element) {
        if (getNodeName(element) === "html") {
          return element;
        }
        return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
      }
      function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
          return null;
        }
        return element.offsetParent;
      }
      function getContainingBlock(element) {
        var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
        var isIE = navigator.userAgent.indexOf("Trident") !== -1;
        if (isIE && isHTMLElement(element)) {
          var elementCss = getComputedStyle$1(element);
          if (elementCss.position === "fixed") {
            return null;
          }
        }
        var currentNode = getParentNode(element);
        while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
          var css2 = getComputedStyle$1(currentNode);
          if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
            return currentNode;
          } else {
            currentNode = currentNode.parentNode;
          }
        }
        return null;
      }
      function getOffsetParent(element) {
        var window2 = getWindow(element);
        var offsetParent = getTrueOffsetParent(element);
        while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
          offsetParent = getTrueOffsetParent(offsetParent);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
          return window2;
        }
        return offsetParent || getContainingBlock(element) || window2;
      }
      function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
      }
      function within(min$1, value, max$1) {
        return max(min$1, min(value, max$1));
      }
      function withinMaxClamp(min2, value, max2) {
        var v2 = within(min2, value, max2);
        return v2 > max2 ? max2 : v2;
      }
      function getFreshSideObject() {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        };
      }
      function mergePaddingObject(paddingObject) {
        return Object.assign({}, getFreshSideObject(), paddingObject);
      }
      function expandToHashMap(value, keys2) {
        return keys2.reduce(function(hashMap, key) {
          hashMap[key] = value;
          return hashMap;
        }, {});
      }
      var toPaddingObject = function toPaddingObject2(padding, state2) {
        padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
          placement: state2.placement
        })) : padding;
        return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
      };
      function arrow(_ref) {
        var _state$modifiersData$;
        var state2 = _ref.state, name = _ref.name, options = _ref.options;
        var arrowElement = state2.elements.arrow;
        var popperOffsets2 = state2.modifiersData.popperOffsets;
        var basePlacement = getBasePlacement(state2.placement);
        var axis = getMainAxisFromPlacement(basePlacement);
        var isVertical = [left, right].indexOf(basePlacement) >= 0;
        var len = isVertical ? "height" : "width";
        if (!arrowElement || !popperOffsets2) {
          return;
        }
        var paddingObject = toPaddingObject(options.padding, state2);
        var arrowRect = getLayoutRect(arrowElement);
        var minProp = axis === "y" ? top : left;
        var maxProp = axis === "y" ? bottom : right;
        var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
        var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
        var arrowOffsetParent = getOffsetParent(arrowElement);
        var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
        var centerToReference = endDiff / 2 - startDiff / 2;
        var min2 = paddingObject[minProp];
        var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
        var offset2 = within(min2, center, max2);
        var axisProp = axis;
        state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
      }
      function effect$1(_ref2) {
        var state2 = _ref2.state, options = _ref2.options;
        var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
        if (arrowElement == null) {
          return;
        }
        if (typeof arrowElement === "string") {
          arrowElement = state2.elements.popper.querySelector(arrowElement);
          if (!arrowElement) {
            return;
          }
        }
        {
          if (!isHTMLElement(arrowElement)) {
            console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
          }
        }
        if (!contains(state2.elements.popper, arrowElement)) {
          {
            console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
          }
          return;
        }
        state2.elements.arrow = arrowElement;
      }
      var arrow$1 = {
        name: "arrow",
        enabled: true,
        phase: "main",
        fn: arrow,
        effect: effect$1,
        requires: ["popperOffsets"],
        requiresIfExists: ["preventOverflow"]
      };
      function getVariation(placement) {
        return placement.split("-")[1];
      }
      var unsetSides = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
      };
      function roundOffsetsByDPR(_ref) {
        var x2 = _ref.x, y2 = _ref.y;
        var win = window;
        var dpr = win.devicePixelRatio || 1;
        return {
          x: round(x2 * dpr) / dpr || 0,
          y: round(y2 * dpr) / dpr || 0
        };
      }
      function mapToStyles(_ref2) {
        var _Object$assign2;
        var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
        var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y2 = _ref3$y === void 0 ? 0 : _ref3$y;
        var hasX = offsets.hasOwnProperty("x");
        var hasY = offsets.hasOwnProperty("y");
        var sideX = left;
        var sideY = top;
        var win = window;
        if (adaptive) {
          var offsetParent = getOffsetParent(popper2);
          var heightProp = "clientHeight";
          var widthProp = "clientWidth";
          if (offsetParent === getWindow(popper2)) {
            offsetParent = getDocumentElement(popper2);
            if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
              heightProp = "scrollHeight";
              widthProp = "scrollWidth";
            }
          }
          offsetParent = offsetParent;
          if (placement === top || (placement === left || placement === right) && variation === end) {
            sideY = bottom;
            var offsetY = isFixed && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
            y2 -= offsetY - popperRect.height;
            y2 *= gpuAcceleration ? 1 : -1;
          }
          if (placement === left || (placement === top || placement === bottom) && variation === end) {
            sideX = right;
            var offsetX = isFixed && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
            x2 -= offsetX - popperRect.width;
            x2 *= gpuAcceleration ? 1 : -1;
          }
        }
        var commonStyles = Object.assign({
          position
        }, adaptive && unsetSides);
        if (gpuAcceleration) {
          var _Object$assign;
          return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
        }
        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
      }
      function computeStyles(_ref4) {
        var state2 = _ref4.state, options = _ref4.options;
        var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
        {
          var transitionProperty = getComputedStyle$1(state2.elements.popper).transitionProperty || "";
          if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property2) {
            return transitionProperty.indexOf(property2) >= 0;
          })) {
            console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
          }
        }
        var commonStyles = {
          placement: getBasePlacement(state2.placement),
          variation: getVariation(state2.placement),
          popper: state2.elements.popper,
          popperRect: state2.rects.popper,
          gpuAcceleration,
          isFixed: state2.options.strategy === "fixed"
        };
        if (state2.modifiersData.popperOffsets != null) {
          state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
            offsets: state2.modifiersData.popperOffsets,
            position: state2.options.strategy,
            adaptive,
            roundOffsets
          })));
        }
        if (state2.modifiersData.arrow != null) {
          state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
            offsets: state2.modifiersData.arrow,
            position: "absolute",
            adaptive: false,
            roundOffsets
          })));
        }
        state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
          "data-popper-placement": state2.placement
        });
      }
      var computeStyles$1 = {
        name: "computeStyles",
        enabled: true,
        phase: "beforeWrite",
        fn: computeStyles,
        data: {}
      };
      var passive = {
        passive: true
      };
      function effect(_ref) {
        var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
        var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
        var window2 = getWindow(state2.elements.popper);
        var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
        if (scroll) {
          scrollParents.forEach(function(scrollParent) {
            scrollParent.addEventListener("scroll", instance.update, passive);
          });
        }
        if (resize) {
          window2.addEventListener("resize", instance.update, passive);
        }
        return function() {
          if (scroll) {
            scrollParents.forEach(function(scrollParent) {
              scrollParent.removeEventListener("scroll", instance.update, passive);
            });
          }
          if (resize) {
            window2.removeEventListener("resize", instance.update, passive);
          }
        };
      }
      var eventListeners = {
        name: "eventListeners",
        enabled: true,
        phase: "write",
        fn: function fn2() {
        },
        effect,
        data: {}
      };
      var hash$1 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, function(matched) {
          return hash$1[matched];
        });
      }
      var hash = {
        start: "end",
        end: "start"
      };
      function getOppositeVariationPlacement(placement) {
        return placement.replace(/start|end/g, function(matched) {
          return hash[matched];
        });
      }
      function getWindowScroll(node) {
        var win = getWindow(node);
        var scrollLeft = win.pageXOffset;
        var scrollTop = win.pageYOffset;
        return {
          scrollLeft,
          scrollTop
        };
      }
      function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
      }
      function getViewportRect(element) {
        var win = getWindow(element);
        var html = getDocumentElement(element);
        var visualViewport = win.visualViewport;
        var width = html.clientWidth;
        var height = html.clientHeight;
        var x2 = 0;
        var y2 = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
            x2 = visualViewport.offsetLeft;
            y2 = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x: x2 + getWindowScrollBarX(element),
          y: y2
        };
      }
      function getDocumentRect(element) {
        var _element$ownerDocumen;
        var html = getDocumentElement(element);
        var winScroll = getWindowScroll(element);
        var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
        var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
        var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
        var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
        var y2 = -winScroll.scrollTop;
        if (getComputedStyle$1(body || html).direction === "rtl") {
          x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
        }
        return {
          width,
          height,
          x: x2,
          y: y2
        };
      }
      function isScrollParent(element) {
        var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
      }
      function getScrollParent(node) {
        if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
          return node.ownerDocument.body;
        }
        if (isHTMLElement(node) && isScrollParent(node)) {
          return node;
        }
        return getScrollParent(getParentNode(node));
      }
      function listScrollParents(element, list) {
        var _element$ownerDocumen;
        if (list === void 0) {
          list = [];
        }
        var scrollParent = getScrollParent(element);
        var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
        var win = getWindow(scrollParent);
        var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
        var updatedList = list.concat(target);
        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
      }
      function rectToClientRect(rect) {
        return Object.assign({}, rect, {
          left: rect.x,
          top: rect.y,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height
        });
      }
      function getInnerBoundingClientRect(element) {
        var rect = getBoundingClientRect(element);
        rect.top = rect.top + element.clientTop;
        rect.left = rect.left + element.clientLeft;
        rect.bottom = rect.top + element.clientHeight;
        rect.right = rect.left + element.clientWidth;
        rect.width = element.clientWidth;
        rect.height = element.clientHeight;
        rect.x = rect.left;
        rect.y = rect.top;
        return rect;
      }
      function getClientRectFromMixedType(element, clippingParent) {
        return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
      }
      function getClippingParents(element) {
        var clippingParents2 = listScrollParents(getParentNode(element));
        var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
        if (!isElement$1(clipperElement)) {
          return [];
        }
        return clippingParents2.filter(function(clippingParent) {
          return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body" && (canEscapeClipping ? getComputedStyle$1(clippingParent).position !== "static" : true);
        });
      }
      function getClippingRect(element, boundary, rootBoundary) {
        var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
        var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
        var firstClippingParent = clippingParents2[0];
        var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
          var rect = getClientRectFromMixedType(element, clippingParent);
          accRect.top = max(rect.top, accRect.top);
          accRect.right = min(rect.right, accRect.right);
          accRect.bottom = min(rect.bottom, accRect.bottom);
          accRect.left = max(rect.left, accRect.left);
          return accRect;
        }, getClientRectFromMixedType(element, firstClippingParent));
        clippingRect.width = clippingRect.right - clippingRect.left;
        clippingRect.height = clippingRect.bottom - clippingRect.top;
        clippingRect.x = clippingRect.left;
        clippingRect.y = clippingRect.top;
        return clippingRect;
      }
      function computeOffsets(_ref) {
        var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
        var basePlacement = placement ? getBasePlacement(placement) : null;
        var variation = placement ? getVariation(placement) : null;
        var commonX = reference2.x + reference2.width / 2 - element.width / 2;
        var commonY = reference2.y + reference2.height / 2 - element.height / 2;
        var offsets;
        switch (basePlacement) {
          case top:
            offsets = {
              x: commonX,
              y: reference2.y - element.height
            };
            break;
          case bottom:
            offsets = {
              x: commonX,
              y: reference2.y + reference2.height
            };
            break;
          case right:
            offsets = {
              x: reference2.x + reference2.width,
              y: commonY
            };
            break;
          case left:
            offsets = {
              x: reference2.x - element.width,
              y: commonY
            };
            break;
          default:
            offsets = {
              x: reference2.x,
              y: reference2.y
            };
        }
        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
        if (mainAxis != null) {
          var len = mainAxis === "y" ? "height" : "width";
          switch (variation) {
            case start:
              offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
              break;
            case end:
              offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
              break;
          }
        }
        return offsets;
      }
      function detectOverflow(state2, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
        var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
        var altContext = elementContext === popper ? reference : popper;
        var popperRect = state2.rects.popper;
        var element = state2.elements[altBoundary ? altContext : elementContext];
        var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary);
        var referenceClientRect = getBoundingClientRect(state2.elements.reference);
        var popperOffsets2 = computeOffsets({
          reference: referenceClientRect,
          element: popperRect,
          strategy: "absolute",
          placement
        });
        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
        var overflowOffsets = {
          top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
          bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
          left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
          right: elementClientRect.right - clippingClientRect.right + paddingObject.right
        };
        var offsetData = state2.modifiersData.offset;
        if (elementContext === popper && offsetData) {
          var offset2 = offsetData[placement];
          Object.keys(overflowOffsets).forEach(function(key) {
            var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
            var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
            overflowOffsets[key] += offset2[axis] * multiply;
          });
        }
        return overflowOffsets;
      }
      function computeAutoPlacement(state2, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
        var variation = getVariation(placement);
        var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
          return getVariation(placement2) === variation;
        }) : basePlacements;
        var allowedPlacements = placements$1.filter(function(placement2) {
          return allowedAutoPlacements.indexOf(placement2) >= 0;
        });
        if (allowedPlacements.length === 0) {
          allowedPlacements = placements$1;
          {
            console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
          }
        }
        var overflows = allowedPlacements.reduce(function(acc, placement2) {
          acc[placement2] = detectOverflow(state2, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding
          })[getBasePlacement(placement2)];
          return acc;
        }, {});
        return Object.keys(overflows).sort(function(a2, b2) {
          return overflows[a2] - overflows[b2];
        });
      }
      function getExpandedFallbackPlacements(placement) {
        if (getBasePlacement(placement) === auto) {
          return [];
        }
        var oppositePlacement = getOppositePlacement(placement);
        return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
      }
      function flip(_ref) {
        var state2 = _ref.state, options = _ref.options, name = _ref.name;
        if (state2.modifiersData[name]._skip) {
          return;
        }
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
        var preferredPlacement = state2.options.placement;
        var basePlacement = getBasePlacement(preferredPlacement);
        var isBasePlacement = basePlacement === preferredPlacement;
        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
        var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
          return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
            placement: placement2,
            boundary,
            rootBoundary,
            padding,
            flipVariations,
            allowedAutoPlacements
          }) : placement2);
        }, []);
        var referenceRect = state2.rects.reference;
        var popperRect = state2.rects.popper;
        var checksMap = new Map();
        var makeFallbackChecks = true;
        var firstFittingPlacement = placements2[0];
        for (var i2 = 0; i2 < placements2.length; i2++) {
          var placement = placements2[i2];
          var _basePlacement = getBasePlacement(placement);
          var isStartVariation = getVariation(placement) === start;
          var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
          var len = isVertical ? "width" : "height";
          var overflow = detectOverflow(state2, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding
          });
          var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
          if (referenceRect[len] > popperRect[len]) {
            mainVariationSide = getOppositePlacement(mainVariationSide);
          }
          var altVariationSide = getOppositePlacement(mainVariationSide);
          var checks = [];
          if (checkMainAxis) {
            checks.push(overflow[_basePlacement] <= 0);
          }
          if (checkAltAxis) {
            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
          }
          if (checks.every(function(check) {
            return check;
          })) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
          }
          checksMap.set(placement, checks);
        }
        if (makeFallbackChecks) {
          var numberOfChecks = flipVariations ? 3 : 1;
          var _loop = function _loop2(_i2) {
            var fittingPlacement = placements2.find(function(placement2) {
              var checks2 = checksMap.get(placement2);
              if (checks2) {
                return checks2.slice(0, _i2).every(function(check) {
                  return check;
                });
              }
            });
            if (fittingPlacement) {
              firstFittingPlacement = fittingPlacement;
              return "break";
            }
          };
          for (var _i = numberOfChecks; _i > 0; _i--) {
            var _ret = _loop(_i);
            if (_ret === "break")
              break;
          }
        }
        if (state2.placement !== firstFittingPlacement) {
          state2.modifiersData[name]._skip = true;
          state2.placement = firstFittingPlacement;
          state2.reset = true;
        }
      }
      var flip$1 = {
        name: "flip",
        enabled: true,
        phase: "main",
        fn: flip,
        requiresIfExists: ["offset"],
        data: {
          _skip: false
        }
      };
      function getSideOffsets(overflow, rect, preventedOffsets) {
        if (preventedOffsets === void 0) {
          preventedOffsets = {
            x: 0,
            y: 0
          };
        }
        return {
          top: overflow.top - rect.height - preventedOffsets.y,
          right: overflow.right - rect.width + preventedOffsets.x,
          bottom: overflow.bottom - rect.height + preventedOffsets.y,
          left: overflow.left - rect.width - preventedOffsets.x
        };
      }
      function isAnySideFullyClipped(overflow) {
        return [top, right, bottom, left].some(function(side) {
          return overflow[side] >= 0;
        });
      }
      function hide(_ref) {
        var state2 = _ref.state, name = _ref.name;
        var referenceRect = state2.rects.reference;
        var popperRect = state2.rects.popper;
        var preventedOffsets = state2.modifiersData.preventOverflow;
        var referenceOverflow = detectOverflow(state2, {
          elementContext: "reference"
        });
        var popperAltOverflow = detectOverflow(state2, {
          altBoundary: true
        });
        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
        state2.modifiersData[name] = {
          referenceClippingOffsets,
          popperEscapeOffsets,
          isReferenceHidden,
          hasPopperEscaped
        };
        state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
          "data-popper-reference-hidden": isReferenceHidden,
          "data-popper-escaped": hasPopperEscaped
        });
      }
      var hide$1 = {
        name: "hide",
        enabled: true,
        phase: "main",
        requiresIfExists: ["preventOverflow"],
        fn: hide
      };
      function distanceAndSkiddingToXY(placement, rects, offset2) {
        var basePlacement = getBasePlacement(placement);
        var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
        var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
          placement
        })) : offset2, skidding = _ref[0], distance = _ref[1];
        skidding = skidding || 0;
        distance = (distance || 0) * invertDistance;
        return [left, right].indexOf(basePlacement) >= 0 ? {
          x: distance,
          y: skidding
        } : {
          x: skidding,
          y: distance
        };
      }
      function offset(_ref2) {
        var state2 = _ref2.state, options = _ref2.options, name = _ref2.name;
        var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
        var data2 = placements.reduce(function(acc, placement) {
          acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
          return acc;
        }, {});
        var _data$state$placement = data2[state2.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
        if (state2.modifiersData.popperOffsets != null) {
          state2.modifiersData.popperOffsets.x += x2;
          state2.modifiersData.popperOffsets.y += y2;
        }
        state2.modifiersData[name] = data2;
      }
      var offset$1 = {
        name: "offset",
        enabled: true,
        phase: "main",
        requires: ["popperOffsets"],
        fn: offset
      };
      function popperOffsets(_ref) {
        var state2 = _ref.state, name = _ref.name;
        state2.modifiersData[name] = computeOffsets({
          reference: state2.rects.reference,
          element: state2.rects.popper,
          strategy: "absolute",
          placement: state2.placement
        });
      }
      var popperOffsets$1 = {
        name: "popperOffsets",
        enabled: true,
        phase: "read",
        fn: popperOffsets,
        data: {}
      };
      function getAltAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      function preventOverflow(_ref) {
        var state2 = _ref.state, options = _ref.options, name = _ref.name;
        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
        var overflow = detectOverflow(state2, {
          boundary,
          rootBoundary,
          padding,
          altBoundary
        });
        var basePlacement = getBasePlacement(state2.placement);
        var variation = getVariation(state2.placement);
        var isBasePlacement = !variation;
        var mainAxis = getMainAxisFromPlacement(basePlacement);
        var altAxis = getAltAxis(mainAxis);
        var popperOffsets2 = state2.modifiersData.popperOffsets;
        var referenceRect = state2.rects.reference;
        var popperRect = state2.rects.popper;
        var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
          placement: state2.placement
        })) : tetherOffset;
        var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
          mainAxis: tetherOffsetValue,
          altAxis: tetherOffsetValue
        } : Object.assign({
          mainAxis: 0,
          altAxis: 0
        }, tetherOffsetValue);
        var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
        var data2 = {
          x: 0,
          y: 0
        };
        if (!popperOffsets2) {
          return;
        }
        if (checkMainAxis) {
          var _offsetModifierState$;
          var mainSide = mainAxis === "y" ? top : left;
          var altSide = mainAxis === "y" ? bottom : right;
          var len = mainAxis === "y" ? "height" : "width";
          var offset2 = popperOffsets2[mainAxis];
          var min$1 = offset2 + overflow[mainSide];
          var max$1 = offset2 - overflow[altSide];
          var additive = tether ? -popperRect[len] / 2 : 0;
          var minLen = variation === start ? referenceRect[len] : popperRect[len];
          var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
          var arrowElement = state2.elements.arrow;
          var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
            width: 0,
            height: 0
          };
          var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
          var arrowPaddingMin = arrowPaddingObject[mainSide];
          var arrowPaddingMax = arrowPaddingObject[altSide];
          var arrowLen = within(0, referenceRect[len], arrowRect[len]);
          var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
          var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
          var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
          var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
          var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
          var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
          var tetherMax = offset2 + maxOffset - offsetModifierValue;
          var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
          popperOffsets2[mainAxis] = preventedOffset;
          data2[mainAxis] = preventedOffset - offset2;
        }
        if (checkAltAxis) {
          var _offsetModifierState$2;
          var _mainSide = mainAxis === "x" ? top : left;
          var _altSide = mainAxis === "x" ? bottom : right;
          var _offset = popperOffsets2[altAxis];
          var _len = altAxis === "y" ? "height" : "width";
          var _min = _offset + overflow[_mainSide];
          var _max = _offset - overflow[_altSide];
          var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
          var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
          var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
          var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
          var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
          popperOffsets2[altAxis] = _preventedOffset;
          data2[altAxis] = _preventedOffset - _offset;
        }
        state2.modifiersData[name] = data2;
      }
      var preventOverflow$1 = {
        name: "preventOverflow",
        enabled: true,
        phase: "main",
        fn: preventOverflow,
        requiresIfExists: ["offset"]
      };
      function getHTMLElementScroll(element) {
        return {
          scrollLeft: element.scrollLeft,
          scrollTop: element.scrollTop
        };
      }
      function getNodeScroll(node) {
        if (node === getWindow(node) || !isHTMLElement(node)) {
          return getWindowScroll(node);
        } else {
          return getHTMLElementScroll(node);
        }
      }
      function isElementScaled(element) {
        var rect = element.getBoundingClientRect();
        var scaleX = round(rect.width) / element.offsetWidth || 1;
        var scaleY = round(rect.height) / element.offsetHeight || 1;
        return scaleX !== 1 || scaleY !== 1;
      }
      function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
        if (isFixed === void 0) {
          isFixed = false;
        }
        var isOffsetParentAnElement = isHTMLElement(offsetParent);
        var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
        var documentElement = getDocumentElement(offsetParent);
        var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);
        var scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        var offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
          if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            offsets = getBoundingClientRect(offsetParent, true);
            offsets.x += offsetParent.clientLeft;
            offsets.y += offsetParent.clientTop;
          } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
          }
        }
        return {
          x: rect.left + scroll.scrollLeft - offsets.x,
          y: rect.top + scroll.scrollTop - offsets.y,
          width: rect.width,
          height: rect.height
        };
      }
      function order(modifiers) {
        var map2 = new Map();
        var visited = new Set();
        var result = [];
        modifiers.forEach(function(modifier) {
          map2.set(modifier.name, modifier);
        });
        function sort(modifier) {
          visited.add(modifier.name);
          var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
          requires.forEach(function(dep) {
            if (!visited.has(dep)) {
              var depModifier = map2.get(dep);
              if (depModifier) {
                sort(depModifier);
              }
            }
          });
          result.push(modifier);
        }
        modifiers.forEach(function(modifier) {
          if (!visited.has(modifier.name)) {
            sort(modifier);
          }
        });
        return result;
      }
      function orderModifiers(modifiers) {
        var orderedModifiers = order(modifiers);
        return modifierPhases.reduce(function(acc, phase) {
          return acc.concat(orderedModifiers.filter(function(modifier) {
            return modifier.phase === phase;
          }));
        }, []);
      }
      function debounce(fn2) {
        var pending;
        return function() {
          if (!pending) {
            pending = new Promise(function(resolve) {
              Promise.resolve().then(function() {
                pending = void 0;
                resolve(fn2());
              });
            });
          }
          return pending;
        };
      }
      function format(str) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return [].concat(args).reduce(function(p2, c2) {
          return p2.replace(/%s/, c2);
        }, str);
      }
      var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
      var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
      var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
      function validateModifiers(modifiers) {
        modifiers.forEach(function(modifier) {
          [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
            return self2.indexOf(value) === index2;
          }).forEach(function(key) {
            switch (key) {
              case "name":
                if (typeof modifier.name !== "string") {
                  console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
                }
                break;
              case "enabled":
                if (typeof modifier.enabled !== "boolean") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
                }
                break;
              case "phase":
                if (modifierPhases.indexOf(modifier.phase) < 0) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
                }
                break;
              case "fn":
                if (typeof modifier.fn !== "function") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
                }
                break;
              case "effect":
                if (modifier.effect != null && typeof modifier.effect !== "function") {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
                }
                break;
              case "requires":
                if (modifier.requires != null && !Array.isArray(modifier.requires)) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
                }
                break;
              case "requiresIfExists":
                if (!Array.isArray(modifier.requiresIfExists)) {
                  console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
                }
                break;
              case "options":
              case "data":
                break;
              default:
                console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s2) {
                  return '"' + s2 + '"';
                }).join(", ") + '; but "' + key + '" was provided.');
            }
            modifier.requires && modifier.requires.forEach(function(requirement) {
              if (modifiers.find(function(mod) {
                return mod.name === requirement;
              }) == null) {
                console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
              }
            });
          });
        });
      }
      function uniqueBy(arr, fn2) {
        var identifiers = new Set();
        return arr.filter(function(item) {
          var identifier = fn2(item);
          if (!identifiers.has(identifier)) {
            identifiers.add(identifier);
            return true;
          }
        });
      }
      function mergeByName(modifiers) {
        var merged = modifiers.reduce(function(merged2, current) {
          var existing = merged2[current.name];
          merged2[current.name] = existing ? Object.assign({}, existing, current, {
            options: Object.assign({}, existing.options, current.options),
            data: Object.assign({}, existing.data, current.data)
          }) : current;
          return merged2;
        }, {});
        return Object.keys(merged).map(function(key) {
          return merged[key];
        });
      }
      var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
      var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
      var DEFAULT_OPTIONS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
      };
      function areValidElements() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return !args.some(function(element) {
          return !(element && typeof element.getBoundingClientRect === "function");
        });
      }
      function popperGenerator(generatorOptions) {
        if (generatorOptions === void 0) {
          generatorOptions = {};
        }
        var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
        return function createPopper2(reference2, popper2, options) {
          if (options === void 0) {
            options = defaultOptions;
          }
          var state2 = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
            modifiersData: {},
            elements: {
              reference: reference2,
              popper: popper2
            },
            attributes: {},
            styles: {}
          };
          var effectCleanupFns = [];
          var isDestroyed = false;
          var instance = {
            state: state2,
            setOptions: function setOptions(setOptionsAction) {
              var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
              cleanupModifierEffects();
              state2.options = Object.assign({}, defaultOptions, state2.options, options2);
              state2.scrollParents = {
                reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
                popper: listScrollParents(popper2)
              };
              var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
              state2.orderedModifiers = orderedModifiers.filter(function(m2) {
                return m2.enabled;
              });
              {
                var modifiers = uniqueBy([].concat(orderedModifiers, state2.options.modifiers), function(_ref) {
                  var name = _ref.name;
                  return name;
                });
                validateModifiers(modifiers);
                if (getBasePlacement(state2.options.placement) === auto) {
                  var flipModifier = state2.orderedModifiers.find(function(_ref2) {
                    var name = _ref2.name;
                    return name === "flip";
                  });
                  if (!flipModifier) {
                    console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
                  }
                }
                var _getComputedStyle = getComputedStyle$1(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
                if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
                  return parseFloat(margin);
                })) {
                  console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
                }
              }
              runModifierEffects();
              return instance.update();
            },
            forceUpdate: function forceUpdate() {
              if (isDestroyed) {
                return;
              }
              var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
              if (!areValidElements(reference3, popper3)) {
                {
                  console.error(INVALID_ELEMENT_ERROR);
                }
                return;
              }
              state2.rects = {
                reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
                popper: getLayoutRect(popper3)
              };
              state2.reset = false;
              state2.placement = state2.options.placement;
              state2.orderedModifiers.forEach(function(modifier) {
                return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
              });
              var __debug_loops__ = 0;
              for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
                {
                  __debug_loops__ += 1;
                  if (__debug_loops__ > 100) {
                    console.error(INFINITE_LOOP_ERROR);
                    break;
                  }
                }
                if (state2.reset === true) {
                  state2.reset = false;
                  index2 = -1;
                  continue;
                }
                var _state$orderedModifie = state2.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                if (typeof fn2 === "function") {
                  state2 = fn2({
                    state: state2,
                    options: _options,
                    name,
                    instance
                  }) || state2;
                }
              }
            },
            update: debounce(function() {
              return new Promise(function(resolve) {
                instance.forceUpdate();
                resolve(state2);
              });
            }),
            destroy: function destroy() {
              cleanupModifierEffects();
              isDestroyed = true;
            }
          };
          if (!areValidElements(reference2, popper2)) {
            {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return instance;
          }
          instance.setOptions(options).then(function(state3) {
            if (!isDestroyed && options.onFirstUpdate) {
              options.onFirstUpdate(state3);
            }
          });
          function runModifierEffects() {
            state2.orderedModifiers.forEach(function(_ref3) {
              var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
              if (typeof effect2 === "function") {
                var cleanupFn = effect2({
                  state: state2,
                  name,
                  instance,
                  options: options2
                });
                var noopFn = function noopFn2() {
                };
                effectCleanupFns.push(cleanupFn || noopFn);
              }
            });
          }
          function cleanupModifierEffects() {
            effectCleanupFns.forEach(function(fn2) {
              return fn2();
            });
            effectCleanupFns = [];
          }
          return instance;
        };
      }
      var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
      var createPopper = /* @__PURE__ */ popperGenerator({
        defaultModifiers
      });
      var script$5 = {
        name: "Popover",
        emits: ["before-show", "after-show", "before-hide", "after-hide"],
        render: function render11() {
          var _this = this;
          return h$5("div", {
            class: ["vc-popover-content-wrapper", {
              "is-interactive": this.isInteractive
            }],
            ref: "popover"
          }, [h$5(script$6, {
            name: this.transition,
            appear: true,
            "on-before-enter": this.beforeEnter,
            "on-after-enter": this.afterEnter,
            "on-before-leave": this.beforeLeave,
            "on-after-leave": this.afterLeave
          }, {
            default: function _default() {
              return _this.isVisible ? h$5("div", {
                tabindex: -1,
                class: ["vc-popover-content", "direction-".concat(_this.direction), _this.contentClass],
                style: _this.contentStyle
              }, [_this.content, h$5("span", {
                class: ["vc-popover-caret", "direction-".concat(_this.direction), "align-".concat(_this.alignment)]
              })]) : null;
            }
          })]);
        },
        props: {
          id: {
            type: String,
            required: true
          },
          contentClass: String
        },
        data: function data2() {
          return {
            ref: null,
            opts: null,
            data: null,
            transition: "slide-fade",
            transitionTranslate: "15px",
            transitionDuration: "0.15s",
            placement: "bottom",
            positionFixed: false,
            modifiers: [],
            isInteractive: false,
            isHovered: false,
            isFocused: false,
            showDelay: 0,
            hideDelay: 110,
            autoHide: false,
            popperEl: null
          };
        },
        computed: {
          content: function content() {
            var _this2 = this;
            return isFunction_1(this.$slots.default) && this.$slots.default({
              direction: this.direction,
              alignment: this.alignment,
              data: this.data,
              updateLayout: this.setupPopper,
              hide: function hide2(opts) {
                return _this2.hide(opts);
              }
            }) || this.$slots.default;
          },
          contentStyle: function contentStyle() {
            return {
              "--slide-translate": this.transitionTranslate,
              "--slide-duration": this.transitionDuration
            };
          },
          popperOptions: function popperOptions() {
            return {
              placement: this.placement,
              strategy: this.positionFixed ? "fixed" : "absolute",
              modifiers: [{
                name: "onUpdate",
                enabled: true,
                phase: "afterWrite",
                fn: this.onPopperUpdate
              }].concat(_toConsumableArray(this.modifiers || [])),
              onFirstUpdate: this.onPopperUpdate
            };
          },
          isVisible: function isVisible() {
            return !!(this.ref && this.content);
          },
          direction: function direction() {
            return this.placement && this.placement.split("-")[0] || "bottom";
          },
          alignment: function alignment() {
            var isLeftRight = this.direction === "left" || this.direction === "right";
            var alignment2 = this.placement.split("-");
            alignment2 = alignment2.length > 1 ? alignment2[1] : "";
            if (["start", "top", "left"].includes(alignment2)) {
              return isLeftRight ? "top" : "left";
            }
            if (["end", "bottom", "right"].includes(alignment2)) {
              return isLeftRight ? "bottom" : "right";
            }
            return isLeftRight ? "middle" : "center";
          }
        },
        watch: {
          opts: function opts(val, oldVal) {
            if (oldVal && oldVal.callback) {
              oldVal.callback(_objectSpread2$1(_objectSpread2$1({}, oldVal), {}, {
                completed: !val,
                reason: val ? "Overridden by action" : null
              }));
            }
          }
        },
        mounted: function mounted() {
          this.popoverEl = this.$refs.popover;
          this.addEvents();
        },
        beforeUnmount: function beforeUnmount() {
          this.destroyPopper();
          this.removeEvents();
          this.popoverEl = null;
        },
        methods: {
          addEvents: function addEvents() {
            on$2(this.popoverEl, "click", this.onClick);
            on$2(this.popoverEl, "mouseover", this.onMouseOver);
            on$2(this.popoverEl, "mouseleave", this.onMouseLeave);
            on$2(this.popoverEl, "focusin", this.onFocusIn);
            on$2(this.popoverEl, "focusout", this.onFocusOut);
            on$2(document, "keydown", this.onDocumentKeydown);
            on$2(document, "click", this.onDocumentClick);
            on$2(document, "show-popover", this.onDocumentShowPopover);
            on$2(document, "hide-popover", this.onDocumentHidePopover);
            on$2(document, "toggle-popover", this.onDocumentTogglePopover);
            on$2(document, "update-popover", this.onDocumentUpdatePopover);
          },
          removeEvents: function removeEvents() {
            off$1(this.popoverEl, "click", this.onClick);
            off$1(this.popoverEl, "mouseover", this.onMouseOver);
            off$1(this.popoverEl, "mouseleave", this.onMouseLeave);
            off$1(this.popoverEl, "focusin", this.onFocusIn);
            off$1(this.popoverEl, "focusout", this.onFocusOut);
            off$1(document, "keydown", this.onDocumentKeydown);
            off$1(document, "click", this.onDocumentClick);
            off$1(document, "show-popover", this.onDocumentShowPopover);
            off$1(document, "hide-popover", this.onDocumentHidePopover);
            off$1(document, "toggle-popover", this.onDocumentTogglePopover);
            off$1(document, "update-popover", this.onDocumentUpdatePopover);
          },
          onClick: function onClick(e2) {
            e2.stopPropagation();
          },
          onMouseOver: function onMouseOver() {
            this.isHovered = true;
            if (this.isInteractive)
              this.show();
          },
          onMouseLeave: function onMouseLeave() {
            this.isHovered = false;
            if (this.autoHide && !this.isFocused && (!this.ref || this.ref !== document.activeElement)) {
              this.hide();
            }
          },
          onFocusIn: function onFocusIn() {
            this.isFocused = true;
            if (this.isInteractive)
              this.show();
          },
          onFocusOut: function onFocusOut(e2) {
            if (!e2.relatedTarget || !elementContains(this.popoverEl, e2.relatedTarget)) {
              this.isFocused = false;
              if (!this.isHovered && this.autoHide)
                this.hide();
            }
          },
          onDocumentClick: function onDocumentClick(e2) {
            if (!this.$refs.popover || !this.ref) {
              return;
            }
            if (elementContains(this.popoverEl, e2.target) || elementContains(this.ref, e2.target)) {
              return;
            }
            this.hide();
          },
          onDocumentKeydown: function onDocumentKeydown(e2) {
            if (e2.key === "Esc" || e2.key === "Escape") {
              this.hide();
            }
          },
          onDocumentShowPopover: function onDocumentShowPopover(_ref) {
            var detail = _ref.detail;
            if (!detail.id || detail.id !== this.id)
              return;
            this.show(detail);
          },
          onDocumentHidePopover: function onDocumentHidePopover(_ref2) {
            var detail = _ref2.detail;
            if (!detail.id || detail.id !== this.id)
              return;
            this.hide(detail);
          },
          onDocumentTogglePopover: function onDocumentTogglePopover(_ref3) {
            var detail = _ref3.detail;
            if (!detail.id || detail.id !== this.id)
              return;
            this.toggle(detail);
          },
          onDocumentUpdatePopover: function onDocumentUpdatePopover(_ref4) {
            var detail = _ref4.detail;
            if (!detail.id || detail.id !== this.id)
              return;
            this.update(detail);
          },
          show: function show() {
            var _this3 = this;
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            opts.action = "show";
            var ref2 = opts.ref || this.ref;
            var delay = opts.showDelay >= 0 ? opts.showDelay : this.showDelay;
            if (!ref2) {
              if (opts.callback) {
                opts.callback({
                  completed: false,
                  reason: "Invalid reference element provided"
                });
              }
              return;
            }
            clearTimeout(this.timeout);
            this.opts = opts;
            var fn2 = function fn3() {
              Object.assign(_this3, omit_1(opts, ["id"]));
              _this3.setupPopper();
              _this3.opts = null;
            };
            if (delay > 0) {
              this.timeout = setTimeout(function() {
                return fn2();
              }, delay);
            } else {
              fn2();
            }
          },
          hide: function hide2() {
            var _this4 = this;
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            opts.action = "hide";
            var ref2 = opts.ref || this.ref;
            var delay = opts.hideDelay >= 0 ? opts.hideDelay : this.hideDelay;
            if (!this.ref || ref2 !== this.ref) {
              if (opts.callback) {
                opts.callback(_objectSpread2$1(_objectSpread2$1({}, opts), {}, {
                  completed: false,
                  reason: this.ref ? "Invalid reference element provided" : "Popover already hidden"
                }));
              }
              return;
            }
            var fn2 = function fn3() {
              _this4.ref = null;
              _this4.opts = null;
            };
            clearTimeout(this.timeout);
            this.opts = opts;
            if (delay > 0) {
              this.timeout = setTimeout(fn2, delay);
            } else {
              fn2();
            }
          },
          toggle: function toggle() {
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (this.isVisible && opts.ref === this.ref) {
              this.hide(opts);
            } else {
              this.show(opts);
            }
          },
          update: function update2() {
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            Object.assign(this, omit_1(opts, ["id"]));
            this.setupPopper();
          },
          setupPopper: function setupPopper() {
            var _this5 = this;
            this.$nextTick(function() {
              if (!_this5.ref || !_this5.$refs.popover)
                return;
              if (_this5.popper && _this5.popper.reference !== _this5.ref) {
                _this5.destroyPopper();
              }
              if (!_this5.popper) {
                _this5.popper = createPopper(_this5.ref, _this5.popoverEl, _this5.popperOptions);
              } else {
                _this5.popper.update();
              }
            });
          },
          onPopperUpdate: function onPopperUpdate(args) {
            if (args.placement) {
              this.placement = args.placement;
            } else if (args.state) {
              this.placement = args.state.placement;
            }
          },
          beforeEnter: function beforeEnter(e2) {
            this.$emit("before-show", e2);
          },
          afterEnter: function afterEnter(e2) {
            this.$emit("after-show", e2);
          },
          beforeLeave: function beforeLeave(e2) {
            this.$emit("before-hide", e2);
          },
          afterLeave: function afterLeave(e2) {
            this.destroyPopper();
            this.$emit("after-hide", e2);
          },
          destroyPopper: function destroyPopper() {
            if (this.popper) {
              this.popper.destroy();
              this.popper = null;
            }
          }
        }
      };
      var css_248z$4 = ".vc-popover-content-wrapper {\n  --popover-horizontal-content-offset: 8px;\n  --popover-vertical-content-offset: 10px;\n  --popover-caret-horizontal-offset: 18px;\n  --popover-caret-vertical-offset: 8px;\n\n  position: absolute;\n  display: block;\n  outline: none;\n  z-index: 10;\n}\n.vc-popover-content-wrapper:not(.is-interactive) {\n    pointer-events: none;\n}\n.vc-popover-content {\n  position: relative;\n  outline: none;\n  z-index: 10;\n  box-shadow: var(--shadow-lg);\n}\n.vc-popover-content.direction-bottom {\n    margin-top: var(--popover-vertical-content-offset);\n}\n.vc-popover-content.direction-top {\n    margin-bottom: var(--popover-vertical-content-offset);\n}\n.vc-popover-content.direction-left {\n    margin-right: var(--popover-horizontal-content-offset);\n}\n.vc-popover-content.direction-right {\n    margin-left: var(--popover-horizontal-content-offset);\n}\n.vc-popover-caret {\n  content: '';\n  position: absolute;\n  display: block;\n  width: 12px;\n  height: 12px;\n  border-top: inherit;\n  border-left: inherit;\n  background-color: inherit;\n  z-index: -1;\n}\n.vc-popover-caret.direction-bottom {\n    top: 0;\n}\n.vc-popover-caret.direction-bottom.align-left {\n      -webkit-transform: translateY(-50%) rotate(45deg);\n              transform: translateY(-50%) rotate(45deg);\n}\n.vc-popover-caret.direction-bottom.align-center {\n      -webkit-transform: translateX(-50%) translateY(-50%) rotate(45deg);\n              transform: translateX(-50%) translateY(-50%) rotate(45deg);\n}\n.vc-popover-caret.direction-bottom.align-right {\n      -webkit-transform: translateY(-50%) rotate(45deg);\n              transform: translateY(-50%) rotate(45deg);\n}\n.vc-popover-caret.direction-top {\n    top: 100%;\n}\n.vc-popover-caret.direction-top.align-left {\n      -webkit-transform: translateY(-50%) rotate(-135deg);\n              transform: translateY(-50%) rotate(-135deg);\n}\n.vc-popover-caret.direction-top.align-center {\n      -webkit-transform: translateX(-50%) translateY(-50%) rotate(-135deg);\n              transform: translateX(-50%) translateY(-50%) rotate(-135deg);\n}\n.vc-popover-caret.direction-top.align-right {\n      -webkit-transform: translateY(-50%) rotate(-135deg);\n              transform: translateY(-50%) rotate(-135deg);\n}\n.vc-popover-caret.direction-left {\n    left: 100%;\n}\n.vc-popover-caret.direction-left.align-top {\n      -webkit-transform: translateX(-50%) rotate(135deg);\n              transform: translateX(-50%) rotate(135deg);\n}\n.vc-popover-caret.direction-left.align-middle {\n      -webkit-transform: translateY(-50%) translateX(-50%) rotate(135deg);\n              transform: translateY(-50%) translateX(-50%) rotate(135deg);\n}\n.vc-popover-caret.direction-left.align-bottom {\n      -webkit-transform: translateX(-50%) rotate(135deg);\n              transform: translateX(-50%) rotate(135deg);\n}\n.vc-popover-caret.direction-right {\n    left: 0;\n}\n.vc-popover-caret.direction-right.align-top {\n      -webkit-transform: translateX(-50%) rotate(-45deg);\n              transform: translateX(-50%) rotate(-45deg);\n}\n.vc-popover-caret.direction-right.align-middle {\n      -webkit-transform: translateY(-50%) translateX(-50%) rotate(-45deg);\n              transform: translateY(-50%) translateX(-50%) rotate(-45deg);\n}\n.vc-popover-caret.direction-right.align-bottom {\n      -webkit-transform: translateX(-50%) rotate(-45deg);\n              transform: translateX(-50%) rotate(-45deg);\n}\n.vc-popover-caret.align-left {\n    left: var(--popover-caret-horizontal-offset);\n}\n.vc-popover-caret.align-center {\n    left: 50%;\n}\n.vc-popover-caret.align-right {\n    right: var(--popover-caret-horizontal-offset);\n}\n.vc-popover-caret.align-top {\n    top: var(--popover-caret-vertical-offset);\n}\n.vc-popover-caret.align-middle {\n    top: 50%;\n}\n.vc-popover-caret.align-bottom {\n    bottom: var(--popover-caret-vertical-offset);\n}\n";
      styleInject(css_248z$4);
      var script$4 = {
        name: "PopoverRow",
        mixins: [childMixin$1],
        props: {
          attribute: Object
        },
        computed: {
          indicator: function indicator() {
            var _this$attribute = this.attribute, highlight = _this$attribute.highlight, dot = _this$attribute.dot, bar = _this$attribute.bar, popover = _this$attribute.popover;
            if (popover && popover.hideIndicator)
              return null;
            if (highlight) {
              var _highlight$start = highlight.start, color = _highlight$start.color, isDark = _highlight$start.isDark;
              return {
                style: _objectSpread2$1(_objectSpread2$1({}, this.theme.bgAccentHigh({
                  color,
                  isDark: !isDark
                })), {}, {
                  width: "10px",
                  height: "5px",
                  borderRadius: "3px"
                })
              };
            }
            if (dot) {
              var _dot$start = dot.start, _color = _dot$start.color, _isDark = _dot$start.isDark;
              return {
                style: _objectSpread2$1(_objectSpread2$1({}, this.theme.bgAccentHigh({
                  color: _color,
                  isDark: !_isDark
                })), {}, {
                  width: "5px",
                  height: "5px",
                  borderRadius: "50%"
                })
              };
            }
            if (bar) {
              var _bar$start = bar.start, _color2 = _bar$start.color, _isDark2 = _bar$start.isDark;
              return {
                style: _objectSpread2$1(_objectSpread2$1({}, this.theme.bgAccentHigh({
                  color: _color2,
                  isDark: !_isDark2
                })), {}, {
                  width: "10px",
                  height: "3px"
                })
              };
            }
            return null;
          }
        }
      };
      var _hoisted_1$n = {
        class: "vc-day-popover-row"
      };
      var _hoisted_2$m = {
        key: 0,
        class: "vc-day-popover-row-indicator"
      };
      var _hoisted_3$f = {
        class: "vc-day-popover-row-content"
      };
      function render$3(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createBlock("div", _hoisted_1$n, [$options.indicator ? (openBlock(), createBlock("div", _hoisted_2$m, [createVNode("span", {
          style: $options.indicator.style,
          class: $options.indicator.class
        }, null, 6)])) : createCommentVNode("", true), createVNode("div", _hoisted_3$f, [renderSlot(_ctx.$slots, "default", {}, function() {
          return [createTextVNode(toDisplayString($props.attribute.popover ? $props.attribute.popover.label : "No content provided"), 1)];
        })])]);
      }
      var css_248z$3 = ".vc-day-popover-row {\n  --day-content-transition-time: 0.13s ease-in;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  transition: all var(--day-content-transition-time);\n}\n.vc-day-popover-row:not(:first-child) {\n    margin-top: 3px;\n}\n.vc-day-popover-row-indicator {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-flex-grow: 0;\n      -ms-flex-positive: 0;\n          flex-grow: 0;\n  width: 15px;\n  margin-right: 3px;\n}\n.vc-day-popover-row-indicator span {\n    transition: all var(--day-content-transition-time);\n}\n.vc-day-popover-row-content {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-flex-wrap: none;\n      -ms-flex-wrap: none;\n          flex-wrap: none;\n  -webkit-flex-grow: 1;\n      -ms-flex-positive: 1;\n          flex-grow: 1;\n  width: -webkit-max-content;\n  width: max-content;\n}\n";
      styleInject(css_248z$3);
      script$4.render = render$3;
      function addMonths(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var date = toDate(dirtyDate);
        var amount = toInteger(dirtyAmount);
        if (isNaN(amount)) {
          return new Date(NaN);
        }
        if (!amount) {
          return date;
        }
        var dayOfMonth = date.getDate();
        var endOfDesiredMonth = new Date(date.getTime());
        endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
        var daysInMonth = endOfDesiredMonth.getDate();
        if (dayOfMonth >= daysInMonth) {
          return endOfDesiredMonth;
        } else {
          date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
          return date;
        }
      }
      function addYears(dirtyDate, dirtyAmount) {
        requiredArgs(2, arguments);
        var amount = toInteger(dirtyAmount);
        return addMonths(dirtyDate, amount * 12);
      }
      var AttributeStore = /* @__PURE__ */ function() {
        function AttributeStore2(theme, locale, attrs) {
          _classCallCheck(this, AttributeStore2);
          this.theme = theme;
          this.locale = locale;
          this.map = {};
          this.refresh(attrs, true);
        }
        _createClass(AttributeStore2, [{
          key: "destroy",
          value: function destroy() {
            this.theme = null;
            this.locale = null;
            this.map = {};
            this.list = [];
            this.pinAttr = null;
          }
        }, {
          key: "refresh",
          value: function refresh(attrs, reset) {
            var _this = this;
            var map2 = {};
            var list = [];
            var pinAttr = null;
            var adds = [];
            var deletes = reset ? new Set() : new Set(Object.keys(this.map));
            if (arrayHasItems(attrs)) {
              attrs.forEach(function(attr, i2) {
                if (!attr || !attr.dates)
                  return;
                var key = attr.key ? attr.key.toString() : i2.toString();
                var order2 = attr.order || 0;
                var hashcode = hash$2(JSON.stringify(attr));
                var exAttr = _this.map[key];
                if (!reset && exAttr && exAttr.hashcode === hashcode) {
                  deletes.delete(key);
                } else {
                  exAttr = new Attribute(_objectSpread2$1({
                    key,
                    order: order2,
                    hashcode
                  }, attr), _this.theme, _this.locale);
                  adds.push(exAttr);
                }
                if (exAttr && exAttr.pinPage) {
                  pinAttr = exAttr;
                }
                map2[key] = exAttr;
                list.push(exAttr);
              });
            }
            this.map = map2;
            this.list = list;
            this.pinAttr = pinAttr;
            return {
              adds,
              deletes: Array.from(deletes)
            };
          }
        }]);
        return AttributeStore2;
      }();
      var addHorizontalSwipeHandler = function addHorizontalSwipeHandler2(element, handler, _ref) {
        var maxSwipeTime2 = _ref.maxSwipeTime, minHorizontalSwipeDistance2 = _ref.minHorizontalSwipeDistance, maxVerticalSwipeDistance2 = _ref.maxVerticalSwipeDistance;
        if (!element || !element.addEventListener || !isFunction_1(handler)) {
          return null;
        }
        var startX = 0;
        var startY = 0;
        var startTime = null;
        var isSwiping = false;
        function touchStart(e2) {
          var t2 = e2.changedTouches[0];
          startX = t2.screenX;
          startY = t2.screenY;
          startTime = new Date().getTime();
          isSwiping = true;
        }
        function touchEnd(e2) {
          if (!isSwiping)
            return;
          isSwiping = false;
          var t2 = e2.changedTouches[0];
          var deltaX = t2.screenX - startX;
          var deltaY = t2.screenY - startY;
          var deltaTime = new Date().getTime() - startTime;
          if (deltaTime < maxSwipeTime2) {
            if (Math.abs(deltaX) >= minHorizontalSwipeDistance2 && Math.abs(deltaY) <= maxVerticalSwipeDistance2) {
              var arg = {
                toLeft: false,
                toRight: false
              };
              if (deltaX < 0) {
                arg.toLeft = true;
              } else {
                arg.toRight = true;
              }
              handler(arg);
            }
          }
        }
        on$2(element, "touchstart", touchStart, {
          passive: true
        });
        on$2(element, "touchend", touchEnd, {
          passive: true
        });
        return function() {
          off$1(element, "touchstart", touchStart);
          off$1(element, "touchend", touchEnd);
        };
      };
      var script$3 = {
        name: "Calendar",
        emits: ["dayfocusin", "dayfocusout", "transition-start", "transition-end", "update:from-page", "update:to-page"],
        render: function render11() {
          var _this = this;
          var panes = this.pages.map(function(page, i2) {
            var position = i2 + 1;
            var row = Math.ceil((i2 + 1) / _this.columns);
            var rowFromEnd = _this.rows - row + 1;
            var column = position % _this.columns || _this.columns;
            var columnFromEnd = _this.columns - column + 1;
            return h$5(script$9, _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
              key: page.key,
              attributes: _this.store,
              page,
              position,
              row,
              rowFromEnd,
              column,
              columnFromEnd,
              titlePosition: _this.titlePosition,
              canMove: _this.canMove,
              "onUpdate:page": function onUpdatePage(e2) {
                return _this.move(e2, {
                  position: i2 + 1
                });
              },
              onDayfocusin: function onDayfocusin(e2) {
                _this.lastFocusedDay = e2;
                _this.$emit("dayfocusin", e2);
              },
              onDayfocusout: function onDayfocusout(e2) {
                _this.lastFocusedDay = null;
                _this.$emit("dayfocusout", e2);
              }
            }), _this.$slots);
          });
          var getArrowButton = function getArrowButton2(isPrev) {
            var click = function click2() {
              return _this.move(isPrev ? -_this.step_ : _this.step_);
            };
            var keydown = function keydown2(e2) {
              return onSpaceOrEnter(e2, click);
            };
            var isDisabled = isPrev ? !_this.canMovePrev : !_this.canMoveNext;
            return h$5("div", {
              class: ["vc-arrow", "is-".concat(isPrev ? "left" : "right"), {
                "is-disabled": isDisabled
              }],
              role: "button",
              onClick: click,
              onKeydown: keydown
            }, [(isPrev ? _this.safeSlot("header-left-button", {
              click
            }) : _this.safeSlot("header-right-button", {
              click
            })) || h$5(script$8, {
              name: isPrev ? "left-arrow" : "right-arrow"
            })]);
          };
          var getNavPopover = function getNavPopover2() {
            return h$5(script$5, {
              id: _this.sharedState.navPopoverId,
              contentClass: "vc-nav-popover-container",
              ref: "navPopover"
            }, {
              default: function _default(_ref) {
                var data2 = _ref.data;
                var position = data2.position, page = data2.page;
                return h$5(script$7, {
                  value: page,
                  position,
                  validator: function validator2(e2) {
                    return _this.canMove(e2, {
                      position
                    });
                  },
                  onInput: function onInput(e2) {
                    return _this.move(e2);
                  }
                }, _objectSpread2$1({}, _this.$slots));
              }
            });
          };
          var getDayPopover = function getDayPopover2() {
            return h$5(script$5, {
              id: _this.sharedState.dayPopoverId,
              contentClass: "vc-day-popover-container"
            }, {
              default: function _default(_ref2) {
                var day = _ref2.data, updateLayout = _ref2.updateLayout, hide2 = _ref2.hide;
                var attributes = Object.values(day.attributes).filter(function(a2) {
                  return a2.popover;
                });
                var masks2 = _this.$locale.masks;
                var format2 = _this.formatDate;
                var dayTitle = format2(day.date, masks2.dayPopover);
                return _this.safeSlot("day-popover", {
                  day,
                  attributes,
                  masks: masks2,
                  format: format2,
                  dayTitle,
                  updateLayout,
                  hide: hide2
                }, h$5("div", [
                  masks2.dayPopover && h$5("div", {
                    class: ["vc-day-popover-header"]
                  }, [dayTitle]),
                  attributes.map(function(attribute) {
                    return h$5(script$4, {
                      key: attribute.key,
                      attribute
                    });
                  })
                ]));
              }
            });
          };
          return h$5("div", {
            "data-helptext": "Press the arrow keys to navigate by day, Home and End to navigate to week ends, PageUp and PageDown to navigate by month, Alt+PageUp and Alt+PageDown to navigate by year",
            class: ["vc-container", "vc-".concat(this.$theme.color), {
              "vc-is-expanded": this.isExpanded,
              "vc-is-dark": this.$theme.isDark
            }],
            onKeydown: this.handleKeydown,
            onMouseup: function onMouseup(e2) {
              return e2.preventDefault();
            },
            ref: "container"
          }, [getNavPopover(), h$5("div", {
            class: ["vc-pane-container", {
              "in-transition": this.inTransition
            }]
          }, [h$5(script$6, {
            name: this.transitionName,
            "on-before-enter": function onBeforeEnter() {
              _this.inTransition = true;
            },
            "on-after-enter": function onAfterEnter() {
              _this.inTransition = false;
            }
          }, {
            default: function _default() {
              return h$5("div", _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
                class: "vc-pane-layout",
                style: {
                  gridTemplateColumns: "repeat(".concat(_this.columns, ", 1fr)")
                },
                key: _this.firstPage ? _this.firstPage.key : ""
              }), panes);
            }
          }), h$5("div", {
            class: ["vc-arrows-container title-".concat(this.titlePosition)]
          }, [getArrowButton(true), getArrowButton(false)]), this.$slots.footer && this.$slots.footer()]), getDayPopover()]);
        },
        mixins: [rootMixin$1, slotMixin$1],
        provide: function provide2() {
          return {
            sharedState: this.sharedState
          };
        },
        props: {
          rows: {
            type: Number,
            default: 1
          },
          columns: {
            type: Number,
            default: 1
          },
          step: Number,
          titlePosition: {
            type: String,
            default: getDefault("titlePosition")
          },
          isExpanded: Boolean,
          fromDate: Date,
          toDate: Date,
          fromPage: Object,
          toPage: Object,
          minPage: Object,
          maxPage: Object,
          transition: String,
          attributes: [Object, Array],
          trimWeeks: Boolean,
          disablePageSwipe: Boolean
        },
        data: function data2() {
          return {
            pages: [],
            store: null,
            lastFocusedDay: null,
            focusableDay: new Date().getDate(),
            transitionName: "",
            inTransition: false,
            sharedState: {
              navPopoverId: createGuid(),
              dayPopoverId: createGuid(),
              theme: {},
              masks: {},
              locale: {}
            }
          };
        },
        computed: {
          firstPage: function firstPage() {
            return head_1(this.pages);
          },
          lastPage: function lastPage() {
            return last_1(this.pages);
          },
          minPage_: function minPage_() {
            return this.minPage || this.pageForDate(this.minDate);
          },
          maxPage_: function maxPage_() {
            return this.maxPage || this.pageForDate(this.maxDate);
          },
          count: function count() {
            return this.rows * this.columns;
          },
          step_: function step_() {
            return this.step || this.count;
          },
          canMovePrev: function canMovePrev() {
            return this.canMove(-this.step_);
          },
          canMoveNext: function canMoveNext() {
            return this.canMove(this.step_);
          }
        },
        watch: {
          $locale: function $locale() {
            this.refreshLocale();
            this.refreshPages({
              page: this.firstPage,
              ignoreCache: true
            });
            this.initStore();
          },
          $theme: function $theme() {
            this.refreshTheme();
            this.initStore();
          },
          fromDate: function fromDate() {
            this.refreshPages();
          },
          fromPage: function fromPage(val) {
            var firstPage = this.pages && this.pages[0];
            if (pageIsEqualToPage(val, firstPage))
              return;
            this.refreshPages();
          },
          toPage: function toPage(val) {
            var lastPage = this.pages && this.pages[this.pages.length - 1];
            if (pageIsEqualToPage(val, lastPage))
              return;
            this.refreshPages();
          },
          count: function count() {
            this.refreshPages();
          },
          attributes: {
            handler: function handler(val) {
              var _this$store$refresh = this.store.refresh(val), adds = _this$store$refresh.adds, deletes = _this$store$refresh.deletes;
              this.refreshAttrs(this.pages, adds, deletes);
            },
            deep: true
          },
          pages: function pages(val) {
            this.refreshAttrs(val, this.store.list, null, true);
          },
          disabledAttribute: function disabledAttribute() {
            this.refreshDisabledDays();
          },
          lastFocusedDay: function lastFocusedDay(val) {
            if (val) {
              this.focusableDay = val.day;
              this.refreshFocusableDays();
            }
          },
          inTransition: function inTransition(val) {
            if (val) {
              this.$emit("transition-start");
            } else {
              this.$emit("transition-end");
              if (this.transitionPromise) {
                this.transitionPromise.resolve(true);
                this.transitionPromise = null;
              }
            }
          }
        },
        created: function created() {
          this.refreshLocale();
          this.refreshTheme();
          this.initStore();
          this.refreshPages();
        },
        mounted: function mounted() {
          var _this2 = this;
          if (!this.disablePageSwipe) {
            this.removeHandlers = addHorizontalSwipeHandler(this.$refs.container, function(_ref3) {
              var toLeft = _ref3.toLeft, toRight = _ref3.toRight;
              if (toLeft) {
                _this2.moveNext();
              } else if (toRight) {
                _this2.movePrev();
              }
            }, getDefault("touch"));
          }
        },
        beforeUnmount: function beforeUnmount() {
          this.pages = [];
          this.store.destroy();
          this.store = null;
          this.sharedState = null;
          if (this.removeHandlers)
            this.removeHandlers();
        },
        methods: {
          refreshLocale: function refreshLocale() {
            this.sharedState.locale = this.$locale;
            this.sharedState.masks = this.$locale.masks;
          },
          refreshTheme: function refreshTheme() {
            this.sharedState.theme = this.$theme;
          },
          canMove: function canMove(arg) {
            var _this3 = this;
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var page = this.firstPage && this.$locale.toPage(arg, this.firstPage);
            if (!page)
              return false;
            var position = opts.position;
            if (isNumber_1(arg))
              position = 1;
            if (!position) {
              if (pageIsBeforePage(page, this.firstPage)) {
                position = -1;
              } else if (pageIsAfterPage(page, this.lastPage)) {
                position = 1;
              } else {
                return true;
              }
            }
            Object.assign(opts, this.getTargetPageRange(page, {
              position,
              force: true
            }));
            return pageRangeToArray(opts.fromPage, opts.toPage).some(function(p2) {
              return pageIsBetweenPages(p2, _this3.minPage_, _this3.maxPage_);
            });
          },
          movePrev: function movePrev(opts) {
            return this.move(-this.step_, opts);
          },
          moveNext: function moveNext(opts) {
            return this.move(this.step_, opts);
          },
          move: function move(arg) {
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var canMove = this.canMove(arg, opts);
            if (!opts.force && !canMove) {
              return Promise.reject(new Error("Move target is disabled: ".concat(JSON.stringify(opts))));
            }
            this.$refs.navPopover.hide({
              hideDelay: 0
            });
            if (opts.fromPage && !pageIsEqualToPage(opts.fromPage, this.firstPage)) {
              return this.refreshPages(_objectSpread2$1(_objectSpread2$1({}, opts), {}, {
                page: opts.fromPage,
                position: 1,
                force: true
              }));
            }
            return Promise.resolve(true);
          },
          focusDate: function focusDate(date) {
            var _this4 = this;
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this.move(date, opts).then(function() {
              var focusableEl = _this4.$el.querySelector(".id-".concat(_this4.$locale.getDayId(date), ".in-month .vc-focusable"));
              if (focusableEl) {
                focusableEl.focus();
                return Promise.resolve(true);
              }
              return Promise.resolve(false);
            });
          },
          showPageRange: function showPageRange(range, opts) {
            var fromPage;
            var toPage;
            if (isDate$1$1(range)) {
              fromPage = this.pageForDate(range);
            } else if (isObject$1$1(range)) {
              var month = range.month, year = range.year;
              var from = range.from, to2 = range.to;
              if (isNumber_1(month) && isNumber_1(year)) {
                fromPage = range;
              } else if (from || to2) {
                fromPage = isDate$1$1(from) ? this.pageForDate(from) : from;
                toPage = isDate$1$1(to2) ? this.pageForDate(to2) : to2;
              }
            } else {
              return Promise.reject(new Error("Invalid page range provided."));
            }
            var lastPage = this.lastPage;
            var page = fromPage;
            if (pageIsAfterPage(toPage, lastPage)) {
              page = addPages(toPage, -(this.pages.length - 1));
            }
            if (pageIsBeforePage(page, fromPage)) {
              page = fromPage;
            }
            return this.refreshPages(_objectSpread2$1(_objectSpread2$1({}, opts), {}, {
              page
            }));
          },
          getTargetPageRange: function getTargetPageRange(page) {
            var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, position = _ref4.position, force = _ref4.force;
            var fromPage = null;
            var toPage = null;
            if (pageIsValid(page)) {
              var pagesToAdd = 0;
              position = +position;
              if (!isNaN(position)) {
                pagesToAdd = position > 0 ? 1 - position : -(this.count + position);
              }
              fromPage = addPages(page, pagesToAdd);
            } else {
              fromPage = this.getDefaultInitialPage();
            }
            toPage = addPages(fromPage, this.count - 1);
            if (!force) {
              if (pageIsBeforePage(fromPage, this.minPage_)) {
                fromPage = this.minPage_;
              } else if (pageIsAfterPage(toPage, this.maxPage_)) {
                fromPage = addPages(this.maxPage_, 1 - this.count);
              }
              toPage = addPages(fromPage, this.count - 1);
            }
            return {
              fromPage,
              toPage
            };
          },
          getDefaultInitialPage: function getDefaultInitialPage() {
            var page = this.fromPage || this.pageForDate(this.fromDate);
            if (!pageIsValid(page)) {
              var toPage = this.toPage || this.pageForDate(this.toPage);
              if (pageIsValid(toPage)) {
                page = addPages(toPage, 1 - this.count);
              }
            }
            if (!pageIsValid(page)) {
              page = this.getPageForAttributes();
            }
            if (!pageIsValid(page)) {
              page = this.pageForThisMonth();
            }
            return page;
          },
          refreshPages: function refreshPages() {
            var _this5 = this;
            var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, page = _ref5.page, _ref5$position = _ref5.position, position = _ref5$position === void 0 ? 1 : _ref5$position, force = _ref5.force, transition = _ref5.transition, ignoreCache = _ref5.ignoreCache;
            return new Promise(function(resolve, reject) {
              var _this5$getTargetPageR = _this5.getTargetPageRange(page, {
                position,
                force
              }), fromPage = _this5$getTargetPageR.fromPage, toPage = _this5$getTargetPageR.toPage;
              var pages = [];
              for (var i2 = 0; i2 < _this5.count; i2++) {
                pages.push(_this5.buildPage(addPages(fromPage, i2), ignoreCache));
              }
              _this5.refreshDisabledDays(pages);
              _this5.refreshFocusableDays(pages);
              _this5.transitionName = _this5.getPageTransition(_this5.pages[0], pages[0], transition);
              _this5.pages = pages;
              _this5.$emit("update:from-page", fromPage);
              _this5.$emit("update:to-page", toPage);
              if (_this5.transitionName && _this5.transitionName !== "none") {
                _this5.transitionPromise = {
                  resolve,
                  reject
                };
              } else {
                resolve(true);
              }
            });
          },
          refreshDisabledDays: function refreshDisabledDays(pages) {
            var _this6 = this;
            this.getPageDays(pages).forEach(function(d2) {
              d2.isDisabled = !!_this6.disabledAttribute && _this6.disabledAttribute.intersectsDay(d2);
            });
          },
          refreshFocusableDays: function refreshFocusableDays(pages) {
            var _this7 = this;
            this.getPageDays(pages).forEach(function(d2) {
              d2.isFocusable = d2.inMonth && d2.day === _this7.focusableDay;
            });
          },
          getPageDays: function getPageDays() {
            var pages = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pages;
            return pages.reduce(function(prev, curr) {
              return prev.concat(curr.days);
            }, []);
          },
          getPageTransition: function getPageTransition(oldPage, newPage) {
            var transition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.transition;
            if (transition === "none")
              return transition;
            if (transition === "fade" || !transition && this.count > 1 || !pageIsValid(oldPage) || !pageIsValid(newPage)) {
              return "fade";
            }
            var movePrev = pageIsBeforePage(newPage, oldPage);
            if (transition === "slide-v") {
              return movePrev ? "slide-down" : "slide-up";
            }
            return movePrev ? "slide-right" : "slide-left";
          },
          getPageForAttributes: function getPageForAttributes() {
            var page = null;
            var attr = this.store.pinAttr;
            if (attr && attr.hasDates) {
              var _attr$dates = _slicedToArray(attr.dates, 1), date = _attr$dates[0];
              date = date.start || date.date;
              page = this.pageForDate(date);
            }
            return page;
          },
          buildPage: function buildPage(_ref6, ignoreCache) {
            var _this8 = this;
            var month = _ref6.month, year = _ref6.year;
            var key = "".concat(year.toString(), "-").concat(month.toString());
            var page = this.pages.find(function(p2) {
              return p2.key === key;
            });
            if (!page || ignoreCache) {
              var date = new Date(year, month - 1, 15);
              var monthComps = this.$locale.getMonthComps(month, year);
              var prevMonthComps = this.$locale.getPrevMonthComps(month, year);
              var nextMonthComps = this.$locale.getNextMonthComps(month, year);
              page = {
                key,
                month,
                year,
                weeks: this.trimWeeks ? monthComps.weeks : 6,
                title: this.$locale.format(date, this.$locale.masks.title),
                shortMonthLabel: this.$locale.format(date, "MMM"),
                monthLabel: this.$locale.format(date, "MMMM"),
                shortYearLabel: year.toString().substring(2),
                yearLabel: year.toString(),
                monthComps,
                prevMonthComps,
                nextMonthComps,
                canMove: function canMove(pg) {
                  return _this8.canMove(pg);
                },
                move: function move(pg) {
                  return _this8.move(pg);
                },
                moveThisMonth: function moveThisMonth() {
                  return _this8.moveThisMonth();
                },
                movePrevMonth: function movePrevMonth() {
                  return _this8.move(prevMonthComps);
                },
                moveNextMonth: function moveNextMonth() {
                  return _this8.move(nextMonthComps);
                },
                refresh: true
              };
              page.days = this.$locale.getCalendarDays(page);
            }
            return page;
          },
          initStore: function initStore() {
            this.store = new AttributeStore(this.$theme, this.$locale, this.attributes);
            this.refreshAttrs(this.pages, this.store.list, [], true);
          },
          refreshAttrs: function refreshAttrs() {
            var pages = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var adds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            var deletes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            var reset = arguments.length > 3 ? arguments[3] : void 0;
            if (!arrayHasItems(pages))
              return;
            pages.forEach(function(p2) {
              p2.days.forEach(function(d2) {
                var shouldRefresh = false;
                var map2 = {};
                if (reset) {
                  shouldRefresh = true;
                } else if (hasAny(d2.attributesMap, deletes)) {
                  map2 = omit_1(d2.attributesMap, deletes);
                  shouldRefresh = true;
                } else {
                  map2 = d2.attributesMap || {};
                }
                adds.forEach(function(attr) {
                  var targetDate = attr.intersectsDay(d2);
                  if (targetDate) {
                    var newAttr = _objectSpread2$1(_objectSpread2$1({}, attr), {}, {
                      targetDate
                    });
                    map2[attr.key] = newAttr;
                    shouldRefresh = true;
                  }
                });
                if (shouldRefresh) {
                  d2.attributesMap = map2;
                  d2.shouldRefresh = true;
                }
              });
            });
          },
          handleKeydown: function handleKeydown(e2) {
            var day = this.lastFocusedDay;
            if (day != null) {
              day.event = e2;
              this.handleDayKeydown(day);
            }
          },
          handleDayKeydown: function handleDayKeydown(day) {
            var dateFromTime = day.dateFromTime, event = day.event;
            var date = dateFromTime(12);
            var newDate = null;
            switch (event.key) {
              case "ArrowLeft": {
                newDate = addDays(date, -1);
                break;
              }
              case "ArrowRight": {
                newDate = addDays(date, 1);
                break;
              }
              case "ArrowUp": {
                newDate = addDays(date, -7);
                break;
              }
              case "ArrowDown": {
                newDate = addDays(date, 7);
                break;
              }
              case "Home": {
                newDate = addDays(date, -day.weekdayPosition + 1);
                break;
              }
              case "End": {
                newDate = addDays(date, day.weekdayPositionFromEnd);
                break;
              }
              case "PageUp": {
                if (event.altKey) {
                  newDate = addYears(date, -1);
                } else {
                  newDate = addMonths(date, -1);
                }
                break;
              }
              case "PageDown": {
                if (event.altKey) {
                  newDate = addYears(date, 1);
                } else {
                  newDate = addMonths(date, 1);
                }
                break;
              }
            }
            if (newDate) {
              event.preventDefault();
              this.focusDate(newDate).catch();
            }
          }
        }
      };
      var css_248z$2 = ".vc-container {\n  --white: #ffffff;\n  --black: #000000;\n\n  --gray-100: #f7fafc;\n  --gray-200: #edf2f7;\n  --gray-300: #e2e8f0;\n  --gray-400: #cbd5e0;\n  --gray-500: #a0aec0;\n  --gray-600: #718096;\n  --gray-700: #4a5568;\n  --gray-800: #2d3748;\n  --gray-900: #1a202c;\n\n  --red-100: #fff5f5;\n  --red-200: #fed7d7;\n  --red-300: #feb2b2;\n  --red-400: #fc8181;\n  --red-500: #f56565;\n  --red-600: #e53e3e;\n  --red-700: #c53030;\n  --red-800: #9b2c2c;\n  --red-900: #742a2a;\n\n  --orange-100: #fffaf0;\n  --orange-200: #feebc8;\n  --orange-300: #fbd38d;\n  --orange-400: #f6ad55;\n  --orange-500: #ed8936;\n  --orange-600: #dd6b20;\n  --orange-700: #c05621;\n  --orange-800: #9c4221;\n  --orange-900: #7b341e;\n\n  --yellow-100: #fffff0;\n  --yellow-200: #fefcbf;\n  --yellow-300: #faf089;\n  --yellow-400: #f6e05e;\n  --yellow-500: #ecc94b;\n  --yellow-600: #d69e2e;\n  --yellow-700: #b7791f;\n  --yellow-800: #975a16;\n  --yellow-900: #744210;\n\n  --green-100: #f0fff4;\n  --green-200: #c6f6d5;\n  --green-300: #9ae6b4;\n  --green-400: #68d391;\n  --green-500: #48bb78;\n  --green-600: #38a169;\n  --green-700: #2f855a;\n  --green-800: #276749;\n  --green-900: #22543d;\n\n  --teal-100: #e6fffa;\n  --teal-200: #b2f5ea;\n  --teal-300: #81e6d9;\n  --teal-400: #4fd1c5;\n  --teal-500: #38b2ac;\n  --teal-600: #319795;\n  --teal-700: #2c7a7b;\n  --teal-800: #285e61;\n  --teal-900: #234e52;\n\n  --blue-100: #ebf8ff;\n  --blue-200: #bee3f8;\n  --blue-300: #90cdf4;\n  --blue-400: #63b3ed;\n  --blue-500: #4299e1;\n  --blue-600: #3182ce;\n  --blue-700: #2b6cb0;\n  --blue-800: #2c5282;\n  --blue-900: #2a4365;\n\n  --indigo-100: #ebf4ff;\n  --indigo-200: #c3dafe;\n  --indigo-300: #a3bffa;\n  --indigo-400: #7f9cf5;\n  --indigo-500: #667eea;\n  --indigo-600: #5a67d8;\n  --indigo-700: #4c51bf;\n  --indigo-800: #434190;\n  --indigo-900: #3c366b;\n\n  --purple-100: #faf5ff;\n  --purple-200: #e9d8fd;\n  --purple-300: #d6bcfa;\n  --purple-400: #b794f4;\n  --purple-500: #9f7aea;\n  --purple-600: #805ad5;\n  --purple-700: #6b46c1;\n  --purple-800: #553c9a;\n  --purple-900: #44337a;\n\n  --pink-100: #fff5f7;\n  --pink-200: #fed7e2;\n  --pink-300: #fbb6ce;\n  --pink-400: #f687b3;\n  --pink-500: #ed64a6;\n  --pink-600: #d53f8c;\n  --pink-700: #b83280;\n  --pink-800: #97266d;\n  --pink-900: #702459;\n}\n.vc-container.vc-red {\n    --accent-100: var(--red-100);\n    --accent-200: var(--red-200);\n    --accent-300: var(--red-300);\n    --accent-400: var(--red-400);\n    --accent-500: var(--red-500);\n    --accent-600: var(--red-600);\n    --accent-700: var(--red-700);\n    --accent-800: var(--red-800);\n    --accent-900: var(--red-900);\n}\n.vc-container.vc-orange {\n    --accent-100: var(--orange-100);\n    --accent-200: var(--orange-200);\n    --accent-300: var(--orange-300);\n    --accent-400: var(--orange-400);\n    --accent-500: var(--orange-500);\n    --accent-600: var(--orange-600);\n    --accent-700: var(--orange-700);\n    --accent-800: var(--orange-800);\n    --accent-900: var(--orange-900);\n}\n.vc-container.vc-yellow {\n    --accent-100: var(--yellow-100);\n    --accent-200: var(--yellow-200);\n    --accent-300: var(--yellow-300);\n    --accent-400: var(--yellow-400);\n    --accent-500: var(--yellow-500);\n    --accent-600: var(--yellow-600);\n    --accent-700: var(--yellow-700);\n    --accent-800: var(--yellow-800);\n    --accent-900: var(--yellow-900);\n}\n.vc-container.vc-green {\n    --accent-100: var(--green-100);\n    --accent-200: var(--green-200);\n    --accent-300: var(--green-300);\n    --accent-400: var(--green-400);\n    --accent-500: var(--green-500);\n    --accent-600: var(--green-600);\n    --accent-700: var(--green-700);\n    --accent-800: var(--green-800);\n    --accent-900: var(--green-900);\n}\n.vc-container.vc-teal {\n    --accent-100: var(--teal-100);\n    --accent-200: var(--teal-200);\n    --accent-300: var(--teal-300);\n    --accent-400: var(--teal-400);\n    --accent-500: var(--teal-500);\n    --accent-600: var(--teal-600);\n    --accent-700: var(--teal-700);\n    --accent-800: var(--teal-800);\n    --accent-900: var(--teal-900);\n}\n.vc-container.vc-blue {\n    --accent-100: var(--blue-100);\n    --accent-200: var(--blue-200);\n    --accent-300: var(--blue-300);\n    --accent-400: var(--blue-400);\n    --accent-500: var(--blue-500);\n    --accent-600: var(--blue-600);\n    --accent-700: var(--blue-700);\n    --accent-800: var(--blue-800);\n    --accent-900: var(--blue-900);\n}\n.vc-container.vc-indigo {\n    --accent-100: var(--indigo-100);\n    --accent-200: var(--indigo-200);\n    --accent-300: var(--indigo-300);\n    --accent-400: var(--indigo-400);\n    --accent-500: var(--indigo-500);\n    --accent-600: var(--indigo-600);\n    --accent-700: var(--indigo-700);\n    --accent-800: var(--indigo-800);\n    --accent-900: var(--indigo-900);\n}\n.vc-container.vc-purple {\n    --accent-100: var(--purple-100);\n    --accent-200: var(--purple-200);\n    --accent-300: var(--purple-300);\n    --accent-400: var(--purple-400);\n    --accent-500: var(--purple-500);\n    --accent-600: var(--purple-600);\n    --accent-700: var(--purple-700);\n    --accent-800: var(--purple-800);\n    --accent-900: var(--purple-900);\n}\n.vc-container.vc-pink {\n    --accent-100: var(--pink-100);\n    --accent-200: var(--pink-200);\n    --accent-300: var(--pink-300);\n    --accent-400: var(--pink-400);\n    --accent-500: var(--pink-500);\n    --accent-600: var(--pink-600);\n    --accent-700: var(--pink-700);\n    --accent-800: var(--pink-800);\n    --accent-900: var(--pink-900);\n}\n.vc-container {\n\n  --font-normal: 400;\n  --font-medium: 500;\n  --font-semibold: 600;\n  --font-bold: 700;\n\n  --text-xs: 12px;\n  --text-sm: 14px;\n  --text-base: 16px;\n  --text-lg: 18px;\n\n  --leading-snug: 1.375;\n\n  --rounded: 0.25rem;\n  --rounded-lg: 0.5rem;\n  --rounded-full: 9999px;\n\n  --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1),\n    0 4px 6px -2px rgba(0, 0, 0, 0.05);\n  --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);\n\n  --slide-translate: 22px;\n  --slide-duration: 0.15s;\n  --slide-timing: ease;\n\n  --day-content-transition-time: 0.13s ease-in;\n  --weeknumber-offset: -34px;\n\n  position: relative;\n  display: -webkit-inline-flex;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  width: -webkit-max-content;\n  width: max-content;\n  height: -webkit-max-content;\n  height: max-content;\n  font-family: BlinkMacSystemFont, -apple-system, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    'Helvetica', 'Arial', sans-serif;\n  color: var(--gray-900);\n  background-color: var(--white);\n  border: 1px solid;\n  border-color: var(--gray-400);\n  border-radius: var(--rounded-lg);\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-tap-highlight-color: transparent;\n}\n.vc-container,\n  .vc-container * {\n    box-sizing: border-box;\n}\n.vc-container:focus, .vc-container *:focus {\n      outline: none;\n}\n.vc-container button,\n  .vc-container [role='button'] {\n    cursor: pointer;\n}\n.vc-container.vc-is-expanded {\n    min-width: 100%;\n}\n/* Hides double border within popovers */\n.vc-container .vc-container {\n    border: none;\n}\n.vc-container.vc-is-dark {\n    color: var(--gray-100);\n    background-color: var(--gray-900);\n    border-color: var(--gray-700);\n}\n.vc-pane-container {\n  width: 100%;\n  position: relative;\n}\n.vc-pane-container.in-transition {\n    overflow: hidden;\n}\n.vc-pane-layout {\n  display: grid;\n}\n.vc-arrow {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  cursor: pointer;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  pointer-events: auto;\n  color: var(--gray-600);\n  border-width: 2px;\n  border-style: solid;\n  border-radius: var(--rounded);\n  border-color: transparent;\n}\n.vc-arrow:hover {\n    background: var(--gray-200);\n}\n.vc-arrow:focus {\n    border-color: var(--gray-300);\n}\n.vc-arrow.is-disabled {\n    opacity: 0.25;\n    pointer-events: none;\n    cursor: not-allowed;\n}\n.vc-day-popover-container {\n  color: var(--white);\n  background-color: var(--gray-800);\n  border: 1px solid;\n  border-color: var(--gray-700);\n  border-radius: var(--rounded);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: 4px 8px;\n  box-shadow: var(--shadow);\n}\n.vc-day-popover-header {\n  font-size: var(--text-xs);\n  color: var(--gray-300);\n  font-weight: var(--font-semibold);\n  text-align: center;\n}\n.vc-arrows-container {\n  width: 100%;\n  position: absolute;\n  top: 0;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: space-between;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  padding: 8px 10px;\n  pointer-events: none;\n}\n.vc-arrows-container.title-left {\n    -webkit-justify-content: flex-end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n}\n.vc-arrows-container.title-right {\n    -webkit-justify-content: flex-start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n}\n.vc-is-dark .vc-arrow {\n    color: var(--white);\n}\n.vc-is-dark .vc-arrow:hover {\n      background: var(--gray-800);\n}\n.vc-is-dark .vc-arrow:focus {\n      border-color: var(--gray-700);\n}\n.vc-is-dark .vc-day-popover-container {\n    color: var(--gray-800);\n    background-color: var(--white);\n    border-color: var(--gray-100);\n}\n.vc-is-dark .vc-day-popover-header {\n    color: var(--gray-700);\n}\n";
      styleInject(css_248z$2);
      var script$2 = {
        inheritAttrs: false,
        emits: ["update:modelValue"],
        props: {
          options: Array,
          modelValue: null
        }
      };
      var _hoisted_1$m = {
        class: "vc-select"
      };
      var _hoisted_2$l = /* @__PURE__ */ createVNode("div", {
        class: "vc-select-arrow"
      }, [/* @__PURE__ */ createVNode("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 20 20"
      }, [/* @__PURE__ */ createVNode("path", {
        d: "M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"
      })])], -1);
      function render$2(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createBlock("div", _hoisted_1$m, [createVNode("select", mergeProps(_ctx.$attrs, {
          value: $props.modelValue,
          onChange: _cache[1] || (_cache[1] = function($event) {
            return _ctx.$emit("update:modelValue", $event.target.value);
          })
        }), [(openBlock(true), createBlock(Fragment, null, renderList($props.options, function(option) {
          return openBlock(), createBlock("option", {
            key: option.value,
            value: option.value,
            disabled: option.disabled
          }, toDisplayString(option.label), 9, ["value", "disabled"]);
        }), 128))], 16, ["value"]), _hoisted_2$l]);
      }
      var css_248z$1 = ".vc-select {\n  position: relative;\n}\n.vc-select select {\n    -webkit-flex-grow: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    display: block;\n    -webkit-appearance: none;\n            appearance: none;\n    width: 52px;\n    height: 30px;\n    font-size: var(--text-base);\n    font-weight: var(--font-medium);\n    text-align: left;\n    background-color: var(--gray-200);\n    border: 2px solid;\n    border-color: var(--gray-200);\n    color: var(--gray-900);\n    padding: 0 20px 0 8px;\n    border-radius: var(--rounded);\n    line-height: var(--leading-tight);\n    text-indent: 0px;\n    cursor: pointer;\n    -moz-padding-start: 3px;\n}\n.vc-select select:hover {\n      color: var(--gray-600);\n}\n.vc-select select:focus {\n      outline: 0;\n      border-color: var(--accent-400);\n      background-color: var(--white);\n}\n.vc-select-arrow {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  padding: 0 4px 0 0;\n  color: var(--gray-500);\n}\n.vc-select-arrow svg {\n    width: 16px;\n    height: 16px;\n    fill: currentColor;\n}\n.vc-is-dark select {\n    background: var(--gray-700);\n    color: var(--gray-100);\n    border-color: var(--gray-700);\n}\n.vc-is-dark select:hover {\n      color: var(--gray-400);\n}\n.vc-is-dark select:focus {\n      border-color: var(--accent-500);\n      background-color: var(--gray-800);\n}\n";
      styleInject(css_248z$1);
      script$2.render = render$2;
      var script$1 = {
        name: "TimePicker",
        components: {
          TimeSelect: script$2
        },
        emits: ["update:modelValue"],
        props: {
          modelValue: {
            type: Object,
            required: true
          },
          locale: {
            type: Object,
            required: true
          },
          theme: {
            type: Object,
            required: true
          },
          is24hr: {
            type: Boolean,
            default: true
          },
          minuteIncrement: {
            type: Number,
            default: 1
          },
          showBorder: Boolean
        },
        data: function data2() {
          return {
            hours: 0,
            minutes: 0,
            isAM: true
          };
        },
        computed: {
          date: function date() {
            var date2 = this.locale.normalizeDate(this.modelValue);
            if (this.modelValue.hours === 24) {
              date2 = new Date(date2.getTime() - 1);
            }
            return date2;
          },
          hourOptions: function hourOptions() {
            var options12 = [{
              value: 0,
              label: "12"
            }, {
              value: 1,
              label: "1"
            }, {
              value: 2,
              label: "2"
            }, {
              value: 3,
              label: "3"
            }, {
              value: 4,
              label: "4"
            }, {
              value: 5,
              label: "5"
            }, {
              value: 6,
              label: "6"
            }, {
              value: 7,
              label: "7"
            }, {
              value: 8,
              label: "8"
            }, {
              value: 9,
              label: "9"
            }, {
              value: 10,
              label: "10"
            }, {
              value: 11,
              label: "11"
            }];
            var options24 = [{
              value: 0,
              label: "00"
            }, {
              value: 1,
              label: "01"
            }, {
              value: 2,
              label: "02"
            }, {
              value: 3,
              label: "03"
            }, {
              value: 4,
              label: "04"
            }, {
              value: 5,
              label: "05"
            }, {
              value: 6,
              label: "06"
            }, {
              value: 7,
              label: "07"
            }, {
              value: 8,
              label: "08"
            }, {
              value: 9,
              label: "09"
            }, {
              value: 10,
              label: "10"
            }, {
              value: 11,
              label: "11"
            }, {
              value: 12,
              label: "12"
            }, {
              value: 13,
              label: "13"
            }, {
              value: 14,
              label: "14"
            }, {
              value: 15,
              label: "15"
            }, {
              value: 16,
              label: "16"
            }, {
              value: 17,
              label: "17"
            }, {
              value: 18,
              label: "18"
            }, {
              value: 19,
              label: "19"
            }, {
              value: 20,
              label: "20"
            }, {
              value: 21,
              label: "21"
            }, {
              value: 22,
              label: "22"
            }, {
              value: 23,
              label: "23"
            }];
            if (this.is24hr)
              return options24;
            return options12;
          },
          minuteOptions: function minuteOptions() {
            var options = [];
            var m2 = 0;
            var added = false;
            while (m2 <= 59) {
              options.push({
                value: m2,
                label: pad$1(m2, 2)
              });
              added = added || m2 === this.minutes;
              m2 += this.minuteIncrement;
              if (!added && m2 > this.minutes) {
                added = true;
                options.push({
                  value: this.minutes,
                  label: pad$1(this.minutes, 2),
                  disabled: true
                });
              }
            }
            return options;
          }
        },
        watch: {
          modelValue: function modelValue() {
            this.setup();
          },
          hours: function hours() {
            this.updateValue();
          },
          minutes: function minutes() {
            this.updateValue();
          },
          isAM: function isAM() {
            this.updateValue();
          }
        },
        created: function created() {
          this.setup();
        },
        methods: {
          protected: function _protected(fn2) {
            var _this = this;
            if (this.busy)
              return;
            this.busy = true;
            fn2();
            this.$nextTick(function() {
              return _this.busy = false;
            });
          },
          setup: function setup2() {
            var _this2 = this;
            this.protected(function() {
              var hours = _this2.modelValue.hours;
              if (hours === 24)
                hours = 0;
              var isAM = true;
              if (!_this2.is24hr && hours >= 12) {
                hours -= 12;
                isAM = false;
              }
              _this2.hours = hours;
              _this2.minutes = _this2.modelValue.minutes;
              _this2.isAM = isAM;
            });
          },
          updateValue: function updateValue() {
            var _this3 = this;
            this.protected(function() {
              var hours = _this3.hours;
              if (!_this3.is24hr && !_this3.isAM) {
                hours += 12;
              }
              _this3.$emit("update:modelValue", _objectSpread2$1(_objectSpread2$1({}, _this3.modelValue), {}, {
                hours,
                minutes: _this3.minutes,
                seconds: 0,
                milliseconds: 0
              }));
            });
          }
        }
      };
      var _withId = /* @__PURE__ */ withScopeId("data-v-63f66eaa");
      pushScopeId("data-v-63f66eaa");
      var _hoisted_1$l = /* @__PURE__ */ createVNode("div", null, [/* @__PURE__ */ createVNode("svg", {
        fill: "none",
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": "2",
        viewBox: "0 0 24 24",
        class: "vc-time-icon",
        stroke: "currentColor"
      }, [/* @__PURE__ */ createVNode("path", {
        d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
      })])], -1);
      var _hoisted_2$k = {
        class: "vc-time-content"
      };
      var _hoisted_3$e = {
        key: 0,
        class: "vc-time-date"
      };
      var _hoisted_4$b = {
        class: "vc-time-weekday"
      };
      var _hoisted_5$8 = {
        class: "vc-time-month"
      };
      var _hoisted_6$5 = {
        class: "vc-time-day"
      };
      var _hoisted_7$4 = {
        class: "vc-time-year"
      };
      var _hoisted_8$5 = {
        class: "vc-time-select"
      };
      var _hoisted_9$4 = /* @__PURE__ */ createVNode("span", {
        style: {
          "margin": "0 4px"
        }
      }, ":", -1);
      var _hoisted_10$3 = {
        key: 0,
        class: "vc-am-pm"
      };
      popScopeId();
      var render$1 = /* @__PURE__ */ _withId(function render11(_ctx, _cache, $props, $setup, $data, $options) {
        var _component_time_select = resolveComponent("time-select");
        return openBlock(), createBlock("div", {
          class: ["vc-time-picker", [{
            "vc-invalid": !$props.modelValue.isValid,
            "vc-bordered": $props.showBorder
          }]]
        }, [_hoisted_1$l, createVNode("div", _hoisted_2$k, [$options.date ? (openBlock(), createBlock("div", _hoisted_3$e, [createVNode("span", _hoisted_4$b, toDisplayString($props.locale.format($options.date, "WWW")), 1), createVNode("span", _hoisted_5$8, toDisplayString($props.locale.format($options.date, "MMM")), 1), createVNode("span", _hoisted_6$5, toDisplayString($props.locale.format($options.date, "D")), 1), createVNode("span", _hoisted_7$4, toDisplayString($props.locale.format($options.date, "YYYY")), 1)])) : createCommentVNode("", true), createVNode("div", _hoisted_8$5, [createVNode(_component_time_select, {
          modelValue: $data.hours,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = function($event) {
            return $data.hours = $event;
          }),
          modelModifiers: {
            number: true
          },
          options: $options.hourOptions
        }, null, 8, ["modelValue", "options"]), _hoisted_9$4, createVNode(_component_time_select, {
          modelValue: $data.minutes,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = function($event) {
            return $data.minutes = $event;
          }),
          modelModifiers: {
            number: true
          },
          options: $options.minuteOptions
        }, null, 8, ["modelValue", "options"]), !$props.is24hr ? (openBlock(), createBlock("div", _hoisted_10$3, [createVNode("button", {
          class: {
            active: $data.isAM
          },
          onClick: _cache[3] || (_cache[3] = withModifiers(function($event) {
            return $data.isAM = true;
          }, ["prevent"])),
          type: "button"
        }, " AM ", 2), createVNode("button", {
          class: {
            active: !$data.isAM
          },
          onClick: _cache[4] || (_cache[4] = withModifiers(function($event) {
            return $data.isAM = false;
          }, ["prevent"])),
          type: "button"
        }, " PM ", 2)])) : createCommentVNode("", true)])])], 2);
      });
      var css_248z = ".vc-time-picker[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  padding: 8px;\n}\n.vc-time-picker.vc-invalid[data-v-63f66eaa] {\n    pointer-events: none;\n    opacity: 0.5;\n}\n.vc-time-picker.vc-bordered[data-v-63f66eaa] {\n    border-top: 1px solid var(--gray-400);\n}\n.vc-time-icon[data-v-63f66eaa] {\n  width: 16px;\n  height: 16px;\n  color: var(--gray-600);\n}\n.vc-time-content[data-v-63f66eaa] {\n  margin-left: 8px;\n}\n.vc-time-date[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  text-transform: uppercase;\n  padding: 0 0 4px 4px;\n  margin-top: -4px;\n  line-height: 21px;\n}\n.vc-time-weekday[data-v-63f66eaa] {\n  color: var(--gray-700);\n  letter-spacing: var(--tracking-wide);\n}\n.vc-time-month[data-v-63f66eaa] {\n  color: var(--accent-600);\n  margin-left: 8px;\n}\n.vc-time-day[data-v-63f66eaa] {\n  color: var(--accent-600);\n  margin-left: 4px;\n}\n.vc-time-year[data-v-63f66eaa] {\n  color: var(--gray-500);\n  margin-left: 8px;\n}\n.vc-time-select[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n.vc-am-pm[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  background: var(--gray-200);\n  color: var(--gray-800);\n  margin-left: 8px;\n  padding: 4px;\n  border-radius: var(--rounded);\n  height: 30px;\n}\n.vc-am-pm button[data-v-63f66eaa] {\n    font-size: var(--text-sm);\n    font-weight: var(--font-medium);\n    padding: 0 4px;\n    background: transparent;\n    border: 2px solid transparent;\n    border-radius: var(--rounded);\n    line-height: var(--leading-snug);\n}\n.vc-am-pm button[data-v-63f66eaa]:hover {\n      color: var(--gray-600);\n}\n.vc-am-pm button[data-v-63f66eaa]:focus {\n      border-color: var(--accent-400);\n}\n.vc-am-pm button.active[data-v-63f66eaa] {\n      background: var(--accent-600);\n      color: var(--white);\n}\n.vc-am-pm button.active[data-v-63f66eaa]:hover {\n        background: var(--accent-500);\n}\n.vc-am-pm button.active[data-v-63f66eaa]:focus {\n        border-color: var(--accent-400);\n}\n.vc-is-dark .vc-time-picker[data-v-63f66eaa] {\n    border-color: var(--gray-700);\n}\n.vc-is-dark .vc-time-icon[data-v-63f66eaa] {\n    color: var(--gray-400);\n}\n.vc-is-dark .vc-time-weekday[data-v-63f66eaa] {\n    color: var(--gray-400);\n}\n.vc-is-dark .vc-time-month[data-v-63f66eaa] {\n    color: var(--accent-400);\n}\n.vc-is-dark .vc-time-day[data-v-63f66eaa] {\n    color: var(--accent-400);\n}\n.vc-is-dark .vc-time-year[data-v-63f66eaa] {\n    color: var(--gray-500);\n}\n.vc-is-dark .vc-am-pm[data-v-63f66eaa] {\n    background: var(--gray-700);\n}\n.vc-is-dark .vc-am-pm[data-v-63f66eaa]:focus {\n      border-color: var(--accent-500);\n}\n.vc-is-dark .vc-am-pm button[data-v-63f66eaa] {\n      color: var(--gray-100);\n}\n.vc-is-dark .vc-am-pm button[data-v-63f66eaa]:hover {\n        color: var(--gray-400);\n}\n.vc-is-dark .vc-am-pm button[data-v-63f66eaa]:focus {\n        border-color: var(--accent-500);\n}\n.vc-is-dark .vc-am-pm button.active[data-v-63f66eaa] {\n        background: var(--accent-500);\n        color: var(--white);\n}\n.vc-is-dark .vc-am-pm button.active[data-v-63f66eaa]:hover {\n          background: var(--accent-600);\n}\n.vc-is-dark .vc-am-pm button.active[data-v-63f66eaa]:focus {\n          border-color: var(--accent-500);\n}\n";
      styleInject(css_248z);
      script$1.render = render$1;
      script$1.__scopeId = "data-v-63f66eaa";
      var _dateConfig = {
        type: "auto",
        mask: "iso",
        timeAdjust: ""
      };
      var _rangeConfig = {
        start: _objectSpread2$1({}, _dateConfig),
        end: _objectSpread2$1({}, _dateConfig)
      };
      var MODE = {
        DATE: "date",
        DATE_TIME: "datetime",
        TIME: "time"
      };
      var RANGE_PRIORITY = {
        NONE: 0,
        START: 1,
        END: 2,
        BOTH: 3
      };
      var script = {
        name: "DatePicker",
        emits: ["update:modelValue", "drag", "dayclick", "daykeydown", "popover-will-show", "popover-did-show", "popover-will-hide", "popover-did-hide"],
        render: function render11() {
          var _this = this;
          var _footer = function footer(wrap, wrapperEl) {
            if (!_this.$slots.footer)
              return wrap;
            var children = [wrap, _this.$slots.footer()];
            return wrapperEl ? h$5(wrapperEl, children) : children;
          };
          var timePicker = function timePicker2() {
            if (!_this.dateParts)
              return null;
            var parts = _this.isRange ? _this.dateParts : [_this.dateParts[0]];
            return h$5("div", {}, _objectSpread2$1(_objectSpread2$1({}, _this.$slots), {}, {
              default: function _default() {
                return parts.map(function(dp, idx) {
                  return h$5(script$1, {
                    modelValue: dp,
                    locale: _this.$locale,
                    theme: _this.$theme,
                    is24hr: _this.is24hr,
                    minuteIncrement: _this.minuteIncrement,
                    showBorder: !_this.isTime,
                    isDisabled: _this.isDateTime && !dp.isValid || _this.isDragging,
                    "onUpdate:modelValue": function onUpdateModelValue(p2) {
                      return _this.onTimeInput(p2, idx === 0);
                    }
                  });
                });
              }
            }));
          };
          var calendar = function calendar2() {
            return h$5(script$3, _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
              attributes: _this.attributes_,
              theme: _this.$theme,
              locale: _this.$locale,
              minDate: _this.minDateExact || _this.minDate,
              maxDate: _this.maxDateExact || _this.maxDate,
              disabledDates: _this.disabledDates,
              availableDates: _this.availableDates,
              onDayclick: _this.onDayClick,
              onDaykeydown: _this.onDayKeydown,
              onDaymouseenter: _this.onDayMouseEnter,
              ref: "calendar"
            }), _objectSpread2$1(_objectSpread2$1({}, _this.$slots), {}, {
              footer: function footer() {
                return _this.isDateTime ? _footer(timePicker()) : _footer();
              }
            }));
          };
          var content = function content2() {
            if (_this.isTime) {
              return h$5("div", {
                class: ["vc-container", "vc-".concat(_this.$theme.color), {
                  "vc-is-dark": _this.$theme.isDark
                }]
              }, _footer(timePicker(), "div"));
            }
            return calendar();
          };
          return this.$slots.default ? h$5("div", [
            this.$slots.default(this.slotArgs),
            h$5(script$5, {
              id: this.datePickerPopoverId,
              placement: "bottom-start",
              contentClass: "vc-container".concat(this.isDark ? " vc-is-dark" : ""),
              "on-before-show": function onBeforeShow(e2) {
                return _this.$emit("popover-will-show", e2);
              },
              "on-after-show": function onAfterShow(e2) {
                return _this.$emit("popover-did-show", e2);
              },
              "on-before-hide": function onBeforeHide(e2) {
                return _this.$emit("popover-will-hide", e2);
              },
              "on-after-hide": function onAfterHide(e2) {
                return _this.$emit("popover-did-hide", e2);
              },
              ref: "popover"
            }, {
              default: content
            })
          ]) : content();
        },
        mixins: [rootMixin$1],
        props: {
          mode: {
            type: String,
            default: MODE.DATE
          },
          modelValue: {
            type: null,
            required: true
          },
          modelConfig: {
            type: Object,
            default: function _default() {
              return _objectSpread2$1({}, _dateConfig);
            }
          },
          is24hr: Boolean,
          minuteIncrement: Number,
          isRequired: Boolean,
          isRange: Boolean,
          updateOnInput: {
            type: Boolean,
            default: getDefault("datePicker.updateOnInput")
          },
          inputDebounce: {
            type: Number,
            default: getDefault("datePicker.inputDebounce")
          },
          popover: {
            type: Object,
            default: function _default() {
              return {};
            }
          },
          dragAttribute: Object,
          selectAttribute: Object,
          attributes: Array
        },
        data: function data2() {
          return {
            value_: null,
            dateParts: null,
            activeDate: "",
            dragValue: null,
            inputValues: ["", ""],
            updateTimeout: null,
            watchValue: true,
            datePickerPopoverId: createGuid()
          };
        },
        computed: {
          isDate: function isDate2() {
            return this.mode.toLowerCase() === MODE.DATE;
          },
          isDateTime: function isDateTime() {
            return this.mode.toLowerCase() === MODE.DATE_TIME;
          },
          isTime: function isTime() {
            return this.mode.toLowerCase() === MODE.TIME;
          },
          isDragging: function isDragging2() {
            return !!this.dragValue;
          },
          modelConfig_: function modelConfig_() {
            if (this.isRange) {
              return {
                start: _objectSpread2$1(_objectSpread2$1({}, _rangeConfig.start), this.modelConfig.start || this.modelConfig),
                end: _objectSpread2$1(_objectSpread2$1({}, _rangeConfig.end), this.modelConfig.end || this.modelConfig)
              };
            }
            return _objectSpread2$1(_objectSpread2$1({}, _dateConfig), this.modelConfig);
          },
          inputMask: function inputMask() {
            var masks2 = this.$locale.masks;
            if (this.isTime) {
              return this.is24hr ? masks2.inputTime24hr : masks2.inputTime;
            }
            if (this.isDateTime) {
              return this.is24hr ? masks2.inputDateTime24hr : masks2.inputDateTime;
            }
            return this.$locale.masks.input;
          },
          inputMaskHasTime: function inputMaskHasTime() {
            return /[Hh]/g.test(this.inputMask);
          },
          inputMaskHasDate: function inputMaskHasDate() {
            return /[dD]{1,2}|Do|W{1,4}|M{1,4}|YY(?:YY)?/g.test(this.inputMask);
          },
          inputMaskPatch: function inputMaskPatch() {
            if (this.inputMaskHasTime && this.inputMaskHasDate) {
              return PATCH.DATE_TIME;
            }
            if (this.inputMaskHasDate)
              return PATCH.DATE;
            if (this.inputMaskHasTime)
              return PATCH.TIME;
            return void 0;
          },
          slotArgs: function slotArgs() {
            var _this2 = this;
            var isRange = this.isRange, isDragging2 = this.isDragging, updateValue = this.updateValue, showPopover2 = this.showPopover, hidePopover2 = this.hidePopover, togglePopover2 = this.togglePopover;
            var inputValue = isRange ? {
              start: this.inputValues[0],
              end: this.inputValues[1]
            } : this.inputValues[0];
            var events2 = [true, false].map(function(isStart) {
              return _objectSpread2$1({
                input: _this2.onInputInput(isStart),
                change: _this2.onInputChange(isStart),
                keyup: _this2.onInputKeyup
              }, getPopoverTriggerEvents(_objectSpread2$1(_objectSpread2$1({}, _this2.popover_), {}, {
                id: _this2.datePickerPopoverId,
                callback: function callback(e2) {
                  if (e2.action === "show" && e2.completed) {
                    _this2.onInputShow(isStart);
                  }
                }
              })));
            });
            var inputEvents = isRange ? {
              start: events2[0],
              end: events2[1]
            } : events2[0];
            return {
              inputValue,
              inputEvents,
              isDragging: isDragging2,
              updateValue,
              showPopover: showPopover2,
              hidePopover: hidePopover2,
              togglePopover: togglePopover2,
              getPopoverTriggerEvents
            };
          },
          popover_: function popover_() {
            return defaultsDeep_1(this.popover, getDefault("datePicker.popover"));
          },
          selectAttribute_: function selectAttribute_() {
            if (!this.hasValue(this.value_))
              return null;
            var attribute = _objectSpread2$1(_objectSpread2$1({
              key: "select-drag"
            }, this.selectAttribute), {}, {
              dates: this.value_,
              pinPage: true
            });
            var dot = attribute.dot, bar = attribute.bar, highlight = attribute.highlight, content = attribute.content;
            if (!dot && !bar && !highlight && !content) {
              attribute.highlight = true;
            }
            return attribute;
          },
          dragAttribute_: function dragAttribute_() {
            if (!this.isRange || !this.hasValue(this.dragValue)) {
              return null;
            }
            var attribute = _objectSpread2$1(_objectSpread2$1({
              key: "select-drag"
            }, this.dragAttribute), {}, {
              dates: this.dragValue
            });
            var dot = attribute.dot, bar = attribute.bar, highlight = attribute.highlight, content = attribute.content;
            if (!dot && !bar && !highlight && !content) {
              attribute.highlight = {
                startEnd: {
                  fillMode: "outline"
                }
              };
            }
            return attribute;
          },
          attributes_: function attributes_() {
            var attrs = isArrayLikeObject_1(this.attributes) ? _toConsumableArray(this.attributes) : [];
            if (this.dragAttribute_) {
              attrs.push(this.dragAttribute_);
            } else if (this.selectAttribute_) {
              attrs.push(this.selectAttribute_);
            }
            return attrs;
          }
        },
        watch: {
          inputMask: function inputMask() {
            this.formatInput();
          },
          modelValue: function modelValue(val) {
            if (!this.watchValue)
              return;
            this.forceUpdateValue(val, {
              config: this.modelConfig,
              notify: false,
              formatInput: true,
              hidePopover: false
            });
          },
          value_: function value_() {
            this.refreshDateParts();
          },
          dragValue: function dragValue() {
            this.refreshDateParts();
          },
          timezone: function timezone() {
            this.refreshDateParts();
            this.forceUpdateValue(this.value_, {
              notify: true,
              formatInput: true
            });
          }
        },
        created: function created() {
          this.forceUpdateValue(this.modelValue, {
            config: this.modelConfig_,
            notify: false,
            formatInput: true,
            hidePopover: false
          });
          this.refreshDateParts();
        },
        mounted: function mounted() {
          on$2(document, "keydown", this.onDocumentKeyDown);
          on$2(document, "click", this.onDocumentClick);
        },
        beforeUnmount: function beforeUnmount() {
          off$1(document, "keydown", this.onDocumentKeyDown);
          off$1(document, "click", this.onDocumentClick);
        },
        methods: {
          getDateParts: function getDateParts(date) {
            return this.$locale.getDateParts(date);
          },
          getDateFromParts: function getDateFromParts(parts) {
            return this.$locale.getDateFromParts(parts);
          },
          refreshDateParts: function refreshDateParts() {
            var _this3 = this;
            var value = this.dragValue || this.value_;
            var dateParts = [];
            if (this.isRange) {
              if (value && value.start) {
                dateParts.push(this.getDateParts(value.start));
              } else {
                dateParts.push({});
              }
              if (value && value.end) {
                dateParts.push(this.getDateParts(value.end));
              } else {
                dateParts.push({});
              }
            } else if (value) {
              dateParts.push(this.getDateParts(value));
            } else {
              dateParts.push({});
            }
            this.$nextTick(function() {
              return _this3.dateParts = dateParts;
            });
          },
          onDocumentKeyDown: function onDocumentKeyDown(e2) {
            if (this.dragValue && e2.key === "Escape") {
              this.dragValue = null;
            }
          },
          onDocumentClick: function onDocumentClick(e2) {
            if (document.body.contains(e2.target) && !elementContains(this.$el, e2.target)) {
              this.dragValue = null;
              this.formatInput();
            }
          },
          onDayClick: function onDayClick(day) {
            this.handleDayClick(day);
            this.$emit("dayclick", day);
          },
          onDayKeydown: function onDayKeydown(day) {
            switch (day.event.key) {
              case " ":
              case "Enter": {
                this.handleDayClick(day);
                day.event.preventDefault();
                break;
              }
              case "Escape": {
                this.hidePopover();
              }
            }
            this.$emit("daykeydown", day);
          },
          handleDayClick: function handleDayClick(day) {
            var _this$popover_ = this.popover_, keepVisibleOnInput = _this$popover_.keepVisibleOnInput, visibility = _this$popover_.visibility;
            var opts = {
              patch: PATCH.DATE,
              adjustTime: true,
              formatInput: true,
              hidePopover: this.isDate && !keepVisibleOnInput && visibility !== "visible"
            };
            if (this.isRange) {
              if (!this.isDragging) {
                this.dragTrackingValue = _objectSpread2$1({}, day.range);
              } else {
                this.dragTrackingValue.end = day.date;
              }
              opts.isDragging = !this.isDragging;
              opts.rangePriority = opts.isDragging ? RANGE_PRIORITY.NONE : RANGE_PRIORITY.BOTH;
              opts.hidePopover = opts.hidePopover && !opts.isDragging;
              this.updateValue(this.dragTrackingValue, opts);
            } else {
              opts.clearIfEqual = !this.isRequired;
              this.updateValue(day.date, opts);
            }
          },
          onDayMouseEnter: function onDayMouseEnter(day) {
            if (!this.isDragging)
              return;
            this.dragTrackingValue.end = day.date;
            this.updateValue(this.dragTrackingValue, {
              patch: PATCH.DATE,
              adjustTime: true,
              formatInput: true,
              hidePriority: false,
              rangePriority: RANGE_PRIORITY.NONE
            });
          },
          onTimeInput: function onTimeInput(parts, isStart) {
            var _this4 = this;
            var value = null;
            if (this.isRange) {
              var start2 = isStart ? parts : this.dateParts[0];
              var end2 = isStart ? this.dateParts[1] : parts;
              value = {
                start: start2,
                end: end2
              };
            } else {
              value = parts;
            }
            this.updateValue(value, {
              patch: PATCH.TIME,
              rangePriority: isStart ? RANGE_PRIORITY.START : RANGE_PRIORITY.END
            }).then(function() {
              return _this4.adjustPageRange(isStart);
            });
          },
          onInputInput: function onInputInput(isStart) {
            var _this5 = this;
            return function(e2) {
              if (!_this5.updateOnInput)
                return;
              _this5.onInputUpdate(e2.target.value, isStart, {
                formatInput: false,
                hidePopover: false,
                debounce: _this5.inputDebounce
              });
            };
          },
          onInputChange: function onInputChange(isStart) {
            var _this6 = this;
            return function(e2) {
              _this6.onInputUpdate(e2.target.value, isStart, {
                formatInput: true,
                hidePopover: false
              });
            };
          },
          onInputUpdate: function onInputUpdate(inputValue, isStart, opts) {
            var _this7 = this;
            this.inputValues.splice(isStart ? 0 : 1, 1, inputValue);
            var value = this.isRange ? {
              start: this.inputValues[0],
              end: this.inputValues[1] || this.inputValues[0]
            } : inputValue;
            var config = {
              type: "string",
              mask: this.inputMask
            };
            this.updateValue(value, _objectSpread2$1(_objectSpread2$1({}, opts), {}, {
              config,
              patch: this.inputMaskPatch,
              rangePriority: isStart ? RANGE_PRIORITY.START : RANGE_PRIORITY.END
            })).then(function() {
              return _this7.adjustPageRange(isStart);
            });
          },
          onInputShow: function onInputShow(isStart) {
            this.adjustPageRange(isStart);
          },
          onInputKeyup: function onInputKeyup(e2) {
            if (e2.key !== "Escape")
              return;
            this.updateValue(this.value_, {
              formatInput: true,
              hidePopover: true
            });
          },
          updateValue: function updateValue(value) {
            var _this8 = this;
            var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            clearTimeout(this.updateTimeout);
            return new Promise(function(resolve) {
              var debounce2 = opts.debounce, args = _objectWithoutProperties$1(opts, ["debounce"]);
              if (debounce2 > 0) {
                _this8.updateTimeout = setTimeout(function() {
                  _this8.forceUpdateValue(value, args);
                  resolve(_this8.value_);
                }, debounce2);
              } else {
                _this8.forceUpdateValue(value, args);
                resolve(_this8.value_);
              }
            });
          },
          forceUpdateValue: function forceUpdateValue(value) {
            var _this9 = this;
            var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$config = _ref.config, config = _ref$config === void 0 ? this.modelConfig_ : _ref$config, _ref$patch = _ref.patch, patch = _ref$patch === void 0 ? PATCH.DATE_TIME : _ref$patch, _ref$notify = _ref.notify, notify = _ref$notify === void 0 ? true : _ref$notify, _ref$clearIfEqual = _ref.clearIfEqual, clearIfEqual = _ref$clearIfEqual === void 0 ? false : _ref$clearIfEqual, _ref$formatInput = _ref.formatInput, formatInput = _ref$formatInput === void 0 ? true : _ref$formatInput, _ref$hidePopover = _ref.hidePopover, hidePopover2 = _ref$hidePopover === void 0 ? false : _ref$hidePopover, _ref$adjustTime = _ref.adjustTime, adjustTime = _ref$adjustTime === void 0 ? false : _ref$adjustTime, _ref$isDragging = _ref.isDragging, isDragging2 = _ref$isDragging === void 0 ? this.isDragging : _ref$isDragging, _ref$rangePriority = _ref.rangePriority, rangePriority = _ref$rangePriority === void 0 ? RANGE_PRIORITY.BOTH : _ref$rangePriority;
            var normalizedValue = this.normalizeValue(value, config, patch, rangePriority);
            if (!normalizedValue && this.isRequired) {
              normalizedValue = this.value_;
            }
            if (adjustTime) {
              normalizedValue = this.adjustTimeForValue(normalizedValue, config);
            }
            var isDisabled = this.valueIsDisabled(normalizedValue);
            if (isDisabled) {
              if (isDragging2)
                return;
              normalizedValue = this.value_;
              hidePopover2 = false;
            }
            var valueKey = isDragging2 ? "dragValue" : "value_";
            var valueChanged = !this.valuesAreEqual(this[valueKey], normalizedValue);
            if (!isDisabled && !valueChanged && clearIfEqual) {
              normalizedValue = null;
              valueChanged = true;
            }
            if (valueChanged) {
              this[valueKey] = normalizedValue;
              if (!isDragging2)
                this.dragValue = null;
            }
            if (notify && valueChanged) {
              var denormalizedValue = this.denormalizeValue(normalizedValue, this.dateConfig);
              var event = this.isDragging ? "drag" : "update:modelValue";
              this.watchValue = false;
              this.$emit(event, denormalizedValue);
              this.$nextTick(function() {
                return _this9.watchValue = true;
              });
            }
            if (hidePopover2)
              this.hidePopover();
            if (formatInput)
              this.formatInput();
          },
          hasValue: function hasValue(value) {
            if (this.isRange) {
              return isObject$1$1(value) && value.start && value.end;
            }
            return !!value;
          },
          normalizeValue: function normalizeValue(value, config, patch, rangePriority) {
            if (!this.hasValue(value))
              return null;
            if (this.isRange) {
              var result = {};
              var start2 = value.start > value.end ? value.end : value.start;
              var startFillDate = this.value_ && this.value_.start || this.modelConfig_.start.fillDate;
              var startConfig = config.start || config;
              result.start = this.normalizeDate(start2, _objectSpread2$1(_objectSpread2$1({}, startConfig), {}, {
                fillDate: startFillDate,
                patch
              }));
              var end2 = value.start > value.end ? value.start : value.end;
              var endFillDate = this.value_ && this.value_.end || this.modelConfig_.end.fillDate;
              var endConfig = config.end || config;
              result.end = this.normalizeDate(end2, _objectSpread2$1(_objectSpread2$1({}, endConfig), {}, {
                fillDate: endFillDate,
                patch
              }));
              return this.sortRange(result, rangePriority);
            }
            return this.normalizeDate(value, _objectSpread2$1(_objectSpread2$1({}, config), {}, {
              fillDate: this.value_ || this.modelConfig_.fillDate,
              patch
            }));
          },
          adjustTimeForValue: function adjustTimeForValue(value, config) {
            if (!this.hasValue(value))
              return null;
            if (this.isRange) {
              return {
                start: this.$locale.adjustTimeForDate(value.start, config.start || config),
                end: this.$locale.adjustTimeForDate(value.end, config.end || config)
              };
            }
            return this.$locale.adjustTimeForDate(value, config);
          },
          sortRange: function sortRange(range) {
            var priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : RANGE_PRIORITY.NONE;
            var start2 = range.start, end2 = range.end;
            if (start2 > end2) {
              switch (priority) {
                case RANGE_PRIORITY.START:
                  return {
                    start: start2,
                    end: start2
                  };
                case RANGE_PRIORITY.END:
                  return {
                    start: end2,
                    end: end2
                  };
                case RANGE_PRIORITY.BOTH:
                  return {
                    start: end2,
                    end: start2
                  };
              }
            }
            return {
              start: start2,
              end: end2
            };
          },
          denormalizeValue: function denormalizeValue(value) {
            var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.modelConfig_;
            if (this.isRange) {
              if (!this.hasValue(value))
                return null;
              return {
                start: this.$locale.denormalizeDate(value.start, config.start || config),
                end: this.$locale.denormalizeDate(value.end, config.end || config)
              };
            }
            return this.$locale.denormalizeDate(value, config);
          },
          valuesAreEqual: function valuesAreEqual(a2, b2) {
            if (this.isRange) {
              var aHasValue = this.hasValue(a2);
              var bHasValue = this.hasValue(b2);
              if (!aHasValue && !bHasValue)
                return true;
              if (aHasValue !== bHasValue)
                return false;
              return datesAreEqual(a2.start, b2.start) && datesAreEqual(a2.end, b2.end);
            }
            return datesAreEqual(a2, b2);
          },
          valueIsDisabled: function valueIsDisabled(value) {
            return this.hasValue(value) && this.disabledAttribute && this.disabledAttribute.intersectsDate(value);
          },
          formatInput: function formatInput() {
            var _this10 = this;
            this.$nextTick(function() {
              var opts = {
                type: "string",
                mask: _this10.inputMask
              };
              var value = _this10.denormalizeValue(_this10.dragValue || _this10.value_, opts);
              if (_this10.isRange) {
                _this10.inputValues = [value && value.start, value && value.end];
              } else {
                _this10.inputValues = [value, ""];
              }
            });
          },
          showPopover: function showPopover$1() {
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            showPopover(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              ref: this.$el
            }, this.popover_), opts), {}, {
              isInteractive: true,
              id: this.datePickerPopoverId
            }));
          },
          hidePopover: function hidePopover$1() {
            var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            hidePopover(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              hideDelay: 10
            }, this.showPopover_), opts), {}, {
              id: this.datePickerPopoverId
            }));
          },
          togglePopover: function togglePopover$1(opts) {
            togglePopover(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
              ref: this.$el
            }, this.popover_), opts), {}, {
              isInteractive: true,
              id: this.datePickerPopoverId
            }));
          },
          adjustPageRange: function adjustPageRange(isStart) {
            var _this11 = this;
            this.$nextTick(function() {
              var calendar = _this11.$refs.calendar;
              var page = _this11.getPageForValue(isStart);
              var position = isStart ? 1 : -1;
              if (page && calendar && !pageIsBetweenPages(page, calendar.firstPage, calendar.lastPage)) {
                calendar.move(page, {
                  position,
                  transition: "fade"
                });
              }
            });
          },
          getPageForValue: function getPageForValue(isStart) {
            if (this.hasValue(this.value_)) {
              return this.pageForDate(this.isRange ? this.value_[isStart ? "start" : "end"] : this.value_);
            }
            return null;
          },
          move: function move(args, opts) {
            if (this.$refs.calendar) {
              return this.$refs.calendar.move(args, opts);
            }
            return Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"));
          },
          focusDate: function focusDate(date, opts) {
            if (this.$refs.calendar) {
              return this.$refs.calendar.focusDate(date, opts);
            }
            return Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"));
          }
        }
      };
      function baseMap(collection, iteratee) {
        var index2 = -1, result = isArrayLike_1(collection) ? Array(collection.length) : [];
        _baseEach(collection, function(value, key, collection2) {
          result[++index2] = iteratee(value, key, collection2);
        });
        return result;
      }
      var _baseMap = baseMap;
      function map(collection, iteratee) {
        var func = isArray_1(collection) ? _arrayMap : _baseMap;
        return func(collection, _baseIteratee(iteratee));
      }
      var map_1 = map;
      function buildMediaQuery(screens) {
        if (isString_1(screens)) {
          screens = { min: screens };
        }
        if (!isArrayLikeObject_1(screens)) {
          screens = [screens];
        }
        return screens.map((screen) => {
          if (has$1$1(screen, "raw")) {
            return screen.raw;
          }
          return map_1(screen, (value, feature) => {
            feature = get_1({
              min: "min-width",
              max: "max-width"
            }, feature, feature);
            return `(${feature}: ${value})`;
          }).join(" and ");
        }).join(", ");
      }
      var screensPlugin = {
        install: (app, screens) => {
          screens = defaultsDeep_1(screens, window && window.__screens__, defaultScreens);
          let shouldRefreshQueries = true;
          const state2 = reactive({
            matches: [],
            queries: []
          });
          const refreshMatches = () => {
            state2.matches = toPairs_1(state2.queries).filter((p2) => p2[1].matches).map((p2) => p2[0]);
          };
          const refreshQueries = () => {
            if (!shouldRefreshQueries || !window || !window.matchMedia)
              return;
            state2.queries = mapValues_1(screens, (v2) => {
              const query = window.matchMedia(buildMediaQuery(v2));
              if (isFunction_1(query.addEventListener)) {
                query.addEventListener("change", refreshMatches);
              } else {
                query.addListener(refreshMatches);
              }
              return query;
            });
            shouldRefreshQueries = false;
            refreshMatches();
          };
          app.mixin({
            mounted() {
              refreshQueries();
            },
            computed: {
              $screens() {
                return (config, def) => state2.matches.reduce((prev, curr) => has$1$1(config, curr) ? config[curr] : prev, isUndefined_1(def) ? config.default : def);
              }
            }
          });
        }
      };
      var setup = (app, defaults2) => {
        defaults2 = setup$1(defaults2);
        app.use(screensPlugin, defaults2.screens);
        return defaults2;
      };
      var __defProp$1 = Object.defineProperty;
      var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
      var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
      var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
      var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues$1 = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp$1.call(b2, prop))
            __defNormalProp$1(a2, prop, b2[prop]);
        if (__getOwnPropSymbols$1)
          for (var prop of __getOwnPropSymbols$1(b2)) {
            if (__propIsEnum$1.call(b2, prop))
              __defNormalProp$1(a2, prop, b2[prop]);
          }
        return a2;
      };
      var isFunction$2 = (value) => typeof value === "function";
      var isString$3 = (value) => typeof value === "string";
      var isNonEmptyString = (value) => isString$3(value) && value.trim().length > 0;
      var isNumber$2 = (value) => typeof value === "number";
      var isUndefined$1 = (value) => typeof value === "undefined";
      var isObject$5 = (value) => typeof value === "object" && value !== null;
      var isJSX = (obj) => hasProp(obj, "tag") && isNonEmptyString(obj.tag);
      var isTouchEvent = (event) => window.TouchEvent && event instanceof TouchEvent;
      var isToastComponent = (obj) => hasProp(obj, "component") && isToastContent(obj.component);
      var isVueComponent = (c2) => isFunction$2(c2) || isObject$5(c2);
      var isToastContent = (obj) => !isUndefined$1(obj) && (isString$3(obj) || isVueComponent(obj) || isToastComponent(obj));
      var isDOMRect = (obj) => isObject$5(obj) && ["height", "width", "right", "left", "top", "bottom"].every((p2) => isNumber$2(obj[p2]));
      var hasProp = (obj, propKey) => (isObject$5(obj) || isFunction$2(obj)) && propKey in obj;
      var getId = ((i2) => () => i2++)(0);
      function getX(event) {
        return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
      }
      function getY(event) {
        return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
      }
      var removeElement = (el) => {
        if (!isUndefined$1(el.remove)) {
          el.remove();
        } else if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
      };
      var getVueComponentFromObj = (obj) => {
        if (isToastComponent(obj)) {
          return getVueComponentFromObj(obj.component);
        }
        if (isJSX(obj)) {
          return defineComponent({
            render() {
              return obj;
            }
          });
        }
        return typeof obj === "string" ? obj : toRaw(unref(obj));
      };
      var normalizeToastComponent = (obj) => {
        if (typeof obj === "string") {
          return obj;
        }
        const props2 = hasProp(obj, "props") && isObject$5(obj.props) ? obj.props : {};
        const listeners = hasProp(obj, "listeners") && isObject$5(obj.listeners) ? obj.listeners : {};
        return { component: getVueComponentFromObj(obj), props: props2, listeners };
      };
      var isBrowser = () => typeof window !== "undefined";
      var EventBus = class {
        constructor() {
          this.allHandlers = {};
        }
        getHandlers(eventType) {
          return this.allHandlers[eventType] || [];
        }
        on(eventType, handler) {
          const handlers2 = this.getHandlers(eventType);
          handlers2.push(handler);
          this.allHandlers[eventType] = handlers2;
        }
        off(eventType, handler) {
          const handlers2 = this.getHandlers(eventType);
          handlers2.splice(handlers2.indexOf(handler) >>> 0, 1);
        }
        emit(eventType, event) {
          const handlers2 = this.getHandlers(eventType);
          handlers2.forEach((handler) => handler(event));
        }
      };
      var isEventBusInterface = (e2) => ["on", "off", "emit"].every((f2) => hasProp(e2, f2) && isFunction$2(e2[f2]));
      var TYPE;
      (function(TYPE2) {
        TYPE2["SUCCESS"] = "success";
        TYPE2["ERROR"] = "error";
        TYPE2["WARNING"] = "warning";
        TYPE2["INFO"] = "info";
        TYPE2["DEFAULT"] = "default";
      })(TYPE || (TYPE = {}));
      var POSITION;
      (function(POSITION2) {
        POSITION2["TOP_LEFT"] = "top-left";
        POSITION2["TOP_CENTER"] = "top-center";
        POSITION2["TOP_RIGHT"] = "top-right";
        POSITION2["BOTTOM_LEFT"] = "bottom-left";
        POSITION2["BOTTOM_CENTER"] = "bottom-center";
        POSITION2["BOTTOM_RIGHT"] = "bottom-right";
      })(POSITION || (POSITION = {}));
      var EVENTS;
      (function(EVENTS2) {
        EVENTS2["ADD"] = "add";
        EVENTS2["DISMISS"] = "dismiss";
        EVENTS2["UPDATE"] = "update";
        EVENTS2["CLEAR"] = "clear";
        EVENTS2["UPDATE_DEFAULTS"] = "update_defaults";
      })(EVENTS || (EVENTS = {}));
      var VT_NAMESPACE = "Vue-Toastification";
      var COMMON = {
        type: {
          type: String,
          default: TYPE.DEFAULT
        },
        classNames: {
          type: [String, Array],
          default: () => []
        },
        trueBoolean: {
          type: Boolean,
          default: true
        }
      };
      var ICON = {
        type: COMMON.type,
        customIcon: {
          type: [String, Boolean, Object, Function],
          default: true
        }
      };
      var CLOSE_BUTTON = {
        component: {
          type: [String, Object, Function, Boolean],
          default: "button"
        },
        classNames: COMMON.classNames,
        showOnHover: {
          type: Boolean,
          default: false
        },
        ariaLabel: {
          type: String,
          default: "close"
        }
      };
      var PROGRESS_BAR = {
        timeout: {
          type: [Number, Boolean],
          default: 5e3
        },
        hideProgressBar: {
          type: Boolean,
          default: false
        },
        isRunning: {
          type: Boolean,
          default: false
        }
      };
      var TRANSITION = {
        transition: {
          type: [Object, String],
          default: `${VT_NAMESPACE}__bounce`
        }
      };
      var CORE_TOAST = {
        position: {
          type: String,
          default: POSITION.TOP_RIGHT
        },
        draggable: COMMON.trueBoolean,
        draggablePercent: {
          type: Number,
          default: 0.6
        },
        pauseOnFocusLoss: COMMON.trueBoolean,
        pauseOnHover: COMMON.trueBoolean,
        closeOnClick: COMMON.trueBoolean,
        timeout: PROGRESS_BAR.timeout,
        hideProgressBar: PROGRESS_BAR.hideProgressBar,
        toastClassName: COMMON.classNames,
        bodyClassName: COMMON.classNames,
        icon: ICON.customIcon,
        closeButton: CLOSE_BUTTON.component,
        closeButtonClassName: CLOSE_BUTTON.classNames,
        showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
        accessibility: {
          type: Object,
          default: () => ({
            toastRole: "alert",
            closeButtonLabel: "close"
          })
        },
        rtl: {
          type: Boolean,
          default: false
        },
        eventBus: {
          type: Object,
          required: false,
          default: () => new EventBus()
        }
      };
      var TOAST = {
        id: {
          type: [String, Number],
          required: true,
          default: 0
        },
        type: COMMON.type,
        content: {
          type: [String, Object, Function],
          required: true,
          default: ""
        },
        onClick: {
          type: Function,
          default: void 0
        },
        onClose: {
          type: Function,
          default: void 0
        }
      };
      var CONTAINER = {
        container: {
          type: [
            Object,
            Function
          ],
          default: () => document.body
        },
        newestOnTop: COMMON.trueBoolean,
        maxToasts: {
          type: Number,
          default: 20
        },
        transition: TRANSITION.transition,
        toastDefaults: Object,
        filterBeforeCreate: {
          type: Function,
          default: (toast) => toast
        },
        filterToasts: {
          type: Function,
          default: (toasts) => toasts
        },
        containerClassName: COMMON.classNames,
        onMounted: Function,
        shareAppContext: [Boolean, Object]
      };
      var propValidators_default = {
        CORE_TOAST,
        TOAST,
        CONTAINER,
        PROGRESS_BAR,
        ICON,
        TRANSITION,
        CLOSE_BUTTON
      };
      var VtProgressBar_default = defineComponent({
        name: "VtProgressBar",
        props: propValidators_default.PROGRESS_BAR,
        data() {
          return {
            hasClass: true
          };
        },
        computed: {
          style() {
            return {
              animationDuration: `${this.timeout}ms`,
              animationPlayState: this.isRunning ? "running" : "paused",
              opacity: this.hideProgressBar ? 0 : 1
            };
          },
          cpClass() {
            return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
          }
        },
        watch: {
          timeout() {
            this.hasClass = false;
            this.$nextTick(() => this.hasClass = true);
          }
        },
        mounted() {
          this.$el.addEventListener("animationend", this.animationEnded);
        },
        beforeUnmount() {
          this.$el.removeEventListener("animationend", this.animationEnded);
        },
        methods: {
          animationEnded() {
            this.$emit("close-toast");
          }
        }
      });
      function render(_ctx, _cache) {
        return openBlock(), createElementBlock("div", {
          style: normalizeStyle(_ctx.style),
          class: normalizeClass(_ctx.cpClass)
        }, null, 6);
      }
      VtProgressBar_default.render = render;
      var VtProgressBar_default2 = VtProgressBar_default;
      var VtCloseButton_default = defineComponent({
        name: "VtCloseButton",
        props: propValidators_default.CLOSE_BUTTON,
        computed: {
          buttonComponent() {
            if (this.component !== false) {
              return getVueComponentFromObj(this.component);
            }
            return "button";
          },
          classes() {
            const classes = [`${VT_NAMESPACE}__close-button`];
            if (this.showOnHover) {
              classes.push("show-on-hover");
            }
            return classes.concat(this.classNames);
          }
        }
      });
      var _hoisted_1$k = /* @__PURE__ */ createTextVNode(" \xD7 ");
      function render2(_ctx, _cache) {
        return openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
          "aria-label": _ctx.ariaLabel,
          class: _ctx.classes
        }, _ctx.$attrs), {
          default: withCtx(() => [
            _hoisted_1$k
          ]),
          _: 1
        }, 16, ["aria-label", "class"]);
      }
      VtCloseButton_default.render = render2;
      var VtCloseButton_default2 = VtCloseButton_default;
      var VtSuccessIcon_default = {};
      var _hoisted_12$2 = {
        "aria-hidden": "true",
        focusable: "false",
        "data-prefix": "fas",
        "data-icon": "check-circle",
        class: "svg-inline--fa fa-check-circle fa-w-16",
        role: "img",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      };
      var _hoisted_2$j = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
      }, null, -1);
      var _hoisted_3$d = [
        _hoisted_2$j
      ];
      function render3(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_12$2, _hoisted_3$d);
      }
      VtSuccessIcon_default.render = render3;
      var VtSuccessIcon_default2 = VtSuccessIcon_default;
      var VtInfoIcon_default = {};
      var _hoisted_13$1 = {
        "aria-hidden": "true",
        focusable: "false",
        "data-prefix": "fas",
        "data-icon": "info-circle",
        class: "svg-inline--fa fa-info-circle fa-w-16",
        role: "img",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      };
      var _hoisted_22 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
      }, null, -1);
      var _hoisted_32 = [
        _hoisted_22
      ];
      function render4(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_13$1, _hoisted_32);
      }
      VtInfoIcon_default.render = render4;
      var VtInfoIcon_default2 = VtInfoIcon_default;
      var VtWarningIcon_default = {};
      var _hoisted_14$1 = {
        "aria-hidden": "true",
        focusable: "false",
        "data-prefix": "fas",
        "data-icon": "exclamation-circle",
        class: "svg-inline--fa fa-exclamation-circle fa-w-16",
        role: "img",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 512 512"
      };
      var _hoisted_23 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
      }, null, -1);
      var _hoisted_33 = [
        _hoisted_23
      ];
      function render5(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_14$1, _hoisted_33);
      }
      VtWarningIcon_default.render = render5;
      var VtWarningIcon_default2 = VtWarningIcon_default;
      var VtErrorIcon_default = {};
      var _hoisted_15$1 = {
        "aria-hidden": "true",
        focusable: "false",
        "data-prefix": "fas",
        "data-icon": "exclamation-triangle",
        class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
        role: "img",
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 576 512"
      };
      var _hoisted_24 = /* @__PURE__ */ createElementVNode("path", {
        fill: "currentColor",
        d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
      }, null, -1);
      var _hoisted_34 = [
        _hoisted_24
      ];
      function render6(_ctx, _cache) {
        return openBlock(), createElementBlock("svg", _hoisted_15$1, _hoisted_34);
      }
      VtErrorIcon_default.render = render6;
      var VtErrorIcon_default2 = VtErrorIcon_default;
      var VtIcon_default = defineComponent({
        name: "VtIcon",
        props: propValidators_default.ICON,
        computed: {
          customIconChildren() {
            return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
          },
          customIconClass() {
            if (isString$3(this.customIcon)) {
              return this.trimValue(this.customIcon);
            } else if (hasProp(this.customIcon, "iconClass")) {
              return this.trimValue(this.customIcon.iconClass);
            }
            return "";
          },
          customIconTag() {
            if (hasProp(this.customIcon, "iconTag")) {
              return this.trimValue(this.customIcon.iconTag, "i");
            }
            return "i";
          },
          hasCustomIcon() {
            return this.customIconClass.length > 0;
          },
          component() {
            if (this.hasCustomIcon) {
              return this.customIconTag;
            }
            if (isToastContent(this.customIcon)) {
              return getVueComponentFromObj(this.customIcon);
            }
            return this.iconTypeComponent;
          },
          iconTypeComponent() {
            const types = {
              [TYPE.DEFAULT]: VtInfoIcon_default2,
              [TYPE.INFO]: VtInfoIcon_default2,
              [TYPE.SUCCESS]: VtSuccessIcon_default2,
              [TYPE.ERROR]: VtErrorIcon_default2,
              [TYPE.WARNING]: VtWarningIcon_default2
            };
            return types[this.type];
          },
          iconClasses() {
            const classes = [`${VT_NAMESPACE}__icon`];
            if (this.hasCustomIcon) {
              return classes.concat(this.customIconClass);
            }
            return classes;
          }
        },
        methods: {
          trimValue(value, empty = "") {
            return isNonEmptyString(value) ? value.trim() : empty;
          }
        }
      });
      function render7(_ctx, _cache) {
        return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
          class: normalizeClass(_ctx.iconClasses)
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.customIconChildren), 1)
          ]),
          _: 1
        }, 8, ["class"]);
      }
      VtIcon_default.render = render7;
      var VtIcon_default2 = VtIcon_default;
      var VtToast_default = defineComponent({
        name: "VtToast",
        components: { ProgressBar: VtProgressBar_default2, CloseButton: VtCloseButton_default2, Icon: VtIcon_default2 },
        inheritAttrs: false,
        props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.TOAST),
        data() {
          const data2 = {
            isRunning: true,
            disableTransitions: false,
            beingDragged: false,
            dragStart: 0,
            dragPos: { x: 0, y: 0 },
            dragRect: {}
          };
          return data2;
        },
        computed: {
          classes() {
            const classes = [
              `${VT_NAMESPACE}__toast`,
              `${VT_NAMESPACE}__toast--${this.type}`,
              `${this.position}`
            ].concat(this.toastClassName);
            if (this.disableTransitions) {
              classes.push("disable-transition");
            }
            if (this.rtl) {
              classes.push(`${VT_NAMESPACE}__toast--rtl`);
            }
            return classes;
          },
          bodyClasses() {
            const classes = [
              `${VT_NAMESPACE}__toast-${isString$3(this.content) ? "body" : "component-body"}`
            ].concat(this.bodyClassName);
            return classes;
          },
          draggableStyle() {
            if (this.dragStart === this.dragPos.x) {
              return {};
            } else if (this.beingDragged) {
              return {
                transform: `translateX(${this.dragDelta}px)`,
                opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
              };
            } else {
              return {
                transition: "transform 0.2s, opacity 0.2s",
                transform: "translateX(0)",
                opacity: 1
              };
            }
          },
          dragDelta() {
            return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
          },
          removalDistance() {
            if (isDOMRect(this.dragRect)) {
              return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
            }
            return 0;
          }
        },
        mounted() {
          if (this.draggable) {
            this.draggableSetup();
          }
          if (this.pauseOnFocusLoss) {
            this.focusSetup();
          }
        },
        beforeUnmount() {
          if (this.draggable) {
            this.draggableCleanup();
          }
          if (this.pauseOnFocusLoss) {
            this.focusCleanup();
          }
        },
        methods: {
          hasProp,
          getVueComponentFromObj,
          closeToast() {
            this.eventBus.emit(EVENTS.DISMISS, this.id);
          },
          clickHandler() {
            if (this.onClick) {
              this.onClick(this.closeToast);
            }
            if (this.closeOnClick) {
              if (!this.beingDragged || this.dragStart === this.dragPos.x) {
                this.closeToast();
              }
            }
          },
          timeoutHandler() {
            this.closeToast();
          },
          hoverPause() {
            if (this.pauseOnHover) {
              this.isRunning = false;
            }
          },
          hoverPlay() {
            if (this.pauseOnHover) {
              this.isRunning = true;
            }
          },
          focusPause() {
            this.isRunning = false;
          },
          focusPlay() {
            this.isRunning = true;
          },
          focusSetup() {
            addEventListener("blur", this.focusPause);
            addEventListener("focus", this.focusPlay);
          },
          focusCleanup() {
            removeEventListener("blur", this.focusPause);
            removeEventListener("focus", this.focusPlay);
          },
          draggableSetup() {
            const element = this.$el;
            element.addEventListener("touchstart", this.onDragStart, {
              passive: true
            });
            element.addEventListener("mousedown", this.onDragStart);
            addEventListener("touchmove", this.onDragMove, { passive: false });
            addEventListener("mousemove", this.onDragMove);
            addEventListener("touchend", this.onDragEnd);
            addEventListener("mouseup", this.onDragEnd);
          },
          draggableCleanup() {
            const element = this.$el;
            element.removeEventListener("touchstart", this.onDragStart);
            element.removeEventListener("mousedown", this.onDragStart);
            removeEventListener("touchmove", this.onDragMove);
            removeEventListener("mousemove", this.onDragMove);
            removeEventListener("touchend", this.onDragEnd);
            removeEventListener("mouseup", this.onDragEnd);
          },
          onDragStart(event) {
            this.beingDragged = true;
            this.dragPos = { x: getX(event), y: getY(event) };
            this.dragStart = getX(event);
            this.dragRect = this.$el.getBoundingClientRect();
          },
          onDragMove(event) {
            if (this.beingDragged) {
              event.preventDefault();
              if (this.isRunning) {
                this.isRunning = false;
              }
              this.dragPos = { x: getX(event), y: getY(event) };
            }
          },
          onDragEnd() {
            if (this.beingDragged) {
              if (Math.abs(this.dragDelta) >= this.removalDistance) {
                this.disableTransitions = true;
                this.$nextTick(() => this.closeToast());
              } else {
                setTimeout(() => {
                  this.beingDragged = false;
                  if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
                    this.isRunning = false;
                  } else {
                    this.isRunning = true;
                  }
                });
              }
            }
          }
        }
      });
      var _hoisted_16$1 = ["role"];
      function render8(_ctx, _cache) {
        const _component_Icon = resolveComponent("Icon");
        const _component_CloseButton = resolveComponent("CloseButton");
        const _component_ProgressBar = resolveComponent("ProgressBar");
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(_ctx.classes),
          style: normalizeStyle(_ctx.draggableStyle),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args)),
          onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.hoverPause && _ctx.hoverPause(...args)),
          onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.hoverPlay && _ctx.hoverPlay(...args))
        }, [
          _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
            key: 0,
            "custom-icon": _ctx.icon,
            type: _ctx.type
          }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
          createElementVNode("div", {
            role: _ctx.accessibility.toastRole || "alert",
            class: normalizeClass(_ctx.bodyClasses)
          }, [
            typeof _ctx.content === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.content), 1)
            ], 2112)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
              key: 1,
              "toast-id": _ctx.id
            }, _ctx.hasProp(_ctx.content, "props") ? _ctx.content.props : {}, toHandlers(_ctx.hasProp(_ctx.content, "listeners") ? _ctx.content.listeners : {}), { onCloseToast: _ctx.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
          ], 10, _hoisted_16$1),
          !!_ctx.closeButton ? (openBlock(), createBlock(_component_CloseButton, {
            key: 1,
            component: _ctx.closeButton,
            "class-names": _ctx.closeButtonClassName,
            "show-on-hover": _ctx.showCloseButtonOnHover,
            "aria-label": _ctx.accessibility.closeButtonLabel,
            onClick: withModifiers(_ctx.closeToast, ["stop"])
          }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
          _ctx.timeout ? (openBlock(), createBlock(_component_ProgressBar, {
            key: 2,
            "is-running": _ctx.isRunning,
            "hide-progress-bar": _ctx.hideProgressBar,
            timeout: _ctx.timeout,
            onCloseToast: _ctx.timeoutHandler
          }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
        ], 38);
      }
      VtToast_default.render = render8;
      var VtToast_default2 = VtToast_default;
      var VtTransition_default = defineComponent({
        name: "VtTransition",
        props: propValidators_default.TRANSITION,
        emits: ["leave"],
        methods: {
          hasProp,
          leave(el) {
            if (el instanceof HTMLElement) {
              el.style.left = el.offsetLeft + "px";
              el.style.top = el.offsetTop + "px";
              el.style.width = getComputedStyle(el).width;
              el.style.position = "absolute";
            }
          }
        }
      });
      function render9(_ctx, _cache) {
        return openBlock(), createBlock(TransitionGroup, {
          tag: "div",
          "enter-active-class": _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`,
          "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
          "leave-active-class": _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`,
          onLeave: _ctx.leave
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
      }
      VtTransition_default.render = render9;
      var VtTransition_default2 = VtTransition_default;
      var VtToastContainer_default = defineComponent({
        name: "VueToastification",
        devtools: {
          hide: true
        },
        components: { Toast: VtToast_default2, VtTransition: VtTransition_default2 },
        props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.CONTAINER, propValidators_default.TRANSITION),
        data() {
          const data2 = {
            count: 0,
            positions: Object.values(POSITION),
            toasts: {},
            defaults: {}
          };
          return data2;
        },
        computed: {
          toastArray() {
            return Object.values(this.toasts);
          },
          filteredToasts() {
            return this.defaults.filterToasts(this.toastArray);
          }
        },
        beforeMount() {
          const events2 = this.eventBus;
          events2.on(EVENTS.ADD, this.addToast);
          events2.on(EVENTS.CLEAR, this.clearToasts);
          events2.on(EVENTS.DISMISS, this.dismissToast);
          events2.on(EVENTS.UPDATE, this.updateToast);
          events2.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
          this.defaults = this.$props;
        },
        mounted() {
          this.setup(this.container);
        },
        methods: {
          async setup(container) {
            if (isFunction$2(container)) {
              container = await container();
            }
            removeElement(this.$el);
            container.appendChild(this.$el);
          },
          setToast(props2) {
            if (!isUndefined$1(props2.id)) {
              this.toasts[props2.id] = props2;
            }
          },
          addToast(params) {
            params.content = normalizeToastComponent(params.content);
            const props2 = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
            const toast = this.defaults.filterBeforeCreate(props2, this.toastArray);
            toast && this.setToast(toast);
          },
          dismissToast(id) {
            const toast = this.toasts[id];
            if (!isUndefined$1(toast) && !isUndefined$1(toast.onClose)) {
              toast.onClose();
            }
            delete this.toasts[id];
          },
          clearToasts() {
            Object.keys(this.toasts).forEach((id) => {
              this.dismissToast(id);
            });
          },
          getPositionToasts(position) {
            const toasts = this.filteredToasts.filter((toast) => toast.position === position).slice(0, this.defaults.maxToasts);
            return this.defaults.newestOnTop ? toasts.reverse() : toasts;
          },
          updateDefaults(update2) {
            if (!isUndefined$1(update2.container)) {
              this.setup(update2.container);
            }
            this.defaults = Object.assign({}, this.defaults, update2);
          },
          updateToast({
            id,
            options,
            create
          }) {
            if (this.toasts[id]) {
              if (options.timeout && options.timeout === this.toasts[id].timeout) {
                options.timeout++;
              }
              this.setToast(Object.assign({}, this.toasts[id], options));
            } else if (create) {
              this.addToast(Object.assign({}, { id }, options));
            }
          },
          getClasses(position) {
            const classes = [`${VT_NAMESPACE}__container`, position];
            return classes.concat(this.defaults.containerClassName);
          }
        }
      });
      function render10(_ctx, _cache) {
        const _component_Toast = resolveComponent("Toast");
        const _component_VtTransition = resolveComponent("VtTransition");
        return openBlock(), createElementBlock("div", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.positions, (pos) => {
            return openBlock(), createElementBlock("div", { key: pos }, [
              createVNode(_component_VtTransition, {
                transition: _ctx.defaults.transition,
                class: normalizeClass(_ctx.getClasses(pos))
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getPositionToasts(pos), (toast) => {
                    return openBlock(), createBlock(_component_Toast, mergeProps({
                      key: toast.id
                    }, toast), null, 16);
                  }), 128))
                ]),
                _: 2
              }, 1032, ["transition", "class"])
            ]);
          }), 128))
        ]);
      }
      VtToastContainer_default.render = render10;
      var VtToastContainer_default2 = VtToastContainer_default;
      var buildInterface = (globalOptions = {}, mountContainer = true) => {
        const events2 = globalOptions.eventBus = globalOptions.eventBus || new EventBus();
        if (mountContainer) {
          nextTick(() => {
            const app = createApp(VtToastContainer_default2, __spreadValues$1({}, globalOptions));
            const component = app.mount(document.createElement("div"));
            const onMounted2 = globalOptions.onMounted;
            if (!isUndefined$1(onMounted2)) {
              onMounted2(component, app);
            }
            if (globalOptions.shareAppContext) {
              const baseApp = globalOptions.shareAppContext;
              if (baseApp === true) {
                console.warn(`[${VT_NAMESPACE}] App to share context with was not provided.`);
              } else {
                app._context.components = baseApp._context.components;
                app._context.directives = baseApp._context.directives;
                app._context.mixins = baseApp._context.mixins;
                app._context.provides = baseApp._context.provides;
                app.config.globalProperties = baseApp.config.globalProperties;
              }
            }
          });
        }
        const toast = (content, options) => {
          const props2 = Object.assign({}, { id: getId(), type: TYPE.DEFAULT }, options, {
            content
          });
          events2.emit(EVENTS.ADD, props2);
          return props2.id;
        };
        toast.clear = () => events2.emit(EVENTS.CLEAR, void 0);
        toast.updateDefaults = (update2) => {
          events2.emit(EVENTS.UPDATE_DEFAULTS, update2);
        };
        toast.dismiss = (id) => {
          events2.emit(EVENTS.DISMISS, id);
        };
        function updateToast(id, { content, options }, create = false) {
          const opt = Object.assign({}, options, { content });
          events2.emit(EVENTS.UPDATE, {
            id,
            options: opt,
            create
          });
        }
        toast.update = updateToast;
        toast.success = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.SUCCESS }));
        toast.info = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.INFO }));
        toast.error = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.ERROR }));
        toast.warning = (content, options) => toast(content, Object.assign({}, options, { type: TYPE.WARNING }));
        return toast;
      };
      var createMockToastInterface = () => {
        const toast = () => console.warn(`[${VT_NAMESPACE}] This plugin does not support SSR!`);
        return new Proxy(toast, {
          get() {
            return toast;
          }
        });
      };
      function createToastInterface(optionsOrEventBus) {
        if (!isBrowser()) {
          return createMockToastInterface();
        }
        if (isEventBusInterface(optionsOrEventBus)) {
          return buildInterface({ eventBus: optionsOrEventBus }, false);
        }
        return buildInterface(optionsOrEventBus, true);
      }
      var toastInjectionKey = Symbol("VueToastification");
      var globalEventBus = new EventBus();
      var VueToastificationPlugin = (App, options) => {
        if ((options == null ? void 0 : options.shareAppContext) === true) {
          options.shareAppContext = App;
        }
        const inter = createToastInterface(__spreadValues$1({
          eventBus: globalEventBus
        }, options));
        App.provide(toastInjectionKey, inter);
      };
      var useToast = (eventBus) => {
        if (eventBus) {
          return createToastInterface(eventBus);
        }
        const toast = getCurrentInstance() ? inject(toastInjectionKey, void 0) : void 0;
        return toast ? toast : createToastInterface(globalEventBus);
      };
      var src_default = VueToastificationPlugin;
      function getDevtoolsGlobalHook() {
        return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
      }
      function getTarget() {
        return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
      }
      const isProxyAvailable = typeof Proxy === "function";
      const HOOK_SETUP = "devtools-plugin:setup";
      const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
      class ApiProxy {
        constructor(plugin, hook) {
          this.target = null;
          this.targetQueue = [];
          this.onQueue = [];
          this.plugin = plugin;
          this.hook = hook;
          const defaultSettings2 = {};
          if (plugin.settings) {
            for (const id in plugin.settings) {
              const item = plugin.settings[id];
              defaultSettings2[id] = item.defaultValue;
            }
          }
          const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
          let currentSettings = __spreadValues({}, defaultSettings2);
          try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data2 = JSON.parse(raw);
            Object.assign(currentSettings, data2);
          } catch (e2) {
          }
          this.fallbacks = {
            getSettings() {
              return currentSettings;
            },
            setSettings(value) {
              try {
                localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
              } catch (e2) {
              }
              currentSettings = value;
            }
          };
          hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
            if (pluginId === this.plugin.id) {
              this.fallbacks.setSettings(value);
            }
          });
          this.proxiedOn = new Proxy({}, {
            get: (_target, prop) => {
              if (this.target) {
                return this.target.on[prop];
              } else {
                return (...args) => {
                  this.onQueue.push({
                    method: prop,
                    args
                  });
                };
              }
            }
          });
          this.proxiedTarget = new Proxy({}, {
            get: (_target, prop) => {
              if (this.target) {
                return this.target[prop];
              } else if (prop === "on") {
                return this.proxiedOn;
              } else if (Object.keys(this.fallbacks).includes(prop)) {
                return (...args) => {
                  this.targetQueue.push({
                    method: prop,
                    args,
                    resolve: () => {
                    }
                  });
                  return this.fallbacks[prop](...args);
                };
              } else {
                return (...args) => {
                  return new Promise((resolve) => {
                    this.targetQueue.push({
                      method: prop,
                      args,
                      resolve
                    });
                  });
                };
              }
            }
          });
        }
        async setRealTarget(target) {
          this.target = target;
          for (const item of this.onQueue) {
            this.target.on[item.method](...item.args);
          }
          for (const item of this.targetQueue) {
            item.resolve(await this.target[item.method](...item.args));
          }
        }
      }
      function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
        const target = getTarget();
        const hook = getDevtoolsGlobalHook();
        const enableProxy = isProxyAvailable && pluginDescriptor.enableEarlyProxy;
        if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
          hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
        } else {
          const proxy = enableProxy ? new ApiProxy(pluginDescriptor, hook) : null;
          const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
          list.push({
            pluginDescriptor,
            setupFn,
            proxy
          });
          if (proxy)
            setupFn(proxy.proxiedTarget);
        }
      }
      /**
        * vee-validate v4.5.7
        * (c) 2021 Abdelrahman Awad
        * @license MIT
        */
      function isCallable(fn2) {
        return typeof fn2 === "function";
      }
      function isNullOrUndefined(value) {
        return value === null || value === void 0;
      }
      const isObject$4 = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
      function isIndex$1(value) {
        return Number(value) >= 0;
      }
      function toNumber(value) {
        const n2 = parseFloat(value);
        return isNaN(n2) ? value : n2;
      }
      const RULES = {};
      function defineRule(id, validator2) {
        guardExtend(id, validator2);
        RULES[id] = validator2;
      }
      function resolveRule(id) {
        return RULES[id];
      }
      function guardExtend(id, validator2) {
        if (isCallable(validator2)) {
          return;
        }
        throw new Error(`Extension Error: The validator '${id}' must be a function.`);
      }
      const FormContextKey = Symbol("vee-validate-form");
      const FieldContextKey = Symbol("vee-validate-field-instance");
      const IS_ABSENT = Symbol("Default empty value");
      function isLocator(value) {
        return isCallable(value) && !!value.__locatorRef;
      }
      function isHTMLTag(tag) {
        return ["input", "textarea", "select"].includes(tag);
      }
      function isFileInputNode(tag, attrs) {
        return isHTMLTag(tag) && attrs.type === "file";
      }
      function isYupValidator(value) {
        return !!value && isCallable(value.validate);
      }
      function hasCheckedAttr(type) {
        return type === "checkbox" || type === "radio";
      }
      function isContainerValue(value) {
        return isObject$4(value) || Array.isArray(value);
      }
      function isEmptyContainer(value) {
        if (Array.isArray(value)) {
          return value.length === 0;
        }
        return isObject$4(value) && Object.keys(value).length === 0;
      }
      function isNotNestedPath(path) {
        return /^\[.+\]$/i.test(path);
      }
      function isNativeMultiSelect(el) {
        return isNativeSelect(el) && el.multiple;
      }
      function isNativeSelect(el) {
        return el.tagName === "SELECT";
      }
      function isNativeMultiSelectNode(tag, attrs) {
        const hasTruthyBindingValue = ![false, null, void 0, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);
        return tag === "select" && "multiple" in attrs && hasTruthyBindingValue;
      }
      function shouldHaveValueBinding(tag, attrs) {
        return isNativeMultiSelectNode(tag, attrs) || isFileInputNode(tag, attrs);
      }
      function isFormSubmitEvent(evt) {
        return isEvent(evt) && evt.target && "submit" in evt.target;
      }
      function isEvent(evt) {
        if (!evt) {
          return false;
        }
        if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
          return true;
        }
        if (evt && evt.srcElement) {
          return true;
        }
        return false;
      }
      function isPropPresent(obj, prop) {
        return prop in obj && obj[prop] !== IS_ABSENT;
      }
      function cleanupNonNestedPath(path) {
        if (isNotNestedPath(path)) {
          return path.replace(/\[|\]/gi, "");
        }
        return path;
      }
      function getFromPath(object, path, fallback) {
        if (!object) {
          return fallback;
        }
        if (isNotNestedPath(path)) {
          return object[cleanupNonNestedPath(path)];
        }
        const resolvedValue = (path || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
          if (isContainerValue(acc) && propKey in acc) {
            return acc[propKey];
          }
          return fallback;
        }, object);
        return resolvedValue;
      }
      function setInPath(object, path, value) {
        if (isNotNestedPath(path)) {
          object[cleanupNonNestedPath(path)] = value;
          return;
        }
        const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
        let acc = object;
        for (let i2 = 0; i2 < keys2.length; i2++) {
          if (i2 === keys2.length - 1) {
            acc[keys2[i2]] = value;
            return;
          }
          if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
            acc[keys2[i2]] = isIndex$1(keys2[i2 + 1]) ? [] : {};
          }
          acc = acc[keys2[i2]];
        }
      }
      function unset(object, key) {
        if (Array.isArray(object) && isIndex$1(key)) {
          object.splice(Number(key), 1);
          return;
        }
        if (isObject$4(object)) {
          delete object[key];
        }
      }
      function unsetPath(object, path) {
        if (isNotNestedPath(path)) {
          delete object[cleanupNonNestedPath(path)];
          return;
        }
        const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
        let acc = object;
        for (let i2 = 0; i2 < keys2.length; i2++) {
          if (i2 === keys2.length - 1) {
            unset(acc, keys2[i2]);
            break;
          }
          if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
            break;
          }
          acc = acc[keys2[i2]];
        }
        const pathValues = keys2.map((_2, idx) => {
          return getFromPath(object, keys2.slice(0, idx).join("."));
        });
        for (let i2 = pathValues.length - 1; i2 >= 0; i2--) {
          if (!isEmptyContainer(pathValues[i2])) {
            continue;
          }
          if (i2 === 0) {
            unset(object, keys2[0]);
            continue;
          }
          unset(pathValues[i2 - 1], keys2[i2 - 1]);
        }
      }
      function keysOf(record) {
        return Object.keys(record);
      }
      function injectWithSelf(symbol, def = void 0) {
        const vm = getCurrentInstance();
        return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject(symbol, def);
      }
      function warn(message) {
        warn$1(`[vee-validate]: ${message}`);
      }
      function normalizeField(field) {
        if (Array.isArray(field)) {
          return field[0];
        }
        return field;
      }
      function resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {
        if (Array.isArray(currentValue)) {
          const newVal = [...currentValue];
          const idx = newVal.indexOf(checkedValue);
          idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);
          return newVal;
        }
        return currentValue === checkedValue ? uncheckedValue : checkedValue;
      }
      function throttle$1(func, limit) {
        let inThrottle;
        let lastResult;
        return function(...args) {
          const context = this;
          if (!inThrottle) {
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
            lastResult = func.apply(context, args);
          }
          return lastResult;
        };
      }
      function debounceAsync(inner, ms = 0) {
        let timer = null;
        let resolves = [];
        return function(...args) {
          if (timer) {
            window.clearTimeout(timer);
          }
          timer = window.setTimeout(() => {
            const result = inner(...args);
            resolves.forEach((r2) => r2(result));
            resolves = [];
          }, ms);
          return new Promise((resolve) => resolves.push(resolve));
        };
      }
      const normalizeChildren = (tag, context, slotProps) => {
        if (!context.slots.default) {
          return context.slots.default;
        }
        if (typeof tag === "string" || !tag) {
          return context.slots.default(slotProps());
        }
        return {
          default: () => {
            var _a, _b;
            return (_b = (_a = context.slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, slotProps());
          }
        };
      };
      function getBoundValue(el) {
        if (hasValueBinding(el)) {
          return el._value;
        }
        return void 0;
      }
      function hasValueBinding(el) {
        return "_value" in el;
      }
      function normalizeEventValue(value) {
        if (!isEvent(value)) {
          return value;
        }
        const input2 = value.target;
        if (hasCheckedAttr(input2.type) && hasValueBinding(input2)) {
          return getBoundValue(input2);
        }
        if (input2.type === "file" && input2.files) {
          return Array.from(input2.files);
        }
        if (isNativeMultiSelect(input2)) {
          return Array.from(input2.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
        }
        if (isNativeSelect(input2)) {
          const selectedOption = Array.from(input2.options).find((opt) => opt.selected);
          return selectedOption ? getBoundValue(selectedOption) : input2.value;
        }
        return input2.value;
      }
      function normalizeRules(rules) {
        const acc = {};
        Object.defineProperty(acc, "_$$isNormalized", {
          value: true,
          writable: false,
          enumerable: false,
          configurable: false
        });
        if (!rules) {
          return acc;
        }
        if (isObject$4(rules) && rules._$$isNormalized) {
          return rules;
        }
        if (isObject$4(rules)) {
          return Object.keys(rules).reduce((prev, curr) => {
            const params = normalizeParams(rules[curr]);
            if (rules[curr] !== false) {
              prev[curr] = buildParams(params);
            }
            return prev;
          }, acc);
        }
        if (typeof rules !== "string") {
          return acc;
        }
        return rules.split("|").reduce((prev, rule) => {
          const parsedRule = parseRule(rule);
          if (!parsedRule.name) {
            return prev;
          }
          prev[parsedRule.name] = buildParams(parsedRule.params);
          return prev;
        }, acc);
      }
      function normalizeParams(params) {
        if (params === true) {
          return [];
        }
        if (Array.isArray(params)) {
          return params;
        }
        if (isObject$4(params)) {
          return params;
        }
        return [params];
      }
      function buildParams(provided) {
        const mapValueToLocator = (value) => {
          if (typeof value === "string" && value[0] === "@") {
            return createLocator(value.slice(1));
          }
          return value;
        };
        if (Array.isArray(provided)) {
          return provided.map(mapValueToLocator);
        }
        if (provided instanceof RegExp) {
          return [provided];
        }
        return Object.keys(provided).reduce((prev, key) => {
          prev[key] = mapValueToLocator(provided[key]);
          return prev;
        }, {});
      }
      const parseRule = (rule) => {
        let params = [];
        const name = rule.split(":")[0];
        if (rule.includes(":")) {
          params = rule.split(":").slice(1).join(":").split(",");
        }
        return { name, params };
      };
      function createLocator(value) {
        const locator = (crossTable) => {
          const val = getFromPath(crossTable, value) || crossTable[value];
          return val;
        };
        locator.__locatorRef = value;
        return locator;
      }
      function extractLocators(params) {
        if (Array.isArray(params)) {
          return params.filter(isLocator);
        }
        return keysOf(params).filter((key) => isLocator(params[key])).map((key) => params[key]);
      }
      const DEFAULT_CONFIG = {
        generateMessage: ({ field }) => `${field} is not valid.`,
        bails: true,
        validateOnBlur: true,
        validateOnChange: true,
        validateOnInput: false,
        validateOnModelUpdate: true
      };
      let currentConfig = Object.assign({}, DEFAULT_CONFIG);
      const getConfig = () => currentConfig;
      async function validate(value, rules, options = {}) {
        const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
        const field = {
          name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
          rules,
          bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
          formData: (options === null || options === void 0 ? void 0 : options.values) || {}
        };
        const result = await _validate(field, value);
        const errors = result.errors;
        return {
          errors,
          valid: !errors.length
        };
      }
      async function _validate(field, value) {
        if (isYupValidator(field.rules)) {
          return validateFieldWithYup(value, field.rules, { bails: field.bails });
        }
        if (isCallable(field.rules)) {
          const ctx = {
            field: field.name,
            form: field.formData,
            value
          };
          const result = await field.rules(value, ctx);
          const isValid = typeof result !== "string" && result;
          const message = typeof result === "string" ? result : _generateFieldError(ctx);
          return {
            errors: !isValid ? [message] : []
          };
        }
        const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });
        const errors = [];
        const rulesKeys = Object.keys(normalizedContext.rules);
        const length = rulesKeys.length;
        for (let i2 = 0; i2 < length; i2++) {
          const rule = rulesKeys[i2];
          const result = await _test(normalizedContext, value, {
            name: rule,
            params: normalizedContext.rules[rule]
          });
          if (result.error) {
            errors.push(result.error);
            if (field.bails) {
              return {
                errors
              };
            }
          }
        }
        return {
          errors
        };
      }
      async function validateFieldWithYup(value, validator2, opts) {
        var _a;
        const errors = await validator2.validate(value, {
          abortEarly: (_a = opts.bails) !== null && _a !== void 0 ? _a : true
        }).then(() => []).catch((err) => {
          if (err.name === "ValidationError") {
            return err.errors;
          }
          throw err;
        });
        return {
          errors
        };
      }
      async function _test(field, value, rule) {
        const validator2 = resolveRule(rule.name);
        if (!validator2) {
          throw new Error(`No such validator '${rule.name}' exists.`);
        }
        const params = fillTargetValues(rule.params, field.formData);
        const ctx = {
          field: field.name,
          value,
          form: field.formData,
          rule: Object.assign(Object.assign({}, rule), { params })
        };
        const result = await validator2(value, params, ctx);
        if (typeof result === "string") {
          return {
            error: result
          };
        }
        return {
          error: result ? void 0 : _generateFieldError(ctx)
        };
      }
      function _generateFieldError(fieldCtx) {
        const message = getConfig().generateMessage;
        if (!message) {
          return "Field is invalid";
        }
        return message(fieldCtx);
      }
      function fillTargetValues(params, crossTable) {
        const normalize = (value) => {
          if (isLocator(value)) {
            return value(crossTable);
          }
          return value;
        };
        if (Array.isArray(params)) {
          return params.map(normalize);
        }
        return Object.keys(params).reduce((acc, param) => {
          acc[param] = normalize(params[param]);
          return acc;
        }, {});
      }
      async function validateYupSchema(schema, values) {
        const errorObjects = await schema.validate(values, { abortEarly: false }).then(() => []).catch((err) => {
          if (err.name !== "ValidationError") {
            throw err;
          }
          return err.inner || [];
        });
        const results = {};
        const errors = {};
        for (const error of errorObjects) {
          const messages = error.errors;
          results[error.path] = { valid: !messages.length, errors: messages };
          if (messages.length) {
            errors[error.path] = messages[0];
          }
        }
        return {
          valid: !errorObjects.length,
          results,
          errors
        };
      }
      async function validateObjectSchema(schema, values, opts) {
        const paths = keysOf(schema);
        const validations = paths.map(async (path) => {
          var _a, _b, _c;
          const fieldResult = await validate(getFromPath(values, path), schema[path], {
            name: ((_a = opts === null || opts === void 0 ? void 0 : opts.names) === null || _a === void 0 ? void 0 : _a[path]) || path,
            values,
            bails: (_c = (_b = opts === null || opts === void 0 ? void 0 : opts.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true
          });
          return Object.assign(Object.assign({}, fieldResult), { path });
        });
        let isAllValid = true;
        const validationResults = await Promise.all(validations);
        const results = {};
        const errors = {};
        for (const result of validationResults) {
          results[result.path] = {
            valid: result.valid,
            errors: result.errors
          };
          if (!result.valid) {
            isAllValid = false;
            errors[result.path] = result.errors[0];
          }
        }
        return {
          valid: isAllValid,
          results,
          errors
        };
      }
      function set(obj, key, val) {
        if (typeof val.value === "object")
          val.value = klona(val.value);
        if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
          Object.defineProperty(obj, key, val);
        } else
          obj[key] = val.value;
      }
      function klona(x2) {
        if (typeof x2 !== "object")
          return x2;
        var i2 = 0, k2, list, tmp, str = Object.prototype.toString.call(x2);
        if (str === "[object Object]") {
          tmp = Object.create(x2.__proto__ || null);
        } else if (str === "[object Array]") {
          tmp = Array(x2.length);
        } else if (str === "[object Set]") {
          tmp = new Set();
          x2.forEach(function(val) {
            tmp.add(klona(val));
          });
        } else if (str === "[object Map]") {
          tmp = new Map();
          x2.forEach(function(val, key) {
            tmp.set(klona(key), klona(val));
          });
        } else if (str === "[object Date]") {
          tmp = new Date(+x2);
        } else if (str === "[object RegExp]") {
          tmp = new RegExp(x2.source, x2.flags);
        } else if (str === "[object DataView]") {
          tmp = new x2.constructor(klona(x2.buffer));
        } else if (str === "[object ArrayBuffer]") {
          tmp = x2.slice(0);
        } else if (str.slice(-6) === "Array]") {
          tmp = new x2.constructor(x2);
        }
        if (tmp) {
          for (list = Object.getOwnPropertySymbols(x2); i2 < list.length; i2++) {
            set(tmp, list[i2], Object.getOwnPropertyDescriptor(x2, list[i2]));
          }
          for (i2 = 0, list = Object.getOwnPropertyNames(x2); i2 < list.length; i2++) {
            if (Object.hasOwnProperty.call(tmp, k2 = list[i2]) && tmp[k2] === x2[k2])
              continue;
            set(tmp, k2, Object.getOwnPropertyDescriptor(x2, k2));
          }
        }
        return tmp || x2;
      }
      var es6 = function equal(a2, b2) {
        if (a2 === b2)
          return true;
        if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
          if (a2.constructor !== b2.constructor)
            return false;
          var length, i2, keys2;
          if (Array.isArray(a2)) {
            length = a2.length;
            if (length != b2.length)
              return false;
            for (i2 = length; i2-- !== 0; )
              if (!equal(a2[i2], b2[i2]))
                return false;
            return true;
          }
          if (a2 instanceof Map && b2 instanceof Map) {
            if (a2.size !== b2.size)
              return false;
            for (i2 of a2.entries())
              if (!b2.has(i2[0]))
                return false;
            for (i2 of a2.entries())
              if (!equal(i2[1], b2.get(i2[0])))
                return false;
            return true;
          }
          if (a2 instanceof Set && b2 instanceof Set) {
            if (a2.size !== b2.size)
              return false;
            for (i2 of a2.entries())
              if (!b2.has(i2[0]))
                return false;
            return true;
          }
          if (ArrayBuffer.isView(a2) && ArrayBuffer.isView(b2)) {
            length = a2.length;
            if (length != b2.length)
              return false;
            for (i2 = length; i2-- !== 0; )
              if (a2[i2] !== b2[i2])
                return false;
            return true;
          }
          if (a2.constructor === RegExp)
            return a2.source === b2.source && a2.flags === b2.flags;
          if (a2.valueOf !== Object.prototype.valueOf)
            return a2.valueOf() === b2.valueOf();
          if (a2.toString !== Object.prototype.toString)
            return a2.toString() === b2.toString();
          keys2 = Object.keys(a2);
          length = keys2.length;
          if (length !== Object.keys(b2).length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
              return false;
          for (i2 = length; i2-- !== 0; ) {
            var key = keys2[i2];
            if (!equal(a2[key], b2[key]))
              return false;
          }
          return true;
        }
        return a2 !== a2 && b2 !== b2;
      };
      let ID_COUNTER = 0;
      function useFieldState(path, init) {
        const { value, initialValue, setInitialValue } = _useFieldValue(path, init.modelValue, !init.standalone);
        const { errorMessage, errors, setErrors } = _useFieldErrors(path, !init.standalone);
        const meta = _useFieldMeta(value, initialValue, errors);
        const id = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;
        function setState(state2) {
          var _a;
          if ("value" in state2) {
            value.value = state2.value;
          }
          if ("errors" in state2) {
            setErrors(state2.errors);
          }
          if ("touched" in state2) {
            meta.touched = (_a = state2.touched) !== null && _a !== void 0 ? _a : meta.touched;
          }
          if ("initialValue" in state2) {
            setInitialValue(state2.initialValue);
          }
        }
        return {
          id,
          path,
          value,
          initialValue,
          meta,
          errors,
          errorMessage,
          setState
        };
      }
      function _useFieldValue(path, modelValue, shouldInjectForm) {
        const form = shouldInjectForm ? injectWithSelf(FormContextKey, void 0) : void 0;
        const modelRef = ref(unref(modelValue));
        function resolveInitialValue2() {
          if (!form) {
            return unref(modelRef);
          }
          return getFromPath(form.meta.value.initialValues, unref(path), unref(modelRef));
        }
        function setInitialValue(value2) {
          if (!form) {
            modelRef.value = value2;
            return;
          }
          form.setFieldInitialValue(unref(path), value2);
        }
        const initialValue = computed(resolveInitialValue2);
        if (!form) {
          const value2 = ref(resolveInitialValue2());
          return {
            value: value2,
            initialValue,
            setInitialValue
          };
        }
        const currentValue = modelValue ? unref(modelValue) : getFromPath(form.values, unref(path), unref(initialValue));
        form.stageInitialValue(unref(path), currentValue);
        const value = computed({
          get() {
            return getFromPath(form.values, unref(path));
          },
          set(newVal) {
            form.setFieldValue(unref(path), newVal);
          }
        });
        return {
          value,
          initialValue,
          setInitialValue
        };
      }
      function _useFieldMeta(currentValue, initialValue, errors) {
        const meta = reactive({
          touched: false,
          pending: false,
          valid: true,
          validated: !!unref(errors).length,
          initialValue: computed(() => unref(initialValue)),
          dirty: computed(() => {
            return !es6(unref(currentValue), unref(initialValue));
          })
        });
        watch(errors, (value) => {
          meta.valid = !value.length;
        }, {
          immediate: true,
          flush: "sync"
        });
        return meta;
      }
      function _useFieldErrors(path, shouldInjectForm) {
        const form = shouldInjectForm ? injectWithSelf(FormContextKey, void 0) : void 0;
        function normalizeErrors(messages) {
          if (!messages) {
            return [];
          }
          return Array.isArray(messages) ? messages : [messages];
        }
        if (!form) {
          const errors2 = ref([]);
          return {
            errors: errors2,
            errorMessage: computed(() => errors2.value[0]),
            setErrors: (messages) => {
              errors2.value = normalizeErrors(messages);
            }
          };
        }
        const errors = computed(() => form.errorBag.value[unref(path)] || []);
        return {
          errors,
          errorMessage: computed(() => errors.value[0]),
          setErrors: (messages) => {
            form.setFieldErrorBag(unref(path), normalizeErrors(messages));
          }
        };
      }
      function installDevtoolsPlugin(app) {
        {
          setupDevtoolsPlugin({
            id: "vee-validate-devtools-plugin",
            label: "VeeValidate Plugin",
            packageName: "vee-validate",
            homepage: "https://vee-validate.logaretm.com/v4",
            app,
            logo: "https://vee-validate.logaretm.com/v4/logo.png"
          }, setupApiHooks);
        }
      }
      const DEVTOOLS_FORMS = {};
      const DEVTOOLS_FIELDS = {};
      let API;
      const refreshInspector = throttle$1(() => {
        setTimeout(async () => {
          await nextTick();
          API === null || API === void 0 ? void 0 : API.sendInspectorState(INSPECTOR_ID$1);
          API === null || API === void 0 ? void 0 : API.sendInspectorTree(INSPECTOR_ID$1);
        }, 100);
      }, 100);
      function registerFormWithDevTools(form) {
        const vm = getCurrentInstance();
        if (!API) {
          const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;
          if (!app) {
            return;
          }
          installDevtoolsPlugin(app);
        }
        DEVTOOLS_FORMS[form.formId] = Object.assign({}, form);
        DEVTOOLS_FORMS[form.formId]._vm = vm;
        onUnmounted(() => {
          delete DEVTOOLS_FORMS[form.formId];
          refreshInspector();
        });
        refreshInspector();
      }
      function registerSingleFieldWithDevtools(field) {
        const vm = getCurrentInstance();
        if (!API) {
          const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;
          if (!app) {
            return;
          }
          installDevtoolsPlugin(app);
        }
        DEVTOOLS_FIELDS[field.id] = Object.assign({}, field);
        DEVTOOLS_FIELDS[field.id]._vm = vm;
        onUnmounted(() => {
          delete DEVTOOLS_FIELDS[field.id];
          refreshInspector();
        });
        refreshInspector();
      }
      const INSPECTOR_ID$1 = "vee-validate-inspector";
      const COLORS = {
        error: 12405579,
        success: 448379,
        unknown: 5522283,
        white: 16777215,
        black: 0,
        blue: 218007,
        purple: 12157168,
        orange: 16099682,
        gray: 12304330
      };
      let SELECTED_NODE = null;
      function setupApiHooks(api2) {
        API = api2;
        api2.addInspector({
          id: INSPECTOR_ID$1,
          icon: "rule",
          label: "vee-validate",
          noSelectionText: "Select a vee-validate node to inspect",
          actions: [
            {
              icon: "done_outline",
              tooltip: "Validate selected item",
              action: async () => {
                if (!SELECTED_NODE) {
                  console.error("There is not a valid selected vee-validate node or component");
                  return;
                }
                const result = await SELECTED_NODE.validate();
                console.log(result);
              }
            },
            {
              icon: "delete_sweep",
              tooltip: "Clear validation state of the selected item",
              action: () => {
                if (!SELECTED_NODE) {
                  console.error("There is not a valid selected vee-validate node or component");
                  return;
                }
                if ("id" in SELECTED_NODE) {
                  SELECTED_NODE.resetField();
                  return;
                }
                SELECTED_NODE.resetForm();
              }
            }
          ]
        });
        api2.on.getInspectorTree((payload) => {
          if (payload.inspectorId !== INSPECTOR_ID$1) {
            return;
          }
          const forms = Object.values(DEVTOOLS_FORMS);
          const fields = Object.values(DEVTOOLS_FIELDS);
          payload.rootNodes = [
            ...forms.map(mapFormForDevtoolsInspector),
            ...fields.map((field) => mapFieldForDevtoolsInspector(field))
          ];
        });
        api2.on.getInspectorState((payload, ctx) => {
          if (payload.inspectorId !== INSPECTOR_ID$1 || ctx.currentTab !== `custom-inspector:${INSPECTOR_ID$1}`) {
            return;
          }
          const { form, field, type } = decodeNodeId(payload.nodeId);
          if (form && type === "form") {
            payload.state = buildFormState(form);
            SELECTED_NODE = form;
            return;
          }
          if (field && type === "field") {
            payload.state = buildFieldState(field);
            SELECTED_NODE = field;
            return;
          }
          SELECTED_NODE = null;
        });
      }
      function mapFormForDevtoolsInspector(form) {
        const { textColor, bgColor } = getTagTheme(form);
        const formTreeNodes = {};
        Object.values(form.fieldsByPath.value).forEach((field) => {
          const fieldInstance = Array.isArray(field) ? field[0] : field;
          if (!fieldInstance) {
            return;
          }
          setInPath(formTreeNodes, unref(fieldInstance.name), mapFieldForDevtoolsInspector(fieldInstance, form));
        });
        function buildFormTree(tree, path = []) {
          const key = [...path].pop();
          if ("id" in tree) {
            return Object.assign(Object.assign({}, tree), { label: key || tree.label });
          }
          if (isObject$4(tree)) {
            return {
              id: `${path.join(".")}`,
              label: key || "",
              children: Object.keys(tree).map((key2) => buildFormTree(tree[key2], [...path, key2]))
            };
          }
          if (Array.isArray(tree)) {
            return {
              id: `${path.join(".")}`,
              label: `${key}[]`,
              children: tree.map((c2, idx) => buildFormTree(c2, [...path, String(idx)]))
            };
          }
          return { id: "", label: "", children: [] };
        }
        const { children } = buildFormTree(formTreeNodes);
        return {
          id: encodeNodeId(form),
          label: "Form",
          children,
          tags: [
            {
              label: "Form",
              textColor,
              backgroundColor: bgColor
            },
            {
              label: `${Object.keys(form.fieldsByPath.value).length} fields`,
              textColor: COLORS.white,
              backgroundColor: COLORS.unknown
            }
          ]
        };
      }
      function mapFieldForDevtoolsInspector(field, form) {
        const fieldInstance = normalizeField(field);
        const { textColor, bgColor } = getTagTheme(fieldInstance);
        const isGroup = Array.isArray(field) && field.length > 1;
        return {
          id: encodeNodeId(form, fieldInstance, !isGroup),
          label: unref(fieldInstance.name),
          children: Array.isArray(field) ? field.map((fieldItem) => mapFieldForDevtoolsInspector(fieldItem, form)) : void 0,
          tags: [
            isGroup ? void 0 : {
              label: "Field",
              textColor,
              backgroundColor: bgColor
            },
            !form ? {
              label: "Standalone",
              textColor: COLORS.black,
              backgroundColor: COLORS.gray
            } : void 0,
            !isGroup && fieldInstance.type === "checkbox" ? {
              label: "Checkbox",
              textColor: COLORS.white,
              backgroundColor: COLORS.blue
            } : void 0,
            !isGroup && fieldInstance.type === "radio" ? {
              label: "Radio",
              textColor: COLORS.white,
              backgroundColor: COLORS.purple
            } : void 0,
            isGroup ? {
              label: "Group",
              textColor: COLORS.black,
              backgroundColor: COLORS.orange
            } : void 0
          ].filter(Boolean)
        };
      }
      function encodeNodeId(form, field, encodeIndex = true) {
        const fieldPath = form ? unref(field === null || field === void 0 ? void 0 : field.name) : field === null || field === void 0 ? void 0 : field.id;
        const fieldGroup = fieldPath ? form === null || form === void 0 ? void 0 : form.fieldsByPath.value[fieldPath] : void 0;
        let idx;
        if (encodeIndex && field && Array.isArray(fieldGroup)) {
          idx = fieldGroup.indexOf(field);
        }
        const idObject = { f: form === null || form === void 0 ? void 0 : form.formId, ff: fieldPath, idx, type: field ? "field" : "form" };
        return btoa(JSON.stringify(idObject));
      }
      function decodeNodeId(nodeId) {
        try {
          const idObject = JSON.parse(atob(nodeId));
          const form = DEVTOOLS_FORMS[idObject.f];
          if (!form && idObject.ff) {
            const field = DEVTOOLS_FIELDS[idObject.ff];
            if (!field) {
              return {};
            }
            return {
              type: idObject.type,
              field
            };
          }
          if (!form) {
            return {};
          }
          const fieldGroup = form.fieldsByPath.value[idObject.ff];
          return {
            type: idObject.type,
            form,
            field: Array.isArray(fieldGroup) ? fieldGroup[idObject.idx || 0] : fieldGroup
          };
        } catch (err) {
        }
        return {};
      }
      function buildFieldState(field) {
        const { errors, meta, value } = field;
        return {
          "Field state": [
            { key: "errors", value: errors.value },
            {
              key: "initialValue",
              value: meta.initialValue
            },
            {
              key: "currentValue",
              value: value.value
            },
            {
              key: "touched",
              value: meta.touched
            },
            {
              key: "dirty",
              value: meta.dirty
            },
            {
              key: "valid",
              value: meta.valid
            }
          ]
        };
      }
      function buildFormState(form) {
        const { errorBag, meta, values, isSubmitting, submitCount } = form;
        return {
          "Form state": [
            {
              key: "submitCount",
              value: submitCount.value
            },
            {
              key: "isSubmitting",
              value: isSubmitting.value
            },
            {
              key: "touched",
              value: meta.value.touched
            },
            {
              key: "dirty",
              value: meta.value.dirty
            },
            {
              key: "valid",
              value: meta.value.valid
            },
            {
              key: "initialValues",
              value: meta.value.initialValues
            },
            {
              key: "currentValues",
              value: values
            },
            {
              key: "errors",
              value: keysOf(errorBag.value).reduce((acc, key) => {
                var _a;
                const message = (_a = errorBag.value[key]) === null || _a === void 0 ? void 0 : _a[0];
                if (message) {
                  acc[key] = message;
                }
                return acc;
              }, {})
            }
          ]
        };
      }
      function getTagTheme(fieldOrForm) {
        const isValid = "id" in fieldOrForm ? fieldOrForm.meta.valid : fieldOrForm.meta.value.valid;
        return {
          bgColor: isValid ? COLORS.success : COLORS.error,
          textColor: isValid ? COLORS.black : COLORS.white
        };
      }
      function useField(name, rules, opts) {
        if (hasCheckedAttr(opts === null || opts === void 0 ? void 0 : opts.type)) {
          return useCheckboxField(name, rules, opts);
        }
        return _useField(name, rules, opts);
      }
      function _useField(name, rules, opts) {
        const { initialValue: modelValue, validateOnMount, bails, type, checkedValue, label, validateOnValueUpdate, uncheckedValue, standalone } = normalizeOptions(unref(name), opts);
        const form = !standalone ? injectWithSelf(FormContextKey) : void 0;
        const { id, value, initialValue, meta, setState, errors, errorMessage } = useFieldState(name, {
          modelValue,
          standalone
        });
        const handleBlur = () => {
          meta.touched = true;
        };
        const normalizedRules = computed(() => {
          let rulesValue = unref(rules);
          const schema = unref(form === null || form === void 0 ? void 0 : form.schema);
          if (schema && !isYupValidator(schema)) {
            rulesValue = extractRuleFromSchema(schema, unref(name)) || rulesValue;
          }
          if (isYupValidator(rulesValue) || isCallable(rulesValue)) {
            return rulesValue;
          }
          return normalizeRules(rulesValue);
        });
        async function validateCurrentValue(mode) {
          var _a, _b;
          if (form === null || form === void 0 ? void 0 : form.validateSchema) {
            return (_a = (await form.validateSchema(mode)).results[unref(name)]) !== null && _a !== void 0 ? _a : { valid: true, errors: [] };
          }
          return validate(value.value, normalizedRules.value, {
            name: unref(label) || unref(name),
            values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},
            bails
          });
        }
        async function validateWithStateMutation() {
          meta.pending = true;
          meta.validated = true;
          const result = await validateCurrentValue("validated-only");
          setState({ errors: result.errors });
          meta.pending = false;
          return result;
        }
        async function validateValidStateOnly() {
          const result = await validateCurrentValue("silent");
          meta.valid = result.valid;
          return result;
        }
        function validate$1(opts2) {
          if (!(opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || (opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) === "force") {
            return validateWithStateMutation();
          }
          if ((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) === "validated-only") {
            return validateWithStateMutation();
          }
          return validateValidStateOnly();
        }
        const handleChange = (e2, shouldValidate = true) => {
          const newValue = normalizeEventValue(e2);
          value.value = newValue;
          if (!validateOnValueUpdate && shouldValidate) {
            validateWithStateMutation();
          }
        };
        onMounted(() => {
          if (validateOnMount) {
            return validateWithStateMutation();
          }
          if (!form || !form.validateSchema) {
            validateValidStateOnly();
          }
        });
        function setTouched(isTouched) {
          meta.touched = isTouched;
        }
        let unwatchValue;
        function watchValue() {
          unwatchValue = watch(value, validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly, {
            deep: true
          });
        }
        watchValue();
        function resetField(state2) {
          var _a;
          unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();
          const newValue = state2 && "value" in state2 ? state2.value : initialValue.value;
          setState({
            value: klona(newValue),
            initialValue: klona(newValue),
            touched: (_a = state2 === null || state2 === void 0 ? void 0 : state2.touched) !== null && _a !== void 0 ? _a : false,
            errors: (state2 === null || state2 === void 0 ? void 0 : state2.errors) || []
          });
          meta.pending = false;
          meta.validated = false;
          validateValidStateOnly();
          nextTick(() => {
            watchValue();
          });
        }
        function setValue(newValue) {
          value.value = newValue;
        }
        function setErrors(errors2) {
          setState({ errors: Array.isArray(errors2) ? errors2 : [errors2] });
        }
        const field = {
          id,
          name,
          label,
          value,
          meta,
          errors,
          errorMessage,
          type,
          checkedValue,
          uncheckedValue,
          bails,
          resetField,
          handleReset: () => resetField(),
          validate: validate$1,
          handleChange,
          handleBlur,
          setState,
          setTouched,
          setErrors,
          setValue
        };
        provide(FieldContextKey, field);
        if (isRef(rules) && typeof unref(rules) !== "function") {
          watch(rules, (value2, oldValue) => {
            if (es6(value2, oldValue)) {
              return;
            }
            meta.validated ? validateWithStateMutation() : validateValidStateOnly();
          }, {
            deep: true
          });
        }
        {
          field._vm = getCurrentInstance();
          watch(() => Object.assign(Object.assign({ errors: errors.value }, meta), { value: value.value }), refreshInspector, {
            deep: true
          });
          if (!form) {
            registerSingleFieldWithDevtools(field);
          }
        }
        if (!form) {
          return field;
        }
        form.register(field);
        onBeforeUnmount(() => {
          form.unregister(field);
        });
        const dependencies = computed(() => {
          const rulesVal = normalizedRules.value;
          if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal)) {
            return {};
          }
          return Object.keys(rulesVal).reduce((acc, rule) => {
            const deps = extractLocators(rulesVal[rule]).map((dep) => dep.__locatorRef).reduce((depAcc, depName) => {
              const depValue = getFromPath(form.values, depName) || form.values[depName];
              if (depValue !== void 0) {
                depAcc[depName] = depValue;
              }
              return depAcc;
            }, {});
            Object.assign(acc, deps);
            return acc;
          }, {});
        });
        watch(dependencies, (deps, oldDeps) => {
          if (!Object.keys(deps).length) {
            return;
          }
          const shouldValidate = !es6(deps, oldDeps);
          if (shouldValidate) {
            meta.validated ? validateWithStateMutation() : validateValidStateOnly();
          }
        });
        return field;
      }
      function normalizeOptions(name, opts) {
        const defaults2 = () => ({
          initialValue: void 0,
          validateOnMount: false,
          bails: true,
          rules: "",
          label: name,
          validateOnValueUpdate: true,
          standalone: false
        });
        if (!opts) {
          return defaults2();
        }
        const checkedValue = "valueProp" in opts ? opts.valueProp : opts.checkedValue;
        return Object.assign(Object.assign(Object.assign({}, defaults2()), opts || {}), { checkedValue });
      }
      function extractRuleFromSchema(schema, fieldName) {
        if (!schema) {
          return void 0;
        }
        return schema[fieldName];
      }
      function useCheckboxField(name, rules, opts) {
        const form = !(opts === null || opts === void 0 ? void 0 : opts.standalone) ? injectWithSelf(FormContextKey) : void 0;
        const checkedValue = opts === null || opts === void 0 ? void 0 : opts.checkedValue;
        const uncheckedValue = opts === null || opts === void 0 ? void 0 : opts.uncheckedValue;
        function patchCheckboxApi(field) {
          const handleChange = field.handleChange;
          const checked = computed(() => {
            const currentValue = unref(field.value);
            const checkedVal = unref(checkedValue);
            return Array.isArray(currentValue) ? currentValue.includes(checkedVal) : checkedVal === currentValue;
          });
          function handleCheckboxChange(e2, shouldValidate = true) {
            var _a, _b;
            if (checked.value === ((_b = (_a = e2) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.checked)) {
              return;
            }
            let newValue = normalizeEventValue(e2);
            if (!form) {
              newValue = resolveNextCheckboxValue(unref(field.value), unref(checkedValue), unref(uncheckedValue));
            }
            handleChange(newValue, shouldValidate);
          }
          onBeforeUnmount(() => {
            if (checked.value) {
              handleCheckboxChange(unref(checkedValue), false);
            }
          });
          return Object.assign(Object.assign({}, field), {
            checked,
            checkedValue,
            uncheckedValue,
            handleChange: handleCheckboxChange
          });
        }
        return patchCheckboxApi(_useField(name, rules, opts));
      }
      const FieldImpl = defineComponent({
        name: "Field",
        inheritAttrs: false,
        props: {
          as: {
            type: [String, Object],
            default: void 0
          },
          name: {
            type: String,
            required: true
          },
          rules: {
            type: [Object, String, Function],
            default: void 0
          },
          validateOnMount: {
            type: Boolean,
            default: false
          },
          validateOnBlur: {
            type: Boolean,
            default: void 0
          },
          validateOnChange: {
            type: Boolean,
            default: void 0
          },
          validateOnInput: {
            type: Boolean,
            default: void 0
          },
          validateOnModelUpdate: {
            type: Boolean,
            default: void 0
          },
          bails: {
            type: Boolean,
            default: () => getConfig().bails
          },
          label: {
            type: String,
            default: void 0
          },
          uncheckedValue: {
            type: null,
            default: void 0
          },
          modelValue: {
            type: null,
            default: IS_ABSENT
          },
          modelModifiers: {
            type: null,
            default: () => ({})
          },
          "onUpdate:modelValue": {
            type: null,
            default: void 0
          },
          standalone: {
            type: Boolean,
            default: false
          }
        },
        setup(props2, ctx) {
          const rules = toRef(props2, "rules");
          const name = toRef(props2, "name");
          const label = toRef(props2, "label");
          const uncheckedValue = toRef(props2, "uncheckedValue");
          const hasModelEvents = isPropPresent(props2, "onUpdate:modelValue");
          const { errors, value, errorMessage, validate: validateField, handleChange, handleBlur, setTouched, resetField, handleReset, meta, checked, setErrors } = useField(name, rules, {
            validateOnMount: props2.validateOnMount,
            bails: props2.bails,
            standalone: props2.standalone,
            type: ctx.attrs.type,
            initialValue: resolveInitialValue(props2, ctx),
            checkedValue: ctx.attrs.value,
            uncheckedValue,
            label,
            validateOnValueUpdate: false
          });
          const onChangeHandler = hasModelEvents ? function handleChangeWithModel(e2, shouldValidate = true) {
            handleChange(e2, shouldValidate);
            ctx.emit("update:modelValue", value.value);
          } : handleChange;
          const handleInput = (e2) => {
            if (!hasCheckedAttr(ctx.attrs.type)) {
              value.value = normalizeEventValue(e2);
            }
          };
          const onInputHandler = hasModelEvents ? function handleInputWithModel(e2) {
            handleInput(e2);
            ctx.emit("update:modelValue", value.value);
          } : handleInput;
          const fieldProps = computed(() => {
            const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = resolveValidationTriggers(props2);
            const baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : void 0].filter(Boolean);
            const baseOnInput = [(e2) => onChangeHandler(e2, validateOnInput), ctx.attrs.onInput].filter(Boolean);
            const baseOnChange = [(e2) => onChangeHandler(e2, validateOnChange), ctx.attrs.onChange].filter(Boolean);
            const attrs = {
              name: props2.name,
              onBlur: baseOnBlur,
              onInput: baseOnInput,
              onChange: baseOnChange
            };
            attrs["onUpdate:modelValue"] = (e2) => onChangeHandler(e2, validateOnModelUpdate);
            if (hasCheckedAttr(ctx.attrs.type) && checked) {
              attrs.checked = checked.value;
            } else {
              attrs.value = value.value;
            }
            const tag = resolveTag(props2, ctx);
            if (shouldHaveValueBinding(tag, ctx.attrs)) {
              delete attrs.value;
            }
            return attrs;
          });
          const modelValue = toRef(props2, "modelValue");
          watch(modelValue, (newModelValue) => {
            if (newModelValue === IS_ABSENT && value.value === void 0) {
              return;
            }
            if (newModelValue !== applyModifiers(value.value, props2.modelModifiers)) {
              value.value = newModelValue === IS_ABSENT ? void 0 : newModelValue;
              validateField();
            }
          });
          function slotProps() {
            return {
              field: fieldProps.value,
              value: value.value,
              meta,
              errors: errors.value,
              errorMessage: errorMessage.value,
              validate: validateField,
              resetField,
              handleChange: onChangeHandler,
              handleInput: onInputHandler,
              handleReset,
              handleBlur,
              setTouched,
              setErrors
            };
          }
          ctx.expose({
            setErrors,
            setTouched,
            reset: resetField,
            validate: validateField,
            handleChange
          });
          return () => {
            const tag = resolveDynamicComponent(resolveTag(props2, ctx));
            const children = normalizeChildren(tag, ctx, slotProps);
            if (tag) {
              return h$5(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);
            }
            return children;
          };
        }
      });
      function resolveTag(props2, ctx) {
        let tag = props2.as || "";
        if (!props2.as && !ctx.slots.default) {
          tag = "input";
        }
        return tag;
      }
      function resolveValidationTriggers(props2) {
        var _a, _b, _c, _d;
        const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();
        return {
          validateOnInput: (_a = props2.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,
          validateOnChange: (_b = props2.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,
          validateOnBlur: (_c = props2.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,
          validateOnModelUpdate: (_d = props2.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate
        };
      }
      function applyModifiers(value, modifiers) {
        if (modifiers.number) {
          return toNumber(value);
        }
        return value;
      }
      function resolveInitialValue(props2, ctx) {
        if (!hasCheckedAttr(ctx.attrs.type)) {
          return isPropPresent(props2, "modelValue") ? props2.modelValue : ctx.attrs.value;
        }
        return isPropPresent(props2, "modelValue") ? props2.modelValue : void 0;
      }
      const Field = FieldImpl;
      let FORM_COUNTER = 0;
      function useForm(opts) {
        const formId = FORM_COUNTER++;
        let RESET_LOCK = false;
        const fieldsByPath = ref({});
        const isSubmitting = ref(false);
        const submitCount = ref(0);
        const fieldArraysLookup = {};
        const formValues = reactive(klona(unref(opts === null || opts === void 0 ? void 0 : opts.initialValues) || {}));
        const { errorBag, setErrorBag, setFieldErrorBag } = useErrorBag(opts === null || opts === void 0 ? void 0 : opts.initialErrors);
        const errors = computed(() => {
          return keysOf(errorBag.value).reduce((acc, key) => {
            const bag = errorBag.value[key];
            if (bag && bag.length) {
              acc[key] = bag[0];
            }
            return acc;
          }, {});
        });
        function getFirstFieldAtPath(path) {
          const fieldOrGroup = fieldsByPath.value[path];
          return Array.isArray(fieldOrGroup) ? fieldOrGroup[0] : fieldOrGroup;
        }
        function fieldExists(path) {
          return !!fieldsByPath.value[path];
        }
        const fieldNames = computed(() => {
          return keysOf(fieldsByPath.value).reduce((names, path) => {
            const field = getFirstFieldAtPath(path);
            if (field) {
              names[path] = unref(field.label || field.name) || "";
            }
            return names;
          }, {});
        });
        const fieldBailsMap = computed(() => {
          return keysOf(fieldsByPath.value).reduce((map2, path) => {
            var _a;
            const field = getFirstFieldAtPath(path);
            if (field) {
              map2[path] = (_a = field.bails) !== null && _a !== void 0 ? _a : true;
            }
            return map2;
          }, {});
        });
        const initialErrors = Object.assign({}, (opts === null || opts === void 0 ? void 0 : opts.initialErrors) || {});
        const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(fieldsByPath, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues);
        const meta = useFormMeta(fieldsByPath, formValues, initialValues, errors);
        const schema = opts === null || opts === void 0 ? void 0 : opts.validationSchema;
        const formCtx = {
          formId,
          fieldsByPath,
          values: formValues,
          errorBag,
          errors,
          schema,
          submitCount,
          meta,
          isSubmitting,
          fieldArraysLookup,
          validateSchema: unref(schema) ? validateSchema : void 0,
          validate: validate2,
          register: registerField,
          unregister: unregisterField,
          setFieldErrorBag,
          validateField,
          setFieldValue,
          setValues,
          setErrors,
          setFieldError,
          setFieldTouched,
          setTouched,
          resetForm,
          handleSubmit,
          stageInitialValue,
          unsetInitialValue,
          setFieldInitialValue
        };
        function isFieldGroup(fieldOrGroup) {
          return Array.isArray(fieldOrGroup);
        }
        function applyFieldMutation(fieldOrGroup, mutation) {
          if (Array.isArray(fieldOrGroup)) {
            return fieldOrGroup.forEach(mutation);
          }
          return mutation(fieldOrGroup);
        }
        function setFieldError(field, message) {
          setFieldErrorBag(field, message);
        }
        function setErrors(fields) {
          setErrorBag(fields);
        }
        function setFieldValue(field, value, { force } = { force: false }) {
          var _a;
          const fieldInstance = fieldsByPath.value[field];
          const clonedValue = klona(value);
          if (!fieldInstance) {
            setInPath(formValues, field, clonedValue);
            return;
          }
          if (isFieldGroup(fieldInstance) && ((_a = fieldInstance[0]) === null || _a === void 0 ? void 0 : _a.type) === "checkbox" && !Array.isArray(value)) {
            const newValue2 = klona(resolveNextCheckboxValue(getFromPath(formValues, field) || [], value, void 0));
            setInPath(formValues, field, newValue2);
            return;
          }
          let newValue = value;
          if (!isFieldGroup(fieldInstance) && fieldInstance.type === "checkbox" && !force && !RESET_LOCK) {
            newValue = klona(resolveNextCheckboxValue(getFromPath(formValues, field), value, unref(fieldInstance.uncheckedValue)));
          }
          setInPath(formValues, field, newValue);
        }
        function setValues(fields) {
          keysOf(formValues).forEach((key) => {
            delete formValues[key];
          });
          keysOf(fields).forEach((path) => {
            setFieldValue(path, fields[path]);
          });
          Object.values(fieldArraysLookup).forEach((f2) => f2 && f2.reset());
        }
        function setFieldTouched(field, isTouched) {
          const fieldInstance = fieldsByPath.value[field];
          if (fieldInstance) {
            applyFieldMutation(fieldInstance, (f2) => f2.setTouched(isTouched));
          }
        }
        function setTouched(fields) {
          keysOf(fields).forEach((field) => {
            setFieldTouched(field, !!fields[field]);
          });
        }
        function resetForm(state2) {
          RESET_LOCK = true;
          if (state2 === null || state2 === void 0 ? void 0 : state2.values) {
            setInitialValues(state2.values);
            setValues(state2 === null || state2 === void 0 ? void 0 : state2.values);
          } else {
            setInitialValues(originalInitialValues.value);
            setValues(originalInitialValues.value);
          }
          Object.values(fieldsByPath.value).forEach((field) => {
            if (!field) {
              return;
            }
            applyFieldMutation(field, (f2) => f2.resetField());
          });
          if (state2 === null || state2 === void 0 ? void 0 : state2.touched) {
            setTouched(state2.touched);
          }
          setErrors((state2 === null || state2 === void 0 ? void 0 : state2.errors) || {});
          submitCount.value = (state2 === null || state2 === void 0 ? void 0 : state2.submitCount) || 0;
          nextTick(() => {
            RESET_LOCK = false;
          });
        }
        function insertFieldAtPath(field, path) {
          const rawField = markRaw(field);
          const fieldPath = path;
          if (!fieldsByPath.value[fieldPath]) {
            fieldsByPath.value[fieldPath] = rawField;
            return;
          }
          const fieldAtPath = fieldsByPath.value[fieldPath];
          if (fieldAtPath && !Array.isArray(fieldAtPath)) {
            fieldsByPath.value[fieldPath] = [fieldAtPath];
          }
          fieldsByPath.value[fieldPath] = [...fieldsByPath.value[fieldPath], rawField];
        }
        function removeFieldFromPath(field, path) {
          const fieldPath = path;
          const fieldAtPath = fieldsByPath.value[fieldPath];
          if (!fieldAtPath) {
            return;
          }
          if (!isFieldGroup(fieldAtPath) && field.id === fieldAtPath.id) {
            delete fieldsByPath.value[fieldPath];
            return;
          }
          if (isFieldGroup(fieldAtPath)) {
            const idx = fieldAtPath.findIndex((f2) => f2.id === field.id);
            if (idx === -1) {
              return;
            }
            fieldAtPath.splice(idx, 1);
            if (fieldAtPath.length === 1) {
              fieldsByPath.value[fieldPath] = fieldAtPath[0];
              return;
            }
            if (!fieldAtPath.length) {
              delete fieldsByPath.value[fieldPath];
            }
          }
        }
        function registerField(field) {
          const fieldPath = unref(field.name);
          insertFieldAtPath(field, fieldPath);
          if (isRef(field.name)) {
            watch(field.name, async (newPath, oldPath) => {
              await nextTick();
              removeFieldFromPath(field, oldPath);
              insertFieldAtPath(field, newPath);
              if (errors.value[oldPath] || errors.value[newPath]) {
                validateField(newPath);
              }
              await nextTick();
              if (!fieldExists(oldPath)) {
                unsetPath(formValues, oldPath);
              }
            });
          }
          const initialErrorMessage = unref(field.errorMessage);
          if (initialErrorMessage && (initialErrors === null || initialErrors === void 0 ? void 0 : initialErrors[fieldPath]) !== initialErrorMessage) {
            validateField(fieldPath);
          }
          delete initialErrors[fieldPath];
        }
        function unregisterField(field) {
          const fieldName = unref(field.name);
          removeFieldFromPath(field, fieldName);
          nextTick(() => {
            if (!fieldExists(fieldName)) {
              setFieldError(fieldName, void 0);
              unsetPath(formValues, fieldName);
            }
          });
        }
        async function validate2(opts2) {
          if (formCtx.validateSchema) {
            return formCtx.validateSchema((opts2 === null || opts2 === void 0 ? void 0 : opts2.mode) || "force");
          }
          const validations = await Promise.all(Object.values(fieldsByPath.value).map((field) => {
            const fieldInstance = Array.isArray(field) ? field[0] : field;
            if (!fieldInstance) {
              return Promise.resolve({ key: "", valid: true, errors: [] });
            }
            return fieldInstance.validate(opts2).then((result) => {
              return {
                key: unref(fieldInstance.name),
                valid: result.valid,
                errors: result.errors
              };
            });
          }));
          const results = {};
          const errors2 = {};
          for (const validation of validations) {
            results[validation.key] = {
              valid: validation.valid,
              errors: validation.errors
            };
            if (validation.errors.length) {
              errors2[validation.key] = validation.errors[0];
            }
          }
          return {
            valid: validations.every((r2) => r2.valid),
            results,
            errors: errors2
          };
        }
        async function validateField(field) {
          const fieldInstance = fieldsByPath.value[field];
          if (!fieldInstance) {
            warn$1(`field with name ${field} was not found`);
            return Promise.resolve({ errors: [], valid: true });
          }
          if (Array.isArray(fieldInstance)) {
            return fieldInstance.map((f2) => f2.validate())[0];
          }
          return fieldInstance.validate();
        }
        function handleSubmit(fn2, onValidationError) {
          return function submissionHandler(e2) {
            if (e2 instanceof Event) {
              e2.preventDefault();
              e2.stopPropagation();
            }
            setTouched(keysOf(fieldsByPath.value).reduce((acc, field) => {
              acc[field] = true;
              return acc;
            }, {}));
            isSubmitting.value = true;
            submitCount.value++;
            return validate2().then((result) => {
              if (result.valid && typeof fn2 === "function") {
                return fn2(klona(formValues), {
                  evt: e2,
                  setErrors,
                  setFieldError,
                  setTouched,
                  setFieldTouched,
                  setValues,
                  setFieldValue,
                  resetForm
                });
              }
              if (!result.valid && typeof onValidationError === "function") {
                onValidationError({
                  values: klona(formValues),
                  evt: e2,
                  errors: result.errors,
                  results: result.results
                });
              }
            }).then((returnVal) => {
              isSubmitting.value = false;
              return returnVal;
            }, (err) => {
              isSubmitting.value = false;
              throw err;
            });
          };
        }
        function setFieldInitialValue(path, value) {
          setInPath(initialValues.value, path, klona(value));
        }
        function unsetInitialValue(path) {
          unsetPath(initialValues.value, path);
        }
        function stageInitialValue(path, value) {
          setInPath(formValues, path, value);
          setFieldInitialValue(path, value);
        }
        async function _validateSchema() {
          const schemaValue = unref(schema);
          if (!schemaValue) {
            return { valid: true, results: {}, errors: {} };
          }
          const formResult = isYupValidator(schemaValue) ? await validateYupSchema(schemaValue, formValues) : await validateObjectSchema(schemaValue, formValues, {
            names: fieldNames.value,
            bailsMap: fieldBailsMap.value
          });
          return formResult;
        }
        const debouncedSchemaValidation = debounceAsync(_validateSchema, 5);
        async function validateSchema(mode) {
          const formResult = await debouncedSchemaValidation();
          const fieldsById = formCtx.fieldsByPath.value || {};
          const currentErrorsPaths = keysOf(formCtx.errorBag.value);
          const paths = [
            ...new Set([...keysOf(formResult.results), ...keysOf(fieldsById), ...currentErrorsPaths])
          ];
          return paths.reduce((validation, path) => {
            const field = fieldsById[path];
            const messages = (formResult.results[path] || { errors: [] }).errors;
            const fieldResult = {
              errors: messages,
              valid: !messages.length
            };
            validation.results[path] = fieldResult;
            if (!fieldResult.valid) {
              validation.errors[path] = fieldResult.errors[0];
            }
            if (!field) {
              setFieldError(path, messages);
              return validation;
            }
            applyFieldMutation(field, (f2) => f2.meta.valid = fieldResult.valid);
            if (mode === "silent") {
              return validation;
            }
            const wasValidated = Array.isArray(field) ? field.some((f2) => f2.meta.validated) : field.meta.validated;
            if (mode === "validated-only" && !wasValidated) {
              return validation;
            }
            applyFieldMutation(field, (f2) => f2.setState({ errors: fieldResult.errors }));
            return validation;
          }, { valid: formResult.valid, results: {}, errors: {} });
        }
        const submitForm = handleSubmit((_2, { evt }) => {
          if (isFormSubmitEvent(evt)) {
            evt.target.submit();
          }
        });
        onMounted(() => {
          if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {
            setErrors(opts.initialErrors);
          }
          if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {
            setTouched(opts.initialTouched);
          }
          if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {
            validate2();
            return;
          }
          if (formCtx.validateSchema) {
            formCtx.validateSchema("silent");
          }
        });
        if (isRef(schema)) {
          watch(schema, () => {
            var _a;
            (_a = formCtx.validateSchema) === null || _a === void 0 ? void 0 : _a.call(formCtx, "validated-only");
          });
        }
        provide(FormContextKey, formCtx);
        {
          registerFormWithDevTools(formCtx);
          watch(() => Object.assign(Object.assign({ errors: errorBag.value }, meta.value), { values: formValues, isSubmitting: isSubmitting.value, submitCount: submitCount.value }), refreshInspector, {
            deep: true
          });
        }
        return {
          errors,
          meta,
          values: formValues,
          isSubmitting,
          submitCount,
          validate: validate2,
          validateField,
          handleReset: () => resetForm(),
          resetForm,
          handleSubmit,
          submitForm,
          setFieldError,
          setErrors,
          setFieldValue,
          setValues,
          setFieldTouched,
          setTouched
        };
      }
      function useFormMeta(fieldsByPath, currentValues, initialValues, errors) {
        const MERGE_STRATEGIES = {
          touched: "some",
          pending: "some",
          valid: "every"
        };
        const isDirty = computed(() => {
          return !es6(currentValues, unref(initialValues));
        });
        function calculateFlags() {
          const fields = Object.values(fieldsByPath.value).flat(1).filter(Boolean);
          return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
            const mergeMethod = MERGE_STRATEGIES[flag];
            acc[flag] = fields[mergeMethod]((field) => field.meta[flag]);
            return acc;
          }, {});
        }
        const flags = reactive(calculateFlags());
        watchEffect(() => {
          const value = calculateFlags();
          flags.touched = value.touched;
          flags.valid = value.valid;
          flags.pending = value.pending;
        });
        return computed(() => {
          return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { valid: flags.valid && !keysOf(errors.value).length, dirty: isDirty.value });
        });
      }
      function useFormInitialValues(fields, formValues, providedValues) {
        const initialValues = ref(klona(unref(providedValues)) || {});
        const originalInitialValues = ref(klona(unref(providedValues)) || {});
        function setInitialValues(values, updateFields = false) {
          initialValues.value = klona(values);
          originalInitialValues.value = klona(values);
          if (!updateFields) {
            return;
          }
          keysOf(fields.value).forEach((fieldPath) => {
            const field = fields.value[fieldPath];
            const wasTouched = Array.isArray(field) ? field.some((f2) => f2.meta.touched) : field === null || field === void 0 ? void 0 : field.meta.touched;
            if (!field || wasTouched) {
              return;
            }
            const newValue = getFromPath(initialValues.value, fieldPath);
            setInPath(formValues, fieldPath, klona(newValue));
          });
        }
        if (isRef(providedValues)) {
          watch(providedValues, (value) => {
            setInitialValues(value, true);
          }, {
            deep: true
          });
        }
        return {
          initialValues,
          originalInitialValues,
          setInitialValues
        };
      }
      function useErrorBag(initialErrors) {
        const errorBag = ref({});
        function normalizeErrorItem(message) {
          return Array.isArray(message) ? message : message ? [message] : [];
        }
        function setFieldErrorBag(field, message) {
          if (!message) {
            delete errorBag.value[field];
            return;
          }
          errorBag.value[field] = normalizeErrorItem(message);
        }
        function setErrorBag(fields) {
          errorBag.value = keysOf(fields).reduce((acc, key) => {
            const message = fields[key];
            if (message) {
              acc[key] = normalizeErrorItem(message);
            }
            return acc;
          }, {});
        }
        if (initialErrors) {
          setErrorBag(initialErrors);
        }
        return {
          errorBag,
          setErrorBag,
          setFieldErrorBag
        };
      }
      const FormImpl = defineComponent({
        name: "Form",
        inheritAttrs: false,
        props: {
          as: {
            type: String,
            default: "form"
          },
          validationSchema: {
            type: Object,
            default: void 0
          },
          initialValues: {
            type: Object,
            default: void 0
          },
          initialErrors: {
            type: Object,
            default: void 0
          },
          initialTouched: {
            type: Object,
            default: void 0
          },
          validateOnMount: {
            type: Boolean,
            default: false
          },
          onSubmit: {
            type: Function,
            default: void 0
          },
          onInvalidSubmit: {
            type: Function,
            default: void 0
          }
        },
        setup(props2, ctx) {
          const initialValues = toRef(props2, "initialValues");
          const validationSchema = toRef(props2, "validationSchema");
          const { errors, values, meta, isSubmitting, submitCount, validate: validate2, validateField, handleReset, resetForm, handleSubmit, submitForm, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched } = useForm({
            validationSchema: validationSchema.value ? validationSchema : void 0,
            initialValues,
            initialErrors: props2.initialErrors,
            initialTouched: props2.initialTouched,
            validateOnMount: props2.validateOnMount
          });
          const onSubmit = props2.onSubmit ? handleSubmit(props2.onSubmit, props2.onInvalidSubmit) : submitForm;
          function handleFormReset(e2) {
            if (isEvent(e2)) {
              e2.preventDefault();
            }
            handleReset();
            if (typeof ctx.attrs.onReset === "function") {
              ctx.attrs.onReset();
            }
          }
          function handleScopedSlotSubmit(evt, onSubmit2) {
            const onSuccess = typeof evt === "function" && !onSubmit2 ? evt : onSubmit2;
            return handleSubmit(onSuccess, props2.onInvalidSubmit)(evt);
          }
          function slotProps() {
            return {
              meta: meta.value,
              errors: errors.value,
              values,
              isSubmitting: isSubmitting.value,
              submitCount: submitCount.value,
              validate: validate2,
              validateField,
              handleSubmit: handleScopedSlotSubmit,
              handleReset,
              submitForm,
              setErrors,
              setFieldError,
              setFieldValue,
              setValues,
              setFieldTouched,
              setTouched,
              resetForm
            };
          }
          ctx.expose({
            setFieldError,
            setErrors,
            setFieldValue,
            setValues,
            setFieldTouched,
            setTouched,
            resetForm,
            validate: validate2,
            validateField
          });
          return function renderForm() {
            const tag = props2.as === "form" ? props2.as : resolveDynamicComponent(props2.as);
            const children = normalizeChildren(tag, ctx, slotProps);
            if (!props2.as) {
              return children;
            }
            const formAttrs = props2.as === "form" ? {
              novalidate: true
            } : {};
            return h$5(tag, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);
          };
        }
      });
      const Form = FormImpl;
      let FIELD_ARRAY_COUNTER = 0;
      function useFieldArray(arrayPath) {
        const id = FIELD_ARRAY_COUNTER++;
        const form = injectWithSelf(FormContextKey, void 0);
        const fields = ref([]);
        const noOp = () => {
        };
        const noOpApi = {
          fields: readonly(fields),
          remove: noOp,
          push: noOp,
          swap: noOp,
          insert: noOp,
          update: noOp,
          replace: noOp,
          prepend: noOp
        };
        if (!form) {
          warn("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly");
          return noOpApi;
        }
        if (!unref(arrayPath)) {
          warn("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?");
          return noOpApi;
        }
        let entryCounter = 0;
        function initFields() {
          const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []);
          fields.value = currentValues.map(createEntry);
          updateEntryFlags();
        }
        initFields();
        function updateEntryFlags() {
          const fieldsLength = fields.value.length;
          for (let i2 = 0; i2 < fieldsLength; i2++) {
            const entry = fields.value[i2];
            entry.isFirst = i2 === 0;
            entry.isLast = i2 === fieldsLength - 1;
          }
        }
        function createEntry(value) {
          const key = entryCounter++;
          const entry = {
            key,
            value: computed(() => {
              const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []);
              const idx = fields.value.findIndex((e2) => e2.key === key);
              return idx === -1 ? value : currentValues[idx];
            }),
            isFirst: false,
            isLast: false
          };
          return entry;
        }
        function remove2(idx) {
          const pathName = unref(arrayPath);
          const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
          if (!pathValue || !Array.isArray(pathValue)) {
            return;
          }
          const newValue = [...pathValue];
          newValue.splice(idx, 1);
          form === null || form === void 0 ? void 0 : form.unsetInitialValue(pathName + `[${idx}]`);
          form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
          fields.value.splice(idx, 1);
          updateEntryFlags();
        }
        function push2(value) {
          const pathName = unref(arrayPath);
          const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
          const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;
          if (!Array.isArray(normalizedPathValue)) {
            return;
          }
          const newValue = [...normalizedPathValue];
          newValue.push(value);
          form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value);
          form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
          fields.value.push(createEntry(value));
          updateEntryFlags();
        }
        function swap(indexA, indexB) {
          const pathName = unref(arrayPath);
          const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
          if (!Array.isArray(pathValue) || !pathValue[indexA] || !pathValue[indexB]) {
            return;
          }
          const newValue = [...pathValue];
          const newFields = [...fields.value];
          const temp = newValue[indexA];
          newValue[indexA] = newValue[indexB];
          newValue[indexB] = temp;
          const tempEntry = newFields[indexA];
          newFields[indexA] = newFields[indexB];
          newFields[indexB] = tempEntry;
          form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
          fields.value = newFields;
          updateEntryFlags();
        }
        function insert(idx, value) {
          const pathName = unref(arrayPath);
          const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
          if (!Array.isArray(pathValue) || pathValue.length < idx) {
            return;
          }
          const newValue = [...pathValue];
          const newFields = [...fields.value];
          newValue.splice(idx, 0, value);
          newFields.splice(idx, 0, createEntry(value));
          form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
          fields.value = newFields;
          updateEntryFlags();
        }
        function replace2(arr) {
          const pathName = unref(arrayPath);
          form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, arr);
          initFields();
        }
        function update2(idx, value) {
          const pathName = unref(arrayPath);
          const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
          if (!Array.isArray(pathValue) || pathValue.length - 1 < idx) {
            return;
          }
          form === null || form === void 0 ? void 0 : form.setFieldValue(`${pathName}[${idx}]`, value);
        }
        function prepend(value) {
          const pathName = unref(arrayPath);
          const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
          const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;
          if (!Array.isArray(normalizedPathValue)) {
            return;
          }
          const newValue = [value, ...normalizedPathValue];
          form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value);
          form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
          fields.value.unshift(createEntry(value));
          updateEntryFlags();
        }
        form.fieldArraysLookup[id] = {
          reset: initFields
        };
        onBeforeUnmount(() => {
          delete form.fieldArraysLookup[id];
        });
        return {
          fields: readonly(fields),
          remove: remove2,
          push: push2,
          swap,
          insert,
          update: update2,
          replace: replace2,
          prepend
        };
      }
      defineComponent({
        name: "FieldArray",
        inheritAttrs: false,
        props: {
          name: {
            type: String,
            required: true
          }
        },
        setup(props2, ctx) {
          const { push: push2, remove: remove2, swap, insert, replace: replace2, update: update2, prepend, fields } = useFieldArray(toRef(props2, "name"));
          function slotProps() {
            return {
              fields: fields.value,
              push: push2,
              remove: remove2,
              swap,
              insert,
              update: update2,
              replace: replace2,
              prepend
            };
          }
          ctx.expose({
            push: push2,
            remove: remove2,
            swap,
            insert,
            update: update2,
            replace: replace2,
            prepend
          });
          return () => {
            const children = normalizeChildren(void 0, ctx, slotProps);
            return children;
          };
        }
      });
      defineComponent({
        name: "ErrorMessage",
        props: {
          as: {
            type: String,
            default: void 0
          },
          name: {
            type: String,
            required: true
          }
        },
        setup(props2, ctx) {
          const form = inject(FormContextKey, void 0);
          const message = computed(() => {
            return form === null || form === void 0 ? void 0 : form.errors.value[props2.name];
          });
          function slotProps() {
            return {
              message: message.value
            };
          }
          return () => {
            if (!message.value) {
              return void 0;
            }
            const tag = props2.as ? resolveDynamicComponent(props2.as) : props2.as;
            const children = normalizeChildren(tag, ctx, slotProps);
            const attrs = Object.assign({ role: "alert" }, ctx.attrs);
            if (!tag && (Array.isArray(children) || !children) && (children === null || children === void 0 ? void 0 : children.length)) {
              return children;
            }
            if ((Array.isArray(children) || !children) && !(children === null || children === void 0 ? void 0 : children.length)) {
              return h$5(tag || "span", attrs, message.value);
            }
            return h$5(tag, attrs, children);
          };
        }
      });
      /*!
       * vuex v4.0.2
       * (c) 2021 Evan You
       * @license MIT
       */
      var storeKey = "store";
      function find$1(list, f2) {
        return list.filter(f2)[0];
      }
      function deepCopy(obj, cache) {
        if (cache === void 0)
          cache = [];
        if (obj === null || typeof obj !== "object") {
          return obj;
        }
        var hit = find$1(cache, function(c2) {
          return c2.original === obj;
        });
        if (hit) {
          return hit.copy;
        }
        var copy = Array.isArray(obj) ? [] : {};
        cache.push({
          original: obj,
          copy
        });
        Object.keys(obj).forEach(function(key) {
          copy[key] = deepCopy(obj[key], cache);
        });
        return copy;
      }
      function forEachValue(obj, fn2) {
        Object.keys(obj).forEach(function(key) {
          return fn2(obj[key], key);
        });
      }
      function isObject$3(obj) {
        return obj !== null && typeof obj === "object";
      }
      function isPromise(val) {
        return val && typeof val.then === "function";
      }
      function assert(condition, msg) {
        if (!condition) {
          throw new Error("[vuex] " + msg);
        }
      }
      function partial(fn2, arg) {
        return function() {
          return fn2(arg);
        };
      }
      function genericSubscribe(fn2, subs, options) {
        if (subs.indexOf(fn2) < 0) {
          options && options.prepend ? subs.unshift(fn2) : subs.push(fn2);
        }
        return function() {
          var i2 = subs.indexOf(fn2);
          if (i2 > -1) {
            subs.splice(i2, 1);
          }
        };
      }
      function resetStore(store2, hot) {
        store2._actions = Object.create(null);
        store2._mutations = Object.create(null);
        store2._wrappedGetters = Object.create(null);
        store2._modulesNamespaceMap = Object.create(null);
        var state2 = store2.state;
        installModule(store2, state2, [], store2._modules.root, true);
        resetStoreState(store2, state2, hot);
      }
      function resetStoreState(store2, state2, hot) {
        var oldState = store2._state;
        store2.getters = {};
        store2._makeLocalGettersCache = Object.create(null);
        var wrappedGetters = store2._wrappedGetters;
        var computedObj = {};
        forEachValue(wrappedGetters, function(fn2, key) {
          computedObj[key] = partial(fn2, store2);
          Object.defineProperty(store2.getters, key, {
            get: function() {
              return computedObj[key]();
            },
            enumerable: true
          });
        });
        store2._state = reactive({
          data: state2
        });
        if (store2.strict) {
          enableStrictMode(store2);
        }
        if (oldState) {
          if (hot) {
            store2._withCommit(function() {
              oldState.data = null;
            });
          }
        }
      }
      function installModule(store2, rootState, path, module2, hot) {
        var isRoot = !path.length;
        var namespace = store2._modules.getNamespace(path);
        if (module2.namespaced) {
          if (store2._modulesNamespaceMap[namespace] && true) {
            console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
          }
          store2._modulesNamespaceMap[namespace] = module2;
        }
        if (!isRoot && !hot) {
          var parentState = getNestedState(rootState, path.slice(0, -1));
          var moduleName = path[path.length - 1];
          store2._withCommit(function() {
            {
              if (moduleName in parentState) {
                console.warn('[vuex] state field "' + moduleName + '" was overridden by a module with the same name at "' + path.join(".") + '"');
              }
            }
            parentState[moduleName] = module2.state;
          });
        }
        var local = module2.context = makeLocalContext(store2, namespace, path);
        module2.forEachMutation(function(mutation, key) {
          var namespacedType = namespace + key;
          registerMutation(store2, namespacedType, mutation, local);
        });
        module2.forEachAction(function(action, key) {
          var type = action.root ? key : namespace + key;
          var handler = action.handler || action;
          registerAction(store2, type, handler, local);
        });
        module2.forEachGetter(function(getter, key) {
          var namespacedType = namespace + key;
          registerGetter(store2, namespacedType, getter, local);
        });
        module2.forEachChild(function(child, key) {
          installModule(store2, rootState, path.concat(key), child, hot);
        });
      }
      function makeLocalContext(store2, namespace, path) {
        var noNamespace = namespace === "";
        var local = {
          dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
            var args = unifyObjectStyle(_type, _payload, _options);
            var payload = args.payload;
            var options = args.options;
            var type = args.type;
            if (!options || !options.root) {
              type = namespace + type;
              if (!store2._actions[type]) {
                console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
                return;
              }
            }
            return store2.dispatch(type, payload);
          },
          commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
            var args = unifyObjectStyle(_type, _payload, _options);
            var payload = args.payload;
            var options = args.options;
            var type = args.type;
            if (!options || !options.root) {
              type = namespace + type;
              if (!store2._mutations[type]) {
                console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
                return;
              }
            }
            store2.commit(type, payload, options);
          }
        };
        Object.defineProperties(local, {
          getters: {
            get: noNamespace ? function() {
              return store2.getters;
            } : function() {
              return makeLocalGetters(store2, namespace);
            }
          },
          state: {
            get: function() {
              return getNestedState(store2.state, path);
            }
          }
        });
        return local;
      }
      function makeLocalGetters(store2, namespace) {
        if (!store2._makeLocalGettersCache[namespace]) {
          var gettersProxy = {};
          var splitPos = namespace.length;
          Object.keys(store2.getters).forEach(function(type) {
            if (type.slice(0, splitPos) !== namespace) {
              return;
            }
            var localType = type.slice(splitPos);
            Object.defineProperty(gettersProxy, localType, {
              get: function() {
                return store2.getters[type];
              },
              enumerable: true
            });
          });
          store2._makeLocalGettersCache[namespace] = gettersProxy;
        }
        return store2._makeLocalGettersCache[namespace];
      }
      function registerMutation(store2, type, handler, local) {
        var entry = store2._mutations[type] || (store2._mutations[type] = []);
        entry.push(function wrappedMutationHandler(payload) {
          handler.call(store2, local.state, payload);
        });
      }
      function registerAction(store2, type, handler, local) {
        var entry = store2._actions[type] || (store2._actions[type] = []);
        entry.push(function wrappedActionHandler(payload) {
          var res = handler.call(store2, {
            dispatch: local.dispatch,
            commit: local.commit,
            getters: local.getters,
            state: local.state,
            rootGetters: store2.getters,
            rootState: store2.state
          }, payload);
          if (!isPromise(res)) {
            res = Promise.resolve(res);
          }
          if (store2._devtoolHook) {
            return res.catch(function(err) {
              store2._devtoolHook.emit("vuex:error", err);
              throw err;
            });
          } else {
            return res;
          }
        });
      }
      function registerGetter(store2, type, rawGetter, local) {
        if (store2._wrappedGetters[type]) {
          {
            console.error("[vuex] duplicate getter key: " + type);
          }
          return;
        }
        store2._wrappedGetters[type] = function wrappedGetter(store3) {
          return rawGetter(local.state, local.getters, store3.state, store3.getters);
        };
      }
      function enableStrictMode(store2) {
        watch(function() {
          return store2._state.data;
        }, function() {
          {
            assert(store2._committing, "do not mutate vuex store state outside mutation handlers.");
          }
        }, { deep: true, flush: "sync" });
      }
      function getNestedState(state2, path) {
        return path.reduce(function(state3, key) {
          return state3[key];
        }, state2);
      }
      function unifyObjectStyle(type, payload, options) {
        if (isObject$3(type) && type.type) {
          options = payload;
          payload = type;
          type = type.type;
        }
        {
          assert(typeof type === "string", "expects string as the type, but found " + typeof type + ".");
        }
        return { type, payload, options };
      }
      var LABEL_VUEX_BINDINGS = "vuex bindings";
      var MUTATIONS_LAYER_ID = "vuex:mutations";
      var ACTIONS_LAYER_ID = "vuex:actions";
      var INSPECTOR_ID = "vuex";
      var actionId = 0;
      function addDevtools(app, store2) {
        setupDevtoolsPlugin({
          id: "org.vuejs.vuex",
          app,
          label: "Vuex",
          homepage: "https://next.vuex.vuejs.org/",
          logo: "https://vuejs.org/images/icons/favicon-96x96.png",
          packageName: "vuex",
          componentStateTypes: [LABEL_VUEX_BINDINGS]
        }, function(api2) {
          api2.addTimelineLayer({
            id: MUTATIONS_LAYER_ID,
            label: "Vuex Mutations",
            color: COLOR_LIME_500
          });
          api2.addTimelineLayer({
            id: ACTIONS_LAYER_ID,
            label: "Vuex Actions",
            color: COLOR_LIME_500
          });
          api2.addInspector({
            id: INSPECTOR_ID,
            label: "Vuex",
            icon: "storage",
            treeFilterPlaceholder: "Filter stores..."
          });
          api2.on.getInspectorTree(function(payload) {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
              if (payload.filter) {
                var nodes = [];
                flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
                payload.rootNodes = nodes;
              } else {
                payload.rootNodes = [
                  formatStoreForInspectorTree(store2._modules.root, "")
                ];
              }
            }
          });
          api2.on.getInspectorState(function(payload) {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
              var modulePath = payload.nodeId;
              makeLocalGetters(store2, modulePath);
              payload.state = formatStoreForInspectorState(getStoreModule(store2._modules, modulePath), modulePath === "root" ? store2.getters : store2._makeLocalGettersCache, modulePath);
            }
          });
          api2.on.editInspectorState(function(payload) {
            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
              var modulePath = payload.nodeId;
              var path = payload.path;
              if (modulePath !== "root") {
                path = modulePath.split("/").filter(Boolean).concat(path);
              }
              store2._withCommit(function() {
                payload.set(store2._state.data, path, payload.state.value);
              });
            }
          });
          store2.subscribe(function(mutation, state2) {
            var data2 = {};
            if (mutation.payload) {
              data2.payload = mutation.payload;
            }
            data2.state = state2;
            api2.notifyComponentUpdate();
            api2.sendInspectorTree(INSPECTOR_ID);
            api2.sendInspectorState(INSPECTOR_ID);
            api2.addTimelineEvent({
              layerId: MUTATIONS_LAYER_ID,
              event: {
                time: Date.now(),
                title: mutation.type,
                data: data2
              }
            });
          });
          store2.subscribeAction({
            before: function(action, state2) {
              var data2 = {};
              if (action.payload) {
                data2.payload = action.payload;
              }
              action._id = actionId++;
              action._time = Date.now();
              data2.state = state2;
              api2.addTimelineEvent({
                layerId: ACTIONS_LAYER_ID,
                event: {
                  time: action._time,
                  title: action.type,
                  groupId: action._id,
                  subtitle: "start",
                  data: data2
                }
              });
            },
            after: function(action, state2) {
              var data2 = {};
              var duration = Date.now() - action._time;
              data2.duration = {
                _custom: {
                  type: "duration",
                  display: duration + "ms",
                  tooltip: "Action duration",
                  value: duration
                }
              };
              if (action.payload) {
                data2.payload = action.payload;
              }
              data2.state = state2;
              api2.addTimelineEvent({
                layerId: ACTIONS_LAYER_ID,
                event: {
                  time: Date.now(),
                  title: action.type,
                  groupId: action._id,
                  subtitle: "end",
                  data: data2
                }
              });
            }
          });
        });
      }
      var COLOR_LIME_500 = 8702998;
      var COLOR_DARK = 6710886;
      var COLOR_WHITE = 16777215;
      var TAG_NAMESPACED = {
        label: "namespaced",
        textColor: COLOR_WHITE,
        backgroundColor: COLOR_DARK
      };
      function extractNameFromPath(path) {
        return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
      }
      function formatStoreForInspectorTree(module2, path) {
        return {
          id: path || "root",
          label: extractNameFromPath(path),
          tags: module2.namespaced ? [TAG_NAMESPACED] : [],
          children: Object.keys(module2._children).map(function(moduleName) {
            return formatStoreForInspectorTree(module2._children[moduleName], path + moduleName + "/");
          })
        };
      }
      function flattenStoreForInspectorTree(result, module2, filter, path) {
        if (path.includes(filter)) {
          result.push({
            id: path || "root",
            label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
            tags: module2.namespaced ? [TAG_NAMESPACED] : []
          });
        }
        Object.keys(module2._children).forEach(function(moduleName) {
          flattenStoreForInspectorTree(result, module2._children[moduleName], filter, path + moduleName + "/");
        });
      }
      function formatStoreForInspectorState(module2, getters, path) {
        getters = path === "root" ? getters : getters[path];
        var gettersKeys = Object.keys(getters);
        var storeState = {
          state: Object.keys(module2.state).map(function(key) {
            return {
              key,
              editable: true,
              value: module2.state[key]
            };
          })
        };
        if (gettersKeys.length) {
          var tree = transformPathsToObjectTree(getters);
          storeState.getters = Object.keys(tree).map(function(key) {
            return {
              key: key.endsWith("/") ? extractNameFromPath(key) : key,
              editable: false,
              value: canThrow(function() {
                return tree[key];
              })
            };
          });
        }
        return storeState;
      }
      function transformPathsToObjectTree(getters) {
        var result = {};
        Object.keys(getters).forEach(function(key) {
          var path = key.split("/");
          if (path.length > 1) {
            var target = result;
            var leafKey = path.pop();
            path.forEach(function(p2) {
              if (!target[p2]) {
                target[p2] = {
                  _custom: {
                    value: {},
                    display: p2,
                    tooltip: "Module",
                    abstract: true
                  }
                };
              }
              target = target[p2]._custom.value;
            });
            target[leafKey] = canThrow(function() {
              return getters[key];
            });
          } else {
            result[key] = canThrow(function() {
              return getters[key];
            });
          }
        });
        return result;
      }
      function getStoreModule(moduleMap, path) {
        var names = path.split("/").filter(function(n2) {
          return n2;
        });
        return names.reduce(function(module2, moduleName, i2) {
          var child = module2[moduleName];
          if (!child) {
            throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
          }
          return i2 === names.length - 1 ? child : child._children;
        }, path === "root" ? moduleMap : moduleMap.root._children);
      }
      function canThrow(cb) {
        try {
          return cb();
        } catch (e2) {
          return e2;
        }
      }
      var Module = function Module2(rawModule, runtime) {
        this.runtime = runtime;
        this._children = Object.create(null);
        this._rawModule = rawModule;
        var rawState = rawModule.state;
        this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
      };
      var prototypeAccessors$1 = { namespaced: { configurable: true } };
      prototypeAccessors$1.namespaced.get = function() {
        return !!this._rawModule.namespaced;
      };
      Module.prototype.addChild = function addChild(key, module2) {
        this._children[key] = module2;
      };
      Module.prototype.removeChild = function removeChild(key) {
        delete this._children[key];
      };
      Module.prototype.getChild = function getChild2(key) {
        return this._children[key];
      };
      Module.prototype.hasChild = function hasChild(key) {
        return key in this._children;
      };
      Module.prototype.update = function update2(rawModule) {
        this._rawModule.namespaced = rawModule.namespaced;
        if (rawModule.actions) {
          this._rawModule.actions = rawModule.actions;
        }
        if (rawModule.mutations) {
          this._rawModule.mutations = rawModule.mutations;
        }
        if (rawModule.getters) {
          this._rawModule.getters = rawModule.getters;
        }
      };
      Module.prototype.forEachChild = function forEachChild(fn2) {
        forEachValue(this._children, fn2);
      };
      Module.prototype.forEachGetter = function forEachGetter(fn2) {
        if (this._rawModule.getters) {
          forEachValue(this._rawModule.getters, fn2);
        }
      };
      Module.prototype.forEachAction = function forEachAction(fn2) {
        if (this._rawModule.actions) {
          forEachValue(this._rawModule.actions, fn2);
        }
      };
      Module.prototype.forEachMutation = function forEachMutation(fn2) {
        if (this._rawModule.mutations) {
          forEachValue(this._rawModule.mutations, fn2);
        }
      };
      Object.defineProperties(Module.prototype, prototypeAccessors$1);
      var ModuleCollection = function ModuleCollection2(rawRootModule) {
        this.register([], rawRootModule, false);
      };
      ModuleCollection.prototype.get = function get2(path) {
        return path.reduce(function(module2, key) {
          return module2.getChild(key);
        }, this.root);
      };
      ModuleCollection.prototype.getNamespace = function getNamespace(path) {
        var module2 = this.root;
        return path.reduce(function(namespace, key) {
          module2 = module2.getChild(key);
          return namespace + (module2.namespaced ? key + "/" : "");
        }, "");
      };
      ModuleCollection.prototype.update = function update$1(rawRootModule) {
        update([], this.root, rawRootModule);
      };
      ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
        var this$1$1 = this;
        if (runtime === void 0)
          runtime = true;
        {
          assertRawModule(path, rawModule);
        }
        var newModule = new Module(rawModule, runtime);
        if (path.length === 0) {
          this.root = newModule;
        } else {
          var parent2 = this.get(path.slice(0, -1));
          parent2.addChild(path[path.length - 1], newModule);
        }
        if (rawModule.modules) {
          forEachValue(rawModule.modules, function(rawChildModule, key) {
            this$1$1.register(path.concat(key), rawChildModule, runtime);
          });
        }
      };
      ModuleCollection.prototype.unregister = function unregister(path) {
        var parent2 = this.get(path.slice(0, -1));
        var key = path[path.length - 1];
        var child = parent2.getChild(key);
        if (!child) {
          {
            console.warn("[vuex] trying to unregister module '" + key + "', which is not registered");
          }
          return;
        }
        if (!child.runtime) {
          return;
        }
        parent2.removeChild(key);
      };
      ModuleCollection.prototype.isRegistered = function isRegistered(path) {
        var parent2 = this.get(path.slice(0, -1));
        var key = path[path.length - 1];
        if (parent2) {
          return parent2.hasChild(key);
        }
        return false;
      };
      function update(path, targetModule, newModule) {
        {
          assertRawModule(path, newModule);
        }
        targetModule.update(newModule);
        if (newModule.modules) {
          for (var key in newModule.modules) {
            if (!targetModule.getChild(key)) {
              {
                console.warn("[vuex] trying to add a new module '" + key + "' on hot reloading, manual reload is needed");
              }
              return;
            }
            update(path.concat(key), targetModule.getChild(key), newModule.modules[key]);
          }
        }
      }
      var functionAssert = {
        assert: function(value) {
          return typeof value === "function";
        },
        expected: "function"
      };
      var objectAssert = {
        assert: function(value) {
          return typeof value === "function" || typeof value === "object" && typeof value.handler === "function";
        },
        expected: 'function or object with "handler" function'
      };
      var assertTypes = {
        getters: functionAssert,
        mutations: functionAssert,
        actions: objectAssert
      };
      function assertRawModule(path, rawModule) {
        Object.keys(assertTypes).forEach(function(key) {
          if (!rawModule[key]) {
            return;
          }
          var assertOptions2 = assertTypes[key];
          forEachValue(rawModule[key], function(value, type) {
            assert(assertOptions2.assert(value), makeAssertionMessage(path, key, type, value, assertOptions2.expected));
          });
        });
      }
      function makeAssertionMessage(path, key, type, value, expected) {
        var buf = key + " should be " + expected + ' but "' + key + "." + type + '"';
        if (path.length > 0) {
          buf += ' in module "' + path.join(".") + '"';
        }
        buf += " is " + JSON.stringify(value) + ".";
        return buf;
      }
      function createStore(options) {
        return new Store(options);
      }
      var Store = function Store2(options) {
        var this$1$1 = this;
        if (options === void 0)
          options = {};
        {
          assert(typeof Promise !== "undefined", "vuex requires a Promise polyfill in this browser.");
          assert(this instanceof Store2, "store must be called with the new operator.");
        }
        var plugins2 = options.plugins;
        if (plugins2 === void 0)
          plugins2 = [];
        var strict = options.strict;
        if (strict === void 0)
          strict = false;
        var devtools = options.devtools;
        this._committing = false;
        this._actions = Object.create(null);
        this._actionSubscribers = [];
        this._mutations = Object.create(null);
        this._wrappedGetters = Object.create(null);
        this._modules = new ModuleCollection(options);
        this._modulesNamespaceMap = Object.create(null);
        this._subscribers = [];
        this._makeLocalGettersCache = Object.create(null);
        this._devtools = devtools;
        var store2 = this;
        var ref2 = this;
        var dispatch = ref2.dispatch;
        var commit = ref2.commit;
        this.dispatch = function boundDispatch(type, payload) {
          return dispatch.call(store2, type, payload);
        };
        this.commit = function boundCommit(type, payload, options2) {
          return commit.call(store2, type, payload, options2);
        };
        this.strict = strict;
        var state2 = this._modules.root.state;
        installModule(this, state2, [], this._modules.root);
        resetStoreState(this, state2);
        plugins2.forEach(function(plugin) {
          return plugin(this$1$1);
        });
      };
      var prototypeAccessors = { state: { configurable: true } };
      Store.prototype.install = function install(app, injectKey) {
        app.provide(injectKey || storeKey, this);
        app.config.globalProperties.$store = this;
        var useDevtools = this._devtools !== void 0 ? this._devtools : true;
        if (useDevtools) {
          addDevtools(app, this);
        }
      };
      prototypeAccessors.state.get = function() {
        return this._state.data;
      };
      prototypeAccessors.state.set = function(v2) {
        {
          assert(false, "use store.replaceState() to explicit replace store state.");
        }
      };
      Store.prototype.commit = function commit(_type, _payload, _options) {
        var this$1$1 = this;
        var ref2 = unifyObjectStyle(_type, _payload, _options);
        var type = ref2.type;
        var payload = ref2.payload;
        var options = ref2.options;
        var mutation = { type, payload };
        var entry = this._mutations[type];
        if (!entry) {
          {
            console.error("[vuex] unknown mutation type: " + type);
          }
          return;
        }
        this._withCommit(function() {
          entry.forEach(function commitIterator(handler) {
            handler(payload);
          });
        });
        this._subscribers.slice().forEach(function(sub) {
          return sub(mutation, this$1$1.state);
        });
        if (options && options.silent) {
          console.warn("[vuex] mutation type: " + type + ". Silent option has been removed. Use the filter functionality in the vue-devtools");
        }
      };
      Store.prototype.dispatch = function dispatch(_type, _payload) {
        var this$1$1 = this;
        var ref2 = unifyObjectStyle(_type, _payload);
        var type = ref2.type;
        var payload = ref2.payload;
        var action = { type, payload };
        var entry = this._actions[type];
        if (!entry) {
          {
            console.error("[vuex] unknown action type: " + type);
          }
          return;
        }
        try {
          this._actionSubscribers.slice().filter(function(sub) {
            return sub.before;
          }).forEach(function(sub) {
            return sub.before(action, this$1$1.state);
          });
        } catch (e2) {
          {
            console.warn("[vuex] error in before action subscribers: ");
            console.error(e2);
          }
        }
        var result = entry.length > 1 ? Promise.all(entry.map(function(handler) {
          return handler(payload);
        })) : entry[0](payload);
        return new Promise(function(resolve, reject) {
          result.then(function(res) {
            try {
              this$1$1._actionSubscribers.filter(function(sub) {
                return sub.after;
              }).forEach(function(sub) {
                return sub.after(action, this$1$1.state);
              });
            } catch (e2) {
              {
                console.warn("[vuex] error in after action subscribers: ");
                console.error(e2);
              }
            }
            resolve(res);
          }, function(error) {
            try {
              this$1$1._actionSubscribers.filter(function(sub) {
                return sub.error;
              }).forEach(function(sub) {
                return sub.error(action, this$1$1.state, error);
              });
            } catch (e2) {
              {
                console.warn("[vuex] error in error action subscribers: ");
                console.error(e2);
              }
            }
            reject(error);
          });
        });
      };
      Store.prototype.subscribe = function subscribe(fn2, options) {
        return genericSubscribe(fn2, this._subscribers, options);
      };
      Store.prototype.subscribeAction = function subscribeAction(fn2, options) {
        var subs = typeof fn2 === "function" ? { before: fn2 } : fn2;
        return genericSubscribe(subs, this._actionSubscribers, options);
      };
      Store.prototype.watch = function watch$1(getter, cb, options) {
        var this$1$1 = this;
        {
          assert(typeof getter === "function", "store.watch only accepts a function.");
        }
        return watch(function() {
          return getter(this$1$1.state, this$1$1.getters);
        }, cb, Object.assign({}, options));
      };
      Store.prototype.replaceState = function replaceState(state2) {
        var this$1$1 = this;
        this._withCommit(function() {
          this$1$1._state.data = state2;
        });
      };
      Store.prototype.registerModule = function registerModule(path, rawModule, options) {
        if (options === void 0)
          options = {};
        if (typeof path === "string") {
          path = [path];
        }
        {
          assert(Array.isArray(path), "module path must be a string or an Array.");
          assert(path.length > 0, "cannot register the root module by using registerModule.");
        }
        this._modules.register(path, rawModule);
        installModule(this, this.state, path, this._modules.get(path), options.preserveState);
        resetStoreState(this, this.state);
      };
      Store.prototype.unregisterModule = function unregisterModule(path) {
        var this$1$1 = this;
        if (typeof path === "string") {
          path = [path];
        }
        {
          assert(Array.isArray(path), "module path must be a string or an Array.");
        }
        this._modules.unregister(path);
        this._withCommit(function() {
          var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
          delete parentState[path[path.length - 1]];
        });
        resetStore(this);
      };
      Store.prototype.hasModule = function hasModule(path) {
        if (typeof path === "string") {
          path = [path];
        }
        {
          assert(Array.isArray(path), "module path must be a string or an Array.");
        }
        return this._modules.isRegistered(path);
      };
      Store.prototype.hotUpdate = function hotUpdate(newOptions) {
        this._modules.update(newOptions);
        resetStore(this, true);
      };
      Store.prototype._withCommit = function _withCommit(fn2) {
        var committing = this._committing;
        this._committing = true;
        fn2();
        this._committing = committing;
      };
      Object.defineProperties(Store.prototype, prototypeAccessors);
      function createLogger(ref2) {
        if (ref2 === void 0)
          ref2 = {};
        var collapsed = ref2.collapsed;
        if (collapsed === void 0)
          collapsed = true;
        var filter = ref2.filter;
        if (filter === void 0)
          filter = function(mutation, stateBefore, stateAfter) {
            return true;
          };
        var transformer = ref2.transformer;
        if (transformer === void 0)
          transformer = function(state2) {
            return state2;
          };
        var mutationTransformer = ref2.mutationTransformer;
        if (mutationTransformer === void 0)
          mutationTransformer = function(mut) {
            return mut;
          };
        var actionFilter = ref2.actionFilter;
        if (actionFilter === void 0)
          actionFilter = function(action, state2) {
            return true;
          };
        var actionTransformer = ref2.actionTransformer;
        if (actionTransformer === void 0)
          actionTransformer = function(act) {
            return act;
          };
        var logMutations = ref2.logMutations;
        if (logMutations === void 0)
          logMutations = true;
        var logActions = ref2.logActions;
        if (logActions === void 0)
          logActions = true;
        var logger2 = ref2.logger;
        if (logger2 === void 0)
          logger2 = console;
        return function(store2) {
          var prevState = deepCopy(store2.state);
          if (typeof logger2 === "undefined") {
            return;
          }
          if (logMutations) {
            store2.subscribe(function(mutation, state2) {
              var nextState = deepCopy(state2);
              if (filter(mutation, prevState, nextState)) {
                var formattedTime = getFormattedTime();
                var formattedMutation = mutationTransformer(mutation);
                var message = "mutation " + mutation.type + formattedTime;
                startMessage(logger2, message, collapsed);
                logger2.log("%c prev state", "color: #9E9E9E; font-weight: bold", transformer(prevState));
                logger2.log("%c mutation", "color: #03A9F4; font-weight: bold", formattedMutation);
                logger2.log("%c next state", "color: #4CAF50; font-weight: bold", transformer(nextState));
                endMessage(logger2);
              }
              prevState = nextState;
            });
          }
          if (logActions) {
            store2.subscribeAction(function(action, state2) {
              if (actionFilter(action, state2)) {
                var formattedTime = getFormattedTime();
                var formattedAction = actionTransformer(action);
                var message = "action " + action.type + formattedTime;
                startMessage(logger2, message, collapsed);
                logger2.log("%c action", "color: #03A9F4; font-weight: bold", formattedAction);
                endMessage(logger2);
              }
            });
          }
        };
      }
      function startMessage(logger2, message, collapsed) {
        var startMessage2 = collapsed ? logger2.groupCollapsed : logger2.group;
        try {
          startMessage2.call(logger2, message);
        } catch (e2) {
          logger2.log(message);
        }
      }
      function endMessage(logger2) {
        try {
          logger2.groupEnd();
        } catch (e2) {
          logger2.log("\u2014\u2014 log end \u2014\u2014");
        }
      }
      function getFormattedTime() {
        var time = new Date();
        return " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
      }
      function repeat(str, times) {
        return new Array(times + 1).join(str);
      }
      function pad(num, maxLength) {
        return repeat("0", maxLength - num.toString().length) + num;
      }
      var logger = createLogger({
        collapsed: false,
        filter(mutation, stateBefore, stateAfter) {
          return mutation.type !== "aBlocklistedMutation";
        },
        actionFilter(action, state2) {
          return action.type !== "aBlocklistedAction";
        },
        transformer(state2) {
          return state2;
        },
        mutationTransformer(mutation) {
          return mutation.type;
        },
        actionTransformer(action) {
          return action.type;
        },
        logActions: true,
        logMutations: true,
        logger: console
      });
      const debug = true;
      var store = createStore({
        modules: {},
        strict: debug,
        plugins: [logger],
        state: {
          user: null,
          rules: [],
          accessToken: null,
          trackerId: null,
          kanbanId: null,
          swimlaneField: null,
          titleField: null,
          descriptionField: null,
          xaxisField: null,
          yaxisField: null,
          boards: {
            byId: {
              1: { id: 1, title: "Agile Board", rows: [1, 2, 3], imageUrl: null }
            },
            allIds: [1]
          },
          rows: {
            byId: {
              1: { id: 1, title: "UX", cells: [1, 2, 3, 4] },
              2: { id: 2, title: "Google Code-in Tasks", cells: [5, 6, 7, 8] },
              3: { id: 3, title: "Design", cells: [9, 10, 11, 12] }
            },
            allIds: [1, 2, 3]
          },
          cols: {
            byId: {
              1: { id: 1, title: "To Do", wip: 15 },
              2: { id: 2, title: "In progress", wip: 10 },
              3: { id: 3, title: "Test", wip: 100 },
              4: { id: 4, title: "Done", wip: 100 }
            },
            allIds: [1, 2, 3, 4]
          },
          cells: {
            byId: {
              1: { id: 1, title: "To do", cards: [] },
              2: { id: 2, title: "In progress", cards: [] },
              3: { id: 3, title: "Done", cards: [] },
              4: { id: 4, title: "To do", cards: [] },
              5: { id: 5, title: "In progress", cards: [] },
              6: { id: 6, title: "Done", cards: [] }
            },
            allIds: [1, 2, 3, 4, 5, 6]
          },
          cards: {
            byId: {
              1: { id: 1, column: 1, row: 1, sortOrder: 1, title: "Make start button", description: "Some card description" },
              2: { id: 2, column: 1, row: 1, sortOrder: 3, title: "Create time tracking", description: "Some card description" },
              3: { id: 3, column: 1, row: 1, sortOrder: 2, title: "Rich text formatting", description: "Some card description" },
              4: { id: 4, column: 1, row: 2, sortOrder: 3, title: "Add feature to Maps application", description: "Some card description" },
              5: { id: 5, column: 1, row: 2, sortOrder: 1, title: "Create a new activity for Sugarizer", description: "Some card description" },
              6: {
                id: 6,
                column: 1,
                row: 2,
                sortOrder: 2,
                title: "Agora-web Display election detail during voting",
                description: "Some card description"
              }
            },
            allIds: [1, 2, 3, 4, 5, 6]
          }
        },
        getters: {
          getUser(state2) {
            return state2.user;
          },
          getRules(state2) {
            return state2.rules;
          },
          getAccessToken(state2) {
            return state2.accessToken;
          },
          getTrackerId(state2) {
            return state2.trackerId;
          },
          getSwimlaneField(state2) {
            return state2.swimlaneField;
          },
          getTitleField(state2) {
            return state2.titleField;
          },
          getDescriptionField(state2) {
            return state2.descriptionField;
          },
          getXaxisField(state2) {
            return state2.xaxisField;
          },
          getYaxisField(state2) {
            return state2.yaxisField;
          },
          getCardsByCol(state2) {
            return (colIndex) => state2.rows.allIds.map((rowId) => state2.rows.byId[rowId].cells[colIndex]).map((cellId) => state2.cells.byId[cellId].cards).flat(1).map((cardId) => state2.cards.byId[cardId]);
          },
          getAllBoards(state2) {
            return state2.boards.allIds.map((id) => state2.boards.byId[id]);
          },
          getBoard(state2) {
            return (id) => state2.boards.byId[id];
          },
          getAllRows(state2) {
            return state2.rows.allIds.map((id) => state2.rows.byId[id]);
          },
          getRows(state2) {
            return (ids) => ids.map((id) => state2.rows.byId[id]);
          },
          getCols(state2) {
            return state2.cols.allIds.map((id) => state2.cols.byId[id]);
          },
          getColColor(state2) {
            return (id) => state2.cols.byId[id].color;
          },
          getCells(state2) {
            return (ids) => ids.map((id) => state2.cells.byId[id]);
          },
          getCell(state2) {
            return (id) => state2.cells.byId[id];
          },
          getCards(state2) {
            return (ids) => ids.map((id) => state2.cards.byId[id]);
          },
          getCard(state2) {
            return (id) => state2.cards.byId[id];
          }
        },
        actions: {
          initBoard({ commit }, data2) {
            commit("setBoard", data2);
          },
          setUser({ commit }, data2) {
            commit("setUser", data2);
          },
          addRules({ commit }, data2) {
            commit("addRules", data2);
          },
          addBoard({ commit }, added) {
            commit("addBoard", added);
          },
          addRow({ commit }, added) {
            commit("addRow", added);
          },
          moveRowBack({ commit }, moved2) {
            commit("moveRowBack", moved2);
          },
          moveRowForth({ commit }, moved2) {
            commit("moveRowForth", moved2);
          },
          moveColumn({ commit }, moved2) {
            commit("moveColumn", moved2);
          },
          addCell({ commit }, added) {
            commit("addCell", added);
          },
          addNewColumn({ commit }, data2) {
            commit("addNewColumn", data2);
          },
          removeCell({ commit }, removed) {
            commit("removeCell", removed);
          },
          moveCard({ commit }, moved2) {
            commit("moveCard", moved2);
          },
          addCard({ commit }, added) {
            commit("addCard", added);
          },
          addNewCard({ commit }, data2) {
            commit("addNewCard", data2);
          },
          removeCard({ commit }, removed) {
            commit("removeCard", removed);
          },
          editBoardField({ commit }, { id, field, data: data2 }) {
            commit("editBoardField", { id, field, data: data2 });
          },
          editRowField({ commit }, { id, field, data: data2 }) {
            commit("editRowField", { id, field, data: data2 });
          },
          editColumnField({ commit }, { id, field, data: data2 }) {
            commit("editColumnField", { id, field, data: data2 });
          },
          editCardField({ commit }, { id, field, data: data2 }) {
            commit("editCardField", { id, field, data: data2 });
          }
        },
        mutations: {
          setUser(state2, data2) {
            state2.user = data2;
          },
          setBoard(state2, data2) {
            let { boards, rows, cols, cells, cards } = makeKanbanData(data2);
            state2.boards = boards;
            state2.rows = rows;
            state2.cols = cols;
            state2.cells = cells;
            state2.cards = cards;
            state2.accessToken = data2.accessToken;
            state2.trackerId = data2.trackerId;
            state2.kanbanId = data2.kanbanId;
            state2.swimlaneField = data2.swimlaneField;
            state2.titleField = data2.titleField;
            state2.descriptionField = data2.descriptionField;
            state2.xaxisField = data2.xaxisField;
            state2.yaxisField = data2.yaxisField;
            state2.rules = data2.CASLAbilityRules;
          },
          addRules(state2, data2) {
            state2.rules = state2.rules.concat(data2);
          },
          addBoard(state2, data2) {
            let newId = makeId(state2.boards.allIds);
            let newRowId = makeId(state2.rows.allIds);
            state2.boards.allIds.push(newId);
            state2.boards.byId[newId] = { id: newId, title: data2.title, rows: [newRowId] };
            state2.rows.allIds.push(newRowId);
            state2.rows.byId[newRowId] = { id: newRowId, title: "New swimlane", cells: [] };
          },
          addRow(state2, data2) {
            let newRowId = makeId(state2.rows.allIds);
            state2.rows.allIds.push(newRowId);
            state2.rows.byId[newRowId] = { id: newRowId, title: data2.title, cells: [] };
            state2.cols.allIds.forEach((id) => {
              let newId = makeId(state2.cells.allIds);
              state2.cells.allIds.push(newId);
              state2.cells.byId[newId] = { id: newId, title: "New col", cards: [], limit: 50 };
              state2.rows.byId[newRowId].cells.push(newId);
            });
          },
          moveRowBack(state2, data2) {
            arrayMove(state2.boards.byId[data2.boardId].rows, data2.oldIndex, data2.oldIndex - 1);
          },
          moveRowForth(state2, data2) {
            arrayMove(state2.boards.byId[data2.boardId].rows, data2.oldIndex, data2.oldIndex + 1);
          },
          moveColumn(state2, data2) {
            state2.rows.allIds.forEach((rowId) => {
              arrayMove(state2.rows.byId[rowId].cells, data2.oldIndex, data2.newIndex);
            });
            arrayMove(state2.cols.allIds, data2.oldIndex, data2.newIndex);
          },
          addCell(state2, data2) {
            state2.rows.byId[data2.rowId].cells.splice(data2.newIndex, 0, data2.element.id);
          },
          addNewColumn(state2, data2) {
            state2.rows.allIds.forEach((rowId) => {
              let newId = makeId(state2.cells.allIds);
              state2.cells.allIds.push(newId);
              state2.cells.byId[newId] = { id: newId, title: data2.title, cards: [] };
              state2.rows.byId[rowId].cells.push(newId);
            });
            let newColId = makeId(state2.cols.allIds);
            state2.cols.byId[newColId] = { id: newColId, title: data2.title };
            state2.cols.allIds.push(newColId);
          },
          removeCell(state2, data2) {
            state2.rows.byId[data2.rowId].cells.splice(data2.oldIndex, 1);
          },
          moveCard(state2, data2) {
            arrayMove(state2.cells.byId[data2.cellId].cards, data2.oldIndex, data2.newIndex);
            setSortOrder(state2, data2);
          },
          addCard(state2, data2) {
            state2.cells.byId[data2.cellId].cards.splice(data2.newIndex, 0, data2.element.id);
            setSortOrder(state2, data2);
          },
          addNewCard(state2, data2) {
            state2.cards.allIds.push(data2.id);
            state2.cards.byId[data2.id] = { id: data2.id, title: data2.title, sortOrder: data2.sortOrder, row: data2.row, column: data2.column };
            state2.cells.byId[data2.cellId].cards.push(data2.id);
          },
          removeCard(state2, data2) {
            state2.cells.byId[data2.cellId].cards.splice(data2.oldIndex, 1);
          },
          editBoardField(state2, { id, field, data: data2 }) {
            state2.boards.byId[id][field] = data2;
          },
          editRowField(state2, { id, field, data: data2 }) {
            state2.rows.byId[id][field] = data2;
          },
          editColumnField(state2, { id, field, data: data2 }) {
            state2.cols.byId[id][field] = data2;
          },
          editCardField(state2, { id, field, data: data2 }) {
            state2.cards.byId[id][field] = data2;
          }
        }
      });
      function makeKanbanData(data2) {
        let boardsById = {};
        let boardsAllIds = [data2.trackerId];
        boardsById[data2.trackerId] = {
          id: data2.trackerId,
          title: `Board ${data2.trackerId}`,
          imageUrl: null,
          rows: []
        };
        let rowsById = data2.rows;
        console.log("CANARI", data2.rows);
        let rowsAllIds = Object.keys(data2.rows);
        boardsById[data2.trackerId].rows = rowsAllIds;
        let colsById = data2.columns;
        let colsAllIds = Object.keys(data2.columns);
        for (const columnId in data2.columns) {
          colsById[columnId].color = "#f3f4fa";
        }
        let cellsById = {};
        let cellsAllIds = [];
        let cellId = 1;
        let rowCells = [];
        rowsAllIds.forEach((rowId) => {
          const row = rowsById[rowId];
          Object.values(colsById).forEach((col) => {
            let cardsIds = data2.cards.filter((card) => {
              return card.row === row.value && card.column === col.value;
            }).sort((a2, b2) => parseFloat(a2.sortOrder) - parseFloat(b2.sortOrder)).map((card) => card.id);
            cellsById[cellId] = { id: cellId, cards: cardsIds };
            cellsAllIds.push(cellId);
            rowCells.push(cellId);
            cellId++;
          });
          rowsById[rowId].cells = rowCells;
          rowCells = [];
        });
        let cardsById = {};
        let cardsAllIds = data2.cards.map((card) => card.id);
        data2.cards.map((card) => {
          card.sortOrder = parseFloat(card.sortOrder);
          return card;
        }).sort((a2, b2) => a2.id - b2.id).forEach((card) => {
          cardsById[card.id] = card;
        });
        return {
          boards: {
            byId: boardsById,
            allIds: boardsAllIds
          },
          rows: {
            byId: rowsById,
            allIds: rowsAllIds
          },
          cols: {
            byId: colsById,
            allIds: colsAllIds
          },
          cells: {
            byId: cellsById,
            allIds: cellsAllIds
          },
          cards: {
            byId: cardsById,
            allIds: cardsAllIds
          }
        };
      }
      function arrayMove(arr, fromIndex, toIndex) {
        let element = arr[fromIndex];
        arr.splice(fromIndex, 1);
        arr.splice(toIndex, 0, element);
      }
      function makeId(ids) {
        return ids.length ? Math.max(...ids) + 1 : 1;
      }
      function setSortOrder(state2, data2) {
        let sortOrder = 1;
        let cardIds = state2.cells.byId[data2.cellId].cards;
        let prevId = cardIds[data2.newIndex - 1];
        let nextId = cardIds[data2.newIndex + 1];
        let sum = [state2.cards.byId[prevId], state2.cards.byId[nextId]].filter((el) => el).map((el) => el.sortOrder).reduce((prev, curr) => prev + curr, 0);
        if (sum > 0 && nextId) {
          sortOrder = sum / 2;
        } else if (sum >= 1) {
          sortOrder = sum + 1;
        }
        state2.cards.byId[data2.element.id].sortOrder = sortOrder;
      }
      var KanbanRow_vue_vue_type_style_index_0_scoped_true_lang = "";
      var _export_sfc$1 = (sfc, props2) => {
        for (const [key, val] of props2) {
          sfc[key] = val;
        }
        return sfc;
      };
      const _hoisted_1$j = { class: "kanban-row" };
      const _hoisted_2$i = {
        key: 0,
        class: "pl-3"
      };
      const __default__$b = {
        name: "KanbanRow"
      };
      const _sfc_main$n = /* @__PURE__ */ Object.assign(__default__$b, {
        props: {
          title: {
            type: String,
            default: ""
          },
          transparentTitleBg: {
            type: Boolean,
            default: false
          },
          boardId: {
            type: Number
          },
          rowId: {
            type: Number
          },
          rowValue: [String, Number],
          index: {
            type: Number
          }
        },
        setup(__props) {
          const props2 = __props;
          const showEditField = ref(false);
          const toast = useToast();
          const handleTitleChange = (event) => {
            showEditField.value = false;
            if (event.target.value.length < 1) {
              toast.error(`This field must be at least 1 character`);
              return;
            }
            store.dispatch("editRowField", {
              id: props2.rowId,
              field: "title",
              data: event.target.value
            });
          };
          return (_ctx, _cache) => {
            const _directive_focus = resolveDirective("focus");
            return openBlock(), createElementBlock("div", _hoisted_1$j, [
              createElementVNode("div", {
                class: normalizeClass(["kanban-row-title", { "bg-color-transparent": __props.transparentTitleBg }])
              }, [
                !showEditField.value ? (openBlock(), createElementBlock("span", _hoisted_2$i, toDisplayString(__props.title), 1)) : createCommentVNode("v-if", true),
                showEditField.value ? (openBlock(), createBlock(unref(Form), { key: 1 }, {
                  default: withCtx(() => [
                    withDirectives(createVNode(unref(Field), {
                      value: __props.title,
                      onBlur: handleTitleChange,
                      name: "rowTitle",
                      type: "text",
                      rules: { minLength: 1 }
                    }, null, 8, ["value"]), [
                      [_directive_focus]
                    ])
                  ]),
                  _: 1
                })) : createCommentVNode("v-if", true),
                createCommentVNode("v-if", true)
              ], 2),
              createElementVNode("div", null, [
                renderSlot(_ctx.$slots, "default", {}, void 0, true)
              ])
            ]);
          };
        }
      });
      var KanbanRow = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__scopeId", "data-v-743da1a3"]]);
      var KanbanCard_vue_vue_type_style_index_0_lang = "";
      const _hoisted_1$i = { class: "kanban-card-body" };
      const _hoisted_2$h = { class: "kanban-card-menu" };
      const _hoisted_3$c = { class: "kanban-card-title" };
      const _hoisted_4$a = { class: "kanban-card-text" };
      const __default__$a = {
        name: "KanbanCard"
      };
      const _sfc_main$m = /* @__PURE__ */ Object.assign(__default__$a, {
        setup(__props) {
          const isHovered = ref(false);
          const handleMouseEnter = (event) => {
            isHovered.value = true;
          };
          const handleMouseLeave = (event) => {
            isHovered.value = false;
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", {
              class: "kanban-card",
              onMouseenter: handleMouseEnter,
              onMouseleave: handleMouseLeave
            }, [
              createElementVNode("div", _hoisted_1$i, [
                renderSlot(_ctx.$slots, "default"),
                createVNode(Transition, { name: "slide-fade" }, {
                  default: withCtx(() => [
                    withDirectives(createElementVNode("div", _hoisted_2$h, [
                      renderSlot(_ctx.$slots, "menu")
                    ], 512), [
                      [vShow, isHovered.value]
                    ])
                  ]),
                  _: 3
                }),
                createElementVNode("div", _hoisted_3$c, [
                  renderSlot(_ctx.$slots, "title")
                ]),
                createElementVNode("div", _hoisted_4$a, [
                  renderSlot(_ctx.$slots, "text")
                ])
              ])
            ], 32);
          };
        }
      });
      var FormAddColumn_vue_vue_type_style_index_0_scoped_true_lang = "";
      var ButtonAddColumn_vue_vue_type_style_index_0_scoped_true_lang = "";
      const __default__$9 = {
        name: "ButtonAddColumn"
      };
      const _sfc_main$l = /* @__PURE__ */ Object.assign(__default__$9, {
        props: {
          rowId: {
            type: Number
          }
        },
        setup(__props) {
          ref(false);
          return (_ctx, _cache) => {
            return createCommentVNode("v-if", true);
          };
        }
      });
      var ButtonAddColumn = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__scopeId", "data-v-62c53c17"]]);
      var e$3, t$4, n$3 = typeof Map == "function" ? new Map() : (e$3 = [], t$4 = [], { has: function(t2) {
        return e$3.indexOf(t2) > -1;
      }, get: function(n2) {
        return t$4[e$3.indexOf(n2)];
      }, set: function(n2, o2) {
        e$3.indexOf(n2) === -1 && (e$3.push(n2), t$4.push(o2));
      }, delete: function(n2) {
        var o2 = e$3.indexOf(n2);
        o2 > -1 && (e$3.splice(o2, 1), t$4.splice(o2, 1));
      } }), o$4 = function(e2) {
        return new Event(e2, { bubbles: true });
      };
      try {
        new Event("test");
      } catch (e2) {
        o$4 = function(e3) {
          var t2 = document.createEvent("Event");
          return t2.initEvent(e3, true, false), t2;
        };
      }
      function r$3(e2) {
        var t2 = n$3.get(e2);
        t2 && t2.destroy();
      }
      function i$4(e2) {
        var t2 = n$3.get(e2);
        t2 && t2.update();
      }
      var l$5 = null;
      typeof window == "undefined" || typeof window.getComputedStyle != "function" ? ((l$5 = function(e2) {
        return e2;
      }).destroy = function(e2) {
        return e2;
      }, l$5.update = function(e2) {
        return e2;
      }) : ((l$5 = function(e2, t2) {
        return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], function(e3) {
          return function(e4) {
            if (e4 && e4.nodeName && e4.nodeName === "TEXTAREA" && !n$3.has(e4)) {
              var t3, r2 = null, i2 = null, l2 = null, d2 = function() {
                e4.clientWidth !== i2 && c2();
              }, a2 = function(t4) {
                window.removeEventListener("resize", d2, false), e4.removeEventListener("input", c2, false), e4.removeEventListener("keyup", c2, false), e4.removeEventListener("autosize:destroy", a2, false), e4.removeEventListener("autosize:update", c2, false), Object.keys(t4).forEach(function(n2) {
                  e4.style[n2] = t4[n2];
                }), n$3.delete(e4);
              }.bind(e4, { height: e4.style.height, resize: e4.style.resize, overflowY: e4.style.overflowY, overflowX: e4.style.overflowX, wordWrap: e4.style.wordWrap });
              e4.addEventListener("autosize:destroy", a2, false), "onpropertychange" in e4 && "oninput" in e4 && e4.addEventListener("keyup", c2, false), window.addEventListener("resize", d2, false), e4.addEventListener("input", c2, false), e4.addEventListener("autosize:update", c2, false), e4.style.overflowX = "hidden", e4.style.wordWrap = "break-word", n$3.set(e4, { destroy: a2, update: c2 }), (t3 = window.getComputedStyle(e4, null)).resize === "vertical" ? e4.style.resize = "none" : t3.resize === "both" && (e4.style.resize = "horizontal"), r2 = t3.boxSizing === "content-box" ? -(parseFloat(t3.paddingTop) + parseFloat(t3.paddingBottom)) : parseFloat(t3.borderTopWidth) + parseFloat(t3.borderBottomWidth), isNaN(r2) && (r2 = 0), c2();
            }
            function u2(t4) {
              var n2 = e4.style.width;
              e4.style.width = "0px", e4.style.width = n2, e4.style.overflowY = t4;
            }
            function s2() {
              if (e4.scrollHeight !== 0) {
                var t4 = function(e5) {
                  for (var t5 = []; e5 && e5.parentNode && e5.parentNode instanceof Element; )
                    e5.parentNode.scrollTop && t5.push({ node: e5.parentNode, scrollTop: e5.parentNode.scrollTop }), e5 = e5.parentNode;
                  return t5;
                }(e4), n2 = document.documentElement && document.documentElement.scrollTop;
                e4.style.height = "", e4.style.height = e4.scrollHeight + r2 + "px", i2 = e4.clientWidth, t4.forEach(function(e5) {
                  e5.node.scrollTop = e5.scrollTop;
                }), n2 && (document.documentElement.scrollTop = n2);
              }
            }
            function c2() {
              s2();
              var t4 = Math.round(parseFloat(e4.style.height)), n2 = window.getComputedStyle(e4, null), r3 = n2.boxSizing === "content-box" ? Math.round(parseFloat(n2.height)) : e4.offsetHeight;
              if (r3 < t4 ? n2.overflowY === "hidden" && (u2("scroll"), s2(), r3 = n2.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(e4, null).height)) : e4.offsetHeight) : n2.overflowY !== "hidden" && (u2("hidden"), s2(), r3 = n2.boxSizing === "content-box" ? Math.round(parseFloat(window.getComputedStyle(e4, null).height)) : e4.offsetHeight), l2 !== r3) {
                l2 = r3;
                var i3 = o$4("autosize:resized");
                try {
                  e4.dispatchEvent(i3);
                } catch (e5) {
                }
              }
            }
          }(e3);
        }), e2;
      }).destroy = function(e2) {
        return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], r$3), e2;
      }, l$5.update = function(e2) {
        return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], i$4), e2;
      });
      var d$5 = l$5;
      function getAugmentedNamespace(n2) {
        if (n2.__esModule)
          return n2;
        var a2 = Object.defineProperty({}, "__esModule", { value: true });
        Object.keys(n2).forEach(function(k2) {
          var d2 = Object.getOwnPropertyDescriptor(n2, k2);
          Object.defineProperty(a2, k2, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return n2[k2];
            }
          });
        });
        return a2;
      }
      var axios$2 = { exports: {} };
      var bind$4 = function bind2(fn2, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i2 = 0; i2 < args.length; i2++) {
            args[i2] = arguments[i2];
          }
          return fn2.apply(thisArg, args);
        };
      };
      var bind$3 = bind$4;
      var toString = Object.prototype.toString;
      function isArray$6(val) {
        return toString.call(val) === "[object Array]";
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer$3(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      function isArrayBuffer(val) {
        return toString.call(val) === "[object ArrayBuffer]";
      }
      function isFormData(val) {
        return typeof FormData !== "undefined" && val instanceof FormData;
      }
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && val.buffer instanceof ArrayBuffer;
        }
        return result;
      }
      function isString$2(val) {
        return typeof val === "string";
      }
      function isNumber$1(val) {
        return typeof val === "number";
      }
      function isObject$2(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject$2(val) {
        if (toString.call(val) !== "[object Object]") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      function isDate$1(val) {
        return toString.call(val) === "[object Date]";
      }
      function isFile(val) {
        return toString.call(val) === "[object File]";
      }
      function isBlob(val) {
        return toString.call(val) === "[object Blob]";
      }
      function isFunction$1(val) {
        return toString.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject$2(val) && isFunction$1(val.pipe);
      }
      function isURLSearchParams(val) {
        return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
      }
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn2) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray$6(obj)) {
          for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
            fn2.call(null, obj[i2], i2, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn2.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge$3() {
        var result = {};
        function assignValue2(val, key) {
          if (isPlainObject$2(result[key]) && isPlainObject$2(val)) {
            result[key] = merge$3(result[key], val);
          } else if (isPlainObject$2(val)) {
            result[key] = merge$3({}, val);
          } else if (isArray$6(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
          forEach(arguments[i2], assignValue2);
        }
        return result;
      }
      function extend$1(a2, b2, thisArg) {
        forEach(b2, function assignValue2(val, key) {
          if (thisArg && typeof val === "function") {
            a2[key] = bind$3(val, thisArg);
          } else {
            a2[key] = val;
          }
        });
        return a2;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      var utils$g = {
        isArray: isArray$6,
        isArrayBuffer,
        isBuffer: isBuffer$3,
        isFormData,
        isArrayBufferView,
        isString: isString$2,
        isNumber: isNumber$1,
        isObject: isObject$2,
        isPlainObject: isPlainObject$2,
        isUndefined,
        isDate: isDate$1,
        isFile,
        isBlob,
        isFunction: isFunction$1,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge: merge$3,
        extend: extend$1,
        trim,
        stripBOM
      };
      var utils$f = utils$g;
      function encode$1(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      var buildURL$2 = function buildURL2(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils$f.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils$f.forEach(params, function serialize(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils$f.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils$f.forEach(val, function parseValue(v2) {
              if (utils$f.isDate(v2)) {
                v2 = v2.toISOString();
              } else if (utils$f.isObject(v2)) {
                v2 = JSON.stringify(v2);
              }
              parts.push(encode$1(key) + "=" + encode$1(v2));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
      var utils$e = utils$g;
      function InterceptorManager$1() {
        this.handlers = [];
      }
      InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager$1.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager$1.prototype.forEach = function forEach2(fn2) {
        utils$e.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn2(h2);
          }
        });
      };
      var InterceptorManager_1 = InterceptorManager$1;
      var utils$d = utils$g;
      var normalizeHeaderName$1 = function normalizeHeaderName2(headers, normalizedName) {
        utils$d.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
      var enhanceError$2 = function enhanceError2(error, config, code, request, response) {
        error.config = config;
        if (code) {
          error.code = code;
        }
        error.request = request;
        error.response = response;
        error.isAxiosError = true;
        error.toJSON = function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        };
        return error;
      };
      var enhanceError$1 = enhanceError$2;
      var createError$2 = function createError2(message, config, code, request, response) {
        var error = new Error(message);
        return enhanceError$1(error, config, code, request, response);
      };
      var createError$1 = createError$2;
      var settle$1 = function settle2(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(createError$1("Request failed with status code " + response.status, response.config, null, response.request, response));
        }
      };
      var utils$c = utils$g;
      var cookies$1 = utils$c.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write2(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils$c.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils$c.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils$c.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read2(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove2(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write2() {
          },
          read: function read2() {
            return null;
          },
          remove: function remove2() {
          }
        };
      }();
      var isAbsoluteURL$1 = function isAbsoluteURL2(url) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
      };
      var combineURLs$1 = function combineURLs2(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
      var isAbsoluteURL = isAbsoluteURL$1;
      var combineURLs = combineURLs$1;
      var buildFullPath$1 = function buildFullPath2(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
      var utils$b = utils$g;
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      var parseHeaders$1 = function parseHeaders2(headers) {
        var parsed = {};
        var key;
        var val;
        var i2;
        if (!headers) {
          return parsed;
        }
        utils$b.forEach(headers.split("\n"), function parser(line) {
          i2 = line.indexOf(":");
          key = utils$b.trim(line.substr(0, i2)).toLowerCase();
          val = utils$b.trim(line.substr(i2 + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
      var utils$a = utils$g;
      var isURLSameOrigin$1 = utils$a.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin2(requestURL) {
          var parsed = utils$a.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin2() {
          return true;
        };
      }();
      function Cancel$3(message) {
        this.message = message;
      }
      Cancel$3.prototype.toString = function toString2() {
        return "Cancel" + (this.message ? ": " + this.message : "");
      };
      Cancel$3.prototype.__CANCEL__ = true;
      var Cancel_1 = Cancel$3;
      var utils$9 = utils$g;
      var settle = settle$1;
      var cookies = cookies$1;
      var buildURL$1 = buildURL$2;
      var buildFullPath = buildFullPath$1;
      var parseHeaders = parseHeaders$1;
      var isURLSameOrigin = isURLSameOrigin$1;
      var createError = createError$2;
      var defaults$7 = defaults_1;
      var Cancel$2 = Cancel_1;
      var xhr = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils$9.isFormData(requestData)) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL$1(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(createError("Request aborted", config, "ECONNABORTED", request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(createError("Network Error", config, null, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || defaults$7.transitional;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
            request = null;
          };
          if (utils$9.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils$9.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils$9.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken || config.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new Cancel$2("canceled") : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          request.send(requestData);
        });
      };
      var utils$8 = utils$g;
      var normalizeHeaderName = normalizeHeaderName$1;
      var enhanceError = enhanceError$2;
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils$8.isUndefined(headers) && utils$8.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = xhr;
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = xhr;
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils$8.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils$8.trim(rawValue);
          } catch (e2) {
            if (e2.name !== "SyntaxError") {
              throw e2;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults$6 = {
        transitional: {
          silentJSONParsing: true,
          forcedJSONParsing: true,
          clarifyTimeoutError: false
        },
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data2, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils$8.isFormData(data2) || utils$8.isArrayBuffer(data2) || utils$8.isBuffer(data2) || utils$8.isStream(data2) || utils$8.isFile(data2) || utils$8.isBlob(data2)) {
            return data2;
          }
          if (utils$8.isArrayBufferView(data2)) {
            return data2.buffer;
          }
          if (utils$8.isURLSearchParams(data2)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data2.toString();
          }
          if (utils$8.isObject(data2) || headers && headers["Content-Type"] === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data2);
          }
          return data2;
        }],
        transformResponse: [function transformResponse(data2) {
          var transitional = this.transitional || defaults$6.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils$8.isString(data2) && data2.length) {
            try {
              return JSON.parse(data2);
            } catch (e2) {
              if (strictJSONParsing) {
                if (e2.name === "SyntaxError") {
                  throw enhanceError(e2, this, "E_JSON_PARSE");
                }
                throw e2;
              }
            }
          }
          return data2;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        validateStatus: function validateStatus(status) {
          return status >= 200 && status < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils$8.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults$6.headers[method] = {};
      });
      utils$8.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults$6.headers[method] = utils$8.merge(DEFAULT_CONTENT_TYPE);
      });
      var defaults_1 = defaults$6;
      var utils$7 = utils$g;
      var defaults$5 = defaults_1;
      var transformData$1 = function transformData2(data2, headers, fns) {
        var context = this || defaults$5;
        utils$7.forEach(fns, function transform(fn2) {
          data2 = fn2.call(context, data2, headers);
        });
        return data2;
      };
      var isCancel$1 = function isCancel2(value) {
        return !!(value && value.__CANCEL__);
      };
      var utils$6 = utils$g;
      var transformData = transformData$1;
      var isCancel = isCancel$1;
      var defaults$4 = defaults_1;
      var Cancel$1 = Cancel_1;
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new Cancel$1("canceled");
        }
      }
      var dispatchRequest$1 = function dispatchRequest2(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
        config.headers = utils$6.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
        utils$6.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
          delete config.headers[method];
        });
        var adapter = config.adapter || defaults$4.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
            }
          }
          return Promise.reject(reason);
        });
      };
      var utils$5 = utils$g;
      var mergeConfig$2 = function mergeConfig2(config1, config2) {
        config2 = config2 || {};
        var config = {};
        function getMergedValue(target, source) {
          if (utils$5.isPlainObject(target) && utils$5.isPlainObject(source)) {
            return utils$5.merge(target, source);
          } else if (utils$5.isPlainObject(source)) {
            return utils$5.merge({}, source);
          } else if (utils$5.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils$5.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils$5.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils$5.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils$5.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils$5.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils$5.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge2 = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge2(prop);
          utils$5.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      };
      var data = {
        "version": "0.24.0"
      };
      var VERSION = data.version;
      var validators$1 = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
        validators$1[type] = function validator2(thing) {
          return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators$1.transitional = function transitional(validator2, version2, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator2 === false) {
            throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
          }
          if (version2 && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
          }
          return validator2 ? validator2(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new TypeError("options must be an object");
        }
        var keys2 = Object.keys(options);
        var i2 = keys2.length;
        while (i2-- > 0) {
          var opt = keys2[i2];
          var validator2 = schema[opt];
          if (validator2) {
            var value = options[opt];
            var result = value === void 0 || validator2(value, opt, options);
            if (result !== true) {
              throw new TypeError("option " + opt + " must be " + result);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw Error("Unknown option " + opt);
          }
        }
      }
      var validator$1 = {
        assertOptions,
        validators: validators$1
      };
      var utils$4 = utils$g;
      var buildURL = buildURL$2;
      var InterceptorManager = InterceptorManager_1;
      var dispatchRequest = dispatchRequest$1;
      var mergeConfig$1 = mergeConfig$2;
      var validator = validator$1;
      var validators = validator.validators;
      function Axios$1(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios$1.prototype.request = function request(config) {
        if (typeof config === "string") {
          config = arguments[1] || {};
          config.url = arguments[0];
        } else {
          config = config || {};
        }
        config = mergeConfig$1(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios$1.prototype.getUri = function getUri(config) {
        config = mergeConfig$1(this.defaults, config);
        return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
      };
      utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios$1.prototype[method] = function(url, config) {
          return this.request(mergeConfig$1(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        Axios$1.prototype[method] = function(url, data2, config) {
          return this.request(mergeConfig$1(config || {}, {
            method,
            url,
            data: data2
          }));
        };
      });
      var Axios_1 = Axios$1;
      var Cancel = Cancel_1;
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token2 = this;
        this.promise.then(function(cancel) {
          if (!token2._listeners)
            return;
          var i2;
          var l2 = token2._listeners.length;
          for (i2 = 0; i2 < l2; i2++) {
            token2._listeners[i2](cancel);
          }
          token2._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token2.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token2.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token2.reason) {
            return;
          }
          token2.reason = new Cancel(message);
          resolvePromise(token2.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token2 = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token: token2,
          cancel
        };
      };
      var CancelToken_1 = CancelToken;
      var spread = function spread2(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
      var isAxiosError = function isAxiosError2(payload) {
        return typeof payload === "object" && payload.isAxiosError === true;
      };
      var utils$3 = utils$g;
      var bind$2 = bind$4;
      var Axios = Axios_1;
      var mergeConfig = mergeConfig$2;
      var defaults$3 = defaults_1;
      function createInstance(defaultConfig2) {
        var context = new Axios(defaultConfig2);
        var instance = bind$2(Axios.prototype.request, context);
        utils$3.extend(instance, Axios.prototype, context);
        utils$3.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig(defaultConfig2, instanceConfig));
        };
        return instance;
      }
      var axios$1 = createInstance(defaults$3);
      axios$1.Axios = Axios;
      axios$1.Cancel = Cancel_1;
      axios$1.CancelToken = CancelToken_1;
      axios$1.isCancel = isCancel$1;
      axios$1.VERSION = data.version;
      axios$1.all = function all(promises) {
        return Promise.all(promises);
      };
      axios$1.spread = spread;
      axios$1.isAxiosError = isAxiosError;
      axios$2.exports = axios$1;
      axios$2.exports.default = axios$1;
      var axios = axios$2.exports;
      var shams = function hasSymbols2() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = shams;
      var hasSymbols$1 = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice = Array.prototype.slice;
      var toStr$1 = Object.prototype.toString;
      var funcType = "[object Function]";
      var implementation$1 = function bind2(that) {
        var target = this;
        if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(this, args.concat(slice.call(arguments)));
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(that, args.concat(slice.call(arguments)));
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i2 = 0; i2 < boundLength; i2++) {
          boundArgs.push("$" + i2);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
      var implementation = implementation$1;
      var functionBind = Function.prototype.bind || implementation;
      var bind$1 = functionBind;
      var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
      var undefined$1;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError$1 = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e2) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e2) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError$1();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = hasSymbols$1();
      var getProto = Object.getPrototypeOf || function(x2) {
        return x2.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined$1,
        "%AsyncFromSyncIteratorPrototype%": undefined$1,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
        "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
        "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined$1,
        "%Symbol%": hasSymbols ? Symbol : undefined$1,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError$1,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
      };
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn2 = doEval2("%AsyncGeneratorFunction%");
          if (fn2) {
            value = fn2.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = functionBind;
      var hasOwn$1 = src;
      var $concat$1 = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace$1 = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last2 = $strSlice(string, -1);
        if (first === "%" && last2 !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last2 === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace$1(string, rePropName, function(match, number, quote2, subString) {
          result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn$1(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError$1("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      var getIntrinsic = function GetIntrinsic2(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError$1("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError$1('"allowMissing" argument must be a boolean');
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat$1([0, 1], alias));
        }
        for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
          var part = parts[i2];
          var first = $strSlice(part, 0, 1);
          var last2 = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first !== last2) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError$1("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i2 + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn$1(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
      var callBind$1 = { exports: {} };
      (function(module2) {
        var bind2 = functionBind;
        var GetIntrinsic2 = getIntrinsic;
        var $apply = GetIntrinsic2("%Function.prototype.apply%");
        var $call = GetIntrinsic2("%Function.prototype.call%");
        var $reflectApply = GetIntrinsic2("%Reflect.apply%", true) || bind2.call($call, $apply);
        var $gOPD2 = GetIntrinsic2("%Object.getOwnPropertyDescriptor%", true);
        var $defineProperty = GetIntrinsic2("%Object.defineProperty%", true);
        var $max = GetIntrinsic2("%Math.max%");
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
          } catch (e2) {
            $defineProperty = null;
          }
        }
        module2.exports = function callBind2(originalFunction) {
          var func = $reflectApply(bind2, $call, arguments);
          if ($gOPD2 && $defineProperty) {
            var desc = $gOPD2(func, "length");
            if (desc.configurable) {
              $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
            }
          }
          return func;
        };
        var applyBind = function applyBind2() {
          return $reflectApply(bind2, $apply, arguments);
        };
        if ($defineProperty) {
          $defineProperty(module2.exports, "apply", { value: applyBind });
        } else {
          module2.exports.apply = applyBind;
        }
      })(callBind$1);
      var GetIntrinsic$1 = getIntrinsic;
      var callBind = callBind$1.exports;
      var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
      var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic$1(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
      var __viteBrowserExternal = new Proxy({}, {
        get() {
          throw new Error('Module "" has been externalized for browser compatibility and cannot be accessed in client code.');
        }
      });
      var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        [Symbol.toStringTag]: "Module",
        "default": __viteBrowserExternal
      });
      var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
      var hasMap = typeof Map === "function" && Map.prototype;
      var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
      var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
      var mapForEach = hasMap && Map.prototype.forEach;
      var hasSet = typeof Set === "function" && Set.prototype;
      var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
      var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
      var setForEach = hasSet && Set.prototype.forEach;
      var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
      var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
      var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
      var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
      var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
      var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
      var booleanValueOf = Boolean.prototype.valueOf;
      var objectToString$1 = Object.prototype.toString;
      var functionToString = Function.prototype.toString;
      var $match = String.prototype.match;
      var $slice = String.prototype.slice;
      var $replace = String.prototype.replace;
      var $toUpperCase = String.prototype.toUpperCase;
      var $toLowerCase = String.prototype.toLowerCase;
      var $test = RegExp.prototype.test;
      var $concat = Array.prototype.concat;
      var $join = Array.prototype.join;
      var $arrSlice = Array.prototype.slice;
      var $floor = Math.floor;
      var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
      var gOPS = Object.getOwnPropertySymbols;
      var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
      var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
      var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
      var isEnumerable = Object.prototype.propertyIsEnumerable;
      var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
        return O2.__proto__;
      } : null);
      function addNumericSeparator(num, str) {
        if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
          return str;
        }
        var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
        if (typeof num === "number") {
          var int = num < 0 ? -$floor(-num) : $floor(num);
          if (int !== num) {
            var intStr = String(int);
            var dec = $slice.call(str, intStr.length + 1);
            return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
          }
        }
        return $replace.call(str, sepRegex, "$&_");
      }
      var inspectCustom = require$$0.custom;
      var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
      var objectInspect = function inspect_(obj, options, depth, seen) {
        var opts = options || {};
        if (has$3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
          throw new TypeError('option "quoteStyle" must be "single" or "double"');
        }
        if (has$3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
          throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        }
        var customInspect = has$3(opts, "customInspect") ? opts.customInspect : true;
        if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
          throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        }
        if (has$3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
          throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        }
        if (has$3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
          throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        }
        var numericSeparator = opts.numericSeparator;
        if (typeof obj === "undefined") {
          return "undefined";
        }
        if (obj === null) {
          return "null";
        }
        if (typeof obj === "boolean") {
          return obj ? "true" : "false";
        }
        if (typeof obj === "string") {
          return inspectString(obj, opts);
        }
        if (typeof obj === "number") {
          if (obj === 0) {
            return Infinity / obj > 0 ? "0" : "-0";
          }
          var str = String(obj);
          return numericSeparator ? addNumericSeparator(obj, str) : str;
        }
        if (typeof obj === "bigint") {
          var bigIntStr = String(obj) + "n";
          return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
        }
        var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
        if (typeof depth === "undefined") {
          depth = 0;
        }
        if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
          return isArray$5(obj) ? "[Array]" : "[Object]";
        }
        var indent = getIndent(opts, depth);
        if (typeof seen === "undefined") {
          seen = [];
        } else if (indexOf(seen, obj) >= 0) {
          return "[Circular]";
        }
        function inspect2(value, from, noIndent) {
          if (from) {
            seen = $arrSlice.call(seen);
            seen.push(from);
          }
          if (noIndent) {
            var newOpts = {
              depth: opts.depth
            };
            if (has$3(opts, "quoteStyle")) {
              newOpts.quoteStyle = opts.quoteStyle;
            }
            return inspect_(value, newOpts, depth + 1, seen);
          }
          return inspect_(value, opts, depth + 1, seen);
        }
        if (typeof obj === "function") {
          var name = nameOf(obj);
          var keys2 = arrObjKeys(obj, inspect2);
          return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
        }
        if (isSymbol(obj)) {
          var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
          return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
        }
        if (isElement(obj)) {
          var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
          var attrs = obj.attributes || [];
          for (var i2 = 0; i2 < attrs.length; i2++) {
            s2 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts);
          }
          s2 += ">";
          if (obj.childNodes && obj.childNodes.length) {
            s2 += "...";
          }
          s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
          return s2;
        }
        if (isArray$5(obj)) {
          if (obj.length === 0) {
            return "[]";
          }
          var xs = arrObjKeys(obj, inspect2);
          if (indent && !singleLineValues(xs)) {
            return "[" + indentedJoin(xs, indent) + "]";
          }
          return "[ " + $join.call(xs, ", ") + " ]";
        }
        if (isError(obj)) {
          var parts = arrObjKeys(obj, inspect2);
          if ("cause" in obj && !isEnumerable.call(obj, "cause")) {
            return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
          }
          if (parts.length === 0) {
            return "[" + String(obj) + "]";
          }
          return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
        }
        if (typeof obj === "object" && customInspect) {
          if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
            return obj[inspectSymbol]();
          } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
            return obj.inspect();
          }
        }
        if (isMap(obj)) {
          var mapParts = [];
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value, obj));
          });
          return collectionOf("Map", mapSize.call(obj), mapParts, indent);
        }
        if (isSet(obj)) {
          var setParts = [];
          setForEach.call(obj, function(value) {
            setParts.push(inspect2(value, obj));
          });
          return collectionOf("Set", setSize.call(obj), setParts, indent);
        }
        if (isWeakMap(obj)) {
          return weakCollectionOf("WeakMap");
        }
        if (isWeakSet(obj)) {
          return weakCollectionOf("WeakSet");
        }
        if (isWeakRef(obj)) {
          return weakCollectionOf("WeakRef");
        }
        if (isNumber(obj)) {
          return markBoxed(inspect2(Number(obj)));
        }
        if (isBigInt(obj)) {
          return markBoxed(inspect2(bigIntValueOf.call(obj)));
        }
        if (isBoolean(obj)) {
          return markBoxed(booleanValueOf.call(obj));
        }
        if (isString$1(obj)) {
          return markBoxed(inspect2(String(obj)));
        }
        if (!isDate(obj) && !isRegExp$1(obj)) {
          var ys = arrObjKeys(obj, inspect2);
          var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
          var protoTag = obj instanceof Object ? "" : "null prototype";
          var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
          var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
          var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
          if (ys.length === 0) {
            return tag + "{}";
          }
          if (indent) {
            return tag + "{" + indentedJoin(ys, indent) + "}";
          }
          return tag + "{ " + $join.call(ys, ", ") + " }";
        }
        return String(obj);
      };
      function wrapQuotes(s2, defaultStyle, opts) {
        var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
        return quoteChar + s2 + quoteChar;
      }
      function quote(s2) {
        return $replace.call(String(s2), /"/g, "&quot;");
      }
      function isArray$5(obj) {
        return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isDate(obj) {
        return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isRegExp$1(obj) {
        return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isError(obj) {
        return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isString$1(obj) {
        return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isNumber(obj) {
        return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isBoolean(obj) {
        return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
      }
      function isSymbol(obj) {
        if (hasShammedSymbols) {
          return obj && typeof obj === "object" && obj instanceof Symbol;
        }
        if (typeof obj === "symbol") {
          return true;
        }
        if (!obj || typeof obj !== "object" || !symToString) {
          return false;
        }
        try {
          symToString.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isBigInt(obj) {
        if (!obj || typeof obj !== "object" || !bigIntValueOf) {
          return false;
        }
        try {
          bigIntValueOf.call(obj);
          return true;
        } catch (e2) {
        }
        return false;
      }
      var hasOwn = Object.prototype.hasOwnProperty || function(key) {
        return key in this;
      };
      function has$3(obj, key) {
        return hasOwn.call(obj, key);
      }
      function toStr(obj) {
        return objectToString$1.call(obj);
      }
      function nameOf(f2) {
        if (f2.name) {
          return f2.name;
        }
        var m2 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
        if (m2) {
          return m2[1];
        }
        return null;
      }
      function indexOf(xs, x2) {
        if (xs.indexOf) {
          return xs.indexOf(x2);
        }
        for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
          if (xs[i2] === x2) {
            return i2;
          }
        }
        return -1;
      }
      function isMap(x2) {
        if (!mapSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          mapSize.call(x2);
          try {
            setSize.call(x2);
          } catch (s2) {
            return true;
          }
          return x2 instanceof Map;
        } catch (e2) {
        }
        return false;
      }
      function isWeakMap(x2) {
        if (!weakMapHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakMapHas.call(x2, weakMapHas);
          try {
            weakSetHas.call(x2, weakSetHas);
          } catch (s2) {
            return true;
          }
          return x2 instanceof WeakMap;
        } catch (e2) {
        }
        return false;
      }
      function isWeakRef(x2) {
        if (!weakRefDeref || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakRefDeref.call(x2);
          return true;
        } catch (e2) {
        }
        return false;
      }
      function isSet(x2) {
        if (!setSize || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          setSize.call(x2);
          try {
            mapSize.call(x2);
          } catch (m2) {
            return true;
          }
          return x2 instanceof Set;
        } catch (e2) {
        }
        return false;
      }
      function isWeakSet(x2) {
        if (!weakSetHas || !x2 || typeof x2 !== "object") {
          return false;
        }
        try {
          weakSetHas.call(x2, weakSetHas);
          try {
            weakMapHas.call(x2, weakMapHas);
          } catch (s2) {
            return true;
          }
          return x2 instanceof WeakSet;
        } catch (e2) {
        }
        return false;
      }
      function isElement(x2) {
        if (!x2 || typeof x2 !== "object") {
          return false;
        }
        if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
          return true;
        }
        return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
      }
      function inspectString(str, opts) {
        if (str.length > opts.maxStringLength) {
          var remaining = str.length - opts.maxStringLength;
          var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
          return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
        }
        var s2 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
        return wrapQuotes(s2, "single", opts);
      }
      function lowbyte(c2) {
        var n2 = c2.charCodeAt(0);
        var x2 = {
          8: "b",
          9: "t",
          10: "n",
          12: "f",
          13: "r"
        }[n2];
        if (x2) {
          return "\\" + x2;
        }
        return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
      }
      function markBoxed(str) {
        return "Object(" + str + ")";
      }
      function weakCollectionOf(type) {
        return type + " { ? }";
      }
      function collectionOf(type, size, entries, indent) {
        var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
        return type + " (" + size + ") {" + joinedEntries + "}";
      }
      function singleLineValues(xs) {
        for (var i2 = 0; i2 < xs.length; i2++) {
          if (indexOf(xs[i2], "\n") >= 0) {
            return false;
          }
        }
        return true;
      }
      function getIndent(opts, depth) {
        var baseIndent;
        if (opts.indent === "	") {
          baseIndent = "	";
        } else if (typeof opts.indent === "number" && opts.indent > 0) {
          baseIndent = $join.call(Array(opts.indent + 1), " ");
        } else {
          return null;
        }
        return {
          base: baseIndent,
          prev: $join.call(Array(depth + 1), baseIndent)
        };
      }
      function indentedJoin(xs, indent) {
        if (xs.length === 0) {
          return "";
        }
        var lineJoiner = "\n" + indent.prev + indent.base;
        return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
      }
      function arrObjKeys(obj, inspect2) {
        var isArr = isArray$5(obj);
        var xs = [];
        if (isArr) {
          xs.length = obj.length;
          for (var i2 = 0; i2 < obj.length; i2++) {
            xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
          }
        }
        var syms = typeof gOPS === "function" ? gOPS(obj) : [];
        var symMap;
        if (hasShammedSymbols) {
          symMap = {};
          for (var k2 = 0; k2 < syms.length; k2++) {
            symMap["$" + syms[k2]] = syms[k2];
          }
        }
        for (var key in obj) {
          if (!has$3(obj, key)) {
            continue;
          }
          if (isArr && String(Number(key)) === key && key < obj.length) {
            continue;
          }
          if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
            continue;
          } else if ($test.call(/[^\w$]/, key)) {
            xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
          } else {
            xs.push(key + ": " + inspect2(obj[key], obj));
          }
        }
        if (typeof gOPS === "function") {
          for (var j2 = 0; j2 < syms.length; j2++) {
            if (isEnumerable.call(obj, syms[j2])) {
              xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
            }
          }
        }
        return xs;
      }
      var GetIntrinsic = getIntrinsic;
      var callBound = callBound$1;
      var inspect = objectInspect;
      var $TypeError = GetIntrinsic("%TypeError%");
      var $WeakMap = GetIntrinsic("%WeakMap%", true);
      var $Map = GetIntrinsic("%Map%", true);
      var $weakMapGet = callBound("WeakMap.prototype.get", true);
      var $weakMapSet = callBound("WeakMap.prototype.set", true);
      var $weakMapHas = callBound("WeakMap.prototype.has", true);
      var $mapGet = callBound("Map.prototype.get", true);
      var $mapSet = callBound("Map.prototype.set", true);
      var $mapHas = callBound("Map.prototype.has", true);
      var listGetNode = function(list, key) {
        for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
          if (curr.key === key) {
            prev.next = curr.next;
            curr.next = list.next;
            list.next = curr;
            return curr;
          }
        }
      };
      var listGet = function(objects, key) {
        var node = listGetNode(objects, key);
        return node && node.value;
      };
      var listSet = function(objects, key, value) {
        var node = listGetNode(objects, key);
        if (node) {
          node.value = value;
        } else {
          objects.next = {
            key,
            next: objects.next,
            value
          };
        }
      };
      var listHas = function(objects, key) {
        return !!listGetNode(objects, key);
      };
      var sideChannel = function getSideChannel2() {
        var $wm;
        var $m;
        var $o2;
        var channel = {
          assert: function(key) {
            if (!channel.has(key)) {
              throw new $TypeError("Side channel does not contain " + inspect(key));
            }
          },
          get: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapGet($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapGet($m, key);
              }
            } else {
              if ($o2) {
                return listGet($o2, key);
              }
            }
          },
          has: function(key) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if ($wm) {
                return $weakMapHas($wm, key);
              }
            } else if ($Map) {
              if ($m) {
                return $mapHas($m, key);
              }
            } else {
              if ($o2) {
                return listHas($o2, key);
              }
            }
            return false;
          },
          set: function(key, value) {
            if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
              if (!$wm) {
                $wm = new $WeakMap();
              }
              $weakMapSet($wm, key, value);
            } else if ($Map) {
              if (!$m) {
                $m = new $Map();
              }
              $mapSet($m, key, value);
            } else {
              if (!$o2) {
                $o2 = { key: {}, next: null };
              }
              listSet($o2, key, value);
            }
          }
        };
        return channel;
      };
      var replace = String.prototype.replace;
      var percentTwenties = /%20/g;
      var Format = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
      };
      var formats$3 = {
        "default": Format.RFC3986,
        formatters: {
          RFC1738: function(value) {
            return replace.call(value, percentTwenties, "+");
          },
          RFC3986: function(value) {
            return String(value);
          }
        },
        RFC1738: Format.RFC1738,
        RFC3986: Format.RFC3986
      };
      var formats$2 = formats$3;
      var has$2 = Object.prototype.hasOwnProperty;
      var isArray$4 = Array.isArray;
      var hexTable = function() {
        var array = [];
        for (var i2 = 0; i2 < 256; ++i2) {
          array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
        }
        return array;
      }();
      var compactQueue = function compactQueue2(queue) {
        while (queue.length > 1) {
          var item = queue.pop();
          var obj = item.obj[item.prop];
          if (isArray$4(obj)) {
            var compacted = [];
            for (var j2 = 0; j2 < obj.length; ++j2) {
              if (typeof obj[j2] !== "undefined") {
                compacted.push(obj[j2]);
              }
            }
            item.obj[item.prop] = compacted;
          }
        }
      };
      var arrayToObject = function arrayToObject2(source, options) {
        var obj = options && options.plainObjects ? Object.create(null) : {};
        for (var i2 = 0; i2 < source.length; ++i2) {
          if (typeof source[i2] !== "undefined") {
            obj[i2] = source[i2];
          }
        }
        return obj;
      };
      var merge$2 = function merge2(target, source, options) {
        if (!source) {
          return target;
        }
        if (typeof source !== "object") {
          if (isArray$4(target)) {
            target.push(source);
          } else if (target && typeof target === "object") {
            if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
              target[source] = true;
            }
          } else {
            return [target, source];
          }
          return target;
        }
        if (!target || typeof target !== "object") {
          return [target].concat(source);
        }
        var mergeTarget = target;
        if (isArray$4(target) && !isArray$4(source)) {
          mergeTarget = arrayToObject(target, options);
        }
        if (isArray$4(target) && isArray$4(source)) {
          source.forEach(function(item, i2) {
            if (has$2.call(target, i2)) {
              var targetItem = target[i2];
              if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
                target[i2] = merge2(targetItem, item, options);
              } else {
                target.push(item);
              }
            } else {
              target[i2] = item;
            }
          });
          return target;
        }
        return Object.keys(source).reduce(function(acc, key) {
          var value = source[key];
          if (has$2.call(acc, key)) {
            acc[key] = merge2(acc[key], value, options);
          } else {
            acc[key] = value;
          }
          return acc;
        }, mergeTarget);
      };
      var assign = function assignSingleSource(target, source) {
        return Object.keys(source).reduce(function(acc, key) {
          acc[key] = source[key];
          return acc;
        }, target);
      };
      var decode = function(str, decoder, charset) {
        var strWithoutPlus = str.replace(/\+/g, " ");
        if (charset === "iso-8859-1") {
          return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
        }
        try {
          return decodeURIComponent(strWithoutPlus);
        } catch (e2) {
          return strWithoutPlus;
        }
      };
      var encode = function encode2(str, defaultEncoder, charset, kind, format2) {
        if (str.length === 0) {
          return str;
        }
        var string = str;
        if (typeof str === "symbol") {
          string = Symbol.prototype.toString.call(str);
        } else if (typeof str !== "string") {
          string = String(str);
        }
        if (charset === "iso-8859-1") {
          return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
            return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
          });
        }
        var out = "";
        for (var i2 = 0; i2 < string.length; ++i2) {
          var c2 = string.charCodeAt(i2);
          if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format2 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
            out += string.charAt(i2);
            continue;
          }
          if (c2 < 128) {
            out = out + hexTable[c2];
            continue;
          }
          if (c2 < 2048) {
            out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
            continue;
          }
          if (c2 < 55296 || c2 >= 57344) {
            out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
            continue;
          }
          i2 += 1;
          c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i2) & 1023);
          out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
        }
        return out;
      };
      var compact = function compact2(value) {
        var queue = [{ obj: { o: value }, prop: "o" }];
        var refs = [];
        for (var i2 = 0; i2 < queue.length; ++i2) {
          var item = queue[i2];
          var obj = item.obj[item.prop];
          var keys2 = Object.keys(obj);
          for (var j2 = 0; j2 < keys2.length; ++j2) {
            var key = keys2[j2];
            var val = obj[key];
            if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
              queue.push({ obj, prop: key });
              refs.push(val);
            }
          }
        }
        compactQueue(queue);
        return value;
      };
      var isRegExp = function isRegExp2(obj) {
        return Object.prototype.toString.call(obj) === "[object RegExp]";
      };
      var isBuffer$2 = function isBuffer2(obj) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
      };
      var combine = function combine2(a2, b2) {
        return [].concat(a2, b2);
      };
      var maybeMap = function maybeMap2(val, fn2) {
        if (isArray$4(val)) {
          var mapped = [];
          for (var i2 = 0; i2 < val.length; i2 += 1) {
            mapped.push(fn2(val[i2]));
          }
          return mapped;
        }
        return fn2(val);
      };
      var utils$2 = {
        arrayToObject,
        assign,
        combine,
        compact,
        decode,
        encode,
        isBuffer: isBuffer$2,
        isRegExp,
        maybeMap,
        merge: merge$2
      };
      var getSideChannel = sideChannel;
      var utils$1 = utils$2;
      var formats$1 = formats$3;
      var has$1 = Object.prototype.hasOwnProperty;
      var arrayPrefixGenerators = {
        brackets: function brackets(prefix) {
          return prefix + "[]";
        },
        comma: "comma",
        indices: function indices(prefix, key) {
          return prefix + "[" + key + "]";
        },
        repeat: function repeat2(prefix) {
          return prefix;
        }
      };
      var isArray$3 = Array.isArray;
      var split = String.prototype.split;
      var push = Array.prototype.push;
      var pushToArray = function(arr, valueOrArray) {
        push.apply(arr, isArray$3(valueOrArray) ? valueOrArray : [valueOrArray]);
      };
      var toISO = Date.prototype.toISOString;
      var defaultFormat = formats$1["default"];
      var defaults$2 = {
        addQueryPrefix: false,
        allowDots: false,
        charset: "utf-8",
        charsetSentinel: false,
        delimiter: "&",
        encode: true,
        encoder: utils$1.encode,
        encodeValuesOnly: false,
        format: defaultFormat,
        formatter: formats$1.formatters[defaultFormat],
        indices: false,
        serializeDate: function serializeDate(date) {
          return toISO.call(date);
        },
        skipNulls: false,
        strictNullHandling: false
      };
      var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
        return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
      };
      var sentinel = {};
      var stringify$2 = function stringify2(object, prefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, sideChannel2) {
        var obj = object;
        var tmpSc = sideChannel2;
        var step = 0;
        var findFlag = false;
        while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
          var pos = tmpSc.get(object);
          step += 1;
          if (typeof pos !== "undefined") {
            if (pos === step) {
              throw new RangeError("Cyclic object value");
            } else {
              findFlag = true;
            }
          }
          if (typeof tmpSc.get(sentinel) === "undefined") {
            step = 0;
          }
        }
        if (typeof filter === "function") {
          obj = filter(prefix, obj);
        } else if (obj instanceof Date) {
          obj = serializeDate(obj);
        } else if (generateArrayPrefix === "comma" && isArray$3(obj)) {
          obj = utils$1.maybeMap(obj, function(value2) {
            if (value2 instanceof Date) {
              return serializeDate(value2);
            }
            return value2;
          });
        }
        if (obj === null) {
          if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset, "key", format2) : prefix;
          }
          obj = "";
        }
        if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
          if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset, "key", format2);
            if (generateArrayPrefix === "comma" && encodeValuesOnly) {
              var valuesArray = split.call(String(obj), ",");
              var valuesJoined = "";
              for (var i2 = 0; i2 < valuesArray.length; ++i2) {
                valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults$2.encoder, charset, "value", format2));
              }
              return [formatter(keyValue) + "=" + valuesJoined];
            }
            return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$2.encoder, charset, "value", format2))];
          }
          return [formatter(prefix) + "=" + formatter(String(obj))];
        }
        var values = [];
        if (typeof obj === "undefined") {
          return values;
        }
        var objKeys;
        if (generateArrayPrefix === "comma" && isArray$3(obj)) {
          objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
        } else if (isArray$3(filter)) {
          objKeys = filter;
        } else {
          var keys2 = Object.keys(obj);
          objKeys = sort ? keys2.sort(sort) : keys2;
        }
        for (var j2 = 0; j2 < objKeys.length; ++j2) {
          var key = objKeys[j2];
          var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
          if (skipNulls && value === null) {
            continue;
          }
          var keyPrefix = isArray$3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
          sideChannel2.set(object, step);
          var valueSideChannel = getSideChannel();
          valueSideChannel.set(sentinel, sideChannel2);
          pushToArray(values, stringify2(value, keyPrefix, generateArrayPrefix, strictNullHandling, skipNulls, encoder, filter, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset, valueSideChannel));
        }
        return values;
      };
      var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
        if (!opts) {
          return defaults$2;
        }
        if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
          throw new TypeError("Encoder has to be a function.");
        }
        var charset = opts.charset || defaults$2.charset;
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var format2 = formats$1["default"];
        if (typeof opts.format !== "undefined") {
          if (!has$1.call(formats$1.formatters, opts.format)) {
            throw new TypeError("Unknown format option provided.");
          }
          format2 = opts.format;
        }
        var formatter = formats$1.formatters[format2];
        var filter = defaults$2.filter;
        if (typeof opts.filter === "function" || isArray$3(opts.filter)) {
          filter = opts.filter;
        }
        return {
          addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults$2.addQueryPrefix,
          allowDots: typeof opts.allowDots === "undefined" ? defaults$2.allowDots : !!opts.allowDots,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$2.charsetSentinel,
          delimiter: typeof opts.delimiter === "undefined" ? defaults$2.delimiter : opts.delimiter,
          encode: typeof opts.encode === "boolean" ? opts.encode : defaults$2.encode,
          encoder: typeof opts.encoder === "function" ? opts.encoder : defaults$2.encoder,
          encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults$2.encodeValuesOnly,
          filter,
          format: format2,
          formatter,
          serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults$2.serializeDate,
          skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults$2.skipNulls,
          sort: typeof opts.sort === "function" ? opts.sort : null,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$2.strictNullHandling
        };
      };
      var stringify_1 = function(object, opts) {
        var obj = object;
        var options = normalizeStringifyOptions(opts);
        var objKeys;
        var filter;
        if (typeof options.filter === "function") {
          filter = options.filter;
          obj = filter("", obj);
        } else if (isArray$3(options.filter)) {
          filter = options.filter;
          objKeys = filter;
        }
        var keys2 = [];
        if (typeof obj !== "object" || obj === null) {
          return "";
        }
        var arrayFormat;
        if (opts && opts.arrayFormat in arrayPrefixGenerators) {
          arrayFormat = opts.arrayFormat;
        } else if (opts && "indices" in opts) {
          arrayFormat = opts.indices ? "indices" : "repeat";
        } else {
          arrayFormat = "indices";
        }
        var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
        if (!objKeys) {
          objKeys = Object.keys(obj);
        }
        if (options.sort) {
          objKeys.sort(options.sort);
        }
        var sideChannel2 = getSideChannel();
        for (var i2 = 0; i2 < objKeys.length; ++i2) {
          var key = objKeys[i2];
          if (options.skipNulls && obj[key] === null) {
            continue;
          }
          pushToArray(keys2, stringify$2(obj[key], key, generateArrayPrefix, options.strictNullHandling, options.skipNulls, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel2));
        }
        var joined = keys2.join(options.delimiter);
        var prefix = options.addQueryPrefix === true ? "?" : "";
        if (options.charsetSentinel) {
          if (options.charset === "iso-8859-1") {
            prefix += "utf8=%26%2310003%3B&";
          } else {
            prefix += "utf8=%E2%9C%93&";
          }
        }
        return joined.length > 0 ? prefix + joined : "";
      };
      var utils = utils$2;
      var has = Object.prototype.hasOwnProperty;
      var isArray$2 = Array.isArray;
      var defaults$1 = {
        allowDots: false,
        allowPrototypes: false,
        allowSparse: false,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: false,
        comma: false,
        decoder: utils.decode,
        delimiter: "&",
        depth: 5,
        ignoreQueryPrefix: false,
        interpretNumericEntities: false,
        parameterLimit: 1e3,
        parseArrays: true,
        plainObjects: false,
        strictNullHandling: false
      };
      var interpretNumericEntities = function(str) {
        return str.replace(/&#(\d+);/g, function($0, numberStr) {
          return String.fromCharCode(parseInt(numberStr, 10));
        });
      };
      var parseArrayValue = function(val, options) {
        if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
          return val.split(",");
        }
        return val;
      };
      var isoSentinel = "utf8=%26%2310003%3B";
      var charsetSentinel = "utf8=%E2%9C%93";
      var parseValues = function parseQueryStringValues(str, options) {
        var obj = {};
        var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
        var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
        var parts = cleanStr.split(options.delimiter, limit);
        var skipIndex = -1;
        var i2;
        var charset = options.charset;
        if (options.charsetSentinel) {
          for (i2 = 0; i2 < parts.length; ++i2) {
            if (parts[i2].indexOf("utf8=") === 0) {
              if (parts[i2] === charsetSentinel) {
                charset = "utf-8";
              } else if (parts[i2] === isoSentinel) {
                charset = "iso-8859-1";
              }
              skipIndex = i2;
              i2 = parts.length;
            }
          }
        }
        for (i2 = 0; i2 < parts.length; ++i2) {
          if (i2 === skipIndex) {
            continue;
          }
          var part = parts[i2];
          var bracketEqualsPos = part.indexOf("]=");
          var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
          var key, val;
          if (pos === -1) {
            key = options.decoder(part, defaults$1.decoder, charset, "key");
            val = options.strictNullHandling ? null : "";
          } else {
            key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, "key");
            val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
              return options.decoder(encodedVal, defaults$1.decoder, charset, "value");
            });
          }
          if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
            val = interpretNumericEntities(val);
          }
          if (part.indexOf("[]=") > -1) {
            val = isArray$2(val) ? [val] : val;
          }
          if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
          } else {
            obj[key] = val;
          }
        }
        return obj;
      };
      var parseObject = function(chain, val, options, valuesParsed) {
        var leaf = valuesParsed ? val : parseArrayValue(val, options);
        for (var i2 = chain.length - 1; i2 >= 0; --i2) {
          var obj;
          var root2 = chain[i2];
          if (root2 === "[]" && options.parseArrays) {
            obj = [].concat(leaf);
          } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
            var index2 = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === "") {
              obj = { 0: leaf };
            } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
              obj = [];
              obj[index2] = leaf;
            } else if (cleanRoot !== "__proto__") {
              obj[cleanRoot] = leaf;
            }
          }
          leaf = obj;
        }
        return leaf;
      };
      var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
        if (!givenKey) {
          return;
        }
        var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
        var brackets = /(\[[^[\]]*])/;
        var child = /(\[[^[\]]*])/g;
        var segment = options.depth > 0 && brackets.exec(key);
        var parent2 = segment ? key.slice(0, segment.index) : key;
        var keys2 = [];
        if (parent2) {
          if (!options.plainObjects && has.call(Object.prototype, parent2)) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys2.push(parent2);
        }
        var i2 = 0;
        while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
          i2 += 1;
          if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
              return;
            }
          }
          keys2.push(segment[1]);
        }
        if (segment) {
          keys2.push("[" + key.slice(segment.index) + "]");
        }
        return parseObject(keys2, val, options, valuesParsed);
      };
      var normalizeParseOptions = function normalizeParseOptions2(opts) {
        if (!opts) {
          return defaults$1;
        }
        if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
          throw new TypeError("Decoder has to be a function.");
        }
        if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
          throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        }
        var charset = typeof opts.charset === "undefined" ? defaults$1.charset : opts.charset;
        return {
          allowDots: typeof opts.allowDots === "undefined" ? defaults$1.allowDots : !!opts.allowDots,
          allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults$1.allowPrototypes,
          allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults$1.allowSparse,
          arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults$1.arrayLimit,
          charset,
          charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults$1.charsetSentinel,
          comma: typeof opts.comma === "boolean" ? opts.comma : defaults$1.comma,
          decoder: typeof opts.decoder === "function" ? opts.decoder : defaults$1.decoder,
          delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults$1.delimiter,
          depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults$1.depth,
          ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
          interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults$1.interpretNumericEntities,
          parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults$1.parameterLimit,
          parseArrays: opts.parseArrays !== false,
          plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults$1.plainObjects,
          strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults$1.strictNullHandling
        };
      };
      var parse$2 = function(str, opts) {
        var options = normalizeParseOptions(opts);
        if (str === "" || str === null || typeof str === "undefined") {
          return options.plainObjects ? Object.create(null) : {};
        }
        var tempObj = typeof str === "string" ? parseValues(str, options) : str;
        var obj = options.plainObjects ? Object.create(null) : {};
        var keys2 = Object.keys(tempObj);
        for (var i2 = 0; i2 < keys2.length; ++i2) {
          var key = keys2[i2];
          var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
          obj = utils.merge(obj, newObj, options);
        }
        if (options.allowSparse === true) {
          return obj;
        }
        return utils.compact(obj);
      };
      var stringify$1 = stringify_1;
      var parse$1 = parse$2;
      var formats = formats$3;
      var lib = {
        formats,
        parse: parse$1,
        stringify: stringify$1
      };
      const baseUrl = location.protocol + "//" + location.host + location.pathname.replace(/\/[^\/]*$/, "") + "/api";
      console.log("LOCATION:", location);
      const api = axios.create({
        baseURL: baseUrl
      });
      var kanban = {
        createBoard: function({ trackerId, itemId }, payload) {
          return api.post(`/trackers/${trackerId}/`, lib.stringify(payload), {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        createItem: function({ trackerId }, payload) {
          return api.post(`/trackers/${trackerId}/items`, lib.stringify(payload, { encode: false }), {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        getItem: function({ trackerId, itemId }, payload) {
          return api.get(`/trackers/${trackerId}/items/${itemId}`, lib.stringify(payload), {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        setItem: function({ trackerId, itemId }, payload) {
          return api.post(`/trackers/${trackerId}/items/${itemId}`, lib.stringify(payload, { encode: false }), {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        deleteItem: function({ trackerId, itemId }) {
          return api.delete(`/trackers/${trackerId}/items/${itemId}`, {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        getField: function({ trackerId, fieldId }, payload) {
          return api.get(`/trackers/${trackerId}/fields/${fieldId}`, lib.stringify(payload), {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        setField: function({ trackerId, fieldId }, payload) {
          return api.post(`/trackers/${trackerId}/fields/${fieldId}`, lib.stringify(payload), {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        deleteField: function({ trackerId, fieldId }) {
          return api.delete(`/trackers/${trackerId}/fields/${fieldId}`, {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        },
        getUsers: function() {
          return api.get(`/users`, {
            headers: {
              Authorization: `Bearer ${store.getters.getAccessToken}`
            }
          });
        }
      };
      var FormAddCard_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _withScopeId$b = (n2) => (pushScopeId("data-v-01b8ad26"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$h = { class: "add-cart-container" };
      const _hoisted_2$g = /* @__PURE__ */ createTextVNode(" Add card ");
      const _hoisted_3$b = {
        key: 0,
        class: "fas fa-spinner fa-spin"
      };
      const _hoisted_4$9 = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
      const __default__$8 = {
        name: "FormAddCard"
      };
      const _sfc_main$k = /* @__PURE__ */ Object.assign(__default__$8, {
        props: {
          cellId: {
            type: Number
          },
          rowValue: [String, Number],
          columnValue: [String, Number]
        },
        emits: ["close"],
        setup(__props, { emit: emit2 }) {
          const props2 = __props;
          const toast = useToast();
          const trackerId = ref(store.getters.getTrackerId);
          const title2 = ref("");
          const textarea = ref(null);
          const loading = ref(false);
          watchEffect(() => {
            d$5(textarea.value);
          });
          const handleAddCard = () => {
            loading.value = true;
            let sortOrder = 1;
            let cardIds = store.getters.getCell(props2.cellId).cards;
            let lastCard = store.getters.getCard(cardIds[cardIds.length - 1]);
            if (lastCard)
              sortOrder = parseFloat(lastCard.sortOrder) + 1;
            kanban.createItem({ trackerId: trackerId.value }, {
              fields: {
                [store.getters.getTitleField]: title2.value,
                [store.getters.getSwimlaneField]: props2.rowValue,
                [store.getters.getXaxisField]: props2.columnValue,
                [store.getters.getYaxisField]: sortOrder
              }
            }).then((res) => {
              loading.value = false;
              emit2("close");
              store.dispatch("addNewCard", {
                id: res.data.itemId,
                title: title2.value,
                cellId: props2.cellId,
                row: props2.rowValue,
                column: props2.columnValue,
                sortOrder
              });
              store.dispatch("addRules", [
                {
                  action: "update",
                  subject: "Tracker_Item",
                  fields: [
                    store.getters.getTitleField,
                    store.getters.getDescriptionField,
                    store.getters.getXaxisField,
                    store.getters.getYaxisField,
                    store.getters.getSwimlaneField
                  ],
                  conditions: {
                    itemId: res.data.itemId
                  }
                },
                {
                  action: "delete",
                  subject: "Tracker_Item",
                  conditions: {
                    itemId: res.data.itemId
                  }
                }
              ]);
              console.log(res.data);
              toast.success(`${res.status} ${res.statusText}! Item created.`);
            }).catch((err) => {
              loading.value = false;
              const { code, errortitle, message } = err.response.data;
              const msg = `Code: ${code} - ${message}`;
              toast.error(msg);
            });
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock("div", _hoisted_1$h, [
              createVNode(_sfc_main$m, null, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("textarea", {
                    ref_key: "textarea",
                    ref: textarea,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => title2.value = $event),
                    class: "form-control",
                    rows: "3",
                    placeholder: "Enter a title for this card..."
                  }, toDisplayString(title2.value), 513), [
                    [vModelText, title2.value]
                  ])
                ]),
                _: 1
              }),
              createVNode(unref(Button), {
                sm: "",
                onClick: handleAddCard
              }, {
                default: withCtx(() => [
                  _hoisted_2$g,
                  loading.value ? (openBlock(), createElementBlock("i", _hoisted_3$b)) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }),
              createVNode(unref(Button), {
                class: "ml-2",
                variant: "default",
                sm: "",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
              }, {
                default: withCtx(() => [
                  _hoisted_4$9
                ]),
                _: 1
              })
            ]);
          };
        }
      });
      var FormAddCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__scopeId", "data-v-01b8ad26"]]);
      function t$3(t2, r2) {
        for (var n2 = 0; n2 < r2.length; n2++) {
          var i2 = r2[n2];
          i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(t2, i2.key, i2);
        }
      }
      function r$2() {
        return (r$2 = Object.assign || function(t2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var n2 = arguments[r2];
            for (var i2 in n2)
              Object.prototype.hasOwnProperty.call(n2, i2) && (t2[i2] = n2[i2]);
          }
          return t2;
        }).apply(this, arguments);
      }
      function n$2(t2, r2) {
        t2.prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2;
      }
      var i$3 = function() {
        function r2(t2, r3) {
          this.operator = t2, this.value = r3, Object.defineProperty(this, "t", { writable: true });
        }
        var n2, i2;
        return r2.prototype.addNote = function(t2) {
          this.t = this.t || [], this.t.push(t2);
        }, n2 = r2, (i2 = [{ key: "notes", get: function() {
          return this.t;
        } }]) && t$3(n2.prototype, i2), r2;
      }(), e$2 = function(t2) {
        function r2() {
          return t2.apply(this, arguments) || this;
        }
        return n$2(r2, t2), r2;
      }(i$3), o$3 = function(t2) {
        function r2(r3, n2) {
          if (!Array.isArray(n2))
            throw new Error('"' + r3 + '" operator expects to receive an array of conditions');
          return t2.call(this, r3, n2) || this;
        }
        return n$2(r2, t2), r2;
      }(e$2), u$4 = "__itself__", f$4 = function(t2) {
        function r2(r3, n2, i2) {
          var e2;
          return (e2 = t2.call(this, r3, i2) || this).field = n2, e2;
        }
        return n$2(r2, t2), r2;
      }(i$3), a$4 = new e$2("__null__", null), c$5 = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
      function s$4(t2, r2) {
        return r2 instanceof o$3 && r2.operator === t2;
      }
      function h$4(t2, r2) {
        return r2.length === 1 ? r2[0] : new o$3(t2, function t3(r3, n2, i2) {
          for (var e2 = i2 || [], o2 = 0, u2 = n2.length; o2 < u2; o2++) {
            var f2 = n2[o2];
            s$4(r3, f2) ? t3(r3, f2.value, e2) : e2.push(f2);
          }
          return e2;
        }(t2, r2));
      }
      var v$3 = function(t2) {
        return t2;
      }, d$4 = function() {
        return Object.create(null);
      }, l$4 = Object.defineProperty(d$4(), "__@type@__", { value: "ignore value" });
      function p$5(t2, r2, n2) {
        if (n2 === void 0 && (n2 = false), !t2 || t2 && t2.constructor !== Object)
          return false;
        for (var i2 in t2) {
          if (c$5(t2, i2) && c$5(r2, i2) && (!n2 || t2[i2] !== l$4))
            return true;
        }
        return false;
      }
      function w$4(t2) {
        var r2 = [];
        for (var n2 in t2)
          c$5(t2, n2) && t2[n2] !== l$4 && r2.push(n2);
        return r2;
      }
      function b$4(t2, r2) {
        r2 !== a$4 && t2.push(r2);
      }
      var y$4 = function(t2) {
        return h$4("and", t2);
      }, j$5 = { compound: function(t2, r2, n2) {
        var i2 = (Array.isArray(r2) ? r2 : [r2]).map(function(t3) {
          return n2.parse(t3);
        });
        return new o$3(t2.name, i2);
      }, field: function(t2, r2, n2) {
        return new f$4(t2.name, n2.field, r2);
      }, document: function(t2, r2) {
        return new e$2(t2.name, r2);
      } }, _$6 = function() {
        function t2(t3, n3) {
          var i2 = this;
          n3 === void 0 && (n3 = d$4()), this.i = void 0, this.o = void 0, this.u = void 0, this.s = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.s = { operatorToConditionName: n3.operatorToConditionName || v$3, defaultOperatorName: n3.defaultOperatorName || "eq", mergeFinalConditions: n3.mergeFinalConditions || y$4 }, this.i = Object.keys(t3).reduce(function(n4, e2) {
            return n4[e2] = r$2({ name: i2.s.operatorToConditionName(e2) }, t3[e2]), n4;
          }, {}), this.o = r$2({}, n3.fieldContext, { field: "", query: {}, parse: this.parse, hasOperators: function(t4) {
            return p$5(t4, i2.i, n3.useIgnoreValue);
          } }), this.u = r$2({}, n3.documentContext, { parse: this.parse, query: {} }), this.h = n3.useIgnoreValue ? w$4 : Object.keys;
        }
        var n2 = t2.prototype;
        return n2.setParse = function(t3) {
          this.parse = t3, this.o.parse = t3, this.u.parse = t3;
        }, n2.parseField = function(t3, r2, n3, i2) {
          var e2 = this.i[r2];
          if (!e2)
            throw new Error('Unsupported operator "' + r2 + '"');
          if (e2.type !== "field")
            throw new Error("Unexpected " + e2.type + ' operator "' + r2 + '" at field level');
          return this.o.field = t3, this.o.query = i2, this.parseInstruction(e2, n3, this.o);
        }, n2.parseInstruction = function(t3, r2, n3) {
          return typeof t3.validate == "function" && t3.validate(t3, r2), (t3.parse || j$5[t3.type])(t3, r2, n3);
        }, n2.parseFieldOperators = function(t3, r2) {
          for (var n3 = [], i2 = this.h(r2), e2 = 0, o2 = i2.length; e2 < o2; e2++) {
            var u2 = i2[e2];
            if (!this.i[u2])
              throw new Error('Field query for "' + t3 + '" may contain only operators or a plain object as a value');
            b$4(n3, this.parseField(t3, u2, r2[u2], r2));
          }
          return n3;
        }, n2.parse = function(t3) {
          var r2 = [], n3 = this.h(t3);
          this.u.query = t3;
          for (var i2 = 0, e2 = n3.length; i2 < e2; i2++) {
            var o2 = n3[i2], u2 = t3[o2], f2 = this.i[o2];
            if (f2) {
              if (f2.type !== "document" && f2.type !== "compound")
                throw new Error('Cannot use parsing instruction for operator "' + o2 + '" in "document" context as it is supposed to be used in  "' + f2.type + '" context');
              b$4(r2, this.parseInstruction(f2, u2, this.u));
            } else
              this.o.hasOperators(u2) ? r2.push.apply(r2, this.parseFieldOperators(o2, u2)) : b$4(r2, this.parseField(o2, this.s.defaultOperatorName, u2, t3));
          }
          return this.s.mergeFinalConditions(r2);
        }, t2;
      }();
      function m$5(t2, r2) {
        var n2 = t2[r2];
        if (typeof n2 != "function")
          throw new Error('Unable to interpret "' + r2 + '" condition. Did you forget to register interpreter for it?');
        return n2;
      }
      function g$4(t2) {
        return t2.operator;
      }
      function E$4(t2, n2) {
        var i2, e2 = n2, o2 = e2 && e2.getInterpreterName || g$4;
        switch (e2 ? e2.numberOfArguments : 0) {
          case 1:
            i2 = function(r2) {
              var n3 = o2(r2, e2);
              return m$5(t2, n3)(r2, u2);
            };
            break;
          case 3:
            i2 = function(r2, n3, i3) {
              var f2 = o2(r2, e2);
              return m$5(t2, f2)(r2, n3, i3, u2);
            };
            break;
          default:
            i2 = function(r2, n3) {
              var i3 = o2(r2, e2);
              return m$5(t2, i3)(r2, n3, u2);
            };
        }
        var u2 = r$2({}, e2, { interpret: i2 });
        return u2.interpret;
      }
      function x$4(t2, r2) {
        return function(n2) {
          for (var i2 = arguments.length, e2 = new Array(i2 > 1 ? i2 - 1 : 0), o2 = 1; o2 < i2; o2++)
            e2[o2 - 1] = arguments[o2];
          var u2 = t2.apply(void 0, [n2].concat(e2)), f2 = r2.bind(null, u2);
          return f2.ast = u2, f2;
        };
      }
      _$6.prototype.parseInstruction;
      function f$3(e2, t2) {
        if (!Array.isArray(t2))
          throw new Error('"' + e2.name + '" expects value to be an array');
      }
      function u$3(e2, t2) {
        if (f$3(e2, t2), !t2.length)
          throw new Error('"' + e2.name + '" expects to have at least one element in array');
      }
      var c$4 = function(e2) {
        return function(t2, r2) {
          if (typeof r2 !== e2)
            throw new Error('"' + t2.name + '" expects value to be a "' + e2 + '"');
        };
      }, p$4 = { type: "compound", validate: u$3, parse: function(t2, r2, n2) {
        var o2 = n2.parse, a2 = r2.map(function(e2) {
          return o2(e2);
        });
        return h$4(t2.name, a2);
      } }, s$3 = p$4, l$3 = { type: "compound", validate: u$3 }, d$3 = { type: "field", validate: function(e2, t2) {
        if (!(t2 && (t2 instanceof RegExp || t2.constructor === Object)))
          throw new Error('"' + e2.name + '" expects to receive either regular expression or object of field operators');
      }, parse: function(e2, n2, o2) {
        var a2 = n2 instanceof RegExp ? new f$4("regex", o2.field, n2) : o2.parse(n2, o2);
        return new o$3(e2.name, [a2]);
      } }, v$2 = { type: "field", validate: function(e2, t2) {
        if (!t2 || t2.constructor !== Object)
          throw new Error('"' + e2.name + '" expects to receive an object with nested query or field level operators');
      }, parse: function(e2, r2, o2) {
        var a2 = o2.parse, i2 = o2.field, f2 = (0, o2.hasOperators)(r2) ? a2(r2, { field: u$4 }) : a2(r2);
        return new f$4(e2.name, i2, f2);
      } }, w$3 = { type: "field", validate: c$4("number") }, y$3 = { type: "field", validate: f$3 }, $$3 = y$3, x$3 = y$3, h$3 = { type: "field", validate: function(e2, t2) {
        if (!Array.isArray(t2) || t2.length !== 2)
          throw new Error('"' + e2.name + '" expects an array with 2 numeric elements');
      } }, m$4 = { type: "field", validate: c$4("boolean") }, g$3 = { type: "field", validate: function(e2, t2) {
        if (!(typeof t2 == "string" || typeof t2 == "number" || t2 instanceof Date))
          throw new Error('"' + e2.name + '" expects value to be comparable (i.e., string, number or date)');
      } }, b$3 = g$3, E$3 = b$3, j$4 = b$3, O$3 = { type: "field" }, R$4 = O$3, _$5 = { type: "field", validate: function(e2, t2) {
        if (!(t2 instanceof RegExp) && typeof t2 != "string")
          throw new Error('"' + e2.name + '" expects value to be a regular expression or a string that represents regular expression');
      }, parse: function(e2, r2, n2) {
        var o2 = typeof r2 == "string" ? new RegExp(r2, n2.query.$options || "") : r2;
        return new f$4(e2.name, n2.field, o2);
      } }, q$5 = { type: "field", parse: function() {
        return a$4;
      } }, A$4 = { type: "document", validate: c$4("function") }, N$5 = Object.freeze({ __proto__: null, $and: p$4, $or: s$3, $nor: l$3, $not: d$3, $elemMatch: v$2, $size: w$3, $in: y$3, $nin: $$3, $all: x$3, $mod: h$3, $exists: m$4, $gte: g$3, $gt: b$3, $lt: E$3, $lte: j$4, $eq: O$3, $ne: R$4, $regex: _$5, $options: q$5, $where: A$4 });
      var P$4 = function(e2) {
        var t2, r2;
        function n2(t3) {
          return e2.call(this, t3, { defaultOperatorName: "$eq", operatorToConditionName: function(e3) {
            return e3.slice(1);
          } }) || this;
        }
        return r2 = e2, (t2 = n2).prototype = Object.create(r2.prototype), t2.prototype.constructor = t2, t2.__proto__ = r2, n2.prototype.parse = function(t3, r3) {
          return r3 && r3.field ? y$4(this.parseFieldOperators(r3.field, t3)) : e2.prototype.parse.call(this, t3);
        }, n2;
      }(_$6), z$4 = N$5;
      function t$2(r2, n2, t2) {
        for (var u2 = 0, e2 = r2.length; u2 < e2; u2++)
          if (t2(r2[u2], n2) === 0)
            return true;
        return false;
      }
      function u$2(r2, n2) {
        return Array.isArray(r2) && Number.isNaN(Number(n2));
      }
      function e$1(r2, n2, t2) {
        if (!u$2(r2, n2))
          return t2(r2, n2);
        for (var e2 = [], o2 = 0; o2 < r2.length; o2++) {
          var i2 = t2(r2[o2], n2);
          i2 !== void 0 && (e2 = e2.concat(i2));
        }
        return e2;
      }
      function o$2(r2) {
        return function(n2, t2, u2) {
          var e2 = u2.get(t2, n2.field);
          return Array.isArray(e2) ? e2.some(function(t3) {
            return r2(n2, t3, u2);
          }) : r2(n2, e2, u2);
        };
      }
      function i$2() {
        return (i$2 = Object.assign || function(r2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var t2 = arguments[n2];
            for (var u2 in t2)
              Object.prototype.hasOwnProperty.call(t2, u2) && (r2[u2] = t2[u2]);
          }
          return r2;
        }).apply(this, arguments);
      }
      var f$2 = function(r2, n2) {
        return r2[n2];
      };
      function c$3(r2, n2, t2) {
        var u2 = n2.lastIndexOf(".");
        return u2 === -1 ? [r2, n2] : [t2(r2, n2.slice(0, u2)), n2.slice(u2 + 1)];
      }
      function a$3(n2, t2, u2) {
        if (u2 === void 0 && (u2 = f$2), t2 === u$4)
          return n2;
        if (!n2)
          throw new Error('Unable to get field "' + t2 + '" out of ' + String(n2) + ".");
        return function(r2, n3, t3) {
          if (n3.indexOf(".") === -1)
            return e$1(r2, n3, t3);
          for (var u3 = n3.split("."), o2 = r2, i2 = 0, f2 = u3.length; i2 < f2; i2++)
            if (!(o2 = e$1(o2, u3[i2], t3)) || typeof o2 != "object")
              return o2;
          return o2;
        }(n2, t2, u2);
      }
      function y$2(r2, n2) {
        return r2 === n2 ? 0 : r2 > n2 ? 1 : -1;
      }
      function l$2(r2, t2) {
        return t2 === void 0 && (t2 = {}), E$4(r2, i$2({ get: a$3, compare: y$2 }, t2));
      }
      var b$2 = function(r2, n2, t2) {
        var u2 = t2.interpret;
        return r2.value.some(function(r3) {
          return u2(r3, n2);
        });
      }, m$3 = function(r2, n2, t2) {
        return !b$2(r2, n2, t2);
      }, d$2 = function(r2, n2, t2) {
        var u2 = t2.interpret;
        return r2.value.every(function(r3) {
          return u2(r3, n2);
        });
      }, g$2 = function(r2, n2, t2) {
        return !(0, t2.interpret)(r2.value[0], n2);
      }, p$3 = function(r2, n2, u2) {
        var e2 = u2.compare, o2 = (0, u2.get)(n2, r2.field);
        return Array.isArray(o2) && !Array.isArray(r2.value) ? t$2(o2, r2.value, e2) : e2(o2, r2.value) === 0;
      }, A$3 = function(r2, n2, t2) {
        return !p$3(r2, n2, t2);
      }, s$2 = o$2(function(r2, n2, t2) {
        var u2 = t2.compare(n2, r2.value);
        return u2 === 0 || u2 === -1;
      }), h$2 = o$2(function(r2, n2, t2) {
        return t2.compare(n2, r2.value) === -1;
      }), j$3 = o$2(function(r2, n2, t2) {
        return t2.compare(n2, r2.value) === 1;
      }), w$2 = o$2(function(r2, n2, t2) {
        var u2 = t2.compare(n2, r2.value);
        return u2 === 0 || u2 === 1;
      }), _$4 = function(n2, t2, e2) {
        var o2 = e2.get;
        if (n2.field === u$4)
          return t2 !== void 0;
        var i2 = c$3(t2, n2.field, o2), f2 = i2[0], a2 = i2[1], v2 = function(r2) {
          return !!r2 && r2.hasOwnProperty(a2) === n2.value;
        };
        return u$2(f2, a2) ? f2.some(v2) : v2(f2);
      }, x$2 = o$2(function(r2, n2) {
        return typeof n2 == "number" && n2 % r2.value[0] === r2.value[1];
      }), O$2 = function(n2, t2, e2) {
        var o2 = e2.get, i2 = c$3(t2, n2.field, o2), f2 = i2[0], a2 = i2[1], v2 = function(r2) {
          var t3 = o2(r2, a2);
          return Array.isArray(t3) && t3.length === n2.value;
        };
        return n2.field !== u$4 && u$2(f2, a2) ? f2.some(v2) : v2(f2);
      }, N$4 = o$2(function(r2, n2) {
        return typeof n2 == "string" && r2.value.test(n2);
      }), q$4 = o$2(function(r2, n2, u2) {
        var e2 = u2.compare;
        return t$2(r2.value, n2, e2);
      }), z$3 = function(r2, n2, t2) {
        return !q$4(r2, n2, t2);
      }, E$2 = function(r2, n2, u2) {
        var e2 = u2.compare, o2 = (0, u2.get)(n2, r2.field);
        return Array.isArray(o2) && r2.value.every(function(r3) {
          return t$2(o2, r3, e2);
        });
      }, M$2 = function(r2, n2, t2) {
        var u2 = t2.interpret, e2 = (0, t2.get)(n2, r2.field);
        return Array.isArray(e2) && e2.some(function(n3) {
          return u2(r2.value, n3);
        });
      }, S$3 = function(r2, n2) {
        return r2.value.call(n2);
      }, U$3 = i$2({}, Object.freeze({ __proto__: null, or: b$2, nor: m$3, and: d$2, not: g$2, eq: p$3, ne: A$3, lte: s$2, lt: h$2, gt: j$3, gte: w$2, exists: _$4, mod: x$2, size: O$2, regex: N$4, within: q$4, nin: z$3, all: E$2, elemMatch: M$2, where: S$3 }), { in: q$4 });
      l$2(U$3);
      function c$2() {
        return (c$2 = Object.assign || function(r2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var o2 = arguments[t2];
            for (var n2 in o2)
              Object.prototype.hasOwnProperty.call(o2, n2) && (r2[n2] = o2[n2]);
          }
          return r2;
        }).apply(this, arguments);
      }
      function a$2(r2) {
        return r2 instanceof Date ? r2.getTime() : r2 && typeof r2.toJSON == "function" ? r2.toJSON() : r2;
      }
      var m$2 = function(r2, t2) {
        return y$2(a$2(r2), a$2(t2));
      };
      function p$2(n2, e2, i2) {
        var u2 = new P$4(n2), a2 = l$2(e2, c$2({ compare: m$2 }, i2));
        if (i2 && i2.forPrimitives) {
          var p2 = { field: u$4 }, s2 = u2.parse;
          u2.setParse(function(r2) {
            return s2(r2, p2);
          });
        }
        return x$4(u2.parse, a2);
      }
      p$2(z$4, U$3);
      p$2(["$and", "$or"].reduce(function(r2, t2) {
        return r2[t2] = c$2({}, r2[t2], { type: "field" }), r2;
      }, c$2({}, z$4, { $nor: c$2({}, z$4.$nor, { type: "field", parse: j$5.compound }) })), U$3, { forPrimitives: true });
      function _$3(t2, r2) {
        for (var i2 = 0; i2 < r2.length; i2++) {
          var n2 = r2[i2];
          n2.enumerable = n2.enumerable || false;
          n2.configurable = true;
          if ("value" in n2)
            n2.writable = true;
          Object.defineProperty(t2, n2.key, n2);
        }
      }
      function P$3(t2, r2, i2) {
        if (r2)
          _$3(t2.prototype, r2);
        if (i2)
          _$3(t2, i2);
        return t2;
      }
      function R$3() {
        R$3 = Object.assign || function(t2) {
          for (var r2 = 1; r2 < arguments.length; r2++) {
            var i2 = arguments[r2];
            for (var n2 in i2)
              if (Object.prototype.hasOwnProperty.call(i2, n2))
                t2[n2] = i2[n2];
          }
          return t2;
        };
        return R$3.apply(this, arguments);
      }
      function k$3(t2, r2) {
        t2.prototype = Object.create(r2.prototype);
        t2.prototype.constructor = t2;
        B$3(t2, r2);
      }
      function B$3(t2, r2) {
        B$3 = Object.setPrototypeOf || function t3(r3, i2) {
          r3.__proto__ = i2;
          return r3;
        };
        return B$3(t2, r2);
      }
      function C$2(t2) {
        if (t2 === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t2;
      }
      function T$2(t2) {
        return Array.isArray(t2) ? t2 : [t2];
      }
      var q$3 = "__caslSubjectType__";
      function z$2(t2, r2) {
        if (r2) {
          if (!r2.hasOwnProperty(q$3))
            Object.defineProperty(r2, q$3, { value: t2 });
          else if (t2 !== r2[q$3])
            throw new Error("Trying to cast object to subject type " + t2 + " but previously it was casted to " + r2[q$3]);
        }
        return r2;
      }
      var S$2 = function t2(r2) {
        var i2 = typeof r2;
        return i2 === "string" || i2 === "function";
      };
      var Y$3 = function t2(r2) {
        return r2.modelName || r2.name;
      };
      var D$3 = function t2(r2) {
        return typeof r2 === "string" ? r2 : Y$3(r2);
      };
      function L$3(t2) {
        if (t2.hasOwnProperty(q$3))
          return t2[q$3];
        return Y$3(t2.constructor);
      }
      function N$3(t2, r2, i2) {
        for (var n2 = i2; n2 < r2.length; n2++)
          t2.push(r2[n2]);
      }
      function Q$2(t2, r2) {
        if (!t2 || !t2.length)
          return r2 || [];
        if (!r2 || !r2.length)
          return t2 || [];
        var i2 = 0;
        var n2 = 0;
        var e2 = [];
        while (i2 < t2.length && n2 < r2.length)
          if (t2[i2].priority < r2[n2].priority) {
            e2.push(t2[i2]);
            i2++;
          } else {
            e2.push(r2[n2]);
            n2++;
          }
        N$3(e2, t2, i2);
        N$3(e2, r2, n2);
        return e2;
      }
      function U$2(t2, r2, i2) {
        var n2 = t2.get(r2);
        if (!n2) {
          n2 = i2();
          t2.set(r2, n2);
        }
        return n2;
      }
      var V$3 = function t2(r2) {
        return r2;
      };
      function W$2(t2, r2) {
        if (Array.isArray(t2.fields) && !t2.fields.length)
          throw new Error("`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa");
        if (t2.fields && !r2.fieldMatcher)
          throw new Error('You need to pass "fieldMatcher" option in order to restrict access by fields');
        if (t2.conditions && !r2.conditionsMatcher)
          throw new Error('You need to pass "conditionsMatcher" option in order to restrict access by conditions');
      }
      var X$2 = function() {
        function t2(t3, r3, i2) {
          if (i2 === void 0)
            i2 = 0;
          W$2(t3, r3);
          this.action = r3.resolveAction(t3.action);
          this.subject = t3.subject;
          this.inverted = !!t3.inverted;
          this.conditions = t3.conditions;
          this.reason = t3.reason;
          this.fields = t3.fields ? T$2(t3.fields) : void 0;
          this.priority = i2;
          this.t = r3;
        }
        var r2 = t2.prototype;
        r2.i = function t3() {
          if (this.conditions && !this.u)
            this.u = this.t.conditionsMatcher(this.conditions);
          return this.u;
        };
        r2.matchesConditions = function t3(r3) {
          if (!this.conditions)
            return true;
          if (!r3 || S$2(r3))
            return !this.inverted;
          var i2 = this.i();
          return i2(r3);
        };
        r2.matchesField = function t3(r3) {
          if (!this.fields)
            return true;
          if (!r3)
            return !this.inverted;
          if (this.fields && !this.o)
            this.o = this.t.fieldMatcher(this.fields);
          return this.o(r3);
        };
        P$3(t2, [{ key: "ast", get: function t3() {
          var r3 = this.i();
          return r3 ? r3.ast : void 0;
        } }]);
        return t2;
      }();
      function Z$2(t2, r2) {
        var i2 = { value: t2, prev: r2, next: null };
        if (r2)
          r2.next = i2;
        return i2;
      }
      function tt$1(t2) {
        if (t2.next)
          t2.next.prev = t2.prev;
        if (t2.prev)
          t2.prev.next = t2.next;
        t2.next = t2.prev = null;
      }
      var rt$1 = function t2(r2) {
        return { value: r2.value, prev: r2.prev, next: r2.next };
      };
      var it$1 = function t2() {
        return { rules: [], merged: false };
      };
      var nt$1 = function t2() {
        return new Map();
      };
      var et$1 = function t2(r2, i2) {
        if (!r2.h && i2.fields)
          r2.h = true;
      };
      var ut$1 = function() {
        function t2(t3, r3) {
          if (t3 === void 0)
            t3 = [];
          if (r3 === void 0)
            r3 = {};
          this.h = false;
          this.v = new Map();
          this.l = { conditionsMatcher: r3.conditionsMatcher, fieldMatcher: r3.fieldMatcher, resolveAction: r3.resolveAction || V$3 };
          this.p = r3.anyAction || "manage";
          this.g = r3.anySubjectType || "all";
          this.A = r3.detectSubjectType || L$3;
          this.$ = t3;
          this.j = this.m(t3);
        }
        var r2 = t2.prototype;
        r2.detectSubjectType = function t3(r3) {
          if (S$2(r3))
            return r3;
          if (!r3)
            return this.g;
          return this.A(r3);
        };
        r2.update = function t3(r3) {
          var i2 = { rules: r3, ability: this, target: this };
          this.M("update", i2);
          this.$ = r3;
          this.j = this.m(r3);
          this.M("updated", i2);
          return this;
        };
        r2.m = function t3(r3) {
          var i2 = new Map();
          for (var n2 = r3.length - 1; n2 >= 0; n2--) {
            var e2 = r3.length - n2 - 1;
            var u2 = new X$2(r3[n2], this.l, e2);
            var o2 = T$2(u2.action);
            var s2 = T$2(u2.subject || this.g);
            et$1(this, u2);
            for (var f2 = 0; f2 < s2.length; f2++) {
              var a2 = U$2(i2, s2[f2], nt$1);
              for (var c2 = 0; c2 < o2.length; c2++)
                U$2(a2, o2[c2], it$1).rules.push(u2);
            }
          }
          return i2;
        };
        r2.possibleRulesFor = function t3(r3, i2) {
          if (i2 === void 0)
            i2 = this.g;
          if (!S$2(i2))
            throw new Error('"possibleRulesFor" accepts only subject types (i.e., string or class) as the 2nd parameter');
          var n2 = U$2(this.j, i2, nt$1);
          var e2 = U$2(n2, r3, it$1);
          if (e2.merged)
            return e2.rules;
          var u2 = r3 !== this.p && n2.has(this.p) ? n2.get(this.p).rules : void 0;
          var o2 = Q$2(e2.rules, u2);
          if (i2 !== this.g)
            o2 = Q$2(o2, this.possibleRulesFor(r3, this.g));
          e2.rules = o2;
          e2.merged = true;
          return o2;
        };
        r2.rulesFor = function t3(r3, i2, n2) {
          var e2 = this.possibleRulesFor(r3, i2);
          if (n2 && typeof n2 !== "string")
            throw new Error("The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details");
          if (!this.h)
            return e2;
          return e2.filter(function(t4) {
            return t4.matchesField(n2);
          });
        };
        r2.on = function t3(r3, i2) {
          var n2 = this;
          var e2 = this.v.get(r3) || null;
          var u2 = Z$2(i2, e2);
          this.v.set(r3, u2);
          return function() {
            var t4 = n2.v.get(r3);
            if (!u2.next && !u2.prev && t4 === u2)
              n2.v.delete(r3);
            else if (u2 === t4)
              n2.v.set(r3, u2.prev);
            tt$1(u2);
          };
        };
        r2.M = function t3(r3, i2) {
          var n2 = this.v.get(r3) || null;
          while (n2 !== null) {
            var e2 = n2.prev ? rt$1(n2.prev) : null;
            n2.value(i2);
            n2 = e2;
          }
        };
        P$3(t2, [{ key: "rules", get: function t3() {
          return this.$;
        } }]);
        return t2;
      }();
      var ot$1 = function(t2) {
        k$3(PureAbility, t2);
        function PureAbility() {
          return t2.apply(this, arguments) || this;
        }
        var r2 = PureAbility.prototype;
        r2.can = function t3() {
          var r3 = this.relevantRuleFor.apply(this, arguments);
          return !!r3 && !r3.inverted;
        };
        r2.relevantRuleFor = function t3(r3, i2, n2) {
          var e2 = this.detectSubjectType(i2);
          var u2 = this.rulesFor(r3, e2, n2);
          for (var o2 = 0, s2 = u2.length; o2 < s2; o2++)
            if (u2[o2].matchesConditions(i2))
              return u2[o2];
          return null;
        };
        r2.cannot = function t3() {
          return !this.can.apply(this, arguments);
        };
        return PureAbility;
      }(ut$1);
      var st$1 = { $eq: O$3, $ne: R$4, $lt: E$3, $lte: j$4, $gt: b$3, $gte: g$3, $in: y$3, $nin: $$3, $all: x$3, $size: w$3, $regex: _$5, $options: q$5, $elemMatch: v$2, $exists: m$4 };
      var ft$1 = { eq: p$3, ne: A$3, lt: h$2, lte: s$2, gt: j$3, gte: w$2, in: q$4, nin: z$3, all: E$2, size: O$2, regex: N$4, elemMatch: M$2, exists: _$4, and: d$2 };
      var ct$1 = p$2(st$1, ft$1);
      var ht$1 = /[-/\\^$+?.()|[\]{}]/g;
      var vt$1 = /\.?\*+\.?/g;
      var lt$1 = /\*+/;
      var dt$1 = /\./g;
      function bt$1(t2, r2, i2) {
        var n2 = i2[0] === "*" || t2[0] === "." && t2[t2.length - 1] === "." ? "+" : "*";
        var e2 = t2.indexOf("**") === -1 ? "[^.]" : ".";
        var u2 = t2.replace(dt$1, "\\$&").replace(lt$1, e2 + n2);
        return r2 + t2.length === i2.length ? "(?:" + u2 + ")?" : u2;
      }
      function yt$1(t2, r2, i2) {
        if (t2 === "." && (i2[r2 - 1] === "*" || i2[r2 + 1] === "*"))
          return t2;
        return "\\" + t2;
      }
      function pt$1(t2) {
        var r2 = t2.map(function(t3) {
          return t3.replace(ht$1, yt$1).replace(vt$1, bt$1);
        });
        var i2 = r2.length > 1 ? "(?:" + r2.join("|") + ")" : r2[0];
        return new RegExp("^" + i2 + "$");
      }
      var wt$1 = function t2(r2) {
        var i2;
        return function(t3) {
          if (typeof i2 === "undefined")
            i2 = r2.every(function(t4) {
              return t4.indexOf("*") === -1;
            }) ? null : pt$1(r2);
          return i2 === null ? r2.indexOf(t3) !== -1 : i2.test(t3);
        };
      };
      var gt$1 = function(t2) {
        k$3(Ability, t2);
        function Ability(r2, i2) {
          if (r2 === void 0)
            r2 = [];
          if (i2 === void 0)
            i2 = {};
          return t2.call(this, r2, R$3({ conditionsMatcher: ct$1, fieldMatcher: wt$1 }, i2)) || this;
        }
        return Ability;
      }(ot$1);
      var $t$1 = function t2(r2) {
        return 'Cannot execute "' + r2.action + '" on "' + r2.subjectType + '"';
      };
      var jt$1 = function t2(r2) {
        this.message = r2;
      };
      jt$1.prototype = Object.create(Error.prototype);
      var mt$1 = function(t2) {
        k$3(ForbiddenError, t2);
        ForbiddenError.setDefaultMessage = function t3(r3) {
          this._ = typeof r3 === "string" ? function() {
            return r3;
          } : r3;
        };
        ForbiddenError.from = function t3(r3) {
          return new this(r3);
        };
        function ForbiddenError(r3) {
          var i2;
          i2 = t2.call(this, "") || this;
          i2.ability = r3;
          if (typeof Error.captureStackTrace === "function") {
            i2.name = "ForbiddenError";
            Error.captureStackTrace(C$2(i2), i2.constructor);
          }
          return i2;
        }
        var r2 = ForbiddenError.prototype;
        r2.setMessage = function t3(r3) {
          this.message = r3;
          return this;
        };
        r2.throwUnlessCan = function t3() {
          var r3;
          var i2 = (r3 = this.ability).relevantRuleFor.apply(r3, arguments);
          if (i2 && !i2.inverted)
            return;
          this.action = arguments.length <= 0 ? void 0 : arguments[0];
          this.subject = arguments.length <= 1 ? void 0 : arguments[1];
          this.subjectType = D$3(this.ability.detectSubjectType(arguments.length <= 1 ? void 0 : arguments[1]));
          this.field = arguments.length <= 2 ? void 0 : arguments[2];
          var n2 = i2 ? i2.reason : "";
          this.message = this.message || n2 || this.constructor._(this);
          throw this;
        };
        return ForbiddenError;
      }(jt$1);
      mt$1._ = $t$1;
      Object.freeze({ __proto__: null });
      var defineAbilityFor = (rules) => {
        return new gt$1(rules);
      };
      var ButtonAddCard_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _withScopeId$a = (n2) => (pushScopeId("data-v-bfeaa5de"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$g = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-plus" }, null, -1));
      const _hoisted_2$f = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createElementVNode("span", { class: "ml-2" }, "Add a card", -1));
      const __default__$7 = {
        name: "ButtonAddCard"
      };
      const _sfc_main$j = /* @__PURE__ */ Object.assign(__default__$7, {
        props: {
          cellId: {
            type: Number
          },
          rowValue: [String, Number],
          columnValue: [String, Number]
        },
        setup(__props) {
          const showForm = ref(false);
          const canCreateCard = computed(() => {
            const ability = defineAbilityFor(store.getters.getRules);
            return ability.can("create", "Tracker_Item");
          });
          const handleOpen = () => {
            showForm.value = true;
          };
          const handleClose = () => {
            showForm.value = false;
          };
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              !showForm.value && unref(canCreateCard) ? (openBlock(), createBlock(unref(Button), {
                key: 0,
                class: "w-100",
                variant: "default",
                sm: "",
                onClick: handleOpen
              }, {
                default: withCtx(() => [
                  _hoisted_1$g,
                  _hoisted_2$f
                ]),
                _: 1
              })) : createCommentVNode("v-if", true),
              showForm.value ? (openBlock(), createBlock(FormAddCard, {
                key: 1,
                cellId: __props.cellId,
                rowValue: __props.rowValue,
                columnValue: __props.columnValue,
                onClose: handleClose
              }, null, 8, ["cellId", "rowValue", "columnValue"])) : createCommentVNode("v-if", true)
            ], 64);
          };
        }
      });
      var ButtonAddCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__scopeId", "data-v-bfeaa5de"]]);
      var KanbanColumn_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _hoisted_1$f = { class: "kanban-column-header" };
      const _hoisted_2$e = {
        key: 0,
        class: "mr-2"
      };
      const _hoisted_7$3 = { class: "kanban-column-body d-flex flex-column flex-grow-1" };
      const _hoisted_8$4 = { class: "flex-grow-1" };
      const _hoisted_9$3 = { key: 0 };
      const __default__$6 = {
        name: "KanbanColumn"
      };
      const _sfc_main$i = /* @__PURE__ */ Object.assign(__default__$6, {
        props: {
          title: {
            type: String,
            default: ""
          },
          limit: {
            type: Number
          },
          total: {
            type: Number
          },
          colId: {
            type: Number
          },
          rowValue: [Number, String],
          columnValue: [Number, String],
          cellId: {
            type: Number
          },
          rowIndex: {
            type: Number
          },
          colIndex: {
            type: Number
          }
        },
        setup(__props) {
          const props2 = __props;
          const showEditField = ref(false);
          const toast = useToast();
          const isLimitExceeded = computed(() => {
            if (props2.limit) {
              return props2.total > props2.limit;
            } else {
              return false;
            }
          });
          const handleTitleBlur = (event) => {
            showEditField.value = false;
            if (event.target.value.length < 1) {
              toast.error(`This field must be at least 1 character`);
              return;
            }
            store.dispatch("editColumnField", {
              id: props2.colId,
              field: "title",
              data: event.target.value
            });
          };
          return (_ctx, _cache) => {
            resolveComponent("ColorPicker");
            const _directive_focus = resolveDirective("focus");
            const _directive_autosize = resolveDirective("autosize");
            return openBlock(), createElementBlock("div", {
              class: normalizeClass(["kanban-column", { "border border-danger": unref(isLimitExceeded) }])
            }, [
              createCommentVNode(` <div class="kanban-column-header mb-2" :style="{'background-color': store.getters.getColColor(props.colId)}"> `),
              createElementVNode("div", _hoisted_1$f, [
                createElementVNode("h6", {
                  class: normalizeClass(["d-flex justify-content-center align-items-center mb-0", { "drag-handle-cell": false }])
                }, [
                  !showEditField.value ? (openBlock(), createElementBlock("span", _hoisted_2$e, toDisplayString(__props.title), 1)) : createCommentVNode("v-if", true),
                  showEditField.value ? withDirectives((openBlock(), createBlock(unref(Field), {
                    key: 1,
                    class: "flex-grow-1 mr-1",
                    as: "textarea",
                    rows: "1",
                    value: __props.title,
                    onBlur: handleTitleBlur,
                    name: "rowTitle",
                    type: "text",
                    rules: { minLength: 1 }
                  }, null, 8, ["value"])), [
                    [_directive_focus],
                    [_directive_autosize]
                  ]) : createCommentVNode("v-if", true)
                ]),
                createElementVNode("span", {
                  class: normalizeClass(["rounded p-1", { "bg-danger text-light": unref(isLimitExceeded) }])
                }, toDisplayString(__props.total) + toDisplayString(__props.limit ? `/${__props.limit}` : ""), 3),
                createCommentVNode("v-if", true)
              ]),
              createElementVNode("div", _hoisted_7$3, [
                createElementVNode("div", _hoisted_8$4, [
                  renderSlot(_ctx.$slots, "default", {}, void 0, true)
                ]),
                __props.colIndex === 0 ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
                  createVNode(ButtonAddCard, {
                    cellId: __props.cellId,
                    rowValue: __props.rowValue,
                    columnValue: __props.columnValue
                  }, null, 8, ["cellId", "rowValue", "columnValue"])
                ])) : createCommentVNode("v-if", true)
              ])
            ], 2);
          };
        }
      });
      var KanbanColumn = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__scopeId", "data-v-35b181c6"]]);
      var FormEditField_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _hoisted_1$e = {
        key: 1,
        class: "editable-container"
      };
      const __default__$5 = {
        name: "FormEditField"
      };
      const _sfc_main$h = /* @__PURE__ */ Object.assign(__default__$5, {
        props: {
          id: [Number, String],
          title: {
            type: String
          }
        },
        setup(__props) {
          const props2 = __props;
          const trackerId = ref(store.getters.getTrackerId);
          const showEditField = ref(false);
          const toast = useToast();
          const titleField = ref(props2.title);
          const handleSaveTitle = (event) => {
            showEditField.value = false;
            if (titleField.value.length < 1) {
              toast.error(`This field must be at least 1 character`);
              return;
            }
            kanban.setItem({ trackerId: trackerId.value, itemId: props2.id }, {
              fields: {
                [store.getters.getTitleField]: titleField.value
              }
            }).then((res) => {
            }).catch((err) => {
              if (!err.response)
                toast.error("Error: title not saved");
              const { code, errortitle, message } = err.response.data;
              const msg = `Code: ${code} - ${message}`;
              toast.error(msg);
            });
            store.dispatch("editCardField", {
              id: props2.id,
              field: "title",
              data: titleField.value
            });
          };
          const handleEditClick = (event) => {
            const ability = defineAbilityFor(store.getters.getRules);
            const canUpdate = ability.can("update", z$2("Tracker_Item", { itemId: props2.id }), store.getters.getTitleField);
            if (canUpdate)
              showEditField.value = true;
          };
          return (_ctx, _cache) => {
            const _directive_focus = resolveDirective("focus");
            const _directive_autosize = resolveDirective("autosize");
            return openBlock(), createElementBlock("div", null, [
              !showEditField.value ? (openBlock(), createElementBlock("div", {
                key: 0,
                onClick: handleEditClick
              }, toDisplayString(titleField.value), 1)) : createCommentVNode("v-if", true),
              showEditField.value ? (openBlock(), createElementBlock("div", _hoisted_1$e, [
                withDirectives(createVNode(unref(Field), {
                  class: "form-control",
                  as: "textarea",
                  rows: "1",
                  modelValue: titleField.value,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => titleField.value = $event),
                  name: "cardTitle",
                  type: "text",
                  rules: { minLength: 1 },
                  onBlur: handleSaveTitle
                }, null, 8, ["modelValue"]), [
                  [_directive_focus],
                  [_directive_autosize]
                ])
              ])) : createCommentVNode("v-if", true)
            ]);
          };
        }
      });
      var FormEditField = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__scopeId", "data-v-7ce40aac"]]);
      /**!
       * Sortable 1.14.0
       * @author	RubaXa   <trash@rubaxa.org>
       * @author	owenm    <owen23355@gmail.com>
       * @license MIT
       */
      function ownKeys(object, enumerableOnly) {
        var keys2 = Object.keys(object);
        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);
          if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          }
          keys2.push.apply(keys2, symbols);
        }
        return keys2;
      }
      function _objectSpread2(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2] != null ? arguments[i2] : {};
          if (i2 % 2) {
            ownKeys(Object(source), true).forEach(function(key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function(key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }
        return target;
      }
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i2 = 1; i2 < arguments.length; i2++) {
            var source = arguments[i2];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i2;
        for (i2 = 0; i2 < sourceKeys.length; i2++) {
          key = sourceKeys[i2];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      function _objectWithoutProperties(source, excluded) {
        if (source == null)
          return {};
        var target = _objectWithoutPropertiesLoose(source, excluded);
        var key, i2;
        if (Object.getOwnPropertySymbols) {
          var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
          for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
            key = sourceSymbolKeys[i2];
            if (excluded.indexOf(key) >= 0)
              continue;
            if (!Object.prototype.propertyIsEnumerable.call(source, key))
              continue;
            target[key] = source[key];
          }
        }
        return target;
      }
      var version = "1.14.0";
      function userAgent(pattern) {
        if (typeof window !== "undefined" && window.navigator) {
          return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
        }
      }
      var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
      var Edge = userAgent(/Edge/i);
      var FireFox = userAgent(/firefox/i);
      var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
      var IOS = userAgent(/iP(ad|od|hone)/i);
      var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
      var captureMode = {
        capture: false,
        passive: false
      };
      function on$1(el, event, fn2) {
        el.addEventListener(event, fn2, !IE11OrLess && captureMode);
      }
      function off(el, event, fn2) {
        el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
      }
      function matches(el, selector) {
        if (!selector)
          return;
        selector[0] === ">" && (selector = selector.substring(1));
        if (el) {
          try {
            if (el.matches) {
              return el.matches(selector);
            } else if (el.msMatchesSelector) {
              return el.msMatchesSelector(selector);
            } else if (el.webkitMatchesSelector) {
              return el.webkitMatchesSelector(selector);
            }
          } catch (_2) {
            return false;
          }
        }
        return false;
      }
      function getParentOrHost(el) {
        return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
      }
      function closest(el, selector, ctx, includeCTX) {
        if (el) {
          ctx = ctx || document;
          do {
            if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
              return el;
            }
            if (el === ctx)
              break;
          } while (el = getParentOrHost(el));
        }
        return null;
      }
      var R_SPACE = /\s+/g;
      function toggleClass(el, name, state2) {
        if (el && name) {
          if (el.classList) {
            el.classList[state2 ? "add" : "remove"](name);
          } else {
            var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
            el.className = (className + (state2 ? " " + name : "")).replace(R_SPACE, " ");
          }
        }
      }
      function css(el, prop, val) {
        var style2 = el && el.style;
        if (style2) {
          if (val === void 0) {
            if (document.defaultView && document.defaultView.getComputedStyle) {
              val = document.defaultView.getComputedStyle(el, "");
            } else if (el.currentStyle) {
              val = el.currentStyle;
            }
            return prop === void 0 ? val : val[prop];
          } else {
            if (!(prop in style2) && prop.indexOf("webkit") === -1) {
              prop = "-webkit-" + prop;
            }
            style2[prop] = val + (typeof val === "string" ? "" : "px");
          }
        }
      }
      function matrix(el, selfOnly) {
        var appliedTransforms = "";
        if (typeof el === "string") {
          appliedTransforms = el;
        } else {
          do {
            var transform = css(el, "transform");
            if (transform && transform !== "none") {
              appliedTransforms = transform + " " + appliedTransforms;
            }
          } while (!selfOnly && (el = el.parentNode));
        }
        var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
        return matrixFn && new matrixFn(appliedTransforms);
      }
      function find(ctx, tagName, iterator) {
        if (ctx) {
          var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
          if (iterator) {
            for (; i2 < n2; i2++) {
              iterator(list[i2], i2);
            }
          }
          return list;
        }
        return [];
      }
      function getWindowScrollingElement() {
        var scrollingElement = document.scrollingElement;
        if (scrollingElement) {
          return scrollingElement;
        } else {
          return document.documentElement;
        }
      }
      function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
        if (!el.getBoundingClientRect && el !== window)
          return;
        var elRect, top2, left2, bottom2, right2, height, width;
        if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
          elRect = el.getBoundingClientRect();
          top2 = elRect.top;
          left2 = elRect.left;
          bottom2 = elRect.bottom;
          right2 = elRect.right;
          height = elRect.height;
          width = elRect.width;
        } else {
          top2 = 0;
          left2 = 0;
          bottom2 = window.innerHeight;
          right2 = window.innerWidth;
          height = window.innerHeight;
          width = window.innerWidth;
        }
        if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
          container = container || el.parentNode;
          if (!IE11OrLess) {
            do {
              if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
                var containerRect = container.getBoundingClientRect();
                top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
                left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
                bottom2 = top2 + elRect.height;
                right2 = left2 + elRect.width;
                break;
              }
            } while (container = container.parentNode);
          }
        }
        if (undoScale && el !== window) {
          var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
          if (elMatrix) {
            top2 /= scaleY;
            left2 /= scaleX;
            width /= scaleX;
            height /= scaleY;
            bottom2 = top2 + height;
            right2 = left2 + width;
          }
        }
        return {
          top: top2,
          left: left2,
          bottom: bottom2,
          right: right2,
          width,
          height
        };
      }
      function isScrolledPast(el, elSide, parentSide) {
        var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
        while (parent2) {
          var parentSideVal = getRect(parent2)[parentSide], visible = void 0;
          if (parentSide === "top" || parentSide === "left") {
            visible = elSideVal >= parentSideVal;
          } else {
            visible = elSideVal <= parentSideVal;
          }
          if (!visible)
            return parent2;
          if (parent2 === getWindowScrollingElement())
            break;
          parent2 = getParentAutoScrollElement(parent2, false);
        }
        return false;
      }
      function getChild(el, childNum, options, includeDragEl) {
        var currentChild = 0, i2 = 0, children = el.children;
        while (i2 < children.length) {
          if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options.draggable, el, false)) {
            if (currentChild === childNum) {
              return children[i2];
            }
            currentChild++;
          }
          i2++;
        }
        return null;
      }
      function lastChild(el, selector) {
        var last2 = el.lastElementChild;
        while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches(last2, selector))) {
          last2 = last2.previousElementSibling;
        }
        return last2 || null;
      }
      function index$1(el, selector) {
        var index2 = 0;
        if (!el || !el.parentNode) {
          return -1;
        }
        while (el = el.previousElementSibling) {
          if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
            index2++;
          }
        }
        return index2;
      }
      function getRelativeScrollOffset(el) {
        var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
        if (el) {
          do {
            var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
            offsetLeft += el.scrollLeft * scaleX;
            offsetTop += el.scrollTop * scaleY;
          } while (el !== winScroller && (el = el.parentNode));
        }
        return [offsetLeft, offsetTop];
      }
      function indexOfObject(arr, obj) {
        for (var i2 in arr) {
          if (!arr.hasOwnProperty(i2))
            continue;
          for (var key in obj) {
            if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
              return Number(i2);
          }
        }
        return -1;
      }
      function getParentAutoScrollElement(el, includeSelf) {
        if (!el || !el.getBoundingClientRect)
          return getWindowScrollingElement();
        var elem = el;
        var gotSelf = false;
        do {
          if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
            var elemCSS = css(elem);
            if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
              if (!elem.getBoundingClientRect || elem === document.body)
                return getWindowScrollingElement();
              if (gotSelf || includeSelf)
                return elem;
              gotSelf = true;
            }
          }
        } while (elem = elem.parentNode);
        return getWindowScrollingElement();
      }
      function extend(dst, src2) {
        if (dst && src2) {
          for (var key in src2) {
            if (src2.hasOwnProperty(key)) {
              dst[key] = src2[key];
            }
          }
        }
        return dst;
      }
      function isRectEqual(rect1, rect2) {
        return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
      }
      var _throttleTimeout;
      function throttle(callback, ms) {
        return function() {
          if (!_throttleTimeout) {
            var args = arguments, _this = this;
            if (args.length === 1) {
              callback.call(_this, args[0]);
            } else {
              callback.apply(_this, args);
            }
            _throttleTimeout = setTimeout(function() {
              _throttleTimeout = void 0;
            }, ms);
          }
        };
      }
      function cancelThrottle() {
        clearTimeout(_throttleTimeout);
        _throttleTimeout = void 0;
      }
      function scrollBy(el, x2, y2) {
        el.scrollLeft += x2;
        el.scrollTop += y2;
      }
      function clone(el) {
        var Polymer = window.Polymer;
        var $2 = window.jQuery || window.Zepto;
        if (Polymer && Polymer.dom) {
          return Polymer.dom(el).cloneNode(true);
        } else if ($2) {
          return $2(el).clone(true)[0];
        } else {
          return el.cloneNode(true);
        }
      }
      var expando = "Sortable" + new Date().getTime();
      function AnimationStateManager() {
        var animationStates = [], animationCallbackId;
        return {
          captureAnimationState: function captureAnimationState() {
            animationStates = [];
            if (!this.options.animation)
              return;
            var children = [].slice.call(this.el.children);
            children.forEach(function(child) {
              if (css(child, "display") === "none" || child === Sortable.ghost)
                return;
              animationStates.push({
                target: child,
                rect: getRect(child)
              });
              var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
              if (child.thisAnimationDuration) {
                var childMatrix = matrix(child, true);
                if (childMatrix) {
                  fromRect.top -= childMatrix.f;
                  fromRect.left -= childMatrix.e;
                }
              }
              child.fromRect = fromRect;
            });
          },
          addAnimationState: function addAnimationState(state2) {
            animationStates.push(state2);
          },
          removeAnimationState: function removeAnimationState(target) {
            animationStates.splice(indexOfObject(animationStates, {
              target
            }), 1);
          },
          animateAll: function animateAll(callback) {
            var _this = this;
            if (!this.options.animation) {
              clearTimeout(animationCallbackId);
              if (typeof callback === "function")
                callback();
              return;
            }
            var animating = false, animationTime = 0;
            animationStates.forEach(function(state2) {
              var time = 0, target = state2.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state2.rect, targetMatrix = matrix(target, true);
              if (targetMatrix) {
                toRect.top -= targetMatrix.f;
                toRect.left -= targetMatrix.e;
              }
              target.toRect = toRect;
              if (target.thisAnimationDuration) {
                if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
                  time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
                }
              }
              if (!isRectEqual(toRect, fromRect)) {
                target.prevFromRect = fromRect;
                target.prevToRect = toRect;
                if (!time) {
                  time = _this.options.animation;
                }
                _this.animate(target, animatingRect, toRect, time);
              }
              if (time) {
                animating = true;
                animationTime = Math.max(animationTime, time);
                clearTimeout(target.animationResetTimer);
                target.animationResetTimer = setTimeout(function() {
                  target.animationTime = 0;
                  target.prevFromRect = null;
                  target.fromRect = null;
                  target.prevToRect = null;
                  target.thisAnimationDuration = null;
                }, time);
                target.thisAnimationDuration = time;
              }
            });
            clearTimeout(animationCallbackId);
            if (!animating) {
              if (typeof callback === "function")
                callback();
            } else {
              animationCallbackId = setTimeout(function() {
                if (typeof callback === "function")
                  callback();
              }, animationTime);
            }
            animationStates = [];
          },
          animate: function animate(target, currentRect, toRect, duration) {
            if (duration) {
              css(target, "transition", "");
              css(target, "transform", "");
              var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
              target.animatingX = !!translateX;
              target.animatingY = !!translateY;
              css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
              this.forRepaintDummy = repaint(target);
              css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
              css(target, "transform", "translate3d(0,0,0)");
              typeof target.animated === "number" && clearTimeout(target.animated);
              target.animated = setTimeout(function() {
                css(target, "transition", "");
                css(target, "transform", "");
                target.animated = false;
                target.animatingX = false;
                target.animatingY = false;
              }, duration);
            }
          }
        };
      }
      function repaint(target) {
        return target.offsetWidth;
      }
      function calculateRealTime(animatingRect, fromRect, toRect, options) {
        return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
      }
      var plugins = [];
      var defaults = {
        initializeByDefault: true
      };
      var PluginManager = {
        mount: function mount2(plugin) {
          for (var option in defaults) {
            if (defaults.hasOwnProperty(option) && !(option in plugin)) {
              plugin[option] = defaults[option];
            }
          }
          plugins.forEach(function(p2) {
            if (p2.pluginName === plugin.pluginName) {
              throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
            }
          });
          plugins.push(plugin);
        },
        pluginEvent: function pluginEvent2(eventName, sortable, evt) {
          var _this = this;
          this.eventCanceled = false;
          evt.cancel = function() {
            _this.eventCanceled = true;
          };
          var eventNameGlobal = eventName + "Global";
          plugins.forEach(function(plugin) {
            if (!sortable[plugin.pluginName])
              return;
            if (sortable[plugin.pluginName][eventNameGlobal]) {
              sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
                sortable
              }, evt));
            }
            if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
              sortable[plugin.pluginName][eventName](_objectSpread2({
                sortable
              }, evt));
            }
          });
        },
        initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
          plugins.forEach(function(plugin) {
            var pluginName = plugin.pluginName;
            if (!sortable.options[pluginName] && !plugin.initializeByDefault)
              return;
            var initialized = new plugin(sortable, el, sortable.options);
            initialized.sortable = sortable;
            initialized.options = sortable.options;
            sortable[pluginName] = initialized;
            _extends(defaults2, initialized.defaults);
          });
          for (var option in sortable.options) {
            if (!sortable.options.hasOwnProperty(option))
              continue;
            var modified = this.modifyOption(sortable, option, sortable.options[option]);
            if (typeof modified !== "undefined") {
              sortable.options[option] = modified;
            }
          }
        },
        getEventProperties: function getEventProperties(name, sortable) {
          var eventProperties = {};
          plugins.forEach(function(plugin) {
            if (typeof plugin.eventProperties !== "function")
              return;
            _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
          });
          return eventProperties;
        },
        modifyOption: function modifyOption(sortable, name, value) {
          var modifiedValue;
          plugins.forEach(function(plugin) {
            if (!sortable[plugin.pluginName])
              return;
            if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
              modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
            }
          });
          return modifiedValue;
        }
      };
      function dispatchEvent(_ref) {
        var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
        sortable = sortable || rootEl2 && rootEl2[expando];
        if (!sortable)
          return;
        var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
        if (window.CustomEvent && !IE11OrLess && !Edge) {
          evt = new CustomEvent(name, {
            bubbles: true,
            cancelable: true
          });
        } else {
          evt = document.createEvent("Event");
          evt.initEvent(name, true, true);
        }
        evt.to = toEl || rootEl2;
        evt.from = fromEl || rootEl2;
        evt.item = targetEl || rootEl2;
        evt.clone = cloneEl2;
        evt.oldIndex = oldIndex2;
        evt.newIndex = newIndex2;
        evt.oldDraggableIndex = oldDraggableIndex2;
        evt.newDraggableIndex = newDraggableIndex2;
        evt.originalEvent = originalEvent;
        evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
        var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
        for (var option in allEventProperties) {
          evt[option] = allEventProperties[option];
        }
        if (rootEl2) {
          rootEl2.dispatchEvent(evt);
        }
        if (options[onName]) {
          options[onName].call(sortable, evt);
        }
      }
      var _excluded = ["evt"];
      var pluginEvent = function pluginEvent2(eventName, sortable) {
        var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data2 = _objectWithoutProperties(_ref, _excluded);
        PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
          dragEl,
          parentEl,
          ghostEl,
          rootEl,
          nextEl,
          lastDownEl,
          cloneEl,
          cloneHidden,
          dragStarted: moved,
          putSortable,
          activeSortable: Sortable.active,
          originalEvent,
          oldIndex,
          oldDraggableIndex,
          newIndex,
          newDraggableIndex,
          hideGhostForTarget: _hideGhostForTarget,
          unhideGhostForTarget: _unhideGhostForTarget,
          cloneNowHidden: function cloneNowHidden() {
            cloneHidden = true;
          },
          cloneNowShown: function cloneNowShown() {
            cloneHidden = false;
          },
          dispatchSortableEvent: function dispatchSortableEvent(name) {
            _dispatchEvent({
              sortable,
              name,
              originalEvent
            });
          }
        }, data2));
      };
      function _dispatchEvent(info) {
        dispatchEvent(_objectSpread2({
          putSortable,
          cloneEl,
          targetEl: dragEl,
          rootEl,
          oldIndex,
          oldDraggableIndex,
          newIndex,
          newDraggableIndex
        }, info));
      }
      var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
      var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
        if (!documentExists)
          return;
        if (IE11OrLess) {
          return false;
        }
        var el = document.createElement("x");
        el.style.cssText = "pointer-events:auto";
        return el.style.pointerEvents === "auto";
      }(), _detectDirection = function _detectDirection2(el, options) {
        var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
        if (elCSS.display === "flex") {
          return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
        }
        if (elCSS.display === "grid") {
          return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
        }
        if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
          var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
          return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
        }
        return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
      }, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
        var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
        return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
      }, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
        var ret;
        sortables.some(function(sortable) {
          var threshold = sortable[expando].options.emptyInsertThreshold;
          if (!threshold || lastChild(sortable))
            return;
          var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
          if (insideHorizontally && insideVertically) {
            return ret = sortable;
          }
        });
        return ret;
      }, _prepareGroup = function _prepareGroup2(options) {
        function toFn(value, pull) {
          return function(to2, from, dragEl2, evt) {
            var sameGroup = to2.options.group.name && from.options.group.name && to2.options.group.name === from.options.group.name;
            if (value == null && (pull || sameGroup)) {
              return true;
            } else if (value == null || value === false) {
              return false;
            } else if (pull && value === "clone") {
              return value;
            } else if (typeof value === "function") {
              return toFn(value(to2, from, dragEl2, evt), pull)(to2, from, dragEl2, evt);
            } else {
              var otherGroup = (pull ? to2 : from).options.group.name;
              return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
            }
          };
        }
        var group = {};
        var originalGroup = options.group;
        if (!originalGroup || _typeof(originalGroup) != "object") {
          originalGroup = {
            name: originalGroup
          };
        }
        group.name = originalGroup.name;
        group.checkPull = toFn(originalGroup.pull, true);
        group.checkPut = toFn(originalGroup.put);
        group.revertClone = originalGroup.revertClone;
        options.group = group;
      }, _hideGhostForTarget = function _hideGhostForTarget2() {
        if (!supportCssPointerEvents && ghostEl) {
          css(ghostEl, "display", "none");
        }
      }, _unhideGhostForTarget = function _unhideGhostForTarget2() {
        if (!supportCssPointerEvents && ghostEl) {
          css(ghostEl, "display", "");
        }
      };
      if (documentExists) {
        document.addEventListener("click", function(evt) {
          if (ignoreNextClick) {
            evt.preventDefault();
            evt.stopPropagation && evt.stopPropagation();
            evt.stopImmediatePropagation && evt.stopImmediatePropagation();
            ignoreNextClick = false;
            return false;
          }
        }, true);
      }
      var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
        if (dragEl) {
          evt = evt.touches ? evt.touches[0] : evt;
          var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
          if (nearest) {
            var event = {};
            for (var i2 in evt) {
              if (evt.hasOwnProperty(i2)) {
                event[i2] = evt[i2];
              }
            }
            event.target = event.rootEl = nearest;
            event.preventDefault = void 0;
            event.stopPropagation = void 0;
            nearest[expando]._onDragOver(event);
          }
        }
      };
      var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
        if (dragEl) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        }
      };
      function Sortable(el, options) {
        if (!(el && el.nodeType && el.nodeType === 1)) {
          throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
        }
        this.el = el;
        this.options = options = _extends({}, options);
        el[expando] = this;
        var defaults2 = {
          group: null,
          sort: true,
          disabled: false,
          store: null,
          handle: null,
          draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
          swapThreshold: 1,
          invertSwap: false,
          invertedSwapThreshold: null,
          removeCloneOnHide: true,
          direction: function direction() {
            return _detectDirection(el, this.options);
          },
          ghostClass: "sortable-ghost",
          chosenClass: "sortable-chosen",
          dragClass: "sortable-drag",
          ignore: "a, img",
          filter: null,
          preventOnFilter: true,
          animation: 0,
          easing: null,
          setData: function setData(dataTransfer, dragEl2) {
            dataTransfer.setData("Text", dragEl2.textContent);
          },
          dropBubble: false,
          dragoverBubble: false,
          dataIdAttr: "data-id",
          delay: 0,
          delayOnTouchOnly: false,
          touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
          forceFallback: false,
          fallbackClass: "sortable-fallback",
          fallbackOnBody: false,
          fallbackTolerance: 0,
          fallbackOffset: {
            x: 0,
            y: 0
          },
          supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
          emptyInsertThreshold: 5
        };
        PluginManager.initializePlugins(this, el, defaults2);
        for (var name in defaults2) {
          !(name in options) && (options[name] = defaults2[name]);
        }
        _prepareGroup(options);
        for (var fn2 in this) {
          if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
            this[fn2] = this[fn2].bind(this);
          }
        }
        this.nativeDraggable = options.forceFallback ? false : supportDraggable;
        if (this.nativeDraggable) {
          this.options.touchStartThreshold = 1;
        }
        if (options.supportPointer) {
          on$1(el, "pointerdown", this._onTapStart);
        } else {
          on$1(el, "mousedown", this._onTapStart);
          on$1(el, "touchstart", this._onTapStart);
        }
        if (this.nativeDraggable) {
          on$1(el, "dragover", this);
          on$1(el, "dragenter", this);
        }
        sortables.push(this.el);
        options.store && options.store.get && this.sort(options.store.get(this) || []);
        _extends(this, AnimationStateManager());
      }
      Sortable.prototype = {
        constructor: Sortable,
        _isOutsideThisEl: function _isOutsideThisEl(target) {
          if (!this.el.contains(target) && target !== this.el) {
            lastTarget = null;
          }
        },
        _getDirection: function _getDirection(evt, target) {
          return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
        },
        _onTapStart: function _onTapStart(evt) {
          if (!evt.cancelable)
            return;
          var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch2 = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch2 || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
          _saveInputCheckedState(el);
          if (dragEl) {
            return;
          }
          if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
            return;
          }
          if (originalTarget.isContentEditable) {
            return;
          }
          if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
            return;
          }
          target = closest(target, options.draggable, el, false);
          if (target && target.animated) {
            return;
          }
          if (lastDownEl === target) {
            return;
          }
          oldIndex = index$1(target);
          oldDraggableIndex = index$1(target, options.draggable);
          if (typeof filter === "function") {
            if (filter.call(this, evt, target, this)) {
              _dispatchEvent({
                sortable: _this,
                rootEl: originalTarget,
                name: "filter",
                targetEl: target,
                toEl: el,
                fromEl: el
              });
              pluginEvent("filter", _this, {
                evt
              });
              preventOnFilter && evt.cancelable && evt.preventDefault();
              return;
            }
          } else if (filter) {
            filter = filter.split(",").some(function(criteria) {
              criteria = closest(originalTarget, criteria.trim(), el, false);
              if (criteria) {
                _dispatchEvent({
                  sortable: _this,
                  rootEl: criteria,
                  name: "filter",
                  targetEl: target,
                  fromEl: el,
                  toEl: el
                });
                pluginEvent("filter", _this, {
                  evt
                });
                return true;
              }
            });
            if (filter) {
              preventOnFilter && evt.cancelable && evt.preventDefault();
              return;
            }
          }
          if (options.handle && !closest(originalTarget, options.handle, el, false)) {
            return;
          }
          this._prepareDragStart(evt, touch2, target);
        },
        _prepareDragStart: function _prepareDragStart(evt, touch2, target) {
          var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
          if (target && !dragEl && target.parentNode === el) {
            var dragRect = getRect(target);
            rootEl = el;
            dragEl = target;
            parentEl = dragEl.parentNode;
            nextEl = dragEl.nextSibling;
            lastDownEl = target;
            activeGroup = options.group;
            Sortable.dragged = dragEl;
            tapEvt = {
              target: dragEl,
              clientX: (touch2 || evt).clientX,
              clientY: (touch2 || evt).clientY
            };
            tapDistanceLeft = tapEvt.clientX - dragRect.left;
            tapDistanceTop = tapEvt.clientY - dragRect.top;
            this._lastX = (touch2 || evt).clientX;
            this._lastY = (touch2 || evt).clientY;
            dragEl.style["will-change"] = "all";
            dragStartFn = function dragStartFn2() {
              pluginEvent("delayEnded", _this, {
                evt
              });
              if (Sortable.eventCanceled) {
                _this._onDrop();
                return;
              }
              _this._disableDelayedDragEvents();
              if (!FireFox && _this.nativeDraggable) {
                dragEl.draggable = true;
              }
              _this._triggerDragStart(evt, touch2);
              _dispatchEvent({
                sortable: _this,
                name: "choose",
                originalEvent: evt
              });
              toggleClass(dragEl, options.chosenClass, true);
            };
            options.ignore.split(",").forEach(function(criteria) {
              find(dragEl, criteria.trim(), _disableDraggable);
            });
            on$1(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
            on$1(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
            on$1(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
            on$1(ownerDocument, "mouseup", _this._onDrop);
            on$1(ownerDocument, "touchend", _this._onDrop);
            on$1(ownerDocument, "touchcancel", _this._onDrop);
            if (FireFox && this.nativeDraggable) {
              this.options.touchStartThreshold = 4;
              dragEl.draggable = true;
            }
            pluginEvent("delayStart", this, {
              evt
            });
            if (options.delay && (!options.delayOnTouchOnly || touch2) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
              if (Sortable.eventCanceled) {
                this._onDrop();
                return;
              }
              on$1(ownerDocument, "mouseup", _this._disableDelayedDrag);
              on$1(ownerDocument, "touchend", _this._disableDelayedDrag);
              on$1(ownerDocument, "touchcancel", _this._disableDelayedDrag);
              on$1(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
              on$1(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
              options.supportPointer && on$1(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
              _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
            } else {
              dragStartFn();
            }
          }
        },
        _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
          var touch2 = e2.touches ? e2.touches[0] : e2;
          if (Math.max(Math.abs(touch2.clientX - this._lastX), Math.abs(touch2.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
            this._disableDelayedDrag();
          }
        },
        _disableDelayedDrag: function _disableDelayedDrag() {
          dragEl && _disableDraggable(dragEl);
          clearTimeout(this._dragStartTimer);
          this._disableDelayedDragEvents();
        },
        _disableDelayedDragEvents: function _disableDelayedDragEvents() {
          var ownerDocument = this.el.ownerDocument;
          off(ownerDocument, "mouseup", this._disableDelayedDrag);
          off(ownerDocument, "touchend", this._disableDelayedDrag);
          off(ownerDocument, "touchcancel", this._disableDelayedDrag);
          off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
          off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
          off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
        },
        _triggerDragStart: function _triggerDragStart(evt, touch2) {
          touch2 = touch2 || evt.pointerType == "touch" && evt;
          if (!this.nativeDraggable || touch2) {
            if (this.options.supportPointer) {
              on$1(document, "pointermove", this._onTouchMove);
            } else if (touch2) {
              on$1(document, "touchmove", this._onTouchMove);
            } else {
              on$1(document, "mousemove", this._onTouchMove);
            }
          } else {
            on$1(dragEl, "dragend", this);
            on$1(rootEl, "dragstart", this._onDragStart);
          }
          try {
            if (document.selection) {
              _nextTick(function() {
                document.selection.empty();
              });
            } else {
              window.getSelection().removeAllRanges();
            }
          } catch (err) {
          }
        },
        _dragStarted: function _dragStarted(fallback, evt) {
          awaitingDragStarted = false;
          if (rootEl && dragEl) {
            pluginEvent("dragStarted", this, {
              evt
            });
            if (this.nativeDraggable) {
              on$1(document, "dragover", _checkOutsideTargetEl);
            }
            var options = this.options;
            !fallback && toggleClass(dragEl, options.dragClass, false);
            toggleClass(dragEl, options.ghostClass, true);
            Sortable.active = this;
            fallback && this._appendGhost();
            _dispatchEvent({
              sortable: this,
              name: "start",
              originalEvent: evt
            });
          } else {
            this._nulling();
          }
        },
        _emulateDragOver: function _emulateDragOver() {
          if (touchEvt) {
            this._lastX = touchEvt.clientX;
            this._lastY = touchEvt.clientY;
            _hideGhostForTarget();
            var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
            var parent2 = target;
            while (target && target.shadowRoot) {
              target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
              if (target === parent2)
                break;
              parent2 = target;
            }
            dragEl.parentNode[expando]._isOutsideThisEl(target);
            if (parent2) {
              do {
                if (parent2[expando]) {
                  var inserted = void 0;
                  inserted = parent2[expando]._onDragOver({
                    clientX: touchEvt.clientX,
                    clientY: touchEvt.clientY,
                    target,
                    rootEl: parent2
                  });
                  if (inserted && !this.options.dragoverBubble) {
                    break;
                  }
                }
                target = parent2;
              } while (parent2 = parent2.parentNode);
            }
            _unhideGhostForTarget();
          }
        },
        _onTouchMove: function _onTouchMove(evt) {
          if (tapEvt) {
            var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch2 = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch2.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch2.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
            if (!Sortable.active && !awaitingDragStarted) {
              if (fallbackTolerance && Math.max(Math.abs(touch2.clientX - this._lastX), Math.abs(touch2.clientY - this._lastY)) < fallbackTolerance) {
                return;
              }
              this._onDragStart(evt, true);
            }
            if (ghostEl) {
              if (ghostMatrix) {
                ghostMatrix.e += dx - (lastDx || 0);
                ghostMatrix.f += dy - (lastDy || 0);
              } else {
                ghostMatrix = {
                  a: 1,
                  b: 0,
                  c: 0,
                  d: 1,
                  e: dx,
                  f: dy
                };
              }
              var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
              css(ghostEl, "webkitTransform", cssMatrix);
              css(ghostEl, "mozTransform", cssMatrix);
              css(ghostEl, "msTransform", cssMatrix);
              css(ghostEl, "transform", cssMatrix);
              lastDx = dx;
              lastDy = dy;
              touchEvt = touch2;
            }
            evt.cancelable && evt.preventDefault();
          }
        },
        _appendGhost: function _appendGhost() {
          if (!ghostEl) {
            var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
            if (PositionGhostAbsolutely) {
              ghostRelativeParent = container;
              while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
                ghostRelativeParent = ghostRelativeParent.parentNode;
              }
              if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
                if (ghostRelativeParent === document)
                  ghostRelativeParent = getWindowScrollingElement();
                rect.top += ghostRelativeParent.scrollTop;
                rect.left += ghostRelativeParent.scrollLeft;
              } else {
                ghostRelativeParent = getWindowScrollingElement();
              }
              ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
            }
            ghostEl = dragEl.cloneNode(true);
            toggleClass(ghostEl, options.ghostClass, false);
            toggleClass(ghostEl, options.fallbackClass, true);
            toggleClass(ghostEl, options.dragClass, true);
            css(ghostEl, "transition", "");
            css(ghostEl, "transform", "");
            css(ghostEl, "box-sizing", "border-box");
            css(ghostEl, "margin", 0);
            css(ghostEl, "top", rect.top);
            css(ghostEl, "left", rect.left);
            css(ghostEl, "width", rect.width);
            css(ghostEl, "height", rect.height);
            css(ghostEl, "opacity", "0.8");
            css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
            css(ghostEl, "zIndex", "100000");
            css(ghostEl, "pointerEvents", "none");
            Sortable.ghost = ghostEl;
            container.appendChild(ghostEl);
            css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
          }
        },
        _onDragStart: function _onDragStart(evt, fallback) {
          var _this = this;
          var dataTransfer = evt.dataTransfer;
          var options = _this.options;
          pluginEvent("dragStart", this, {
            evt
          });
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          pluginEvent("setupClone", this);
          if (!Sortable.eventCanceled) {
            cloneEl = clone(dragEl);
            cloneEl.draggable = false;
            cloneEl.style["will-change"] = "";
            this._hideClone();
            toggleClass(cloneEl, this.options.chosenClass, false);
            Sortable.clone = cloneEl;
          }
          _this.cloneId = _nextTick(function() {
            pluginEvent("clone", _this);
            if (Sortable.eventCanceled)
              return;
            if (!_this.options.removeCloneOnHide) {
              rootEl.insertBefore(cloneEl, dragEl);
            }
            _this._hideClone();
            _dispatchEvent({
              sortable: _this,
              name: "clone"
            });
          });
          !fallback && toggleClass(dragEl, options.dragClass, true);
          if (fallback) {
            ignoreNextClick = true;
            _this._loopId = setInterval(_this._emulateDragOver, 50);
          } else {
            off(document, "mouseup", _this._onDrop);
            off(document, "touchend", _this._onDrop);
            off(document, "touchcancel", _this._onDrop);
            if (dataTransfer) {
              dataTransfer.effectAllowed = "move";
              options.setData && options.setData.call(_this, dataTransfer, dragEl);
            }
            on$1(document, "drop", _this);
            css(dragEl, "transform", "translateZ(0)");
          }
          awaitingDragStarted = true;
          _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
          on$1(document, "selectstart", _this);
          moved = true;
          if (Safari) {
            css(document.body, "user-select", "none");
          }
        },
        _onDragOver: function _onDragOver(evt) {
          var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
          if (_silent)
            return;
          function dragOverEvent(name, extra) {
            pluginEvent(name, _this, _objectSpread2({
              evt,
              isOwner,
              axis: vertical ? "vertical" : "horizontal",
              revert,
              dragRect,
              targetRect,
              canSort,
              fromSortable,
              target,
              completed,
              onMove: function onMove(target2, after2) {
                return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
              },
              changed
            }, extra));
          }
          function capture() {
            dragOverEvent("dragOverAnimationCapture");
            _this.captureAnimationState();
            if (_this !== fromSortable) {
              fromSortable.captureAnimationState();
            }
          }
          function completed(insertion) {
            dragOverEvent("dragOverCompleted", {
              insertion
            });
            if (insertion) {
              if (isOwner) {
                activeSortable._hideClone();
              } else {
                activeSortable._showClone(_this);
              }
              if (_this !== fromSortable) {
                toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
                toggleClass(dragEl, options.ghostClass, true);
              }
              if (putSortable !== _this && _this !== Sortable.active) {
                putSortable = _this;
              } else if (_this === Sortable.active && putSortable) {
                putSortable = null;
              }
              if (fromSortable === _this) {
                _this._ignoreWhileAnimating = target;
              }
              _this.animateAll(function() {
                dragOverEvent("dragOverAnimationComplete");
                _this._ignoreWhileAnimating = null;
              });
              if (_this !== fromSortable) {
                fromSortable.animateAll();
                fromSortable._ignoreWhileAnimating = null;
              }
            }
            if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
              lastTarget = null;
            }
            if (!options.dragoverBubble && !evt.rootEl && target !== document) {
              dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
              !insertion && nearestEmptyInsertDetectEvent(evt);
            }
            !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
            return completedFired = true;
          }
          function changed() {
            newIndex = index$1(dragEl);
            newDraggableIndex = index$1(dragEl, options.draggable);
            _dispatchEvent({
              sortable: _this,
              name: "change",
              toEl: el,
              newIndex,
              newDraggableIndex,
              originalEvent: evt
            });
          }
          if (evt.preventDefault !== void 0) {
            evt.cancelable && evt.preventDefault();
          }
          target = closest(target, options.draggable, el, true);
          dragOverEvent("dragOver");
          if (Sortable.eventCanceled)
            return completedFired;
          if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
            return completed(false);
          }
          ignoreNextClick = false;
          if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
            vertical = this._getDirection(evt, target) === "vertical";
            dragRect = getRect(dragEl);
            dragOverEvent("dragOverValid");
            if (Sortable.eventCanceled)
              return completedFired;
            if (revert) {
              parentEl = rootEl;
              capture();
              this._hideClone();
              dragOverEvent("revert");
              if (!Sortable.eventCanceled) {
                if (nextEl) {
                  rootEl.insertBefore(dragEl, nextEl);
                } else {
                  rootEl.appendChild(dragEl);
                }
              }
              return completed(true);
            }
            var elLastChild = lastChild(el, options.draggable);
            if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
              if (elLastChild === dragEl) {
                return completed(false);
              }
              if (elLastChild && el === evt.target) {
                target = elLastChild;
              }
              if (target) {
                targetRect = getRect(target);
              }
              if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
                capture();
                el.appendChild(dragEl);
                parentEl = el;
                changed();
                return completed(true);
              }
            } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
              var firstChild = getChild(el, 0, options, true);
              if (firstChild === dragEl) {
                return completed(false);
              }
              target = firstChild;
              targetRect = getRect(target);
              if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
                capture();
                el.insertBefore(dragEl, firstChild);
                parentEl = el;
                changed();
                return completed(true);
              }
            } else if (target.parentNode === el) {
              targetRect = getRect(target);
              var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
              if (lastTarget !== target) {
                targetBeforeFirstSwap = targetRect[side1];
                pastFirstInvertThresh = false;
                isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
              }
              direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
              var sibling;
              if (direction !== 0) {
                var dragIndex = index$1(dragEl);
                do {
                  dragIndex -= direction;
                  sibling = parentEl.children[dragIndex];
                } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
              }
              if (direction === 0 || sibling === target) {
                return completed(false);
              }
              lastTarget = target;
              lastDirection = direction;
              var nextSibling = target.nextElementSibling, after = false;
              after = direction === 1;
              var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
              if (moveVector !== false) {
                if (moveVector === 1 || moveVector === -1) {
                  after = moveVector === 1;
                }
                _silent = true;
                setTimeout(_unsilent, 30);
                capture();
                if (after && !nextSibling) {
                  el.appendChild(dragEl);
                } else {
                  target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                }
                if (scrolledPastTop) {
                  scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
                }
                parentEl = dragEl.parentNode;
                if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
                  targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
                }
                changed();
                return completed(true);
              }
            }
            if (el.contains(dragEl)) {
              return completed(false);
            }
          }
          return false;
        },
        _ignoreWhileAnimating: null,
        _offMoveEvents: function _offMoveEvents() {
          off(document, "mousemove", this._onTouchMove);
          off(document, "touchmove", this._onTouchMove);
          off(document, "pointermove", this._onTouchMove);
          off(document, "dragover", nearestEmptyInsertDetectEvent);
          off(document, "mousemove", nearestEmptyInsertDetectEvent);
          off(document, "touchmove", nearestEmptyInsertDetectEvent);
        },
        _offUpEvents: function _offUpEvents() {
          var ownerDocument = this.el.ownerDocument;
          off(ownerDocument, "mouseup", this._onDrop);
          off(ownerDocument, "touchend", this._onDrop);
          off(ownerDocument, "pointerup", this._onDrop);
          off(ownerDocument, "touchcancel", this._onDrop);
          off(document, "selectstart", this);
        },
        _onDrop: function _onDrop(evt) {
          var el = this.el, options = this.options;
          newIndex = index$1(dragEl);
          newDraggableIndex = index$1(dragEl, options.draggable);
          pluginEvent("drop", this, {
            evt
          });
          parentEl = dragEl && dragEl.parentNode;
          newIndex = index$1(dragEl);
          newDraggableIndex = index$1(dragEl, options.draggable);
          if (Sortable.eventCanceled) {
            this._nulling();
            return;
          }
          awaitingDragStarted = false;
          isCircumstantialInvert = false;
          pastFirstInvertThresh = false;
          clearInterval(this._loopId);
          clearTimeout(this._dragStartTimer);
          _cancelNextTick(this.cloneId);
          _cancelNextTick(this._dragStartId);
          if (this.nativeDraggable) {
            off(document, "drop", this);
            off(el, "dragstart", this._onDragStart);
          }
          this._offMoveEvents();
          this._offUpEvents();
          if (Safari) {
            css(document.body, "user-select", "");
          }
          css(dragEl, "transform", "");
          if (evt) {
            if (moved) {
              evt.cancelable && evt.preventDefault();
              !options.dropBubble && evt.stopPropagation();
            }
            ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
            if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
              cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
            }
            if (dragEl) {
              if (this.nativeDraggable) {
                off(dragEl, "dragend", this);
              }
              _disableDraggable(dragEl);
              dragEl.style["will-change"] = "";
              if (moved && !awaitingDragStarted) {
                toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
              }
              toggleClass(dragEl, this.options.chosenClass, false);
              _dispatchEvent({
                sortable: this,
                name: "unchoose",
                toEl: parentEl,
                newIndex: null,
                newDraggableIndex: null,
                originalEvent: evt
              });
              if (rootEl !== parentEl) {
                if (newIndex >= 0) {
                  _dispatchEvent({
                    rootEl: parentEl,
                    name: "add",
                    toEl: parentEl,
                    fromEl: rootEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    sortable: this,
                    name: "remove",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    rootEl: parentEl,
                    name: "sort",
                    toEl: parentEl,
                    fromEl: rootEl,
                    originalEvent: evt
                  });
                  _dispatchEvent({
                    sortable: this,
                    name: "sort",
                    toEl: parentEl,
                    originalEvent: evt
                  });
                }
                putSortable && putSortable.save();
              } else {
                if (newIndex !== oldIndex) {
                  if (newIndex >= 0) {
                    _dispatchEvent({
                      sortable: this,
                      name: "update",
                      toEl: parentEl,
                      originalEvent: evt
                    });
                    _dispatchEvent({
                      sortable: this,
                      name: "sort",
                      toEl: parentEl,
                      originalEvent: evt
                    });
                  }
                }
              }
              if (Sortable.active) {
                if (newIndex == null || newIndex === -1) {
                  newIndex = oldIndex;
                  newDraggableIndex = oldDraggableIndex;
                }
                _dispatchEvent({
                  sortable: this,
                  name: "end",
                  toEl: parentEl,
                  originalEvent: evt
                });
                this.save();
              }
            }
          }
          this._nulling();
        },
        _nulling: function _nulling() {
          pluginEvent("nulling", this);
          rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
          savedInputChecked.forEach(function(el) {
            el.checked = true;
          });
          savedInputChecked.length = lastDx = lastDy = 0;
        },
        handleEvent: function handleEvent(evt) {
          switch (evt.type) {
            case "drop":
            case "dragend":
              this._onDrop(evt);
              break;
            case "dragenter":
            case "dragover":
              if (dragEl) {
                this._onDragOver(evt);
                _globalDragOver(evt);
              }
              break;
            case "selectstart":
              evt.preventDefault();
              break;
          }
        },
        toArray: function toArray() {
          var order2 = [], el, children = this.el.children, i2 = 0, n2 = children.length, options = this.options;
          for (; i2 < n2; i2++) {
            el = children[i2];
            if (closest(el, options.draggable, this.el, false)) {
              order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
            }
          }
          return order2;
        },
        sort: function sort(order2, useAnimation) {
          var items = {}, rootEl2 = this.el;
          this.toArray().forEach(function(id, i2) {
            var el = rootEl2.children[i2];
            if (closest(el, this.options.draggable, rootEl2, false)) {
              items[id] = el;
            }
          }, this);
          useAnimation && this.captureAnimationState();
          order2.forEach(function(id) {
            if (items[id]) {
              rootEl2.removeChild(items[id]);
              rootEl2.appendChild(items[id]);
            }
          });
          useAnimation && this.animateAll();
        },
        save: function save() {
          var store2 = this.options.store;
          store2 && store2.set && store2.set(this);
        },
        closest: function closest$1(el, selector) {
          return closest(el, selector || this.options.draggable, this.el, false);
        },
        option: function option(name, value) {
          var options = this.options;
          if (value === void 0) {
            return options[name];
          } else {
            var modifiedValue = PluginManager.modifyOption(this, name, value);
            if (typeof modifiedValue !== "undefined") {
              options[name] = modifiedValue;
            } else {
              options[name] = value;
            }
            if (name === "group") {
              _prepareGroup(options);
            }
          }
        },
        destroy: function destroy() {
          pluginEvent("destroy", this);
          var el = this.el;
          el[expando] = null;
          off(el, "mousedown", this._onTapStart);
          off(el, "touchstart", this._onTapStart);
          off(el, "pointerdown", this._onTapStart);
          if (this.nativeDraggable) {
            off(el, "dragover", this);
            off(el, "dragenter", this);
          }
          Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
            el2.removeAttribute("draggable");
          });
          this._onDrop();
          this._disableDelayedDragEvents();
          sortables.splice(sortables.indexOf(this.el), 1);
          this.el = el = null;
        },
        _hideClone: function _hideClone() {
          if (!cloneHidden) {
            pluginEvent("hideClone", this);
            if (Sortable.eventCanceled)
              return;
            css(cloneEl, "display", "none");
            if (this.options.removeCloneOnHide && cloneEl.parentNode) {
              cloneEl.parentNode.removeChild(cloneEl);
            }
            cloneHidden = true;
          }
        },
        _showClone: function _showClone(putSortable2) {
          if (putSortable2.lastPutMode !== "clone") {
            this._hideClone();
            return;
          }
          if (cloneHidden) {
            pluginEvent("showClone", this);
            if (Sortable.eventCanceled)
              return;
            if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
              rootEl.insertBefore(cloneEl, dragEl);
            } else if (nextEl) {
              rootEl.insertBefore(cloneEl, nextEl);
            } else {
              rootEl.appendChild(cloneEl);
            }
            if (this.options.group.revertClone) {
              this.animate(dragEl, cloneEl);
            }
            css(cloneEl, "display", "");
            cloneHidden = false;
          }
        }
      };
      function _globalDragOver(evt) {
        if (evt.dataTransfer) {
          evt.dataTransfer.dropEffect = "move";
        }
        evt.cancelable && evt.preventDefault();
      }
      function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
        var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
        if (window.CustomEvent && !IE11OrLess && !Edge) {
          evt = new CustomEvent("move", {
            bubbles: true,
            cancelable: true
          });
        } else {
          evt = document.createEvent("Event");
          evt.initEvent("move", true, true);
        }
        evt.to = toEl;
        evt.from = fromEl;
        evt.dragged = dragEl2;
        evt.draggedRect = dragRect;
        evt.related = targetEl || toEl;
        evt.relatedRect = targetRect || getRect(toEl);
        evt.willInsertAfter = willInsertAfter;
        evt.originalEvent = originalEvent;
        fromEl.dispatchEvent(evt);
        if (onMoveFn) {
          retVal = onMoveFn.call(sortable, evt, originalEvent);
        }
        return retVal;
      }
      function _disableDraggable(el) {
        el.draggable = false;
      }
      function _unsilent() {
        _silent = false;
      }
      function _ghostIsFirst(evt, vertical, sortable) {
        var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
        var spacer = 10;
        return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
      }
      function _ghostIsLast(evt, vertical, sortable) {
        var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
        var spacer = 10;
        return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
      }
      function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
        var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
        if (!invertSwap) {
          if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
            if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
              pastFirstInvertThresh = true;
            }
            if (!pastFirstInvertThresh) {
              if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
                return -lastDirection;
              }
            } else {
              invert = true;
            }
          } else {
            if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
              return _getInsertDirection(target);
            }
          }
        }
        invert = invert || invertSwap;
        if (invert) {
          if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
            return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
          }
        }
        return 0;
      }
      function _getInsertDirection(target) {
        if (index$1(dragEl) < index$1(target)) {
          return 1;
        } else {
          return -1;
        }
      }
      function _generateId(el) {
        var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
        while (i2--) {
          sum += str.charCodeAt(i2);
        }
        return sum.toString(36);
      }
      function _saveInputCheckedState(root2) {
        savedInputChecked.length = 0;
        var inputs = root2.getElementsByTagName("input");
        var idx = inputs.length;
        while (idx--) {
          var el = inputs[idx];
          el.checked && savedInputChecked.push(el);
        }
      }
      function _nextTick(fn2) {
        return setTimeout(fn2, 0);
      }
      function _cancelNextTick(id) {
        return clearTimeout(id);
      }
      if (documentExists) {
        on$1(document, "touchmove", function(evt) {
          if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
            evt.preventDefault();
          }
        });
      }
      Sortable.utils = {
        on: on$1,
        off,
        css,
        find,
        is: function is(el, selector) {
          return !!closest(el, selector, el, false);
        },
        extend,
        throttle,
        closest,
        toggleClass,
        clone,
        index: index$1,
        nextTick: _nextTick,
        cancelNextTick: _cancelNextTick,
        detectDirection: _detectDirection,
        getChild
      };
      Sortable.get = function(element) {
        return element[expando];
      };
      Sortable.mount = function() {
        for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
          plugins2[_key] = arguments[_key];
        }
        if (plugins2[0].constructor === Array)
          plugins2 = plugins2[0];
        plugins2.forEach(function(plugin) {
          if (!plugin.prototype || !plugin.prototype.constructor) {
            throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
          }
          if (plugin.utils)
            Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
          PluginManager.mount(plugin);
        });
      };
      Sortable.create = function(el, options) {
        return new Sortable(el, options);
      };
      Sortable.version = version;
      var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
      function AutoScrollPlugin() {
        function AutoScroll() {
          this.defaults = {
            scroll: true,
            forceAutoScrollFallback: false,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            bubbleScroll: true
          };
          for (var fn2 in this) {
            if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
              this[fn2] = this[fn2].bind(this);
            }
          }
        }
        AutoScroll.prototype = {
          dragStarted: function dragStarted(_ref) {
            var originalEvent = _ref.originalEvent;
            if (this.sortable.nativeDraggable) {
              on$1(document, "dragover", this._handleAutoScroll);
            } else {
              if (this.options.supportPointer) {
                on$1(document, "pointermove", this._handleFallbackAutoScroll);
              } else if (originalEvent.touches) {
                on$1(document, "touchmove", this._handleFallbackAutoScroll);
              } else {
                on$1(document, "mousemove", this._handleFallbackAutoScroll);
              }
            }
          },
          dragOverCompleted: function dragOverCompleted(_ref2) {
            var originalEvent = _ref2.originalEvent;
            if (!this.options.dragOverBubble && !originalEvent.rootEl) {
              this._handleAutoScroll(originalEvent);
            }
          },
          drop: function drop2() {
            if (this.sortable.nativeDraggable) {
              off(document, "dragover", this._handleAutoScroll);
            } else {
              off(document, "pointermove", this._handleFallbackAutoScroll);
              off(document, "touchmove", this._handleFallbackAutoScroll);
              off(document, "mousemove", this._handleFallbackAutoScroll);
            }
            clearPointerElemChangedInterval();
            clearAutoScrolls();
            cancelThrottle();
          },
          nulling: function nulling() {
            touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
            autoScrolls.length = 0;
          },
          _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
            this._handleAutoScroll(evt, true);
          },
          _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
            var _this = this;
            var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
            touchEvt$1 = evt;
            if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
              autoScroll(evt, this.options, elem, fallback);
              var ogElemScroller = getParentAutoScrollElement(elem, true);
              if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
                pointerElemChangedInterval && clearPointerElemChangedInterval();
                pointerElemChangedInterval = setInterval(function() {
                  var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
                  if (newElem !== ogElemScroller) {
                    ogElemScroller = newElem;
                    clearAutoScrolls();
                  }
                  autoScroll(evt, _this.options, newElem, fallback);
                }, 10);
                lastAutoScrollX = x2;
                lastAutoScrollY = y2;
              }
            } else {
              if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
                clearAutoScrolls();
                return;
              }
              autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
            }
          }
        };
        return _extends(AutoScroll, {
          pluginName: "scroll",
          initializeByDefault: true
        });
      }
      function clearAutoScrolls() {
        autoScrolls.forEach(function(autoScroll2) {
          clearInterval(autoScroll2.pid);
        });
        autoScrolls = [];
      }
      function clearPointerElemChangedInterval() {
        clearInterval(pointerElemChangedInterval);
      }
      var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
        if (!options.scroll)
          return;
        var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
        var scrollThisInstance = false, scrollCustomFn;
        if (scrollRootEl !== rootEl2) {
          scrollRootEl = rootEl2;
          clearAutoScrolls();
          scrollEl = options.scroll;
          scrollCustomFn = options.scrollFn;
          if (scrollEl === true) {
            scrollEl = getParentAutoScrollElement(rootEl2, true);
          }
        }
        var layersOut = 0;
        var currentParent = scrollEl;
        do {
          var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
          if (el === winScroller) {
            canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
            canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
          } else {
            canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
            canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
          }
          var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
          var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
          if (!autoScrolls[layersOut]) {
            for (var i2 = 0; i2 <= layersOut; i2++) {
              if (!autoScrolls[i2]) {
                autoScrolls[i2] = {};
              }
            }
          }
          if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
            autoScrolls[layersOut].el = el;
            autoScrolls[layersOut].vx = vx;
            autoScrolls[layersOut].vy = vy;
            clearInterval(autoScrolls[layersOut].pid);
            if (vx != 0 || vy != 0) {
              scrollThisInstance = true;
              autoScrolls[layersOut].pid = setInterval(function() {
                if (isFallback && this.layer === 0) {
                  Sortable.active._onTouchMove(touchEvt$1);
                }
                var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
                var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
                if (typeof scrollCustomFn === "function") {
                  if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                    return;
                  }
                }
                scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
              }.bind({
                layer: layersOut
              }), 24);
            }
          }
          layersOut++;
        } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
        scrolling = scrollThisInstance;
      }, 30);
      var drop = function drop2(_ref) {
        var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
        if (!originalEvent)
          return;
        var toSortable = putSortable2 || activeSortable;
        hideGhostForTarget();
        var touch2 = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
        var target = document.elementFromPoint(touch2.clientX, touch2.clientY);
        unhideGhostForTarget();
        if (toSortable && !toSortable.el.contains(target)) {
          dispatchSortableEvent("spill");
          this.onSpill({
            dragEl: dragEl2,
            putSortable: putSortable2
          });
        }
      };
      function Revert() {
      }
      Revert.prototype = {
        startIndex: null,
        dragStart: function dragStart(_ref2) {
          var oldDraggableIndex2 = _ref2.oldDraggableIndex;
          this.startIndex = oldDraggableIndex2;
        },
        onSpill: function onSpill(_ref3) {
          var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
          this.sortable.captureAnimationState();
          if (putSortable2) {
            putSortable2.captureAnimationState();
          }
          var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
          if (nextSibling) {
            this.sortable.el.insertBefore(dragEl2, nextSibling);
          } else {
            this.sortable.el.appendChild(dragEl2);
          }
          this.sortable.animateAll();
          if (putSortable2) {
            putSortable2.animateAll();
          }
        },
        drop
      };
      _extends(Revert, {
        pluginName: "revertOnSpill"
      });
      function Remove() {
      }
      Remove.prototype = {
        onSpill: function onSpill(_ref4) {
          var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
          var parentSortable = putSortable2 || this.sortable;
          parentSortable.captureAnimationState();
          dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
          parentSortable.animateAll();
        },
        drop
      };
      _extends(Remove, {
        pluginName: "removeOnSpill"
      });
      Sortable.mount(new AutoScrollPlugin());
      Sortable.mount(Remove, Revert);
      function removeNode(node) {
        if (node.parentElement !== null) {
          node.parentElement.removeChild(node);
        }
      }
      function insertNodeAt(fatherNode, node, position) {
        const refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
        fatherNode.insertBefore(node, refNode);
      }
      function getConsole() {
        if (typeof window !== "undefined") {
          return window.console;
        }
        return global.console;
      }
      const console$1 = getConsole();
      function cached(fn2) {
        const cache = Object.create(null);
        return function cachedFn(str) {
          const hit = cache[str];
          return hit || (cache[str] = fn2(str));
        };
      }
      const regex = /-(\w)/g;
      const camelize = cached((str) => str.replace(regex, (_2, c2) => c2.toUpperCase()));
      const manageAndEmit$1 = ["Start", "Add", "Remove", "Update", "End"];
      const emit$1 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
      const manage$1 = ["Move"];
      const eventHandlerNames = [manage$1, manageAndEmit$1, emit$1].flatMap((events2) => events2).map((evt) => `on${evt}`);
      const events = {
        manage: manage$1,
        manageAndEmit: manageAndEmit$1,
        emit: emit$1
      };
      function isReadOnly(eventName) {
        return eventHandlerNames.indexOf(eventName) !== -1;
      }
      const tags = [
        "a",
        "abbr",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "base",
        "bdi",
        "bdo",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "cite",
        "code",
        "col",
        "colgroup",
        "data",
        "datalist",
        "dd",
        "del",
        "details",
        "dfn",
        "dialog",
        "div",
        "dl",
        "dt",
        "em",
        "embed",
        "fieldset",
        "figcaption",
        "figure",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "iframe",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "link",
        "main",
        "map",
        "mark",
        "math",
        "menu",
        "menuitem",
        "meta",
        "meter",
        "nav",
        "noscript",
        "object",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "param",
        "picture",
        "pre",
        "progress",
        "q",
        "rb",
        "rp",
        "rt",
        "rtc",
        "ruby",
        "s",
        "samp",
        "script",
        "section",
        "select",
        "slot",
        "small",
        "source",
        "span",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "svg",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "title",
        "tr",
        "track",
        "u",
        "ul",
        "var",
        "video",
        "wbr"
      ];
      function isHtmlTag(name) {
        return tags.includes(name);
      }
      function isTransition(name) {
        return ["transition-group", "TransitionGroup"].includes(name);
      }
      function isHtmlAttribute(value) {
        return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
      }
      function project(entries) {
        return entries.reduce((res, [key, value]) => {
          res[key] = value;
          return res;
        }, {});
      }
      function getComponentAttributes({ $attrs, componentData = {} }) {
        const attributes = project(Object.entries($attrs).filter(([key, _2]) => isHtmlAttribute(key)));
        return __spreadValues(__spreadValues({}, attributes), componentData);
      }
      function createSortableOption({ $attrs, callBackBuilder }) {
        const options = project(getValidSortableEntries($attrs));
        Object.entries(callBackBuilder).forEach(([eventType, eventBuilder]) => {
          events[eventType].forEach((event) => {
            options[`on${event}`] = eventBuilder(event);
          });
        });
        const draggable = `[data-draggable]${options.draggable || ""}`;
        return __spreadProps(__spreadValues({}, options), {
          draggable
        });
      }
      function getValidSortableEntries(value) {
        return Object.entries(value).filter(([key, _2]) => !isHtmlAttribute(key)).map(([key, value2]) => [camelize(key), value2]).filter(([key, _2]) => !isReadOnly(key));
      }
      const getHtmlElementFromNode = ({ el }) => el;
      const addContext = (domElement, context) => domElement.__draggable_context = context;
      const getContext = (domElement) => domElement.__draggable_context;
      class ComponentStructure {
        constructor({
          nodes: { header, default: defaultNodes, footer },
          root: root2,
          realList
        }) {
          this.defaultNodes = defaultNodes;
          this.children = [...header, ...defaultNodes, ...footer];
          this.externalComponent = root2.externalComponent;
          this.rootTransition = root2.transition;
          this.tag = root2.tag;
          this.realList = realList;
        }
        get _isRootComponent() {
          return this.externalComponent || this.rootTransition;
        }
        render(h2, attributes) {
          const { tag, children, _isRootComponent } = this;
          const option = !_isRootComponent ? children : { default: () => children };
          return h2(tag, attributes, option);
        }
        updated() {
          const { defaultNodes, realList } = this;
          defaultNodes.forEach((node, index2) => {
            addContext(getHtmlElementFromNode(node), {
              element: realList[index2],
              index: index2
            });
          });
        }
        getUnderlyingVm(domElement) {
          return getContext(domElement);
        }
        getVmIndexFromDomIndex(domIndex, element) {
          const { defaultNodes } = this;
          const { length } = defaultNodes;
          const domChildren = element.children;
          const domElement = domChildren.item(domIndex);
          if (domElement === null) {
            return length;
          }
          const context = getContext(domElement);
          if (context) {
            return context.index;
          }
          if (length === 0) {
            return 0;
          }
          const firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
          const indexFirstDomListElement = [...domChildren].findIndex((element2) => element2 === firstDomListElement);
          return domIndex < indexFirstDomListElement ? 0 : length;
        }
      }
      function getSlot(slots, key) {
        const slotValue = slots[key];
        return slotValue ? slotValue() : [];
      }
      function computeNodes({ $slots, realList, getKey }) {
        const normalizedList = realList || [];
        const [header, footer] = ["header", "footer"].map((name) => getSlot($slots, name));
        const { item } = $slots;
        if (!item) {
          throw new Error("draggable element must have an item slot");
        }
        const defaultNodes = normalizedList.flatMap((element, index2) => item({ element, index: index2 }).map((node) => {
          node.key = getKey(element);
          node.props = __spreadProps(__spreadValues({}, node.props || {}), { "data-draggable": true });
          return node;
        }));
        if (defaultNodes.length !== normalizedList.length) {
          throw new Error("Item slot must have only one child");
        }
        return {
          header,
          footer,
          default: defaultNodes
        };
      }
      function getRootInformation(tag) {
        const transition = isTransition(tag);
        const externalComponent = !isHtmlTag(tag) && !transition;
        return {
          transition,
          externalComponent,
          tag: externalComponent ? resolveComponent(tag) : transition ? TransitionGroup : tag
        };
      }
      function computeComponentStructure({ $slots, tag, realList, getKey }) {
        const nodes = computeNodes({ $slots, realList, getKey });
        const root2 = getRootInformation(tag);
        return new ComponentStructure({ nodes, root: root2, realList });
      }
      function emit(evtName, evtData) {
        nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
      }
      function manage(evtName) {
        return (evtData, originalElement) => {
          if (this.realList !== null) {
            return this[`onDrag${evtName}`](evtData, originalElement);
          }
        };
      }
      function manageAndEmit(evtName) {
        const delegateCallBack = manage.call(this, evtName);
        return (evtData, originalElement) => {
          delegateCallBack.call(this, evtData, originalElement);
          emit.call(this, evtName, evtData);
        };
      }
      let draggingElement = null;
      const props = {
        list: {
          type: Array,
          required: false,
          default: null
        },
        modelValue: {
          type: Array,
          required: false,
          default: null
        },
        itemKey: {
          type: [String, Function],
          required: true
        },
        clone: {
          type: Function,
          default: (original) => {
            return original;
          }
        },
        tag: {
          type: String,
          default: "div"
        },
        move: {
          type: Function,
          default: null
        },
        componentData: {
          type: Object,
          required: false,
          default: null
        }
      };
      const emits = [
        "update:modelValue",
        "change",
        ...[...events.manageAndEmit, ...events.emit].map((evt) => evt.toLowerCase())
      ];
      const draggableComponent = defineComponent({
        name: "draggable",
        inheritAttrs: false,
        props,
        emits,
        data() {
          return {
            error: false
          };
        },
        render() {
          try {
            this.error = false;
            const { $slots, $attrs, tag, componentData, realList, getKey } = this;
            const componentStructure = computeComponentStructure({
              $slots,
              tag,
              realList,
              getKey
            });
            this.componentStructure = componentStructure;
            const attributes = getComponentAttributes({ $attrs, componentData });
            return componentStructure.render(h$5, attributes);
          } catch (err) {
            this.error = true;
            return h$5("pre", { style: { color: "red" } }, err.stack);
          }
        },
        created() {
          if (this.list !== null && this.modelValue !== null) {
            console$1.error("modelValue and list props are mutually exclusive! Please set one or another.");
          }
        },
        mounted() {
          if (this.error) {
            return;
          }
          const { $attrs, $el, componentStructure } = this;
          componentStructure.updated();
          const sortableOptions = createSortableOption({
            $attrs,
            callBackBuilder: {
              manageAndEmit: (event) => manageAndEmit.call(this, event),
              emit: (event) => emit.bind(this, event),
              manage: (event) => manage.call(this, event)
            }
          });
          const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
          this._sortable = new Sortable(targetDomElement, sortableOptions);
          this.targetDomElement = targetDomElement;
          targetDomElement.__draggable_component__ = this;
        },
        updated() {
          this.componentStructure.updated();
        },
        beforeUnmount() {
          if (this._sortable !== void 0)
            this._sortable.destroy();
        },
        computed: {
          realList() {
            const { list } = this;
            return list ? list : this.modelValue;
          },
          getKey() {
            const { itemKey } = this;
            if (typeof itemKey === "function") {
              return itemKey;
            }
            return (element) => element[itemKey];
          }
        },
        watch: {
          $attrs: {
            handler(newOptionValue) {
              const { _sortable } = this;
              if (!_sortable)
                return;
              getValidSortableEntries(newOptionValue).forEach(([key, value]) => {
                _sortable.option(key, value);
              });
            },
            deep: true
          }
        },
        methods: {
          getUnderlyingVm(domElement) {
            return this.componentStructure.getUnderlyingVm(domElement) || null;
          },
          getUnderlyingPotencialDraggableComponent(htmElement) {
            return htmElement.__draggable_component__;
          },
          emitChanges(evt) {
            nextTick(() => this.$emit("change", evt));
          },
          alterList(onList) {
            if (this.list) {
              onList(this.list);
              return;
            }
            const newList = [...this.modelValue];
            onList(newList);
            this.$emit("update:modelValue", newList);
          },
          spliceList() {
            const spliceList = (list) => list.splice(...arguments);
            this.alterList(spliceList);
          },
          updatePosition(oldIndex2, newIndex2) {
            const updatePosition = (list) => list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
            this.alterList(updatePosition);
          },
          getRelatedContextFromMoveEvent({ to: to2, related }) {
            const component = this.getUnderlyingPotencialDraggableComponent(to2);
            if (!component) {
              return { component };
            }
            const list = component.realList;
            const context = { list, component };
            if (to2 !== related && list) {
              const destination = component.getUnderlyingVm(related) || {};
              return __spreadValues(__spreadValues({}, destination), context);
            }
            return context;
          },
          getVmIndexFromDomIndex(domIndex) {
            return this.componentStructure.getVmIndexFromDomIndex(domIndex, this.targetDomElement);
          },
          onDragStart(evt) {
            this.context = this.getUnderlyingVm(evt.item);
            evt.item._underlying_vm_ = this.clone(this.context.element);
            draggingElement = evt.item;
          },
          onDragAdd(evt) {
            const element = evt.item._underlying_vm_;
            if (element === void 0) {
              return;
            }
            removeNode(evt.item);
            const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
            this.spliceList(newIndex2, 0, element);
            const added = { element, newIndex: newIndex2 };
            this.emitChanges({ added });
          },
          onDragRemove(evt) {
            insertNodeAt(this.$el, evt.item, evt.oldIndex);
            if (evt.pullMode === "clone") {
              removeNode(evt.clone);
              return;
            }
            const { index: oldIndex2, element } = this.context;
            this.spliceList(oldIndex2, 1);
            const removed = { element, oldIndex: oldIndex2 };
            this.emitChanges({ removed });
          },
          onDragUpdate(evt) {
            removeNode(evt.item);
            insertNodeAt(evt.from, evt.item, evt.oldIndex);
            const oldIndex2 = this.context.index;
            const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
            this.updatePosition(oldIndex2, newIndex2);
            const moved2 = { element: this.context.element, oldIndex: oldIndex2, newIndex: newIndex2 };
            this.emitChanges({ moved: moved2 });
          },
          computeFutureIndex(relatedContext, evt) {
            if (!relatedContext.element) {
              return 0;
            }
            const domChildren = [...evt.to.children].filter((el) => el.style["display"] !== "none");
            const currentDomIndex = domChildren.indexOf(evt.related);
            const currentIndex = relatedContext.component.getVmIndexFromDomIndex(currentDomIndex);
            const draggedInList = domChildren.indexOf(draggingElement) !== -1;
            return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
          },
          onDragMove(evt, originalEvent) {
            const { move, realList } = this;
            if (!move || !realList) {
              return true;
            }
            const relatedContext = this.getRelatedContextFromMoveEvent(evt);
            const futureIndex = this.computeFutureIndex(relatedContext, evt);
            const draggedContext = __spreadProps(__spreadValues({}, this.context), {
              futureIndex
            });
            const sendEvent = __spreadProps(__spreadValues({}, evt), {
              relatedContext,
              draggedContext
            });
            return move(sendEvent, originalEvent);
          },
          onDragEnd() {
            draggingElement = null;
          }
        }
      });
      var KanbanCards_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _withScopeId$9 = (n2) => (pushScopeId("data-v-50651a6c"), n2 = n2(), popScopeId(), n2);
      const _hoisted_3$a = { class: "card-menu" };
      const _hoisted_4$8 = ["href"];
      const _hoisted_5$7 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-link" }, null, -1));
      const _hoisted_6$4 = [
        _hoisted_5$7
      ];
      const _hoisted_7$2 = ["href"];
      const _hoisted_8$3 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-edit" }, null, -1));
      const _hoisted_9$2 = [
        _hoisted_8$3
      ];
      const _hoisted_10$2 = {
        key: 0,
        class: "mt-1"
      };
      const __default__$4 = {
        name: "KanbanCards"
      };
      const _sfc_main$g = /* @__PURE__ */ Object.assign(__default__$4, {
        props: {
          cardIds: {
            type: Array,
            default() {
              return [];
            }
          },
          rowId: {
            type: Number
          },
          rowValue: [Number, String],
          columnValue: [Number, String],
          cellId: {
            type: Number
          }
        },
        emits: ["editCard"],
        setup(__props, { emit: emit2 }) {
          const props2 = __props;
          const toast = useToast();
          const dragging = ref(false);
          const getCards = computed(() => store.getters.getCards(props2.cardIds));
          const getTrackerItemEditLink = computed(() => (id) => `tiki-tracker-update_item?trackerId=${store.getters.getTrackerId}&itemId=${id}`);
          const getTrackerItemLink = computed(() => (id) => `tiki-view_tracker_item.php?itemId=${id}`);
          const startDragging = () => dragging.value = true;
          const endDragging = () => setTimeout(() => dragging.value = false, 0);
          const checkMove = (event) => {
            const ability = defineAbilityFor(store.getters.getRules);
            const canUpdate = ability.can("update", z$2("Tracker_Item", { itemId: event.draggedContext.element.id }), store.getters.getColumnField);
            return canUpdate;
          };
          const handleChange = (event) => {
            if (event.moved) {
              store.dispatch("moveCard", {
                oldIndex: event.moved.oldIndex,
                newIndex: event.moved.newIndex,
                element: event.moved.element,
                rowId: props2.rowId,
                cellId: props2.cellId
              });
              let sortOrder = store.getters.getCard(event.moved.element.id).sortOrder;
              setItem(event.moved.element.id, sortOrder);
            } else if (event.added) {
              store.dispatch("addCard", {
                newIndex: event.added.newIndex,
                element: event.added.element,
                rowId: props2.rowId,
                cellId: props2.cellId
              });
              let sortOrder = store.getters.getCard(event.added.element.id).sortOrder;
              setItem(event.added.element.id, sortOrder);
            } else if (event.removed) {
              store.dispatch("removeCard", {
                oldIndex: event.removed.oldIndex,
                element: event.removed.element,
                rowId: props2.rowId,
                cellId: props2.cellId
              });
            }
          };
          const setItem = (itemId, newIndex2) => {
            kanban.setItem({ trackerId: store.getters.getTrackerId, itemId }, {
              fields: {
                [store.getters.getSwimlaneField]: props2.rowValue,
                [store.getters.getXaxisField]: props2.columnValue,
                [store.getters.getYaxisField]: newIndex2
              }
            }).then((res) => {
            }).catch((err) => {
              if (!err.response)
                return;
              const { code, errortitle, message } = err.response.data;
              const msg = `Code: ${code} - ${message}`;
              toast.error(msg);
            });
          };
          return (_ctx, _cache) => {
            return openBlock(), createBlock(unref(draggableComponent), {
              list: unref(getCards),
              group: "cards",
              "item-key": "id",
              class: "container-cards",
              chosenClass: "chosen-card",
              ghostClass: "ghost-card",
              dragClass: "dragging-card",
              filter: "textarea",
              preventOnFilter: false,
              onChange: handleChange,
              onStart: startDragging,
              onEnd: endDragging,
              move: checkMove,
              fallbackTolerance: 3,
              forceFallback: true,
              animation: 150
            }, {
              item: withCtx(({ element }) => [
                createVNode(_sfc_main$m, null, {
                  menu: withCtx(() => [
                    createElementVNode("div", _hoisted_3$a, [
                      createElementVNode("a", {
                        class: "p-1 mr-3",
                        href: unref(getTrackerItemLink)(element.id),
                        target: "_blank"
                      }, _hoisted_6$4, 8, _hoisted_4$8),
                      createElementVNode("a", {
                        class: "p-1 mr-1",
                        href: unref(getTrackerItemEditLink)(element.id),
                        target: "_blank"
                      }, _hoisted_9$2, 8, _hoisted_7$2),
                      createCommentVNode(' <Button class="d-inline-block" variant="default" sm @click="handleEditCard(element)"> ')
                    ])
                  ]),
                  title: withCtx(() => [
                    createVNode(FormEditField, {
                      title: element.title,
                      id: element.id
                    }, null, 8, ["title", "id"])
                  ]),
                  text: withCtx(() => [
                    element.description ? (openBlock(), createElementBlock("div", _hoisted_10$2, toDisplayString(element.description.substring(0, 115)), 1)) : createCommentVNode("v-if", true)
                  ]),
                  default: withCtx(() => [
                    createCommentVNode("v-if", true),
                    createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 1
            }, 8, ["list"]);
          };
        }
      });
      var KanbanCards = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__scopeId", "data-v-50651a6c"]]);
      var FormEditCard_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _withScopeId$8 = (n2) => (pushScopeId("data-v-d4a11364"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$d = { class: "mb-3" };
      const _hoisted_2$d = {
        key: 1,
        class: "editable-container"
      };
      const _hoisted_3$9 = { class: "editable-controls" };
      const _hoisted_4$7 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-check" }, null, -1));
      const _hoisted_5$6 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
      const _hoisted_6$3 = {
        key: 0,
        class: "mb-2"
      };
      const _hoisted_7$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("span", { class: "mr-2" }, [
        /* @__PURE__ */ createElementVNode("i", { class: "fas fa-link" })
      ], -1));
      const _hoisted_8$2 = ["href"];
      const _hoisted_9$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("h6", { class: "d-inline-block mr-2" }, [
        /* @__PURE__ */ createElementVNode("i", { class: "fas fa-align-left mr-2" }),
        /* @__PURE__ */ createTextVNode(" Description")
      ], -1));
      const _hoisted_10$1 = { key: 2 };
      const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-check" }, null, -1));
      const _hoisted_12$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
      const __default__$3 = {
        name: "FormEditCard"
      };
      const _sfc_main$f = /* @__PURE__ */ Object.assign(__default__$3, {
        props: {
          id: [Number, String],
          title: {
            type: String
          },
          desc: {
            type: String,
            default: ""
          },
          reference: {
            type: String,
            default: ""
          }
        },
        setup(__props) {
          const props2 = __props;
          const trackerId = ref(store.getters.getTrackerId);
          const showEditField = ref(false);
          const toast = useToast();
          const editDesc = ref(false);
          const titleField = ref(props2.title);
          const description = ref("");
          ref(null);
          watchEffect(() => {
            description.value = props2.desc;
          });
          const handleEditClick = (event) => {
            const ability = defineAbilityFor(store.getters.getRules);
            const canUpdate = ability.can("update", z$2("Tracker_Item", { itemId: props2.id }), store.getters.getTitleField);
            if (canUpdate)
              showEditField.value = true;
          };
          const handleSaveTitle = (event) => {
            showEditField.value = false;
            if (titleField.value.length < 1) {
              toast.error(`This field must be at least 1 character`);
              return;
            }
            kanban.setItem({ trackerId: trackerId.value, itemId: props2.id }, {
              fields: {
                [store.getters.getTitleField]: titleField.value
              }
            }).then((res) => {
              toast.success(`Success! Title saved.`);
            }).catch((err) => {
              if (!err.response)
                toast.error("Error: title not saved");
              const { code, errortitle, message } = err.response.data;
              const msg = `Code: ${code} - ${message}`;
              toast.error(msg);
            });
            store.dispatch("editCardField", {
              id: props2.id,
              field: "title",
              data: titleField.value
            });
          };
          const handleDescriptionInput = (event) => {
            description.value = event.target.value;
          };
          const handleEditDesc = () => {
            const ability = defineAbilityFor(store.getters.getRules);
            const canUpdate = ability.can("update", z$2("Tracker_Item", { itemId: props2.id }), store.getters.getDescriptionField);
            if (canUpdate)
              editDesc.value = true;
          };
          const handleSaveDesc = () => {
            kanban.setItem({ trackerId: trackerId.value, itemId: props2.id }, {
              fields: {
                [store.getters.getDescriptionField]: description.value
              }
            }).then((res) => {
              toast.success(`Success! Description saved.`);
            }).catch((err) => {
              if (!err.response)
                toast.error("Error: description not saved");
              const { code, errortitle, message } = err.response.data;
              const msg = `Code: ${code} - ${message}`;
              toast.error(msg);
            });
            store.dispatch("editCardField", {
              id: props2.id,
              field: "description",
              data: description.value
            });
            editDesc.value = false;
          };
          const handleCancel = () => {
            description.value = props2.desc;
            editDesc.value = false;
          };
          const handleCancelEditTitle = () => {
            titleField.value = props2.title;
            showEditField.value = false;
          };
          return (_ctx, _cache) => {
            const _directive_focus = resolveDirective("focus");
            const _directive_autosize = resolveDirective("autosize");
            return openBlock(), createElementBlock(Fragment, null, [
              createElementVNode("div", _hoisted_1$d, [
                !showEditField.value ? (openBlock(), createElementBlock("h4", {
                  key: 0,
                  onClick: handleEditClick
                }, toDisplayString(titleField.value), 1)) : createCommentVNode("v-if", true),
                showEditField.value ? (openBlock(), createElementBlock("div", _hoisted_2$d, [
                  withDirectives(createVNode(unref(Field), {
                    class: "form-control mb-1",
                    as: "textarea",
                    rows: "1",
                    modelValue: titleField.value,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => titleField.value = $event),
                    name: "cardTitle",
                    type: "text",
                    rules: { minLength: 1 }
                  }, null, 8, ["modelValue"]), [
                    [_directive_focus],
                    [_directive_autosize]
                  ]),
                  createElementVNode("div", _hoisted_3$9, [
                    createVNode(unref(Button), {
                      class: "d-inline-block",
                      variant: "default",
                      sm: "",
                      onClick: handleSaveTitle
                    }, {
                      default: withCtx(() => [
                        _hoisted_4$7
                      ]),
                      _: 1
                    }),
                    createVNode(unref(Button), {
                      class: "d-inline-block ml-2",
                      variant: "default",
                      sm: "",
                      onClick: handleCancelEditTitle
                    }, {
                      default: withCtx(() => [
                        _hoisted_5$6
                      ]),
                      _: 1
                    })
                  ])
                ])) : createCommentVNode("v-if", true)
              ]),
              __props.reference ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
                createElementVNode("small", null, [
                  _hoisted_7$1,
                  createElementVNode("a", {
                    href: __props.reference,
                    target: "_blank"
                  }, "item-" + toDisplayString(__props.id), 9, _hoisted_8$2)
                ])
              ])) : createCommentVNode("v-if", true),
              _hoisted_9$1,
              !editDesc.value ? (openBlock(), createElementBlock("p", {
                key: 1,
                onClick: handleEditDesc
              }, [
                description.value.length === 0 ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  onClick: handleEditDesc
                }, "Click to add description...")) : createCommentVNode("v-if", true),
                createTextVNode(" " + toDisplayString(description.value), 1)
              ])) : createCommentVNode("v-if", true),
              editDesc.value ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
                withDirectives((openBlock(), createElementBlock("textarea", {
                  onInput: handleDescriptionInput,
                  class: "form-control mb-2",
                  name: "",
                  id: ""
                }, [
                  createTextVNode(toDisplayString(description.value), 1)
                ], 32)), [
                  [_directive_autosize],
                  [_directive_focus]
                ]),
                createElementVNode("div", null, [
                  createVNode(unref(Button), {
                    class: "d-inline-block",
                    variant: "default",
                    sm: "",
                    onClick: handleSaveDesc
                  }, {
                    default: withCtx(() => [
                      _hoisted_11$1
                    ]),
                    _: 1
                  }),
                  createVNode(unref(Button), {
                    class: "d-inline-block ml-2",
                    variant: "default",
                    sm: "",
                    onClick: handleCancel
                  }, {
                    default: withCtx(() => [
                      _hoisted_12$1
                    ]),
                    _: 1
                  })
                ])
              ])) : createCommentVNode("v-if", true)
            ], 64);
          };
        }
      });
      var FormEditCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__scopeId", "data-v-d4a11364"]]);
      function C$1(e2) {
        return (C$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && typeof Symbol == "function" && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        })(e2);
      }
      function k$2(e2, t2, n2, o2, r2, i2, a2) {
        try {
          var l2 = e2[i2](a2), u2 = l2.value;
        } catch (e3) {
          return void n2(e3);
        }
        l2.done ? t2(u2) : Promise.resolve(u2).then(o2, r2);
      }
      function A$2(e2, t2) {
        for (var n2 = 0; n2 < t2.length; n2++) {
          var o2 = t2[n2];
          o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, o2.key, o2);
        }
      }
      function L$2(e2, t2, n2) {
        return t2 in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
      }
      function B$2(e2, t2) {
        var n2 = Object.keys(e2);
        if (Object.getOwnPropertySymbols) {
          var o2 = Object.getOwnPropertySymbols(e2);
          t2 && (o2 = o2.filter(function(t3) {
            return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
          })), n2.push.apply(n2, o2);
        }
        return n2;
      }
      function _$2(e2) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var n2 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? B$2(Object(n2), true).forEach(function(t3) {
            L$2(e2, t3, n2[t3]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : B$2(Object(n2)).forEach(function(t3) {
            Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
          });
        }
        return e2;
      }
      function j$2(e2) {
        return function(e3) {
          if (Array.isArray(e3))
            return P$2(e3);
        }(e2) || function(e3) {
          if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
            return Array.from(e3);
        }(e2) || function(e3, t2) {
          if (!e3)
            return;
          if (typeof e3 == "string")
            return P$2(e3, t2);
          var n2 = Object.prototype.toString.call(e3).slice(8, -1);
          n2 === "Object" && e3.constructor && (n2 = e3.constructor.name);
          if (n2 === "Map" || n2 === "Set")
            return Array.from(e3);
          if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
            return P$2(e3, t2);
        }(e2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function P$2(e2, t2) {
        (t2 == null || t2 > e2.length) && (t2 = e2.length);
        for (var n2 = 0, o2 = new Array(t2); n2 < t2; n2++)
          o2[n2] = e2[n2];
        return o2;
      }
      var I$2 = function(e2) {
        return function(e3, t2) {
          return j$2(e3.querySelectorAll(t2) || []);
        }(e2, 'button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=""]:not([disabled]), [contentEditable="true"]:not([disabled]), [contentEditable="TRUE"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex="-1"])');
      }, V$2 = function(e2) {
        return e2 == document.activeElement;
      }, D$2 = function() {
        function e2() {
          !function(e3, t3) {
            if (!(e3 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }(this, e2), this.root = null, this.elements = [], this.onKeyDown = this.onKeyDown.bind(this), this.enable = this.enable.bind(this), this.disable = this.disable.bind(this), this.firstElement = this.firstElement.bind(this), this.lastElement = this.lastElement.bind(this);
        }
        var t2, n2;
        return t2 = e2, (n2 = [{ key: "lastElement", value: function() {
          return this.elements[this.elements.length - 1] || null;
        } }, { key: "firstElement", value: function() {
          return this.elements[0] || null;
        } }, { key: "onKeyDown", value: function(e3) {
          if (function(e4) {
            return e4.key === "Tab" || e4.keyCode === 9;
          }(e3)) {
            if (!e3.shiftKey)
              return !document.activeElement || V$2(this.lastElement()) ? (this.firstElement().focus(), void e3.preventDefault()) : void 0;
            V$2(this.firstElement()) && (this.lastElement().focus(), e3.preventDefault());
          }
        } }, { key: "enabled", value: function() {
          return !!this.root;
        } }, { key: "enable", value: function(e3) {
          e3 && (this.root = e3, this.elements = I$2(this.root), this.root.addEventListener("keydown", this.onKeyDown));
        } }, { key: "disable", value: function() {
          this.root.removeEventListener("keydown", this.onKeyDown), this.root = null;
        } }]) && A$2(t2.prototype, n2), e2;
      }(), N$2 = function(e2) {
        var t2 = e2.targetTouches ? e2.targetTouches[0] : e2;
        return { x: t2.clientX, y: t2.clientY };
      }, R$2 = function(e2, t2, n2) {
        return typeof e2 != "number" && (e2 = Math.min(t2, n2) || t2), typeof n2 != "number" && (n2 = Math.max(t2, e2)), Math.min(Math.max(t2, e2), n2);
      }, $$2 = function(e2) {
        return e2 && Number(e2.replace(/px$/, "")) || 0;
      }, H$1 = { down: { pc: "mousedown", m: "touchstart" }, move: { pc: "mousemove", m: "touchmove" }, up: { pc: "mouseup", m: "touchend" } }, K$1 = function(e2, t2, n2) {
        t2 && t2.addEventListener(H$1[e2].pc, n2), t2 && t2.addEventListener(H$1[e2].m, n2, { passive: false });
      }, U$1 = function(e2, t2, n2) {
        t2 && t2.removeEventListener(H$1[e2].pc, n2), t2 && t2.removeEventListener(H$1[e2].m, n2);
      }, F$2 = false;
      if (typeof window != "undefined") {
        var W$1 = { get passive() {
          F$2 = true;
        } };
        window.addEventListener("testPassive", null, W$1), window.removeEventListener("testPassive", null, W$1);
      }
      var Y$2, q$2, G$1 = typeof window != "undefined" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1), X$1 = [], Z$1 = false, J$2 = 0, Q$1 = -1, ee$1 = function(e2, t2) {
        var n2 = false;
        return function(e3) {
          for (var t3 = []; e3; ) {
            if (t3.push(e3), e3.classList.contains("vfm"))
              return t3;
            e3 = e3.parentElement;
          }
          return t3;
        }(e2).forEach(function(e3) {
          (function(e4) {
            if (!e4 || e4.nodeType !== Node.ELEMENT_NODE)
              return false;
            var t3 = window.getComputedStyle(e4);
            return ["auto", "scroll"].includes(t3.overflowY) && e4.scrollHeight > e4.clientHeight;
          })(e3) && function(e4, t3) {
            return !(e4.scrollTop === 0 && t3 < 0 || e4.scrollTop + e4.clientHeight + t3 >= e4.scrollHeight && t3 > 0);
          }(e3, t2) && (n2 = true);
        }), n2;
      }, te$1 = function(e2) {
        return X$1.some(function() {
          return ee$1(e2, -J$2);
        });
      }, ne$1 = function(e2) {
        var t2 = e2 || window.event;
        return !!te$1(t2.target) || (t2.touches.length > 1 || (t2.preventDefault && t2.preventDefault(), false));
      }, oe$1 = function(e2, t2) {
        if (e2) {
          if (!X$1.some(function(t3) {
            return t3.targetElement === e2;
          })) {
            var n2 = { targetElement: e2, options: t2 || {} };
            X$1 = [].concat(j$2(X$1), [n2]), G$1 ? (e2.ontouchstart = function(e3) {
              e3.targetTouches.length === 1 && (Q$1 = e3.targetTouches[0].clientY);
            }, e2.ontouchmove = function(t3) {
              t3.targetTouches.length === 1 && function(e3, t4) {
                J$2 = e3.targetTouches[0].clientY - Q$1, !te$1(e3.target) && (t4 && t4.scrollTop === 0 && J$2 > 0 || function(e4) {
                  return !!e4 && e4.scrollHeight - e4.scrollTop <= e4.clientHeight;
                }(t4) && J$2 < 0 ? ne$1(e3) : e3.stopPropagation());
              }(t3, e2);
            }, Z$1 || (document.addEventListener("touchmove", ne$1, F$2 ? { passive: false } : void 0), Z$1 = true)) : function(e3) {
              if (q$2 === void 0) {
                var t3 = !!e3 && e3.reserveScrollBarGap === true, n3 = window.innerWidth - document.documentElement.clientWidth;
                if (t3 && n3 > 0) {
                  var o2 = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
                  q$2 = document.body.style.paddingRight, document.body.style.paddingRight = "".concat(o2 + n3, "px");
                }
              }
              Y$2 === void 0 && (Y$2 = document.body.style.overflow, document.body.style.overflow = "hidden");
            }(t2);
          }
        } else
          console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
      }, re$1 = function(e2) {
        e2 ? (X$1 = X$1.filter(function(t2) {
          return t2.targetElement !== e2;
        }), G$1 ? (e2.ontouchstart = null, e2.ontouchmove = null, Z$1 && X$1.length === 0 && (document.removeEventListener("touchmove", ne$1, F$2 ? { passive: false } : void 0), Z$1 = false)) : X$1.length || (q$2 !== void 0 && (document.body.style.paddingRight = q$2, q$2 = void 0), Y$2 !== void 0 && (document.body.style.overflow = Y$2, Y$2 = void 0))) : console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
      }, ie$1 = function() {
      }, ae$1 = "enter", le$1 = "entering", ue$1 = "leave", se$1 = "leavng", fe$1 = { t: "ns-resize", tr: "nesw-resize", r: "ew-resize", br: "nwse-resize", b: "ns-resize", bl: "nesw-resize", l: "ew-resize", tl: "nwse-resize" }, de$1 = { props: { name: { type: String, default: null }, modelValue: { type: Boolean, default: false }, ssr: { type: Boolean, default: true }, classes: { type: [String, Object, Array], default: "" }, overlayClass: { type: [String, Object, Array], default: "" }, contentClass: { type: [String, Object, Array], default: "" }, styles: { type: [Object, Array], default: function() {
        return {};
      } }, overlayStyle: { type: [Object, Array], default: function() {
        return {};
      } }, contentStyle: { type: [Object, Array], default: function() {
        return {};
      } }, lockScroll: { type: Boolean, default: true }, hideOverlay: { type: Boolean, default: false }, clickToClose: { type: Boolean, default: true }, escToClose: { type: Boolean, default: false }, preventClick: { type: Boolean, default: false }, attach: { type: null, default: false, validator: function(e2) {
        var t2 = C$1(e2);
        return t2 === "boolean" || t2 === "string" || e2.nodeType === Node.ELEMENT_NODE;
      } }, transition: { type: [String, Object], default: "vfm" }, overlayTransition: { type: [String, Object], default: "vfm" }, keepOverlay: { type: Boolean, default: false }, zIndexAuto: { type: Boolean, default: true }, zIndexBase: { type: [String, Number], default: 1e3 }, zIndex: { type: [Boolean, String, Number], default: false }, focusRetain: { type: Boolean, default: true }, focusTrap: { type: Boolean, default: false }, fitParent: { type: Boolean, default: true }, drag: { type: Boolean, default: false }, dragSelector: { type: String, default: "" }, keepChangedStyle: { type: Boolean, default: false }, resize: { type: Boolean, default: false }, resizeDirections: { type: Array, default: function() {
        return ["t", "tr", "r", "br", "b", "bl", "l", "tl"];
      }, validator: function(e2) {
        return ["t", "tr", "r", "br", "b", "bl", "l", "tl"].filter(function(t2) {
          return e2.indexOf(t2) !== -1;
        }).length === e2.length;
      } }, minWidth: { type: Number, default: 0 }, minHeight: { type: Number, default: 0 }, maxWidth: { type: Number, default: 1 / 0 }, maxHeight: { type: Number, default: 1 / 0 } }, emits: ["update:modelValue", "click-outside", "before-open", "opened", "before-close", "closed", "_before-open", "_opened", "_closed", "drag:start", "drag:move", "drag:end", "resize:start", "resize:move", "resize:end"], setup: function(l2, u2) {
        var s2 = u2.emit, f2 = Symbol("vfm"), d2 = ref(null), c2 = ref(null), v2 = ref(null), p2 = ref(null), m2 = ref(null), y2 = ref(null), h2 = ref(null), b2 = new D$2(), g2 = ref(false), w2 = reactive({ modal: false, overlay: false, resize: false }), x2 = ref(null), E2 = ref(null), S2 = ref(false), O2 = ref({}), z2 = ref({}), M2 = ref(null), T2 = ref(null), C2 = ie$1, k2 = ie$1, A2 = computed(function() {
          return typeof l2.overlayTransition == "string" ? { name: l2.overlayTransition } : _$2({}, l2.overlayTransition);
        }), B2 = computed(function() {
          return typeof l2.transition == "string" ? { name: l2.transition } : _$2({}, l2.transition);
        }), P2 = computed(function() {
          return (l2.hideOverlay || x2.value === ue$1) && E2.value === ue$1;
        }), I2 = computed(function() {
          return l2.zIndex === false ? !!l2.zIndexAuto && +l2.zIndexBase + 2 * (h2.value || 0) : l2.zIndex;
        }), V2 = computed(function() {
          return _$2({}, I2.value !== false && { zIndex: I2.value });
        }), H2 = computed(function() {
          var e2 = [z2.value];
          return Array.isArray(l2.contentStyle) ? e2.push.apply(e2, j$2(l2.contentStyle)) : e2.push(l2.contentStyle), e2;
        });
        function F2() {
          return { uid: f2, props: l2, emit: s2, vfmContainer: c2, vfmContent: v2, vfmResize: p2, vfmOverlayTransition: m2, vfmTransition: y2, getAttachElement: G2, modalStackIndex: h2, visibility: w2, handleLockScroll: q2, $focusTrap: b2, toggle: Q2, params: O2 };
        }
        function W2() {
          if (l2.modelValue) {
            if (s2("_before-open", X2({ type: "_before-open" })), Z2("before-open", false))
              return void k2("show");
            var e2 = G2();
            if (e2 || l2.attach === false) {
              if (l2.attach !== false) {
                if (!d2.value)
                  return g2.value = true, void nextTick(function() {
                    W2();
                  });
                e2.appendChild(d2.value);
              }
              var t2 = l2.api.openedModals.findIndex(function(e3) {
                return e3.uid === f2;
              });
              t2 !== -1 && l2.api.openedModals.splice(t2, 1), l2.api.openedModals.push(F2()), h2.value = l2.api.openedModals.length - 1, q2(), l2.api.openedModals.filter(function(e3) {
                return e3.uid !== f2;
              }).forEach(function(t3, n2) {
                t3.getAttachElement() === e2 && (t3.modalStackIndex.value = n2, !t3.props.keepOverlay && (t3.visibility.overlay = false));
              }), g2.value = true, w2.overlay = true, w2.modal = true;
            } else
              e2 !== false && console.warn("Unable to locate target ".concat(l2.attach));
          }
        }
        function Y2() {
          var e2 = l2.api.openedModals.findIndex(function(e3) {
            return e3.uid === f2;
          });
          if (e2 !== -1 && l2.api.openedModals.splice(e2, 1), l2.api.openedModals.length > 0) {
            var t2 = l2.api.openedModals[l2.api.openedModals.length - 1];
            t2.props.focusTrap && t2.$focusTrap.firstElement().focus(), (t2.props.focusRetain || t2.props.focusTrap) && t2.vfmContainer.value.focus(), !t2.props.hideOverlay && (t2.visibility.overlay = true);
          }
          l2.drag && ne2(), l2.resize && ce2(), M2.value = null, w2.overlay = false, w2.modal = false;
        }
        function q2() {
          l2.modelValue && nextTick(function() {
            l2.lockScroll ? oe$1(c2.value, { reserveScrollBarGap: true }) : re$1(c2.value);
          });
        }
        function G2() {
          return l2.attach !== false && (typeof l2.attach == "string" ? !!window && window.document.querySelector(l2.attach) : l2.attach);
        }
        function X2() {
          var e2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return _$2({ ref: F2() }, e2);
        }
        function Z2(e2, t2) {
          var n2 = false, o2 = X2({ type: e2, stop: function() {
            n2 = true;
          } });
          return s2(e2, o2), !!n2 && (S2.value = true, nextTick(function() {
            s2("update:modelValue", t2);
          }), true);
        }
        function J2(e2, t2, n2) {
          M2.value = "".concat(t2, ":").concat(n2), s2(M2.value, e2);
        }
        function Q2(e2, t2) {
          var n2 = arguments;
          return new Promise(function(o2, r2) {
            C2 = function(e3) {
              o2(e3), C2 = ie$1;
            }, k2 = function(e3) {
              r2(e3), k2 = ie$1;
            };
            var i2 = typeof e2 == "boolean" ? e2 : !l2.modelValue;
            i2 && n2.length === 2 && (O2.value = t2), s2("update:modelValue", i2);
          });
        }
        function ee2(e2) {
          e2.stopPropagation();
          var t2, n2 = "resize", o2 = "drag", r2 = e2.target.getAttribute("direction");
          if (r2)
            t2 = n2;
          else {
            if (!function(e3, t3, n3) {
              return n3 === "" || j$2(t3.querySelectorAll(n3)).includes(e3.target);
            }(e2, v2.value, l2.dragSelector))
              return;
            t2 = o2;
          }
          J2(e2, t2, "start");
          var i2, a2, u3, s3, f3 = N$2(e2), d3 = c2.value.getBoundingClientRect(), p3 = v2.value.getBoundingClientRect(), m3 = window.getComputedStyle(v2.value).position === "absolute", y3 = $$2(z2.value.top), h3 = $$2(z2.value.left), b3 = function() {
            if (l2.fitParent) {
              var e3 = { absolute: function() {
                return { minTop: 0, minLeft: 0, maxTop: d3.height - p3.height, maxLeft: d3.width - p3.width };
              }, relative: function() {
                return { minTop: y3 + d3.top - p3.top, minLeft: h3 + d3.left - p3.left, maxTop: y3 + d3.bottom - p3.bottom, maxLeft: h3 + d3.right - p3.right };
              } };
              return m3 ? e3.absolute() : e3.relative();
            }
            return {};
          }(), g3 = t2 === n2 && (i2 = document.body, a2 = "cursor", u3 = fe$1[r2], s3 = i2.style[a2], i2.style[a2] = u3, function() {
            i2.style[a2] = s3;
          }), w3 = function(e3) {
            e3.stopPropagation(), J2(e3, t2, "move");
            var i3, a3, u4 = N$2(e3), s4 = { x: u4.x - f3.x, y: u4.y - f3.y };
            t2 === n2 && (s4 = function(e4, t3, n3, o3, r3) {
              var i4 = function(e5) {
                var n4, o4 = t3[e5.axis];
                o4 = l2.fitParent ? R$2(e5.min, o4, e5.max) : o4;
                var i5 = R$2(e5.minEdge, e5.getEdge(o4), e5.maxEdge);
                return o4 = e5.getOffsetAxis(i5, r3), L$2(n4 = {}, e5.edgeName, i5), L$2(n4, e5.axis, o4), n4;
              }, a4 = function(e5, t4, r4, i5) {
                var a5, u6 = o3[t4], s6 = n3[e5] - o3[e5], f4 = (a5 = t4).charAt(0).toUpperCase() + a5.slice(1);
                return { axis: r4, edgeName: t4, min: i5 ? s6 : -u6, max: i5 ? u6 : s6, minEdge: l2["min".concat(f4)], maxEdge: l2["max".concat(f4)], getEdge: function(e6) {
                  return o3[t4] - e6 * (i5 ? 1 : -1);
                }, getOffsetAxis: function(e6, n4) {
                  var r5 = o3[t4] - e6;
                  return n4 ? i5 ? r5 : 0 : (i5 ? 1 : -1) * r5 / 2;
                } };
              }, u5 = { t: ["top", "height", "y", true], b: ["bottom", "height", "y", false], l: ["left", "width", "x", true], r: ["right", "width", "x", false] }, s5 = { x: 0, y: 0 };
              return e4.split("").forEach(function(e5) {
                var t4 = a4.apply(void 0, j$2(u5[e5]));
                s5 = _$2(_$2({}, s5), i4(t4));
              }), s5;
            }(r2, s4, d3, p3, m3)), m3 ? (i3 = p3.top - d3.top + s4.y, a3 = p3.left - d3.left + s4.x) : (i3 = y3 + s4.y, a3 = h3 + s4.x), t2 === o2 && l2.fitParent && (i3 = R$2(b3.minTop, i3, b3.maxTop), a3 = R$2(b3.minLeft, a3, b3.maxLeft));
            var c3 = _$2(_$2(_$2({ position: "relative", top: i3 + "px", left: a3 + "px", margin: "unset", touchAction: "none" }, m3 && { position: "absolute", transform: "unset", width: p3.width + "px", height: p3.height + "px" }), s4.width && { width: s4.width + "px" }), s4.height && { height: s4.height + "px" });
            z2.value = _$2(_$2({}, z2.value), c3);
          };
          K$1("move", document, w3), K$1("up", document, function e3(o3) {
            o3.stopPropagation(), t2 === n2 && g3 && g3(), setTimeout(function() {
              J2(o3, t2, "end");
            }), U$1("move", document, w3), U$1("up", document, e3);
          });
        }
        function te2() {
          K$1("down", v2.value, ee2), z2.value.touchAction = "none";
        }
        function ne2() {
          U$1("down", v2.value, ee2);
        }
        function de2() {
          w2.resize = true, nextTick(function() {
            K$1("down", p2.value, ee2);
          });
        }
        function ce2() {
          U$1("down", p2.value, ee2), w2.resize = false;
        }
        return watch(function() {
          return l2.modelValue;
        }, function(e2) {
          if (S2.value)
            S2.value = false;
          else if (W2(), !e2) {
            if (Z2("before-close", true))
              return void k2("hide");
            Y2();
          }
        }), watch(function() {
          return l2.lockScroll;
        }, q2), watch(function() {
          return l2.hideOverlay;
        }, function(e2) {
          l2.modelValue && !e2 && (w2.overlay = true);
        }), watch(function() {
          return l2.attach;
        }, W2), watch(P2, function(e2) {
          e2 && (g2.value = false, c2.value.style.display = "none");
        }, { flush: "post" }), watch(function() {
          return l2.drag;
        }, function(e2) {
          g2.value && (e2 ? te2() : ne2());
        }), watch(function() {
          return l2.resize;
        }, function(e2) {
          g2.value && (e2 ? de2() : ce2());
        }), watch(function() {
          return l2.keepChangedStyle;
        }, function(e2) {
          e2 || (z2.value = {});
        }), l2.api.modals.push(F2()), onMounted(function() {
          W2();
        }), onBeforeUnmount(function() {
          var e2;
          Y2(), l2.lockScroll && c2.value && re$1(c2.value), d2 == null || (e2 = d2.value) === null || e2 === void 0 || e2.remove();
          var t2 = l2.api.modals.findIndex(function(e3) {
            return e3.uid === f2;
          });
          l2.api.modals.splice(t2, 1);
        }), { root: d2, vfmContainer: c2, vfmContent: v2, vfmResize: p2, vfmOverlayTransition: m2, vfmTransition: y2, computedOverlayTransition: A2, computedTransition: B2, visible: g2, visibility: w2, params: O2, calculateZIndex: I2, bindStyle: V2, bindContentStyle: H2, beforeOverlayEnter: function() {
          x2.value = le$1;
        }, afterOverlayEnter: function() {
          x2.value = ae$1;
        }, beforeOverlayLeave: function() {
          x2.value = se$1;
        }, afterOverlayLeave: function() {
          x2.value = ue$1;
        }, beforeModalEnter: function() {
          E2.value = le$1;
        }, afterModalEnter: function() {
          E2.value = ae$1, (l2.focusRetain || l2.focusTrap) && c2.value.focus(), l2.focusTrap && b2.enable(c2.value), l2.drag && te2(), l2.resize && de2(), s2("_opened"), s2("opened", X2({ type: "opened" })), C2("show");
        }, beforeModalLeave: function() {
          E2.value = se$1, b2.enabled() && b2.disable();
        }, afterModalLeave: function() {
          E2.value = ue$1, h2.value = null, l2.lockScroll && re$1(c2.value), l2.keepChangedStyle || (z2.value = {});
          var e2 = false, t2 = X2({ type: "closed", stop: function() {
            e2 = true;
          } });
          s2("_closed"), s2("closed", t2), C2("hide"), e2 || (O2.value = {});
        }, onMousedown: function(e2) {
          T2.value = e2 == null ? void 0 : e2.target;
        }, onMouseupContainer: function() {
          T2.value === c2.value && M2.value !== "resize:move" && (s2("click-outside", X2({ type: "click-outside" })), l2.clickToClose && s2("update:modelValue", false));
        }, onEsc: function() {
          g2.value && l2.escToClose && s2("update:modelValue", false);
        } };
      } }, ce$1 = withScopeId("data-v-2836fdb5");
      pushScopeId("data-v-2836fdb5");
      var ve$1 = { key: 0, ref: "vfmResize", class: "vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none" };
      popScopeId();
      var pe$1 = ce$1(function(e2, t2, n2, o2, r2, i2) {
        return n2.ssr || o2.visible ? withDirectives((openBlock(), createBlock("div", { key: 0, ref: "root", style: o2.bindStyle, class: ["vfm vfm--inset", [n2.attach === false ? "vfm--fixed" : "vfm--absolute", { "vfm--prevent-none": n2.preventClick }]], onKeydown: t2[4] || (t2[4] = withKeys(function() {
          return o2.onEsc && o2.onEsc.apply(o2, arguments);
        }, ["esc"])) }, [createVNode(Transition, mergeProps(o2.computedOverlayTransition, { onBeforeEnter: o2.beforeOverlayEnter, onAfterEnter: o2.afterOverlayEnter, onBeforeLeave: o2.beforeOverlayLeave, onAfterLeave: o2.afterOverlayLeave }), { default: ce$1(function() {
          return [!n2.hideOverlay && o2.visibility.overlay ? (openBlock(), createBlock("div", { key: 0, class: ["vfm__overlay vfm--overlay vfm--absolute vfm--inset", n2.overlayClass], style: n2.overlayStyle }, null, 6)) : createCommentVNode("v-if", true)];
        }), _: 1 }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]), createVNode(Transition, mergeProps(o2.computedTransition, { onBeforeEnter: o2.beforeModalEnter, onAfterEnter: o2.afterModalEnter, onBeforeLeave: o2.beforeModalLeave, onAfterLeave: o2.afterModalLeave }), { default: ce$1(function() {
          return [withDirectives(createVNode("div", { ref: "vfmContainer", class: ["vfm__container vfm--absolute vfm--inset vfm--outline-none", n2.classes], style: n2.styles, "aria-expanded": o2.visibility.modal.toString(), role: "dialog", "aria-modal": "true", tabindex: "-1", onMouseup: t2[2] || (t2[2] = withModifiers(function() {
            return o2.onMouseupContainer && o2.onMouseupContainer.apply(o2, arguments);
          }, ["self"])), onMousedown: t2[3] || (t2[3] = withModifiers(function() {
            return o2.onMousedown && o2.onMousedown.apply(o2, arguments);
          }, ["self"])) }, [createVNode("div", { ref: "vfmContent", class: ["vfm__content", [n2.contentClass, { "vfm--prevent-auto": n2.preventClick }]], style: o2.bindContentStyle, onMousedown: t2[1] || (t2[1] = function(e3) {
            return o2.onMousedown(null);
          }) }, [renderSlot(e2.$slots, "default", { params: o2.params, close: function() {
            return e2.$emit("update:modelValue", false);
          } }), o2.visibility.resize && o2.visibility.modal ? (openBlock(), createBlock("div", ve$1, [(openBlock(true), createBlock(Fragment, null, renderList(n2.resizeDirections, function(e3) {
            return openBlock(), createBlock("div", { key: e3, direction: e3, class: ["vfm--resize-".concat(e3), "vfm--absolute vfm--prevent-auto"] }, null, 10, ["direction"]);
          }), 128))], 512)) : createCommentVNode("v-if", true)], 38)], 46, ["aria-expanded"]), [[vShow, o2.visibility.modal]])];
        }), _: 3 }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])], 38)), [[vShow, !n2.ssr || o2.visible]]) : createCommentVNode("v-if", true);
      });
      !function(e2, t2) {
        t2 === void 0 && (t2 = {});
        var n2 = t2.insertAt;
        if (e2 && typeof document != "undefined") {
          var o2 = document.head || document.getElementsByTagName("head")[0], r2 = document.createElement("style");
          r2.type = "text/css", n2 === "top" && o2.firstChild ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), r2.styleSheet ? r2.styleSheet.cssText = e2 : r2.appendChild(document.createTextNode(e2));
        }
      }("\n.vfm--fixed[data-v-2836fdb5] {\n  position: fixed;\n}\n.vfm--absolute[data-v-2836fdb5] {\n  position: absolute;\n}\n.vfm--inset[data-v-2836fdb5] {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay[data-v-2836fdb5] {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none[data-v-2836fdb5] {\n  pointer-events: none;\n}\n.vfm--prevent-auto[data-v-2836fdb5] {\n  pointer-events: auto;\n}\n.vfm--outline-none[data-v-2836fdb5]:focus {\n  outline: none;\n}\n.vfm-enter-active[data-v-2836fdb5],\n.vfm-leave-active[data-v-2836fdb5] {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from[data-v-2836fdb5],\n.vfm-leave-to[data-v-2836fdb5] {\n  opacity: 0;\n}\n.vfm--touch-none[data-v-2836fdb5] {\n  touch-action: none;\n}\n.vfm--select-none[data-v-2836fdb5] {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vfm--resize-tr[data-v-2836fdb5],\n.vfm--resize-br[data-v-2836fdb5],\n.vfm--resize-bl[data-v-2836fdb5],\n.vfm--resize-tl[data-v-2836fdb5] {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n.vfm--resize-t[data-v-2836fdb5] {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr[data-v-2836fdb5] {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r[data-v-2836fdb5] {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br[data-v-2836fdb5] {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b[data-v-2836fdb5] {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl[data-v-2836fdb5] {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l[data-v-2836fdb5] {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl[data-v-2836fdb5] {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n"), de$1.render = pe$1, de$1.__scopeId = "data-v-2836fdb5", de$1.__file = "lib/VueFinalModal.vue";
      var me$1 = { props: {}, methods: { slice: function(e2) {
        this.api.dynamicModals.splice(e2, 1);
      }, beforeOpen: function(e2, t2, n2) {
        var o2, r2 = this;
        return (o2 = function* () {
          e2.ref.params.value = t2.params, yield r2.$nextTick(), yield r2.$nextTick(), t2.value || (r2.slice(n2), t2.reject("show"));
        }, function() {
          var e3 = this, t3 = arguments;
          return new Promise(function(n3, r3) {
            var i2 = o2.apply(e3, t3);
            function a2(e4) {
              k$2(i2, n3, r3, a2, l2, "next", e4);
            }
            function l2(e4) {
              k$2(i2, n3, r3, a2, l2, "throw", e4);
            }
            a2(void 0);
          });
        })();
      }, isString: function(e2) {
        return typeof e2 == "string";
      } } }, ye$1 = { class: "modals-container" };
      function he$1(e2, t2) {
        var n2 = _$2(_$2({}, e2), {}, { props: _$2({}, e2.props) });
        return Object.assign(n2.props, { api: { type: Object, default: function() {
          return t2;
        } } }), n2;
      }
      me$1.render = function(e2, t2, n2, o2, r2, i2) {
        return openBlock(), createBlock("div", ye$1, [(openBlock(true), createBlock(Fragment, null, renderList(e2.api.dynamicModals, function(e3, t3) {
          return openBlock(), createBlock(resolveDynamicComponent(e3.component), mergeProps({ key: e3.id }, e3.bind, { modelValue: e3.value, "onUpdate:modelValue": function(t4) {
            return e3.value = t4;
          } }, toHandlers(e3.on), { on_closed: function(e4) {
            return i2.slice(t3);
          }, on_beforeOpen: function(t4) {
            return i2.beforeOpen(t4, e3);
          }, on_opened: e3.opened }), createSlots({ _: 2 }, [renderList(e3.slots, function(e4, t4) {
            return { name: t4, fn: withCtx(function() {
              return [createCommentVNode(" eslint-disable vue/no-v-html "), i2.isString(e4) ? (openBlock(), createBlock("div", { key: 0, innerHTML: e4 }, null, 8, ["innerHTML"])) : (openBlock(), createBlock(resolveDynamicComponent(e4.component), mergeProps({ key: 1 }, e4.bind, toHandlers(e4.on || {})), null, 16))];
            }) };
          })]), 1040, ["modelValue", "onUpdate:modelValue", "on_closed", "on_beforeOpen", "on_opened"]);
        }), 128))]);
      }, me$1.__file = "lib/ModalsContainer.vue";
      var ge$1 = function() {
        var e2, t2, n2 = (t2 = null, { show: function(e3) {
          for (var n3 = this, o2 = arguments.length, r2 = new Array(o2 > 1 ? o2 - 1 : 0), i2 = 1; i2 < o2; i2++)
            r2[i2 - 1] = arguments[i2];
          switch (C$1(e3)) {
            case "string":
              return this.toggle.apply(this, [e3, true].concat(r2));
            case "object":
              return Promise.allSettled([new Promise(function(o3, i3) {
                var a2 = { value: true, id: Symbol("dynamicModal"), component: t2, bind: {}, slots: {}, on: {}, params: r2[0], reject: i3, opened: function() {
                  o3("show");
                } };
                n3.dynamicModals.push(shallowReactive(Object.assign(a2, e3)));
              })]);
          }
        }, hide: function() {
          for (var e3 = arguments.length, t3 = new Array(e3), n3 = 0; n3 < e3; n3++)
            t3[n3] = arguments[n3];
          return this.toggle(t3, false);
        }, hideAll: function() {
          return this.hide.apply(this, j$2(this.openedModals.map(function(e3) {
            return e3.props.name;
          })));
        }, toggle: function(e3) {
          for (var t3 = arguments.length, n3 = new Array(t3 > 1 ? t3 - 1 : 0), o2 = 1; o2 < t3; o2++)
            n3[o2 - 1] = arguments[o2];
          var r2 = Array.isArray(e3) ? this.get.apply(this, j$2(e3)) : this.get(e3);
          return Promise.allSettled(r2.map(function(e4) {
            return e4.toggle.apply(e4, n3);
          }));
        }, get: function() {
          for (var e3 = arguments.length, t3 = new Array(e3), n3 = 0; n3 < e3; n3++)
            t3[n3] = arguments[n3];
          return this.modals.filter(function(e4) {
            return t3.includes(e4.props.name);
          });
        }, dynamicModals: shallowReactive([]), openedModals: [], modals: [], _setDefaultModal: function(e3) {
          t2 = e3;
        } });
        return L$2(e2 = {}, "$vfm", n2), L$2(e2, "VueFinalModal", function(e3) {
          var t3 = he$1(de$1, e3);
          return e3._setDefaultModal(t3), t3;
        }(n2)), L$2(e2, "ModalsContainer", function(e3) {
          return he$1(me$1, e3);
        }(n2)), e2;
      }, we$1 = ge$1();
      we$1.$vfm;
      var Ee$1 = we$1.VueFinalModal;
      we$1.ModalsContainer;
      var KanbanColumns_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _withScopeId$7 = (n2) => (pushScopeId("data-v-792774b4"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$c = {
        key: 0,
        class: "d-flex"
      };
      const _hoisted_2$c = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
      const _hoisted_3$8 = { class: "w-100" };
      const __default__$2 = {
        name: "KanbanColumns"
      };
      const _sfc_main$e = /* @__PURE__ */ Object.assign(__default__$2, {
        props: {
          cellIds: {
            type: Array,
            default() {
              return [];
            }
          },
          rowId: {
            type: Number
          },
          rowValue: [Number, String],
          rowIndex: {
            type: Number
          }
        },
        setup(__props) {
          const props2 = __props;
          const dragging = ref(false);
          const showModal = ref(false);
          const card = ref(false);
          ref(false);
          const getCells = computed(() => store.getters.getCells(props2.cellIds));
          const getCols = computed(() => store.getters.getCols);
          const startDragging = () => dragging.value = true;
          const endDragging = () => dragging.value = false;
          const handleChange = (event) => {
            if (event.moved) {
              store.dispatch("moveColumn", {
                oldIndex: event.moved.oldIndex,
                newIndex: event.moved.newIndex,
                element: event.moved.element,
                rowId: props2.rowId
              });
            } else if (event.added) {
              store.dispatch("addCell", {
                newIndex: event.added.newIndex,
                element: event.added.element,
                rowId: props2.rowId
              });
            } else if (event.removed) {
              store.dispatch("removeCell", {
                oldIndex: event.removed.oldIndex,
                element: event.removed.element,
                rowId: props2.rowId
              });
            }
          };
          const handleEditCard = (element) => {
            card.value = element;
            showModal.value = true;
          };
          const handleClickOutside = () => {
            showModal.value = false;
          };
          const handleModalClosed = () => {
            showModal.value = false;
          };
          return (_ctx, _cache) => {
            const _component_PerfectScrollbar = resolveComponent("PerfectScrollbar");
            resolveComponent("DatePicker");
            return openBlock(), createElementBlock(Fragment, null, [
              createVNode(unref(draggableComponent), {
                list: unref(getCells),
                group: "cells",
                "item-key": "id",
                class: "container-cells",
                chosenClass: "chosen-cell",
                ghostClass: "ghost-cell",
                dragClass: "dragging-cell",
                handle: ".drag-handle-cell",
                onChange: handleChange,
                onStart: startDragging,
                onEnd: endDragging,
                forceFallback: true,
                animation: 200
              }, {
                item: withCtx(({ element, index: index2 }) => [
                  createVNode(KanbanColumn, {
                    rowIndex: __props.rowIndex,
                    colIndex: index2,
                    cellId: element.id,
                    columnValue: unref(getCols)[index2].value,
                    rowValue: __props.rowValue,
                    colId: unref(getCols)[index2].id,
                    title: unref(getCols)[index2].title,
                    limit: unref(getCols)[index2].wip,
                    total: unref(store).getters.getCardsByCol(index2).length
                  }, {
                    default: withCtx(() => [
                      createVNode(_component_PerfectScrollbar, {
                        class: "d-flex h-100",
                        options: { suppressScrollX: true }
                      }, {
                        default: withCtx(() => [
                          createVNode(KanbanCards, {
                            cellId: element.id,
                            rowId: __props.rowId,
                            columnValue: unref(getCols)[index2].value,
                            rowValue: __props.rowValue,
                            cardIds: element.cards,
                            onEditCard: handleEditCard
                          }, null, 8, ["cellId", "rowId", "columnValue", "rowValue", "cardIds"])
                        ]),
                        _: 2
                      }, 1024)
                    ]),
                    _: 2
                  }, 1032, ["rowIndex", "colIndex", "cellId", "columnValue", "rowValue", "colId", "title", "limit", "total"])
                ]),
                _: 1
              }, 8, ["list"]),
              createVNode(unref(Ee$1), {
                modelValue: showModal.value,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => showModal.value = $event),
                classes: "f-modal-container",
                "content-class": "f-modal-content",
                drag: false,
                resize: false,
                "fit-parent": false,
                onClickOutside: handleClickOutside,
                onClosed: handleModalClosed
              }, {
                default: withCtx(() => [
                  showModal.value ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
                    createVNode(unref(Button), {
                      class: "f-modal-close",
                      variant: "default",
                      onClick: _cache[0] || (_cache[0] = ($event) => showModal.value = false)
                    }, {
                      default: withCtx(() => [
                        _hoisted_2$c
                      ]),
                      _: 1
                    }),
                    createElementVNode("div", _hoisted_3$8, [
                      createVNode(FormEditCard, {
                        id: card.value.id,
                        title: card.value.title,
                        desc: card.value.description,
                        reference: `tiki-view_tracker_item.php?itemId=${card.value.id}`
                      }, null, 8, ["id", "title", "desc", "reference"])
                    ]),
                    createCommentVNode("v-if", true)
                  ])) : createCommentVNode("v-if", true)
                ]),
                _: 1
              }, 8, ["modelValue"])
            ], 64);
          };
        }
      });
      var KanbanColumns = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__scopeId", "data-v-792774b4"]]);
      var KanbanBoard_vue_vue_type_style_index_0_scoped_true_lang = "";
      const _withScopeId$6 = (n2) => (pushScopeId("data-v-0390af22"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$b = {
        key: 0,
        style: { "font-size": "1.25rem", "font-weight": "500" }
      };
      const _hoisted_2$b = {
        key: 1,
        class: "mx-2"
      };
      const _hoisted_3$7 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-spinner fa-spin" }, null, -1));
      const _hoisted_4$6 = [
        _hoisted_3$7
      ];
      const _hoisted_5$5 = {
        key: 2,
        class: "mx-2"
      };
      const _hoisted_8$1 = { class: "board-container" };
      const __default__$1 = {
        name: "KanbanBoard"
      };
      const _sfc_main$d = /* @__PURE__ */ Object.assign(__default__$1, {
        props: {
          id: {
            type: Number
          },
          loading: {
            type: Boolean,
            default: false
          }
        },
        setup(__props) {
          const props2 = __props;
          const board = computed(() => store.getters.getBoard(props2.id));
          const getUserName = computed(() => {
            const user = store.getters.getUser;
            if (user && user.user)
              return user.user;
            return user ? user : "guest";
          });
          const showEditField = ref(false);
          const toast = useToast();
          const handleTitleBlur = (event) => {
            showEditField.value = false;
            if (event.target.value.length < 1) {
              toast.error(`This field must be at least 1 character`);
              return;
            }
            store.dispatch("editBoardField", {
              id: props2.id,
              field: "title",
              data: event.target.value
            });
          };
          return (_ctx, _cache) => {
            const _component_PerfectScrollbar = resolveComponent("PerfectScrollbar");
            const _directive_focus = resolveDirective("focus");
            const _directive_autosize = resolveDirective("autosize");
            return openBlock(), createElementBlock("div", {
              class: "kanban-container",
              style: normalizeStyle({ backgroundImage: unref(board).imageUrl ? `url(${unref(board).imageUrl})` : "none" })
            }, [
              createCommentVNode(` <nav class="navbar navbar-light rounded-lg bg-color-grey" :class="{'bg-color-transparent': board.imageUrl, 'bg-light': !board.imageUrl}"> `),
              createElementVNode("nav", {
                class: normalizeClass(["navbar navbar-light", { "bg-color-transparent": unref(board).imageUrl }])
              }, [
                createElementVNode("div", null, [
                  !showEditField.value ? (openBlock(), createElementBlock("span", _hoisted_1$b, toDisplayString(unref(board).title), 1)) : createCommentVNode("v-if", true),
                  __props.loading ? (openBlock(), createElementBlock("span", _hoisted_2$b, _hoisted_4$6)) : createCommentVNode("v-if", true),
                  !__props.loading ? (openBlock(), createElementBlock("span", _hoisted_5$5, "(" + toDisplayString(unref(getUserName)) + ")", 1)) : createCommentVNode("v-if", true),
                  showEditField.value ? withDirectives((openBlock(), createBlock(unref(Field), {
                    key: 3,
                    as: "textarea",
                    rows: "1",
                    value: unref(board).title,
                    onBlur: handleTitleBlur,
                    name: "rowTitle",
                    type: "text",
                    rules: { minLength: 1 }
                  }, null, 8, ["value"])), [
                    [_directive_focus],
                    [_directive_autosize]
                  ]) : createCommentVNode("v-if", true)
                ]),
                createCommentVNode("v-if", true)
              ], 2),
              createVNode(_component_PerfectScrollbar, { class: "d-flex" }, {
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_8$1, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).getters.getRows(unref(board).rows), (row, index2) => {
                      return openBlock(), createBlock(KanbanRow, {
                        key: row.title,
                        title: row.title,
                        transparentTitleBg: unref(board).imageUrl ? true : false,
                        boardId: __props.id,
                        rowId: row.id,
                        rowValue: row.value,
                        index: index2
                      }, {
                        default: withCtx(() => [
                          createVNode(KanbanColumns, {
                            rowId: row.id,
                            rowIndex: index2,
                            rowValue: row.value,
                            cellIds: row.cells
                          }, null, 8, ["rowId", "rowIndex", "rowValue", "cellIds"]),
                          index2 === 0 ? (openBlock(), createBlock(ButtonAddColumn, {
                            key: 0,
                            rowId: row.id
                          }, null, 8, ["rowId"])) : createCommentVNode("v-if", true)
                        ]),
                        _: 2
                      }, 1032, ["title", "transparentTitleBg", "boardId", "rowId", "rowValue", "index"]);
                    }), 128))
                  ])
                ]),
                _: 1
              })
            ], 4);
          };
        }
      });
      var KanbanBoard = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__scopeId", "data-v-0390af22"]]);
      const __default__ = {
        name: "App"
      };
      const _sfc_main$c = /* @__PURE__ */ Object.assign(__default__, {
        props: {
          customProps: {
            type: Object
          }
        },
        setup(__props) {
          const props2 = __props;
          const boardId = ref(props2.customProps.kanbanData.trackerId);
          const loading = ref(false);
          onBeforeMount(() => {
            console.log(props2.customProps.kanbanData);
            loading.value = false;
            const cardsAllIds = props2.customProps.kanbanData.cards.map((card) => card.id);
            props2.customProps.kanbanData.cards = [...new Set(cardsAllIds)].map((id) => {
              return props2.customProps.kanbanData.cards.find((card) => card.id === id);
            });
            store.dispatch("initBoard", props2.customProps.kanbanData);
            store.dispatch("setUser", props2.customProps.kanbanData.user);
          });
          return (_ctx, _cache) => {
            return openBlock(), createElementBlock(Fragment, null, [
              createCommentVNode(' <Sidebar>\n        <template v-slot:sidebar-content>\n            <Sidemenu @boardId="setBoardId"/>\n        </template>\n        <KanbanBoard :id="boardId" />\n    </Sidebar> '),
              createVNode(KanbanBoard, {
                id: boardId.value,
                loading: loading.value
              }, null, 8, ["id", "loading"])
            ], 2112);
          };
        }
      });
      /*!
       * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
       *
       * Copyright (c) 2014-2017, Jon Schlinkert.
       * Released under the MIT License.
       */
      function isObject$1(o2) {
        return Object.prototype.toString.call(o2) === "[object Object]";
      }
      function isPlainObject$1(o2) {
        var ctor, prot;
        if (isObject$1(o2) === false)
          return false;
        ctor = o2.constructor;
        if (ctor === void 0)
          return true;
        prot = ctor.prototype;
        if (isObject$1(prot) === false)
          return false;
        if (prot.hasOwnProperty("isPrototypeOf") === false) {
          return false;
        }
        return true;
      }
      function t$1() {
        return t$1 = Object.assign || function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var r2 = arguments[t2];
            for (var n2 in r2)
              Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
          }
          return e2;
        }, t$1.apply(this, arguments);
      }
      function r$1(e2, t2) {
        if (e2 == null)
          return {};
        var r2, n2, i2 = {}, o2 = Object.keys(e2);
        for (n2 = 0; n2 < o2.length; n2++)
          t2.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e2[r2]);
        return i2;
      }
      const n$1 = { silent: false, logLevel: "warn" }, i$1 = ["validator"], o$1 = Object.prototype, a$1 = o$1.toString, s$1 = o$1.hasOwnProperty, u$1 = /^\s*function (\w+)/;
      function l$1(e2) {
        var t2;
        const r2 = (t2 = e2 == null ? void 0 : e2.type) !== null && t2 !== void 0 ? t2 : e2;
        if (r2) {
          const e3 = r2.toString().match(u$1);
          return e3 ? e3[1] : "";
        }
        return "";
      }
      const c$1 = isPlainObject$1, f$1 = (e2) => e2;
      let d$1 = f$1;
      {
        const e2 = typeof console != "undefined";
        d$1 = e2 ? function(e3, t2 = n$1.logLevel) {
          n$1.silent === false && console[t2](`[VueTypes warn]: ${e3}`);
        } : f$1;
      }
      const p$1 = (e2, t2) => s$1.call(e2, t2), y$1 = Number.isInteger || function(e2) {
        return typeof e2 == "number" && isFinite(e2) && Math.floor(e2) === e2;
      }, v$1 = Array.isArray || function(e2) {
        return a$1.call(e2) === "[object Array]";
      }, h$1 = (e2) => a$1.call(e2) === "[object Function]", b$1 = (e2) => c$1(e2) && p$1(e2, "_vueTypes_name"), g$1 = (e2) => c$1(e2) && (p$1(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t2) => p$1(e2, t2)));
      function O$1(e2, t2) {
        return Object.defineProperty(e2.bind(t2), "__original", { value: e2 });
      }
      function m$1(e2, t2, r2 = false) {
        let n2, i2 = true, o2 = "";
        n2 = c$1(e2) ? e2 : { type: e2 };
        const a2 = b$1(n2) ? n2._vueTypes_name + " - " : "";
        if (g$1(n2) && n2.type !== null) {
          if (n2.type === void 0 || n2.type === true)
            return i2;
          if (!n2.required && t2 === void 0)
            return i2;
          v$1(n2.type) ? (i2 = n2.type.some((e3) => m$1(e3, t2, true) === true), o2 = n2.type.map((e3) => l$1(e3)).join(" or ")) : (o2 = l$1(n2), i2 = o2 === "Array" ? v$1(t2) : o2 === "Object" ? c$1(t2) : o2 === "String" || o2 === "Number" || o2 === "Boolean" || o2 === "Function" ? function(e3) {
            if (e3 == null)
              return "";
            const t3 = e3.constructor.toString().match(u$1);
            return t3 ? t3[1] : "";
          }(t2) === o2 : t2 instanceof n2.type);
        }
        if (!i2) {
          const e3 = `${a2}value "${t2}" should be of type "${o2}"`;
          return r2 === false ? (d$1(e3), false) : e3;
        }
        if (p$1(n2, "validator") && h$1(n2.validator)) {
          const e3 = d$1, o3 = [];
          if (d$1 = (e4) => {
            o3.push(e4);
          }, i2 = n2.validator(t2), d$1 = e3, !i2) {
            const e4 = (o3.length > 1 ? "* " : "") + o3.join("\n* ");
            return o3.length = 0, r2 === false ? (d$1(e4), i2) : e4;
          }
        }
        return i2;
      }
      function j$1(e2, t2) {
        const r2 = Object.defineProperties(t2, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
          return this.required = true, this;
        } }, def: { value(e3) {
          return e3 === void 0 ? (p$1(this, "default") && delete this.default, this) : h$1(e3) || m$1(this, e3, true) === true ? (this.default = v$1(e3) ? () => [...e3] : c$1(e3) ? () => Object.assign({}, e3) : e3, this) : (d$1(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
        } } }), { validator: n2 } = r2;
        return h$1(n2) && (r2.validator = O$1(n2, r2)), r2;
      }
      function _$1(e2, t2) {
        const r2 = j$1(e2, t2);
        return Object.defineProperty(r2, "validate", { value(e3) {
          return h$1(this.validator) && d$1(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O$1(e3, this), this;
        } });
      }
      function T$1(e2, t2, n2) {
        const o2 = function(e3) {
          const t3 = {};
          return Object.getOwnPropertyNames(e3).forEach((r2) => {
            t3[r2] = Object.getOwnPropertyDescriptor(e3, r2);
          }), Object.defineProperties({}, t3);
        }(t2);
        if (o2._vueTypes_name = e2, !c$1(n2))
          return o2;
        const { validator: a2 } = n2, s2 = r$1(n2, i$1);
        if (h$1(a2)) {
          let { validator: e3 } = o2;
          e3 && (e3 = (l2 = (u2 = e3).__original) !== null && l2 !== void 0 ? l2 : u2), o2.validator = O$1(e3 ? function(t3) {
            return e3.call(this, t3) && a2.call(this, t3);
          } : a2, o2);
        }
        var u2, l2;
        return Object.assign(o2, s2);
      }
      function $$1(e2) {
        return e2.replace(/^(?!\s*$)/gm, "  ");
      }
      const w$1 = () => _$1("any", {}), P$1 = () => _$1("function", { type: Function }), x$1 = () => _$1("boolean", { type: Boolean }), E$1 = () => _$1("string", { type: String }), N$1 = () => _$1("number", { type: Number }), q$1 = () => _$1("array", { type: Array }), A$1 = () => _$1("object", { type: Object }), V$1 = () => j$1("integer", { type: Number, validator: (e2) => y$1(e2) }), S$1 = () => j$1("symbol", { validator: (e2) => typeof e2 == "symbol" });
      function k$1(e2, t2 = "custom validation failed") {
        if (typeof e2 != "function")
          throw new TypeError("[VueTypes error]: You must provide a function as argument");
        return j$1(e2.name || "<<anonymous function>>", { type: null, validator(r2) {
          const n2 = e2(r2);
          return n2 || d$1(`${this._vueTypes_name} - ${t2}`), n2;
        } });
      }
      function D$1(e2) {
        if (!v$1(e2))
          throw new TypeError("[VueTypes error]: You must provide an array as argument.");
        const t2 = `oneOf - value should be one of "${e2.join('", "')}".`, r2 = e2.reduce((e3, t3) => {
          if (t3 != null) {
            const r3 = t3.constructor;
            e3.indexOf(r3) === -1 && e3.push(r3);
          }
          return e3;
        }, []);
        return j$1("oneOf", { type: r2.length > 0 ? r2 : void 0, validator(r3) {
          const n2 = e2.indexOf(r3) !== -1;
          return n2 || d$1(t2), n2;
        } });
      }
      function L$1(e2) {
        if (!v$1(e2))
          throw new TypeError("[VueTypes error]: You must provide an array as argument");
        let t2 = false, r2 = [];
        for (let n3 = 0; n3 < e2.length; n3 += 1) {
          const i2 = e2[n3];
          if (g$1(i2)) {
            if (b$1(i2) && i2._vueTypes_name === "oneOf" && i2.type) {
              r2 = r2.concat(i2.type);
              continue;
            }
            if (h$1(i2.validator) && (t2 = true), i2.type === true || !i2.type) {
              d$1('oneOfType - invalid usage of "true" or "null" as types.');
              continue;
            }
            r2 = r2.concat(i2.type);
          } else
            r2.push(i2);
        }
        r2 = r2.filter((e3, t3) => r2.indexOf(e3) === t3);
        const n2 = r2.length > 0 ? r2 : null;
        return j$1("oneOfType", t2 ? { type: n2, validator(t3) {
          const r3 = [], n3 = e2.some((e3) => {
            const n4 = m$1(b$1(e3) && e3._vueTypes_name === "oneOf" ? e3.type || null : e3, t3, true);
            return typeof n4 == "string" && r3.push(n4), n4 === true;
          });
          return n3 || d$1(`oneOfType - provided value does not match any of the ${r3.length} passed-in validators:
${$$1(r3.join("\n"))}`), n3;
        } } : { type: n2 });
      }
      function F$1(e2) {
        return j$1("arrayOf", { type: Array, validator(t2) {
          let r2 = "";
          const n2 = t2.every((t3) => (r2 = m$1(e2, t3, true), r2 === true));
          return n2 || d$1(`arrayOf - value validation error:
${$$1(r2)}`), n2;
        } });
      }
      function Y$1(e2) {
        return j$1("instanceOf", { type: e2 });
      }
      function B$1(e2) {
        return j$1("objectOf", { type: Object, validator(t2) {
          let r2 = "";
          const n2 = Object.keys(t2).every((n3) => (r2 = m$1(e2, t2[n3], true), r2 === true));
          return n2 || d$1(`objectOf - value validation error:
${$$1(r2)}`), n2;
        } });
      }
      function I$1(e2) {
        const t2 = Object.keys(e2), r2 = t2.filter((t3) => {
          var r3;
          return !((r3 = e2[t3]) === null || r3 === void 0 || !r3.required);
        }), n2 = j$1("shape", { type: Object, validator(n3) {
          if (!c$1(n3))
            return false;
          const i2 = Object.keys(n3);
          if (r2.length > 0 && r2.some((e3) => i2.indexOf(e3) === -1)) {
            const e3 = r2.filter((e4) => i2.indexOf(e4) === -1);
            return d$1(e3.length === 1 ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
          }
          return i2.every((r3) => {
            if (t2.indexOf(r3) === -1)
              return this._vueTypes_isLoose === true || (d$1(`shape - shape definition does not include a "${r3}" property. Allowed keys: "${t2.join('", "')}".`), false);
            const i3 = m$1(e2[r3], n3[r3], true);
            return typeof i3 == "string" && d$1(`shape - "${r3}" property validation error:
 ${$$1(i3)}`), i3 === true;
          });
        } });
        return Object.defineProperty(n2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n2, "loose", { get() {
          return this._vueTypes_isLoose = true, this;
        } }), n2;
      }
      const J$1 = ["name", "validate", "getter"], M$1 = /* @__PURE__ */ (() => {
        var e2, t2;
        return t2 = e2 = class {
          static get any() {
            return w$1();
          }
          static get func() {
            return P$1().def(this.defaults.func);
          }
          static get bool() {
            return x$1().def(this.defaults.bool);
          }
          static get string() {
            return E$1().def(this.defaults.string);
          }
          static get number() {
            return N$1().def(this.defaults.number);
          }
          static get array() {
            return q$1().def(this.defaults.array);
          }
          static get object() {
            return A$1().def(this.defaults.object);
          }
          static get integer() {
            return V$1().def(this.defaults.integer);
          }
          static get symbol() {
            return S$1();
          }
          static extend(e3) {
            if (v$1(e3))
              return e3.forEach((e4) => this.extend(e4)), this;
            const { name: t3, validate: n2 = false, getter: i2 = false } = e3, o2 = r$1(e3, J$1);
            if (p$1(this, t3))
              throw new TypeError(`[VueTypes error]: Type "${t3}" already defined`);
            const { type: a2 } = o2;
            if (b$1(a2))
              return delete o2.type, Object.defineProperty(this, t3, i2 ? { get: () => T$1(t3, a2, o2) } : { value(...e4) {
                const r2 = T$1(t3, a2, o2);
                return r2.validator && (r2.validator = r2.validator.bind(r2, ...e4)), r2;
              } });
            let s2;
            return s2 = i2 ? { get() {
              const e4 = Object.assign({}, o2);
              return n2 ? _$1(t3, e4) : j$1(t3, e4);
            }, enumerable: true } : { value(...e4) {
              const r2 = Object.assign({}, o2);
              let i3;
              return i3 = n2 ? _$1(t3, r2) : j$1(t3, r2), r2.validator && (i3.validator = r2.validator.bind(i3, ...e4)), i3;
            }, enumerable: true }, Object.defineProperty(this, t3, s2);
          }
        }, e2.defaults = {}, e2.sensibleDefaults = void 0, e2.config = n$1, e2.custom = k$1, e2.oneOf = D$1, e2.instanceOf = Y$1, e2.oneOfType = L$1, e2.arrayOf = F$1, e2.objectOf = B$1, e2.shape = I$1, e2.utils = { validate: (e3, t3) => m$1(t3, e3, true) === true, toType: (e3, t3, r2 = false) => r2 ? _$1(e3, t3) : j$1(e3, t3) }, t2;
      })();
      function R$1(e2 = { func: () => {
      }, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
        var r2, n2;
        return n2 = r2 = class extends M$1 {
          static get sensibleDefaults() {
            return t$1({}, this.defaults);
          }
          static set sensibleDefaults(r3) {
            this.defaults = r3 !== false ? t$1({}, r3 !== true ? r3 : e2) : {};
          }
        }, r2.defaults = t$1({}, e2), n2;
      }
      class z$1 extends R$1() {
      }
      var tinycolor$1 = { exports: {} };
      (function(module2) {
        (function(Math2) {
          var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
          function tinycolor2(color, opts) {
            color = color ? color : "";
            opts = opts || {};
            if (color instanceof tinycolor2) {
              return color;
            }
            if (!(this instanceof tinycolor2)) {
              return new tinycolor2(color, opts);
            }
            var rgb = inputToRGB(color);
            this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format;
            this._gradientType = opts.gradientType;
            if (this._r < 1) {
              this._r = mathRound(this._r);
            }
            if (this._g < 1) {
              this._g = mathRound(this._g);
            }
            if (this._b < 1) {
              this._b = mathRound(this._b);
            }
            this._ok = rgb.ok;
            this._tc_id = tinyCounter++;
          }
          tinycolor2.prototype = {
            isDark: function() {
              return this.getBrightness() < 128;
            },
            isLight: function() {
              return !this.isDark();
            },
            isValid: function() {
              return this._ok;
            },
            getOriginalInput: function() {
              return this._originalInput;
            },
            getFormat: function() {
              return this._format;
            },
            getAlpha: function() {
              return this._a;
            },
            getBrightness: function() {
              var rgb = this.toRgb();
              return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
            },
            getLuminance: function() {
              var rgb = this.toRgb();
              var RsRGB, GsRGB, BsRGB, R2, G2, B2;
              RsRGB = rgb.r / 255;
              GsRGB = rgb.g / 255;
              BsRGB = rgb.b / 255;
              if (RsRGB <= 0.03928) {
                R2 = RsRGB / 12.92;
              } else {
                R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
              }
              if (GsRGB <= 0.03928) {
                G2 = GsRGB / 12.92;
              } else {
                G2 = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
              }
              if (BsRGB <= 0.03928) {
                B2 = BsRGB / 12.92;
              } else {
                B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
              }
              return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
            },
            setAlpha: function(value) {
              this._a = boundAlpha(value);
              this._roundA = mathRound(100 * this._a) / 100;
              return this;
            },
            toHsv: function() {
              var hsv = rgbToHsv(this._r, this._g, this._b);
              return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
            },
            toHsvString: function() {
              var hsv = rgbToHsv(this._r, this._g, this._b);
              var h2 = mathRound(hsv.h * 360), s2 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
              return this._a == 1 ? "hsv(" + h2 + ", " + s2 + "%, " + v2 + "%)" : "hsva(" + h2 + ", " + s2 + "%, " + v2 + "%, " + this._roundA + ")";
            },
            toHsl: function() {
              var hsl = rgbToHsl(this._r, this._g, this._b);
              return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
            },
            toHslString: function() {
              var hsl = rgbToHsl(this._r, this._g, this._b);
              var h2 = mathRound(hsl.h * 360), s2 = mathRound(hsl.s * 100), l2 = mathRound(hsl.l * 100);
              return this._a == 1 ? "hsl(" + h2 + ", " + s2 + "%, " + l2 + "%)" : "hsla(" + h2 + ", " + s2 + "%, " + l2 + "%, " + this._roundA + ")";
            },
            toHex: function(allow3Char) {
              return rgbToHex(this._r, this._g, this._b, allow3Char);
            },
            toHexString: function(allow3Char) {
              return "#" + this.toHex(allow3Char);
            },
            toHex8: function(allow4Char) {
              return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
            },
            toHex8String: function(allow4Char) {
              return "#" + this.toHex8(allow4Char);
            },
            toRgb: function() {
              return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
            },
            toRgbString: function() {
              return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
            },
            toPercentageRgb: function() {
              return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
            },
            toPercentageRgbString: function() {
              return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
            },
            toName: function() {
              if (this._a === 0) {
                return "transparent";
              }
              if (this._a < 1) {
                return false;
              }
              return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
            },
            toFilter: function(secondColor) {
              var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
              var secondHex8String = hex8String;
              var gradientType = this._gradientType ? "GradientType = 1, " : "";
              if (secondColor) {
                var s2 = tinycolor2(secondColor);
                secondHex8String = "#" + rgbaToArgbHex(s2._r, s2._g, s2._b, s2._a);
              }
              return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
            },
            toString: function(format2) {
              var formatSet = !!format2;
              format2 = format2 || this._format;
              var formattedString = false;
              var hasAlpha = this._a < 1 && this._a >= 0;
              var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
              if (needsAlphaFormat) {
                if (format2 === "name" && this._a === 0) {
                  return this.toName();
                }
                return this.toRgbString();
              }
              if (format2 === "rgb") {
                formattedString = this.toRgbString();
              }
              if (format2 === "prgb") {
                formattedString = this.toPercentageRgbString();
              }
              if (format2 === "hex" || format2 === "hex6") {
                formattedString = this.toHexString();
              }
              if (format2 === "hex3") {
                formattedString = this.toHexString(true);
              }
              if (format2 === "hex4") {
                formattedString = this.toHex8String(true);
              }
              if (format2 === "hex8") {
                formattedString = this.toHex8String();
              }
              if (format2 === "name") {
                formattedString = this.toName();
              }
              if (format2 === "hsl") {
                formattedString = this.toHslString();
              }
              if (format2 === "hsv") {
                formattedString = this.toHsvString();
              }
              return formattedString || this.toHexString();
            },
            clone: function() {
              return tinycolor2(this.toString());
            },
            _applyModification: function(fn2, args) {
              var color = fn2.apply(null, [this].concat([].slice.call(args)));
              this._r = color._r;
              this._g = color._g;
              this._b = color._b;
              this.setAlpha(color._a);
              return this;
            },
            lighten: function() {
              return this._applyModification(lighten, arguments);
            },
            brighten: function() {
              return this._applyModification(brighten, arguments);
            },
            darken: function() {
              return this._applyModification(darken, arguments);
            },
            desaturate: function() {
              return this._applyModification(desaturate, arguments);
            },
            saturate: function() {
              return this._applyModification(saturate, arguments);
            },
            greyscale: function() {
              return this._applyModification(greyscale, arguments);
            },
            spin: function() {
              return this._applyModification(spin, arguments);
            },
            _applyCombination: function(fn2, args) {
              return fn2.apply(null, [this].concat([].slice.call(args)));
            },
            analogous: function() {
              return this._applyCombination(analogous, arguments);
            },
            complement: function() {
              return this._applyCombination(complement, arguments);
            },
            monochromatic: function() {
              return this._applyCombination(monochromatic, arguments);
            },
            splitcomplement: function() {
              return this._applyCombination(splitcomplement, arguments);
            },
            triad: function() {
              return this._applyCombination(triad, arguments);
            },
            tetrad: function() {
              return this._applyCombination(tetrad, arguments);
            }
          };
          tinycolor2.fromRatio = function(color, opts) {
            if (typeof color == "object") {
              var newColor = {};
              for (var i2 in color) {
                if (color.hasOwnProperty(i2)) {
                  if (i2 === "a") {
                    newColor[i2] = color[i2];
                  } else {
                    newColor[i2] = convertToPercentage(color[i2]);
                  }
                }
              }
              color = newColor;
            }
            return tinycolor2(color, opts);
          };
          function inputToRGB(color) {
            var rgb = { r: 0, g: 0, b: 0 };
            var a2 = 1;
            var s2 = null;
            var v2 = null;
            var l2 = null;
            var ok = false;
            var format2 = false;
            if (typeof color == "string") {
              color = stringInputToObject(color);
            }
            if (typeof color == "object") {
              if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
              } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
                s2 = convertToPercentage(color.s);
                v2 = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, s2, v2);
                ok = true;
                format2 = "hsv";
              } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
                s2 = convertToPercentage(color.s);
                l2 = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, s2, l2);
                ok = true;
                format2 = "hsl";
              }
              if (color.hasOwnProperty("a")) {
                a2 = color.a;
              }
            }
            a2 = boundAlpha(a2);
            return {
              ok,
              format: color.format || format2,
              r: mathMin(255, mathMax(rgb.r, 0)),
              g: mathMin(255, mathMax(rgb.g, 0)),
              b: mathMin(255, mathMax(rgb.b, 0)),
              a: a2
            };
          }
          function rgbToRgb(r2, g2, b2) {
            return {
              r: bound01(r2, 255) * 255,
              g: bound01(g2, 255) * 255,
              b: bound01(b2, 255) * 255
            };
          }
          function rgbToHsl(r2, g2, b2) {
            r2 = bound01(r2, 255);
            g2 = bound01(g2, 255);
            b2 = bound01(b2, 255);
            var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
            var h2, s2, l2 = (max2 + min2) / 2;
            if (max2 == min2) {
              h2 = s2 = 0;
            } else {
              var d2 = max2 - min2;
              s2 = l2 > 0.5 ? d2 / (2 - max2 - min2) : d2 / (max2 + min2);
              switch (max2) {
                case r2:
                  h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
                  break;
                case g2:
                  h2 = (b2 - r2) / d2 + 2;
                  break;
                case b2:
                  h2 = (r2 - g2) / d2 + 4;
                  break;
              }
              h2 /= 6;
            }
            return { h: h2, s: s2, l: l2 };
          }
          function hslToRgb(h2, s2, l2) {
            var r2, g2, b2;
            h2 = bound01(h2, 360);
            s2 = bound01(s2, 100);
            l2 = bound01(l2, 100);
            function hue2rgb(p3, q3, t2) {
              if (t2 < 0)
                t2 += 1;
              if (t2 > 1)
                t2 -= 1;
              if (t2 < 1 / 6)
                return p3 + (q3 - p3) * 6 * t2;
              if (t2 < 1 / 2)
                return q3;
              if (t2 < 2 / 3)
                return p3 + (q3 - p3) * (2 / 3 - t2) * 6;
              return p3;
            }
            if (s2 === 0) {
              r2 = g2 = b2 = l2;
            } else {
              var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
              var p2 = 2 * l2 - q2;
              r2 = hue2rgb(p2, q2, h2 + 1 / 3);
              g2 = hue2rgb(p2, q2, h2);
              b2 = hue2rgb(p2, q2, h2 - 1 / 3);
            }
            return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
          }
          function rgbToHsv(r2, g2, b2) {
            r2 = bound01(r2, 255);
            g2 = bound01(g2, 255);
            b2 = bound01(b2, 255);
            var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
            var h2, s2, v2 = max2;
            var d2 = max2 - min2;
            s2 = max2 === 0 ? 0 : d2 / max2;
            if (max2 == min2) {
              h2 = 0;
            } else {
              switch (max2) {
                case r2:
                  h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
                  break;
                case g2:
                  h2 = (b2 - r2) / d2 + 2;
                  break;
                case b2:
                  h2 = (r2 - g2) / d2 + 4;
                  break;
              }
              h2 /= 6;
            }
            return { h: h2, s: s2, v: v2 };
          }
          function hsvToRgb(h2, s2, v2) {
            h2 = bound01(h2, 360) * 6;
            s2 = bound01(s2, 100);
            v2 = bound01(v2, 100);
            var i2 = Math2.floor(h2), f2 = h2 - i2, p2 = v2 * (1 - s2), q2 = v2 * (1 - f2 * s2), t2 = v2 * (1 - (1 - f2) * s2), mod = i2 % 6, r2 = [v2, q2, p2, p2, t2, v2][mod], g2 = [t2, v2, v2, q2, p2, p2][mod], b2 = [p2, p2, t2, v2, v2, q2][mod];
            return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
          }
          function rgbToHex(r2, g2, b2, allow3Char) {
            var hex = [
              pad2(mathRound(r2).toString(16)),
              pad2(mathRound(g2).toString(16)),
              pad2(mathRound(b2).toString(16))
            ];
            if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
            }
            return hex.join("");
          }
          function rgbaToHex(r2, g2, b2, a2, allow4Char) {
            var hex = [
              pad2(mathRound(r2).toString(16)),
              pad2(mathRound(g2).toString(16)),
              pad2(mathRound(b2).toString(16)),
              pad2(convertDecimalToHex(a2))
            ];
            if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
              return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
            }
            return hex.join("");
          }
          function rgbaToArgbHex(r2, g2, b2, a2) {
            var hex = [
              pad2(convertDecimalToHex(a2)),
              pad2(mathRound(r2).toString(16)),
              pad2(mathRound(g2).toString(16)),
              pad2(mathRound(b2).toString(16))
            ];
            return hex.join("");
          }
          tinycolor2.equals = function(color1, color2) {
            if (!color1 || !color2) {
              return false;
            }
            return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
          };
          tinycolor2.random = function() {
            return tinycolor2.fromRatio({
              r: mathRandom(),
              g: mathRandom(),
              b: mathRandom()
            });
          };
          function desaturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.s -= amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor2(hsl);
          }
          function saturate(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.s += amount / 100;
            hsl.s = clamp01(hsl.s);
            return tinycolor2(hsl);
          }
          function greyscale(color) {
            return tinycolor2(color).desaturate(100);
          }
          function lighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.l += amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor2(hsl);
          }
          function brighten(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var rgb = tinycolor2(color).toRgb();
            rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
            rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
            rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
            return tinycolor2(rgb);
          }
          function darken(color, amount) {
            amount = amount === 0 ? 0 : amount || 10;
            var hsl = tinycolor2(color).toHsl();
            hsl.l -= amount / 100;
            hsl.l = clamp01(hsl.l);
            return tinycolor2(hsl);
          }
          function spin(color, amount) {
            var hsl = tinycolor2(color).toHsl();
            var hue = (hsl.h + amount) % 360;
            hsl.h = hue < 0 ? 360 + hue : hue;
            return tinycolor2(hsl);
          }
          function complement(color) {
            var hsl = tinycolor2(color).toHsl();
            hsl.h = (hsl.h + 180) % 360;
            return tinycolor2(hsl);
          }
          function triad(color) {
            var hsl = tinycolor2(color).toHsl();
            var h2 = hsl.h;
            return [
              tinycolor2(color),
              tinycolor2({ h: (h2 + 120) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h2 + 240) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function tetrad(color) {
            var hsl = tinycolor2(color).toHsl();
            var h2 = hsl.h;
            return [
              tinycolor2(color),
              tinycolor2({ h: (h2 + 90) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h2 + 180) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h2 + 270) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function splitcomplement(color) {
            var hsl = tinycolor2(color).toHsl();
            var h2 = hsl.h;
            return [
              tinycolor2(color),
              tinycolor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
              tinycolor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
            ];
          }
          function analogous(color, results, slices) {
            results = results || 6;
            slices = slices || 30;
            var hsl = tinycolor2(color).toHsl();
            var part = 360 / slices;
            var ret = [tinycolor2(color)];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
              hsl.h = (hsl.h + part) % 360;
              ret.push(tinycolor2(hsl));
            }
            return ret;
          }
          function monochromatic(color, results) {
            results = results || 6;
            var hsv = tinycolor2(color).toHsv();
            var h2 = hsv.h, s2 = hsv.s, v2 = hsv.v;
            var ret = [];
            var modification = 1 / results;
            while (results--) {
              ret.push(tinycolor2({ h: h2, s: s2, v: v2 }));
              v2 = (v2 + modification) % 1;
            }
            return ret;
          }
          tinycolor2.mix = function(color1, color2, amount) {
            amount = amount === 0 ? 0 : amount || 50;
            var rgb1 = tinycolor2(color1).toRgb();
            var rgb2 = tinycolor2(color2).toRgb();
            var p2 = amount / 100;
            var rgba = {
              r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
              g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
              b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
              a: (rgb2.a - rgb1.a) * p2 + rgb1.a
            };
            return tinycolor2(rgba);
          };
          tinycolor2.readability = function(color1, color2) {
            var c1 = tinycolor2(color1);
            var c2 = tinycolor2(color2);
            return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
          };
          tinycolor2.isReadable = function(color1, color2, wcag2) {
            var readability = tinycolor2.readability(color1, color2);
            var wcag2Parms, out;
            out = false;
            wcag2Parms = validateWCAG2Parms(wcag2);
            switch (wcag2Parms.level + wcag2Parms.size) {
              case "AAsmall":
              case "AAAlarge":
                out = readability >= 4.5;
                break;
              case "AAlarge":
                out = readability >= 3;
                break;
              case "AAAsmall":
                out = readability >= 7;
                break;
            }
            return out;
          };
          tinycolor2.mostReadable = function(baseColor, colorList, args) {
            var bestColor = null;
            var bestScore = 0;
            var readability;
            var includeFallbackColors, level, size;
            args = args || {};
            includeFallbackColors = args.includeFallbackColors;
            level = args.level;
            size = args.size;
            for (var i2 = 0; i2 < colorList.length; i2++) {
              readability = tinycolor2.readability(baseColor, colorList[i2]);
              if (readability > bestScore) {
                bestScore = readability;
                bestColor = tinycolor2(colorList[i2]);
              }
            }
            if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
              return bestColor;
            } else {
              args.includeFallbackColors = false;
              return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
            }
          };
          var names = tinycolor2.names = {
            aliceblue: "f0f8ff",
            antiquewhite: "faebd7",
            aqua: "0ff",
            aquamarine: "7fffd4",
            azure: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "000",
            blanchedalmond: "ffebcd",
            blue: "00f",
            blueviolet: "8a2be2",
            brown: "a52a2a",
            burlywood: "deb887",
            burntsienna: "ea7e5d",
            cadetblue: "5f9ea0",
            chartreuse: "7fff00",
            chocolate: "d2691e",
            coral: "ff7f50",
            cornflowerblue: "6495ed",
            cornsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "0ff",
            darkblue: "00008b",
            darkcyan: "008b8b",
            darkgoldenrod: "b8860b",
            darkgray: "a9a9a9",
            darkgreen: "006400",
            darkgrey: "a9a9a9",
            darkkhaki: "bdb76b",
            darkmagenta: "8b008b",
            darkolivegreen: "556b2f",
            darkorange: "ff8c00",
            darkorchid: "9932cc",
            darkred: "8b0000",
            darksalmon: "e9967a",
            darkseagreen: "8fbc8f",
            darkslateblue: "483d8b",
            darkslategray: "2f4f4f",
            darkslategrey: "2f4f4f",
            darkturquoise: "00ced1",
            darkviolet: "9400d3",
            deeppink: "ff1493",
            deepskyblue: "00bfff",
            dimgray: "696969",
            dimgrey: "696969",
            dodgerblue: "1e90ff",
            firebrick: "b22222",
            floralwhite: "fffaf0",
            forestgreen: "228b22",
            fuchsia: "f0f",
            gainsboro: "dcdcdc",
            ghostwhite: "f8f8ff",
            gold: "ffd700",
            goldenrod: "daa520",
            gray: "808080",
            green: "008000",
            greenyellow: "adff2f",
            grey: "808080",
            honeydew: "f0fff0",
            hotpink: "ff69b4",
            indianred: "cd5c5c",
            indigo: "4b0082",
            ivory: "fffff0",
            khaki: "f0e68c",
            lavender: "e6e6fa",
            lavenderblush: "fff0f5",
            lawngreen: "7cfc00",
            lemonchiffon: "fffacd",
            lightblue: "add8e6",
            lightcoral: "f08080",
            lightcyan: "e0ffff",
            lightgoldenrodyellow: "fafad2",
            lightgray: "d3d3d3",
            lightgreen: "90ee90",
            lightgrey: "d3d3d3",
            lightpink: "ffb6c1",
            lightsalmon: "ffa07a",
            lightseagreen: "20b2aa",
            lightskyblue: "87cefa",
            lightslategray: "789",
            lightslategrey: "789",
            lightsteelblue: "b0c4de",
            lightyellow: "ffffe0",
            lime: "0f0",
            limegreen: "32cd32",
            linen: "faf0e6",
            magenta: "f0f",
            maroon: "800000",
            mediumaquamarine: "66cdaa",
            mediumblue: "0000cd",
            mediumorchid: "ba55d3",
            mediumpurple: "9370db",
            mediumseagreen: "3cb371",
            mediumslateblue: "7b68ee",
            mediumspringgreen: "00fa9a",
            mediumturquoise: "48d1cc",
            mediumvioletred: "c71585",
            midnightblue: "191970",
            mintcream: "f5fffa",
            mistyrose: "ffe4e1",
            moccasin: "ffe4b5",
            navajowhite: "ffdead",
            navy: "000080",
            oldlace: "fdf5e6",
            olive: "808000",
            olivedrab: "6b8e23",
            orange: "ffa500",
            orangered: "ff4500",
            orchid: "da70d6",
            palegoldenrod: "eee8aa",
            palegreen: "98fb98",
            paleturquoise: "afeeee",
            palevioletred: "db7093",
            papayawhip: "ffefd5",
            peachpuff: "ffdab9",
            peru: "cd853f",
            pink: "ffc0cb",
            plum: "dda0dd",
            powderblue: "b0e0e6",
            purple: "800080",
            rebeccapurple: "663399",
            red: "f00",
            rosybrown: "bc8f8f",
            royalblue: "4169e1",
            saddlebrown: "8b4513",
            salmon: "fa8072",
            sandybrown: "f4a460",
            seagreen: "2e8b57",
            seashell: "fff5ee",
            sienna: "a0522d",
            silver: "c0c0c0",
            skyblue: "87ceeb",
            slateblue: "6a5acd",
            slategray: "708090",
            slategrey: "708090",
            snow: "fffafa",
            springgreen: "00ff7f",
            steelblue: "4682b4",
            tan: "d2b48c",
            teal: "008080",
            thistle: "d8bfd8",
            tomato: "ff6347",
            turquoise: "40e0d0",
            violet: "ee82ee",
            wheat: "f5deb3",
            white: "fff",
            whitesmoke: "f5f5f5",
            yellow: "ff0",
            yellowgreen: "9acd32"
          };
          var hexNames = tinycolor2.hexNames = flip2(names);
          function flip2(o2) {
            var flipped = {};
            for (var i2 in o2) {
              if (o2.hasOwnProperty(i2)) {
                flipped[o2[i2]] = i2;
              }
            }
            return flipped;
          }
          function boundAlpha(a2) {
            a2 = parseFloat(a2);
            if (isNaN(a2) || a2 < 0 || a2 > 1) {
              a2 = 1;
            }
            return a2;
          }
          function bound01(n2, max2) {
            if (isOnePointZero(n2)) {
              n2 = "100%";
            }
            var processPercent = isPercentage(n2);
            n2 = mathMin(max2, mathMax(0, parseFloat(n2)));
            if (processPercent) {
              n2 = parseInt(n2 * max2, 10) / 100;
            }
            if (Math2.abs(n2 - max2) < 1e-6) {
              return 1;
            }
            return n2 % max2 / parseFloat(max2);
          }
          function clamp01(val) {
            return mathMin(1, mathMax(0, val));
          }
          function parseIntFromHex(val) {
            return parseInt(val, 16);
          }
          function isOnePointZero(n2) {
            return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
          }
          function isPercentage(n2) {
            return typeof n2 === "string" && n2.indexOf("%") != -1;
          }
          function pad2(c2) {
            return c2.length == 1 ? "0" + c2 : "" + c2;
          }
          function convertToPercentage(n2) {
            if (n2 <= 1) {
              n2 = n2 * 100 + "%";
            }
            return n2;
          }
          function convertDecimalToHex(d2) {
            return Math2.round(parseFloat(d2) * 255).toString(16);
          }
          function convertHexToDecimal(h2) {
            return parseIntFromHex(h2) / 255;
          }
          var matchers = function() {
            var CSS_INTEGER = "[-\\+]?\\d+%?";
            var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
            var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
            var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
            return {
              CSS_UNIT: new RegExp(CSS_UNIT),
              rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
              rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
              hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
              hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
              hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
              hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
              hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
              hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
              hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            };
          }();
          function isValidCSSUnit(color) {
            return !!matchers.CSS_UNIT.exec(color);
          }
          function stringInputToObject(color) {
            color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
            var named = false;
            if (names[color]) {
              color = names[color];
              named = true;
            } else if (color == "transparent") {
              return { r: 0, g: 0, b: 0, a: 0, format: "name" };
            }
            var match;
            if (match = matchers.rgb.exec(color)) {
              return { r: match[1], g: match[2], b: match[3] };
            }
            if (match = matchers.rgba.exec(color)) {
              return { r: match[1], g: match[2], b: match[3], a: match[4] };
            }
            if (match = matchers.hsl.exec(color)) {
              return { h: match[1], s: match[2], l: match[3] };
            }
            if (match = matchers.hsla.exec(color)) {
              return { h: match[1], s: match[2], l: match[3], a: match[4] };
            }
            if (match = matchers.hsv.exec(color)) {
              return { h: match[1], s: match[2], v: match[3] };
            }
            if (match = matchers.hsva.exec(color)) {
              return { h: match[1], s: match[2], v: match[3], a: match[4] };
            }
            if (match = matchers.hex8.exec(color)) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
              };
            }
            if (match = matchers.hex6.exec(color)) {
              return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
              };
            }
            if (match = matchers.hex4.exec(color)) {
              return {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                a: convertHexToDecimal(match[4] + "" + match[4]),
                format: named ? "name" : "hex8"
              };
            }
            if (match = matchers.hex3.exec(color)) {
              return {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                format: named ? "name" : "hex"
              };
            }
            return false;
          }
          function validateWCAG2Parms(parms) {
            var level, size;
            parms = parms || { "level": "AA", "size": "small" };
            level = (parms.level || "AA").toUpperCase();
            size = (parms.size || "small").toLowerCase();
            if (level !== "AA" && level !== "AAA") {
              level = "AA";
            }
            if (size !== "small" && size !== "large") {
              size = "small";
            }
            return { "level": level, "size": size };
          }
          if (module2.exports) {
            module2.exports = tinycolor2;
          } else {
            window.tinycolor = tinycolor2;
          }
        })(Math);
      })(tinycolor$1);
      var tinycolor = tinycolor$1.exports;
      function tryOnScopeDispose(fn2) {
        if (getCurrentScope()) {
          onScopeDispose(fn2);
          return true;
        }
        return false;
      }
      const isClient = typeof window !== "undefined";
      const isString = (val) => typeof val === "string";
      const noop = () => {
      };
      function createFilterWrapper(filter, fn2) {
        function wrapper(...args) {
          filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args });
        }
        return wrapper;
      }
      const bypassFilter = (invoke) => {
        return invoke();
      };
      function debounceFilter(ms, options = {}) {
        let timer;
        let maxTimer;
        const filter = (invoke) => {
          const duration = unref(ms);
          const maxDuration = unref(options.maxWait);
          if (timer)
            clearTimeout(timer);
          if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
            if (maxTimer) {
              clearTimeout(maxTimer);
              maxTimer = null;
            }
            return invoke();
          }
          if (maxDuration && !maxTimer) {
            maxTimer = setTimeout(() => {
              if (timer)
                clearTimeout(timer);
              maxTimer = null;
              invoke();
            }, maxDuration);
          }
          timer = setTimeout(() => {
            if (maxTimer)
              clearTimeout(maxTimer);
            maxTimer = null;
            invoke();
          }, duration);
        };
        return filter;
      }
      function useDebounceFn(fn2, ms = 200, options = {}) {
        return createFilterWrapper(debounceFilter(ms, options), fn2);
      }
      var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
      var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
      var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
      var __objRest$5 = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols$9)
          for (var prop of __getOwnPropSymbols$9(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function watchWithFilter(source, cb, options = {}) {
        const _a = options, {
          eventFilter = bypassFilter
        } = _a, watchOptions = __objRest$5(_a, [
          "eventFilter"
        ]);
        return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
      }
      function tryOnMounted(fn2, sync = true) {
        if (getCurrentInstance())
          onMounted(fn2);
        else if (sync)
          fn2();
        else
          nextTick(fn2);
      }
      function whenever(source, cb, options) {
        return watch(source, (v2, ov, onInvalidate) => {
          if (v2)
            cb(v2, ov, onInvalidate);
        }, options);
      }
      function unrefElement(elRef) {
        var _a;
        const plain = unref(elRef);
        return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
      }
      const defaultWindow = isClient ? window : void 0;
      function useEventListener(...args) {
        let target;
        let event;
        let listener;
        let options;
        if (isString(args[0])) {
          [event, listener, options] = args;
          target = defaultWindow;
        } else {
          [target, event, listener, options] = args;
        }
        if (!target)
          return noop;
        let cleanup = noop;
        const stopWatch = watch(() => unref(target), (el) => {
          cleanup();
          if (!el)
            return;
          el.addEventListener(event, listener, options);
          cleanup = () => {
            el.removeEventListener(event, listener, options);
            cleanup = noop;
          };
        }, { immediate: true, flush: "post" });
        const stop = () => {
          stopWatch();
          cleanup();
        };
        tryOnScopeDispose(stop);
        return stop;
      }
      function onClickOutside(target, handler, options = {}) {
        const { window: window2 = defaultWindow, event = "pointerdown" } = options;
        if (!window2)
          return;
        const listener = (event2) => {
          const el = unrefElement(target);
          if (!el)
            return;
          if (el === event2.target || event2.composedPath().includes(el))
            return;
          handler(event2);
        };
        return useEventListener(window2, event, listener, { passive: true });
      }
      const StorageSerializers = {
        boolean: {
          read: (v2) => v2 === "true",
          write: (v2) => String(v2)
        },
        object: {
          read: (v2) => JSON.parse(v2),
          write: (v2) => JSON.stringify(v2)
        },
        number: {
          read: (v2) => Number.parseFloat(v2),
          write: (v2) => String(v2)
        },
        any: {
          read: (v2) => v2,
          write: (v2) => String(v2)
        },
        string: {
          read: (v2) => v2,
          write: (v2) => String(v2)
        },
        map: {
          read: (v2) => new Map(JSON.parse(v2)),
          write: (v2) => JSON.stringify(Array.from(v2.entries()))
        },
        set: {
          read: (v2) => new Set(JSON.parse(v2)),
          write: (v2) => JSON.stringify(Array.from(v2.entries()))
        }
      };
      function useStorage(key, initialValue, storage = ((_a) => (_a = defaultWindow) == null ? void 0 : _a.localStorage)(), options = {}) {
        var _a2;
        const {
          flush = "pre",
          deep = true,
          listenToStorageChanges = true,
          writeDefaults = true,
          shallow,
          window: window2 = defaultWindow,
          eventFilter,
          onError = (e2) => {
            console.error(e2);
          }
        } = options;
        const rawInit = unref(initialValue);
        const type = rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
        const data2 = (shallow ? shallowRef : ref)(initialValue);
        const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
        function read2(event) {
          if (!storage || event && event.key !== key)
            return;
          try {
            const rawValue = event ? event.newValue : storage.getItem(key);
            if (rawValue == null) {
              data2.value = rawInit;
              if (writeDefaults && rawInit !== null)
                storage.setItem(key, serializer.write(rawInit));
            } else {
              data2.value = serializer.read(rawValue);
            }
          } catch (e2) {
            onError(e2);
          }
        }
        read2();
        if (window2 && listenToStorageChanges)
          useEventListener(window2, "storage", (e2) => setTimeout(() => read2(e2), 0));
        if (storage) {
          watchWithFilter(data2, () => {
            try {
              if (data2.value == null)
                storage.removeItem(key);
              else
                storage.setItem(key, serializer.write(data2.value));
            } catch (e2) {
              onError(e2);
            }
          }, {
            flush,
            deep,
            eventFilter
          });
        }
        return data2;
      }
      function useLocalStorage(key, initialValue, options = {}) {
        const { window: window2 = defaultWindow } = options;
        return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
      }
      var SwipeDirection;
      (function(SwipeDirection2) {
        SwipeDirection2["UP"] = "UP";
        SwipeDirection2["RIGHT"] = "RIGHT";
        SwipeDirection2["DOWN"] = "DOWN";
        SwipeDirection2["LEFT"] = "LEFT";
        SwipeDirection2["NONE"] = "NONE";
      })(SwipeDirection || (SwipeDirection = {}));
      var t = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
      function e(t2) {
        var e2 = { exports: {} };
        return t2(e2, e2.exports), e2.exports;
      }
      var n = function(t2) {
        return t2 && t2.Math == Math && t2;
      }, r = n(typeof globalThis == "object" && globalThis) || n(typeof window == "object" && window) || n(typeof self == "object" && self) || n(typeof t == "object" && t) || function() {
        return this;
      }() || Function("return this")(), o = function(t2) {
        try {
          return !!t2();
        } catch (t3) {
          return true;
        }
      }, i = !o(function() {
        return Object.defineProperty({}, 1, { get: function() {
          return 7;
        } })[1] != 7;
      }), u = {}.propertyIsEnumerable, a = Object.getOwnPropertyDescriptor, c = { f: a && !u.call({ 1: 2 }, 1) ? function(t2) {
        var e2 = a(this, t2);
        return !!e2 && e2.enumerable;
      } : u }, l = function(t2, e2) {
        return { enumerable: !(1 & t2), configurable: !(2 & t2), writable: !(4 & t2), value: e2 };
      }, f = {}.toString, s = function(t2) {
        return f.call(t2).slice(8, -1);
      }, d = "".split, v = o(function() {
        return !Object("z").propertyIsEnumerable(0);
      }) ? function(t2) {
        return s(t2) == "String" ? d.call(t2, "") : Object(t2);
      } : Object, p = function(t2) {
        if (t2 == null)
          throw TypeError("Can't call method on " + t2);
        return t2;
      }, g = function(t2) {
        return v(p(t2));
      }, h = function(t2) {
        return typeof t2 == "object" ? t2 !== null : typeof t2 == "function";
      }, y = function(t2, e2) {
        if (!h(t2))
          return t2;
        var n2, r2;
        if (e2 && typeof (n2 = t2.toString) == "function" && !h(r2 = n2.call(t2)))
          return r2;
        if (typeof (n2 = t2.valueOf) == "function" && !h(r2 = n2.call(t2)))
          return r2;
        if (!e2 && typeof (n2 = t2.toString) == "function" && !h(r2 = n2.call(t2)))
          return r2;
        throw TypeError("Can't convert object to primitive value");
      }, m = {}.hasOwnProperty, S = function(t2, e2) {
        return m.call(t2, e2);
      }, x = r.document, b = h(x) && h(x.createElement), E = function(t2) {
        return b ? x.createElement(t2) : {};
      }, w = !i && !o(function() {
        return Object.defineProperty(E("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      }), O = Object.getOwnPropertyDescriptor, T = { f: i ? O : function(t2, e2) {
        if (t2 = g(t2), e2 = y(e2, true), w)
          try {
            return O(t2, e2);
          } catch (t3) {
          }
        if (S(t2, e2))
          return l(!c.f.call(t2, e2), t2[e2]);
      } }, A = function(t2) {
        if (!h(t2))
          throw TypeError(String(t2) + " is not an object");
        return t2;
      }, k = Object.defineProperty, R = { f: i ? k : function(t2, e2, n2) {
        if (A(t2), e2 = y(e2, true), A(n2), w)
          try {
            return k(t2, e2, n2);
          } catch (t3) {
          }
        if ("get" in n2 || "set" in n2)
          throw TypeError("Accessors not supported");
        return "value" in n2 && (t2[e2] = n2.value), t2;
      } }, I = i ? function(t2, e2, n2) {
        return R.f(t2, e2, l(1, n2));
      } : function(t2, e2, n2) {
        return t2[e2] = n2, t2;
      }, j = function(t2, e2) {
        try {
          I(r, t2, e2);
        } catch (n2) {
          r[t2] = e2;
        }
        return e2;
      }, C = r["__core-js_shared__"] || j("__core-js_shared__", {}), L = Function.toString;
      typeof C.inspectSource != "function" && (C.inspectSource = function(t2) {
        return L.call(t2);
      });
      var P, M, _, D = C.inspectSource, U = r.WeakMap, N = typeof U == "function" && /native code/.test(D(U)), F = e(function(t2) {
        (t2.exports = function(t3, e2) {
          return C[t3] || (C[t3] = e2 !== void 0 ? e2 : {});
        })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
      }), W = 0, z = Math.random(), $ = function(t2) {
        return "Symbol(" + String(t2 === void 0 ? "" : t2) + ")_" + (++W + z).toString(36);
      }, B = F("keys"), Y = function(t2) {
        return B[t2] || (B[t2] = $(t2));
      }, G = {}, H = r.WeakMap;
      if (N) {
        var X = C.state || (C.state = new H()), V = X.get, K = X.has, q = X.set;
        P = function(t2, e2) {
          return e2.facade = t2, q.call(X, t2, e2), e2;
        }, M = function(t2) {
          return V.call(X, t2) || {};
        }, _ = function(t2) {
          return K.call(X, t2);
        };
      } else {
        var Q = Y("state");
        G[Q] = true, P = function(t2, e2) {
          return e2.facade = t2, I(t2, Q, e2), e2;
        }, M = function(t2) {
          return S(t2, Q) ? t2[Q] : {};
        }, _ = function(t2) {
          return S(t2, Q);
        };
      }
      var J = { set: P, get: M, has: _, enforce: function(t2) {
        return _(t2) ? M(t2) : P(t2, {});
      }, getterFor: function(t2) {
        return function(e2) {
          var n2;
          if (!h(e2) || (n2 = M(e2)).type !== t2)
            throw TypeError("Incompatible receiver, " + t2 + " required");
          return n2;
        };
      } }, Z = e(function(t2) {
        var e2 = J.get, n2 = J.enforce, o2 = String(String).split("String");
        (t2.exports = function(t3, e3, i2, u2) {
          var a2, c2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet;
          typeof i2 == "function" && (typeof e3 != "string" || S(i2, "name") || I(i2, "name", e3), (a2 = n2(i2)).source || (a2.source = o2.join(typeof e3 == "string" ? e3 : ""))), t3 !== r ? (c2 ? !f2 && t3[e3] && (l2 = true) : delete t3[e3], l2 ? t3[e3] = i2 : I(t3, e3, i2)) : l2 ? t3[e3] = i2 : j(e3, i2);
        })(Function.prototype, "toString", function() {
          return typeof this == "function" && e2(this).source || D(this);
        });
      }), tt = r, et = function(t2) {
        return typeof t2 == "function" ? t2 : void 0;
      }, nt = function(t2, e2) {
        return arguments.length < 2 ? et(tt[t2]) || et(r[t2]) : tt[t2] && tt[t2][e2] || r[t2] && r[t2][e2];
      }, rt = Math.ceil, ot = Math.floor, it = function(t2) {
        return isNaN(t2 = +t2) ? 0 : (t2 > 0 ? ot : rt)(t2);
      }, ut = Math.min, at = function(t2) {
        return t2 > 0 ? ut(it(t2), 9007199254740991) : 0;
      }, ct = Math.max, lt = Math.min, ft = function(t2, e2) {
        var n2 = it(t2);
        return n2 < 0 ? ct(n2 + e2, 0) : lt(n2, e2);
      }, st = function(t2) {
        return function(e2, n2, r2) {
          var o2, i2 = g(e2), u2 = at(i2.length), a2 = ft(r2, u2);
          if (t2 && n2 != n2) {
            for (; u2 > a2; )
              if ((o2 = i2[a2++]) != o2)
                return true;
          } else
            for (; u2 > a2; a2++)
              if ((t2 || a2 in i2) && i2[a2] === n2)
                return t2 || a2 || 0;
          return !t2 && -1;
        };
      }, dt = { includes: st(true), indexOf: st(false) }, vt = dt.indexOf, pt = function(t2, e2) {
        var n2, r2 = g(t2), o2 = 0, i2 = [];
        for (n2 in r2)
          !S(G, n2) && S(r2, n2) && i2.push(n2);
        for (; e2.length > o2; )
          S(r2, n2 = e2[o2++]) && (~vt(i2, n2) || i2.push(n2));
        return i2;
      }, gt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ht = gt.concat("length", "prototype"), yt = { f: Object.getOwnPropertyNames || function(t2) {
        return pt(t2, ht);
      } }, mt = { f: Object.getOwnPropertySymbols }, St = nt("Reflect", "ownKeys") || function(t2) {
        var e2 = yt.f(A(t2)), n2 = mt.f;
        return n2 ? e2.concat(n2(t2)) : e2;
      }, xt = function(t2, e2) {
        for (var n2 = St(e2), r2 = R.f, o2 = T.f, i2 = 0; i2 < n2.length; i2++) {
          var u2 = n2[i2];
          S(t2, u2) || r2(t2, u2, o2(e2, u2));
        }
      }, bt = /#|\.prototype\./, Et = function(t2, e2) {
        var n2 = Ot[wt(t2)];
        return n2 == At || n2 != Tt && (typeof e2 == "function" ? o(e2) : !!e2);
      }, wt = Et.normalize = function(t2) {
        return String(t2).replace(bt, ".").toLowerCase();
      }, Ot = Et.data = {}, Tt = Et.NATIVE = "N", At = Et.POLYFILL = "P", kt = Et, Rt = T.f, It = function(t2, e2) {
        var n2, o2, i2, u2, a2, c2 = t2.target, l2 = t2.global, f2 = t2.stat;
        if (n2 = l2 ? r : f2 ? r[c2] || j(c2, {}) : (r[c2] || {}).prototype)
          for (o2 in e2) {
            if (u2 = e2[o2], i2 = t2.noTargetGet ? (a2 = Rt(n2, o2)) && a2.value : n2[o2], !kt(l2 ? o2 : c2 + (f2 ? "." : "#") + o2, t2.forced) && i2 !== void 0) {
              if (typeof u2 == typeof i2)
                continue;
              xt(u2, i2);
            }
            (t2.sham || i2 && i2.sham) && I(u2, "sham", true), Z(n2, o2, u2, t2);
          }
      }, jt = function(t2, e2) {
        var n2 = [][t2];
        return !!n2 && o(function() {
          n2.call(null, e2 || function() {
            throw 1;
          }, 1);
        });
      }, Ct = Object.defineProperty, Lt = {}, Pt = function(t2) {
        throw t2;
      }, Mt = function(t2, e2) {
        if (S(Lt, t2))
          return Lt[t2];
        e2 || (e2 = {});
        var n2 = [][t2], r2 = !!S(e2, "ACCESSORS") && e2.ACCESSORS, u2 = S(e2, 0) ? e2[0] : Pt, a2 = S(e2, 1) ? e2[1] : void 0;
        return Lt[t2] = !!n2 && !o(function() {
          if (r2 && !i)
            return true;
          var t3 = { length: -1 };
          r2 ? Ct(t3, 1, { enumerable: true, get: Pt }) : t3[1] = 1, n2.call(t3, u2, a2);
        });
      }, _t = dt.indexOf, Dt = [].indexOf, Ut = !!Dt && 1 / [1].indexOf(1, -0) < 0, Nt = jt("indexOf"), Ft = Mt("indexOf", { ACCESSORS: true, 1: 0 });
      function Wt(t2, e2) {
        if (!(t2 instanceof e2))
          throw new TypeError("Cannot call a class as a function");
      }
      function zt(t2, e2) {
        for (var n2 = 0; n2 < e2.length; n2++) {
          var r2 = e2[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t2, r2.key, r2);
        }
      }
      function $t(t2, e2, n2) {
        return e2 && zt(t2.prototype, e2), n2 && zt(t2, n2), t2;
      }
      It({ target: "Array", proto: true, forced: Ut || !Nt || !Ft }, { indexOf: function(t2) {
        return Ut ? Dt.apply(this, arguments) || 0 : _t(this, t2, arguments.length > 1 ? arguments[1] : void 0);
      } });
      (function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "isInBrowser", value: function() {
          return typeof window != "undefined";
        } }, { key: "isServer", value: function() {
          return typeof window == "undefined";
        } }, { key: "getUA", value: function() {
          return t2.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
        } }, { key: "isMobile", value: function() {
          return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
        } }, { key: "isOpera", value: function() {
          return navigator.userAgent.indexOf("Opera") !== -1;
        } }, { key: "isIE", value: function() {
          var e2 = t2.getUA();
          return e2 !== "" && e2.indexOf("msie") > 0;
        } }, { key: "isIE9", value: function() {
          var e2 = t2.getUA();
          return e2 !== "" && e2.indexOf("msie 9.0") > 0;
        } }, { key: "isEdge", value: function() {
          var e2 = t2.getUA();
          return e2 !== "" && e2.indexOf("edge/") > 0;
        } }, { key: "isChrome", value: function() {
          var e2 = t2.getUA();
          return e2 !== "" && /chrome\/\d+/.test(e2) && !t2.isEdge();
        } }, { key: "isPhantomJS", value: function() {
          var e2 = t2.getUA();
          return e2 !== "" && /phantomjs/.test(e2);
        } }, { key: "isFirefox", value: function() {
          var e2 = t2.getUA();
          return e2 !== "" && /firefox/.test(e2);
        } }]), t2;
      })();
      var Yt = [].join, Gt = v != Object, Ht = jt("join", ",");
      It({ target: "Array", proto: true, forced: Gt || !Ht }, { join: function(t2) {
        return Yt.call(g(this), t2 === void 0 ? "," : t2);
      } });
      var Xt, Vt, Kt = function(t2) {
        return Object(p(t2));
      }, qt = Array.isArray || function(t2) {
        return s(t2) == "Array";
      }, Qt = !!Object.getOwnPropertySymbols && !o(function() {
        return !String(Symbol());
      }), Jt = Qt && !Symbol.sham && typeof Symbol.iterator == "symbol", Zt = F("wks"), te = r.Symbol, ee = Jt ? te : te && te.withoutSetter || $, ne = function(t2) {
        return S(Zt, t2) || (Qt && S(te, t2) ? Zt[t2] = te[t2] : Zt[t2] = ee("Symbol." + t2)), Zt[t2];
      }, re = ne("species"), oe = function(t2, e2) {
        var n2;
        return qt(t2) && (typeof (n2 = t2.constructor) != "function" || n2 !== Array && !qt(n2.prototype) ? h(n2) && (n2 = n2[re]) === null && (n2 = void 0) : n2 = void 0), new (n2 === void 0 ? Array : n2)(e2 === 0 ? 0 : e2);
      }, ie = function(t2, e2, n2) {
        var r2 = y(e2);
        r2 in t2 ? R.f(t2, r2, l(0, n2)) : t2[r2] = n2;
      }, ue = nt("navigator", "userAgent") || "", ae = r.process, ce = ae && ae.versions, le = ce && ce.v8;
      le ? Vt = (Xt = le.split("."))[0] + Xt[1] : ue && (!(Xt = ue.match(/Edge\/(\d+)/)) || Xt[1] >= 74) && (Xt = ue.match(/Chrome\/(\d+)/)) && (Vt = Xt[1]);
      var fe = Vt && +Vt, se = ne("species"), de = function(t2) {
        return fe >= 51 || !o(function() {
          var e2 = [];
          return (e2.constructor = {})[se] = function() {
            return { foo: 1 };
          }, e2[t2](Boolean).foo !== 1;
        });
      }, ve = de("splice"), pe = Mt("splice", { ACCESSORS: true, 0: 0, 1: 2 }), ge = Math.max, he = Math.min;
      It({ target: "Array", proto: true, forced: !ve || !pe }, { splice: function(t2, e2) {
        var n2, r2, o2, i2, u2, a2, c2 = Kt(this), l2 = at(c2.length), f2 = ft(t2, l2), s2 = arguments.length;
        if (s2 === 0 ? n2 = r2 = 0 : s2 === 1 ? (n2 = 0, r2 = l2 - f2) : (n2 = s2 - 2, r2 = he(ge(it(e2), 0), l2 - f2)), l2 + n2 - r2 > 9007199254740991)
          throw TypeError("Maximum allowed length exceeded");
        for (o2 = oe(c2, r2), i2 = 0; i2 < r2; i2++)
          (u2 = f2 + i2) in c2 && ie(o2, i2, c2[u2]);
        if (o2.length = r2, n2 < r2) {
          for (i2 = f2; i2 < l2 - r2; i2++)
            a2 = i2 + n2, (u2 = i2 + r2) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
          for (i2 = l2; i2 > l2 - r2 + n2; i2--)
            delete c2[i2 - 1];
        } else if (n2 > r2)
          for (i2 = l2 - r2; i2 > f2; i2--)
            a2 = i2 + n2 - 1, (u2 = i2 + r2 - 1) in c2 ? c2[a2] = c2[u2] : delete c2[a2];
        for (i2 = 0; i2 < n2; i2++)
          c2[i2 + f2] = arguments[i2 + 2];
        return c2.length = l2 - r2 + n2, o2;
      } });
      var ye = {};
      ye[ne("toStringTag")] = "z";
      var me = String(ye) === "[object z]", Se = ne("toStringTag"), xe = s(function() {
        return arguments;
      }()) == "Arguments", be = me ? s : function(t2) {
        var e2, n2, r2;
        return t2 === void 0 ? "Undefined" : t2 === null ? "Null" : typeof (n2 = function(t3, e3) {
          try {
            return t3[e3];
          } catch (t4) {
          }
        }(e2 = Object(t2), Se)) == "string" ? n2 : xe ? s(e2) : (r2 = s(e2)) == "Object" && typeof e2.callee == "function" ? "Arguments" : r2;
      }, Ee = me ? {}.toString : function() {
        return "[object " + be(this) + "]";
      };
      me || Z(Object.prototype, "toString", Ee, { unsafe: true });
      var we = function() {
        var t2 = A(this), e2 = "";
        return t2.global && (e2 += "g"), t2.ignoreCase && (e2 += "i"), t2.multiline && (e2 += "m"), t2.dotAll && (e2 += "s"), t2.unicode && (e2 += "u"), t2.sticky && (e2 += "y"), e2;
      };
      function Oe(t2, e2) {
        return RegExp(t2, e2);
      }
      var Te, Ae, ke = { UNSUPPORTED_Y: o(function() {
        var t2 = Oe("a", "y");
        return t2.lastIndex = 2, t2.exec("abcd") != null;
      }), BROKEN_CARET: o(function() {
        var t2 = Oe("^r", "gy");
        return t2.lastIndex = 2, t2.exec("str") != null;
      }) }, Re = RegExp.prototype.exec, Ie = String.prototype.replace, je = Re, Ce = (Te = /a/, Ae = /b*/g, Re.call(Te, "a"), Re.call(Ae, "a"), Te.lastIndex !== 0 || Ae.lastIndex !== 0), Le = ke.UNSUPPORTED_Y || ke.BROKEN_CARET, Pe = /()??/.exec("")[1] !== void 0;
      (Ce || Pe || Le) && (je = function(t2) {
        var e2, n2, r2, o2, i2 = this, u2 = Le && i2.sticky, a2 = we.call(i2), c2 = i2.source, l2 = 0, f2 = t2;
        return u2 && ((a2 = a2.replace("y", "")).indexOf("g") === -1 && (a2 += "g"), f2 = String(t2).slice(i2.lastIndex), i2.lastIndex > 0 && (!i2.multiline || i2.multiline && t2[i2.lastIndex - 1] !== "\n") && (c2 = "(?: " + c2 + ")", f2 = " " + f2, l2++), n2 = new RegExp("^(?:" + c2 + ")", a2)), Pe && (n2 = new RegExp("^" + c2 + "$(?!\\s)", a2)), Ce && (e2 = i2.lastIndex), r2 = Re.call(u2 ? n2 : i2, f2), u2 ? r2 ? (r2.input = r2.input.slice(l2), r2[0] = r2[0].slice(l2), r2.index = i2.lastIndex, i2.lastIndex += r2[0].length) : i2.lastIndex = 0 : Ce && r2 && (i2.lastIndex = i2.global ? r2.index + r2[0].length : e2), Pe && r2 && r2.length > 1 && Ie.call(r2[0], n2, function() {
          for (o2 = 1; o2 < arguments.length - 2; o2++)
            arguments[o2] === void 0 && (r2[o2] = void 0);
        }), r2;
      });
      var Me = je;
      It({ target: "RegExp", proto: true, forced: /./.exec !== Me }, { exec: Me });
      var _e = RegExp.prototype, De = _e.toString, Ue = o(function() {
        return De.call({ source: "a", flags: "b" }) != "/a/b";
      }), Ne = De.name != "toString";
      (Ue || Ne) && Z(RegExp.prototype, "toString", function() {
        var t2 = A(this), e2 = String(t2.source), n2 = t2.flags;
        return "/" + e2 + "/" + String(n2 === void 0 && t2 instanceof RegExp && !("flags" in _e) ? we.call(t2) : n2);
      }, { unsafe: true });
      var Fe = ne("species"), We = !o(function() {
        var t2 = /./;
        return t2.exec = function() {
          var t3 = [];
          return t3.groups = { a: "7" }, t3;
        }, "".replace(t2, "$<a>") !== "7";
      }), ze = "a".replace(/./, "$0") === "$0", $e = ne("replace"), Be = !!/./[$e] && /./[$e]("a", "$0") === "", Ye = !o(function() {
        var t2 = /(?:)/, e2 = t2.exec;
        t2.exec = function() {
          return e2.apply(this, arguments);
        };
        var n2 = "ab".split(t2);
        return n2.length !== 2 || n2[0] !== "a" || n2[1] !== "b";
      }), Ge = function(t2, e2, n2, r2) {
        var i2 = ne(t2), u2 = !o(function() {
          var e3 = {};
          return e3[i2] = function() {
            return 7;
          }, ""[t2](e3) != 7;
        }), a2 = u2 && !o(function() {
          var e3 = false, n3 = /a/;
          return t2 === "split" && ((n3 = {}).constructor = {}, n3.constructor[Fe] = function() {
            return n3;
          }, n3.flags = "", n3[i2] = /./[i2]), n3.exec = function() {
            return e3 = true, null;
          }, n3[i2](""), !e3;
        });
        if (!u2 || !a2 || t2 === "replace" && (!We || !ze || Be) || t2 === "split" && !Ye) {
          var c2 = /./[i2], l2 = n2(i2, ""[t2], function(t3, e3, n3, r3, o2) {
            return e3.exec === Me ? u2 && !o2 ? { done: true, value: c2.call(e3, n3, r3) } : { done: true, value: t3.call(n3, e3, r3) } : { done: false };
          }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f2 = l2[0], s2 = l2[1];
          Z(String.prototype, t2, f2), Z(RegExp.prototype, i2, e2 == 2 ? function(t3, e3) {
            return s2.call(t3, this, e3);
          } : function(t3) {
            return s2.call(t3, this);
          });
        }
        r2 && I(RegExp.prototype[i2], "sham", true);
      }, He = ne("match"), Xe = function(t2) {
        var e2;
        return h(t2) && ((e2 = t2[He]) !== void 0 ? !!e2 : s(t2) == "RegExp");
      }, Ve = function(t2) {
        if (typeof t2 != "function")
          throw TypeError(String(t2) + " is not a function");
        return t2;
      }, Ke = ne("species"), qe = function(t2) {
        return function(e2, n2) {
          var r2, o2, i2 = String(p(e2)), u2 = it(n2), a2 = i2.length;
          return u2 < 0 || u2 >= a2 ? t2 ? "" : void 0 : (r2 = i2.charCodeAt(u2)) < 55296 || r2 > 56319 || u2 + 1 === a2 || (o2 = i2.charCodeAt(u2 + 1)) < 56320 || o2 > 57343 ? t2 ? i2.charAt(u2) : r2 : t2 ? i2.slice(u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
        };
      }, Qe = { codeAt: qe(false), charAt: qe(true) }, Je = Qe.charAt, Ze = function(t2, e2, n2) {
        return e2 + (n2 ? Je(t2, e2).length : 1);
      }, tn = function(t2, e2) {
        var n2 = t2.exec;
        if (typeof n2 == "function") {
          var r2 = n2.call(t2, e2);
          if (typeof r2 != "object")
            throw TypeError("RegExp exec method returned something other than an Object or null");
          return r2;
        }
        if (s(t2) !== "RegExp")
          throw TypeError("RegExp#exec called on incompatible receiver");
        return Me.call(t2, e2);
      }, en = [].push, nn = Math.min, rn = !o(function() {
        return !RegExp(4294967295, "y");
      });
      Ge("split", 2, function(t2, e2, n2) {
        var r2;
        return r2 = "abbc".split(/(b)*/)[1] == "c" || "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t3, n3) {
          var r3 = String(p(this)), o2 = n3 === void 0 ? 4294967295 : n3 >>> 0;
          if (o2 === 0)
            return [];
          if (t3 === void 0)
            return [r3];
          if (!Xe(t3))
            return e2.call(r3, t3, o2);
          for (var i2, u2, a2, c2 = [], l2 = (t3.ignoreCase ? "i" : "") + (t3.multiline ? "m" : "") + (t3.unicode ? "u" : "") + (t3.sticky ? "y" : ""), f2 = 0, s2 = new RegExp(t3.source, l2 + "g"); (i2 = Me.call(s2, r3)) && !((u2 = s2.lastIndex) > f2 && (c2.push(r3.slice(f2, i2.index)), i2.length > 1 && i2.index < r3.length && en.apply(c2, i2.slice(1)), a2 = i2[0].length, f2 = u2, c2.length >= o2)); )
            s2.lastIndex === i2.index && s2.lastIndex++;
          return f2 === r3.length ? !a2 && s2.test("") || c2.push("") : c2.push(r3.slice(f2)), c2.length > o2 ? c2.slice(0, o2) : c2;
        } : "0".split(void 0, 0).length ? function(t3, n3) {
          return t3 === void 0 && n3 === 0 ? [] : e2.call(this, t3, n3);
        } : e2, [function(e3, n3) {
          var o2 = p(this), i2 = e3 == null ? void 0 : e3[t2];
          return i2 !== void 0 ? i2.call(e3, o2, n3) : r2.call(String(o2), e3, n3);
        }, function(t3, o2) {
          var i2 = n2(r2, t3, this, o2, r2 !== e2);
          if (i2.done)
            return i2.value;
          var u2 = A(t3), a2 = String(this), c2 = function(t4, e3) {
            var n3, r3 = A(t4).constructor;
            return r3 === void 0 || (n3 = A(r3)[Ke]) == null ? e3 : Ve(n3);
          }(u2, RegExp), l2 = u2.unicode, f2 = (u2.ignoreCase ? "i" : "") + (u2.multiline ? "m" : "") + (u2.unicode ? "u" : "") + (rn ? "y" : "g"), s2 = new c2(rn ? u2 : "^(?:" + u2.source + ")", f2), d2 = o2 === void 0 ? 4294967295 : o2 >>> 0;
          if (d2 === 0)
            return [];
          if (a2.length === 0)
            return tn(s2, a2) === null ? [a2] : [];
          for (var v2 = 0, p2 = 0, g2 = []; p2 < a2.length; ) {
            s2.lastIndex = rn ? p2 : 0;
            var h2, y2 = tn(s2, rn ? a2 : a2.slice(p2));
            if (y2 === null || (h2 = nn(at(s2.lastIndex + (rn ? 0 : p2)), a2.length)) === v2)
              p2 = Ze(a2, p2, l2);
            else {
              if (g2.push(a2.slice(v2, p2)), g2.length === d2)
                return g2;
              for (var m2 = 1; m2 <= y2.length - 1; m2++)
                if (g2.push(y2[m2]), g2.length === d2)
                  return g2;
              p2 = v2 = h2;
            }
          }
          return g2.push(a2.slice(v2)), g2;
        }];
      }, !rn);
      var on = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", un = "[" + on + "]", an = RegExp("^" + un + un + "*"), cn = RegExp(un + un + "*$"), ln = function(t2) {
        return function(e2) {
          var n2 = String(p(e2));
          return 1 & t2 && (n2 = n2.replace(an, "")), 2 & t2 && (n2 = n2.replace(cn, "")), n2;
        };
      }, fn = { start: ln(1), end: ln(2), trim: ln(3) }, sn = fn.trim;
      It({ target: "String", proto: true, forced: function(t2) {
        return o(function() {
          return !!on[t2]() || "\u200B\x85\u180E"[t2]() != "\u200B\x85\u180E" || on[t2].name !== t2;
        });
      }("trim") }, { trim: function() {
        return sn(this);
      } });
      var dn = de("slice"), vn = Mt("slice", { ACCESSORS: true, 0: 0, 1: 2 }), pn = ne("species"), gn = [].slice, hn = Math.max;
      It({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t2, e2) {
        var n2, r2, o2, i2 = g(this), u2 = at(i2.length), a2 = ft(t2, u2), c2 = ft(e2 === void 0 ? u2 : e2, u2);
        if (qt(i2) && (typeof (n2 = i2.constructor) != "function" || n2 !== Array && !qt(n2.prototype) ? h(n2) && (n2 = n2[pn]) === null && (n2 = void 0) : n2 = void 0, n2 === Array || n2 === void 0))
          return gn.call(i2, a2, c2);
        for (r2 = new (n2 === void 0 ? Array : n2)(hn(c2 - a2, 0)), o2 = 0; a2 < c2; a2++, o2++)
          a2 in i2 && ie(r2, o2, i2[a2]);
        return r2.length = o2, r2;
      } });
      var yn = Object.keys || function(t2) {
        return pt(t2, gt);
      }, mn = o(function() {
        yn(1);
      });
      It({ target: "Object", stat: true, forced: mn }, { keys: function(t2) {
        return yn(Kt(t2));
      } });
      var Sn, xn = function(t2) {
        if (Xe(t2))
          throw TypeError("The method doesn't accept regular expressions");
        return t2;
      }, bn = ne("match"), En = T.f, wn = "".startsWith, On = Math.min, Tn = function(t2) {
        var e2 = /./;
        try {
          "/./"[t2](e2);
        } catch (n2) {
          try {
            return e2[bn] = false, "/./"[t2](e2);
          } catch (t3) {
          }
        }
        return false;
      }("startsWith"), An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
      function kn(t2) {
        return (kn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t3) {
          return typeof t3;
        } : function(t3) {
          return t3 && typeof Symbol == "function" && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
        })(t2);
      }
      It({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t2) {
        var e2 = String(p(this));
        xn(t2);
        var n2 = at(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r2 = String(t2);
        return wn ? wn.call(e2, r2, n2) : e2.slice(n2, n2 + r2.length) === r2;
      } });
      var jn = function(t2) {
        return typeof t2 == "string";
      }, Mn = function(t2) {
        return t2 !== null && kn(t2) === "object";
      }, Vn = function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "isWindow", value: function(t3) {
          return t3 === window;
        } }, { key: "addEventListener", value: function(t3, e2, n2) {
          var r2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
          t3 && e2 && n2 && t3.addEventListener(e2, n2, r2);
        } }, { key: "removeEventListener", value: function(t3, e2, n2) {
          var r2 = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
          t3 && e2 && n2 && t3.removeEventListener(e2, n2, r2);
        } }, { key: "triggerDragEvent", value: function(e2, n2) {
          var r2 = false, o2 = function(t3) {
            var e3;
            (e3 = n2.drag) === null || e3 === void 0 || e3.call(n2, t3);
          }, i2 = function e3(i3) {
            var u2;
            t2.removeEventListener(document, "mousemove", o2), t2.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r2 = false, (u2 = n2.end) === null || u2 === void 0 || u2.call(n2, i3);
          };
          t2.addEventListener(e2, "mousedown", function(e3) {
            var u2;
            r2 || (document.onselectstart = function() {
              return false;
            }, document.ondragstart = function() {
              return false;
            }, t2.addEventListener(document, "mousemove", o2), t2.addEventListener(document, "mouseup", i2), r2 = true, (u2 = n2.start) === null || u2 === void 0 || u2.call(n2, e3));
          });
        } }, { key: "getBoundingClientRect", value: function(t3) {
          return t3 && Mn(t3) && t3.nodeType === 1 ? t3.getBoundingClientRect() : null;
        } }, { key: "hasClass", value: function(t3, e2) {
          return !!(t3 && Mn(t3) && jn(e2) && t3.nodeType === 1) && t3.classList.contains(e2.trim());
        } }, { key: "addClass", value: function(e2, n2) {
          if (e2 && Mn(e2) && jn(n2) && e2.nodeType === 1 && (n2 = n2.trim(), !t2.hasClass(e2, n2))) {
            var r2 = e2.className;
            e2.className = r2 ? r2 + " " + n2 : n2;
          }
        } }, { key: "removeClass", value: function(t3, e2) {
          if (t3 && Mn(t3) && jn(e2) && t3.nodeType === 1 && typeof t3.className == "string") {
            e2 = e2.trim();
            for (var n2 = t3.className.trim().split(" "), r2 = n2.length - 1; r2 >= 0; r2--)
              n2[r2] = n2[r2].trim(), n2[r2] && n2[r2] !== e2 || n2.splice(r2, 1);
            t3.className = n2.join(" ");
          }
        } }, { key: "toggleClass", value: function(t3, e2, n2) {
          t3 && Mn(t3) && jn(e2) && t3.nodeType === 1 && t3.classList.toggle(e2, n2);
        } }, { key: "replaceClass", value: function(e2, n2, r2) {
          e2 && Mn(e2) && jn(n2) && jn(r2) && e2.nodeType === 1 && (n2 = n2.trim(), r2 = r2.trim(), t2.removeClass(e2, n2), t2.addClass(e2, r2));
        } }, { key: "getScrollTop", value: function(t3) {
          var e2 = "scrollTop" in t3 ? t3.scrollTop : t3.pageYOffset;
          return Math.max(e2, 0);
        } }, { key: "setScrollTop", value: function(t3, e2) {
          "scrollTop" in t3 ? t3.scrollTop = e2 : t3.scrollTo(t3.scrollX, e2);
        } }, { key: "getRootScrollTop", value: function() {
          return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        } }, { key: "setRootScrollTop", value: function(e2) {
          t2.setScrollTop(window, e2), t2.setScrollTop(document.body, e2);
        } }, { key: "getElementTop", value: function(e2, n2) {
          if (t2.isWindow(e2))
            return 0;
          var r2 = n2 ? t2.getScrollTop(n2) : t2.getRootScrollTop();
          return e2.getBoundingClientRect().top + r2;
        } }, { key: "getVisibleHeight", value: function(e2) {
          return t2.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
        } }, { key: "isHidden", value: function(t3) {
          if (!t3)
            return false;
          var e2 = window.getComputedStyle(t3), n2 = e2.display === "none", r2 = t3.offsetParent === null && e2.position !== "fixed";
          return n2 || r2;
        } }, { key: "triggerEvent", value: function(t3, e2) {
          if ("createEvent" in document) {
            var n2 = document.createEvent("HTMLEvents");
            n2.initEvent(e2, false, true), t3.dispatchEvent(n2);
          }
        } }, { key: "calcAngle", value: function(t3, e2) {
          var n2 = t3.getBoundingClientRect(), r2 = n2.left + n2.width / 2, o2 = n2.top + n2.height / 2, i2 = Math.abs(r2 - e2.clientX), u2 = Math.abs(o2 - e2.clientY), a2 = u2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(u2, 2)), c2 = Math.acos(a2), l2 = Math.floor(180 / (Math.PI / c2));
          return e2.clientX > r2 && e2.clientY > o2 && (l2 = 180 - l2), e2.clientX == r2 && e2.clientY > o2 && (l2 = 180), e2.clientX > r2 && e2.clientY == o2 && (l2 = 90), e2.clientX < r2 && e2.clientY > o2 && (l2 = 180 + l2), e2.clientX < r2 && e2.clientY == o2 && (l2 = 270), e2.clientX < r2 && e2.clientY < o2 && (l2 = 360 - l2), l2;
        } }, { key: "querySelector", value: function(t3, e2) {
          return e2 ? e2.querySelector(t3) : document.querySelector(t3);
        } }, { key: "createElement", value: function(t3) {
          for (var e2 = document.createElement(t3), n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++)
            r2[o2 - 1] = arguments[o2];
          for (var i2 = 0; i2 < r2.length; i2++)
            r2[i2] && e2.classList.add(r2[i2]);
          return e2;
        } }, { key: "appendChild", value: function(t3) {
          for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++)
            t3.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
        } }, { key: "getWindow", value: function(t3) {
          if (t3.toString() !== "[object Window]") {
            var e2 = t3.ownerDocument;
            return e2 && e2.defaultView || window;
          }
          return t3;
        } }, { key: "isElement", value: function(t3) {
          return t3 instanceof this.getWindow(t3).Element || t3 instanceof Element;
        } }, { key: "isHTMLElement", value: function(t3) {
          return t3 instanceof this.getWindow(t3).HTMLElement || t3 instanceof HTMLElement;
        } }, { key: "isShadowRoot", value: function(t3) {
          return typeof ShadowRoot != "undefined" && (t3 instanceof this.getWindow(t3).ShadowRoot || t3 instanceof ShadowRoot);
        } }, { key: "getWindowScroll", value: function(t3) {
          var e2 = this.getWindow(t3);
          return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
        } }]), t2;
      }(), Kn = Math.floor, qn = "".replace, Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g, Jn = /\$([$&'`]|\d\d?)/g, Zn = function(t2, e2, n2, r2, o2, i2) {
        var u2 = n2 + t2.length, a2 = r2.length, c2 = Jn;
        return o2 !== void 0 && (o2 = Kt(o2), c2 = Qn), qn.call(i2, c2, function(i3, c3) {
          var l2;
          switch (c3.charAt(0)) {
            case "$":
              return "$";
            case "&":
              return t2;
            case "`":
              return e2.slice(0, n2);
            case "'":
              return e2.slice(u2);
            case "<":
              l2 = o2[c3.slice(1, -1)];
              break;
            default:
              var f2 = +c3;
              if (f2 === 0)
                return i3;
              if (f2 > a2) {
                var s2 = Kn(f2 / 10);
                return s2 === 0 ? i3 : s2 <= a2 ? r2[s2 - 1] === void 0 ? c3.charAt(1) : r2[s2 - 1] + c3.charAt(1) : i3;
              }
              l2 = r2[f2 - 1];
          }
          return l2 === void 0 ? "" : l2;
        });
      }, tr = Math.max, er = Math.min;
      Ge("replace", 2, function(t2, e2, n2, r2) {
        var o2 = r2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i2 = r2.REPLACE_KEEPS_$0, u2 = o2 ? "$" : "$0";
        return [function(n3, r3) {
          var o3 = p(this), i3 = n3 == null ? void 0 : n3[t2];
          return i3 !== void 0 ? i3.call(n3, o3, r3) : e2.call(String(o3), n3, r3);
        }, function(t3, r3) {
          if (!o2 && i2 || typeof r3 == "string" && r3.indexOf(u2) === -1) {
            var a2 = n2(e2, t3, this, r3);
            if (a2.done)
              return a2.value;
          }
          var c2 = A(t3), l2 = String(this), f2 = typeof r3 == "function";
          f2 || (r3 = String(r3));
          var s2 = c2.global;
          if (s2) {
            var d2 = c2.unicode;
            c2.lastIndex = 0;
          }
          for (var v2 = []; ; ) {
            var p2 = tn(c2, l2);
            if (p2 === null)
              break;
            if (v2.push(p2), !s2)
              break;
            String(p2[0]) === "" && (c2.lastIndex = Ze(l2, at(c2.lastIndex), d2));
          }
          for (var g2, h2 = "", y2 = 0, m2 = 0; m2 < v2.length; m2++) {
            p2 = v2[m2];
            for (var S2 = String(p2[0]), x2 = tr(er(it(p2.index), l2.length), 0), b2 = [], E2 = 1; E2 < p2.length; E2++)
              b2.push((g2 = p2[E2]) === void 0 ? g2 : String(g2));
            var w2 = p2.groups;
            if (f2) {
              var O2 = [S2].concat(b2, x2, l2);
              w2 !== void 0 && O2.push(w2);
              var T2 = String(r3.apply(void 0, O2));
            } else
              T2 = Zn(S2, l2, x2, b2, w2, r3);
            x2 >= y2 && (h2 += l2.slice(y2, x2) + T2, y2 = x2 + S2.length);
          }
          return h2 + l2.slice(y2);
        }];
      });
      (function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "camelize", value: function(t3) {
          return t3.replace(/-(\w)/g, function(t4, e2) {
            return e2 ? e2.toUpperCase() : "";
          });
        } }, { key: "capitalize", value: function(t3) {
          return t3.charAt(0).toUpperCase() + t3.slice(1);
        } }]), t2;
      })();
      (function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "_clone", value: function() {
        } }]), t2;
      })();
      var or = ne("isConcatSpreadable"), ir = fe >= 51 || !o(function() {
        var t2 = [];
        return t2[or] = false, t2.concat()[0] !== t2;
      }), ur = de("concat"), ar = function(t2) {
        if (!h(t2))
          return false;
        var e2 = t2[or];
        return e2 !== void 0 ? !!e2 : qt(t2);
      };
      It({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t2) {
        var e2, n2, r2, o2, i2, u2 = Kt(this), a2 = oe(u2, 0), c2 = 0;
        for (e2 = -1, r2 = arguments.length; e2 < r2; e2++)
          if (ar(i2 = e2 === -1 ? u2 : arguments[e2])) {
            if (c2 + (o2 = at(i2.length)) > 9007199254740991)
              throw TypeError("Maximum allowed index exceeded");
            for (n2 = 0; n2 < o2; n2++, c2++)
              n2 in i2 && ie(a2, c2, i2[n2]);
          } else {
            if (c2 >= 9007199254740991)
              throw TypeError("Maximum allowed index exceeded");
            ie(a2, c2++, i2);
          }
        return a2.length = c2, a2;
      } });
      var cr, lr = function(t2, e2, n2) {
        if (Ve(t2), e2 === void 0)
          return t2;
        switch (n2) {
          case 0:
            return function() {
              return t2.call(e2);
            };
          case 1:
            return function(n3) {
              return t2.call(e2, n3);
            };
          case 2:
            return function(n3, r2) {
              return t2.call(e2, n3, r2);
            };
          case 3:
            return function(n3, r2, o2) {
              return t2.call(e2, n3, r2, o2);
            };
        }
        return function() {
          return t2.apply(e2, arguments);
        };
      }, fr = [].push, sr = function(t2) {
        var e2 = t2 == 1, n2 = t2 == 2, r2 = t2 == 3, o2 = t2 == 4, i2 = t2 == 6, u2 = t2 == 7, a2 = t2 == 5 || i2;
        return function(c2, l2, f2, s2) {
          for (var d2, p2, g2 = Kt(c2), h2 = v(g2), y2 = lr(l2, f2, 3), m2 = at(h2.length), S2 = 0, x2 = s2 || oe, b2 = e2 ? x2(c2, m2) : n2 || u2 ? x2(c2, 0) : void 0; m2 > S2; S2++)
            if ((a2 || S2 in h2) && (p2 = y2(d2 = h2[S2], S2, g2), t2))
              if (e2)
                b2[S2] = p2;
              else if (p2)
                switch (t2) {
                  case 3:
                    return true;
                  case 5:
                    return d2;
                  case 6:
                    return S2;
                  case 2:
                    fr.call(b2, d2);
                }
              else
                switch (t2) {
                  case 4:
                    return false;
                  case 7:
                    fr.call(b2, d2);
                }
          return i2 ? -1 : r2 || o2 ? o2 : b2;
        };
      }, dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) }, vr = i ? Object.defineProperties : function(t2, e2) {
        A(t2);
        for (var n2, r2 = yn(e2), o2 = r2.length, i2 = 0; o2 > i2; )
          R.f(t2, n2 = r2[i2++], e2[n2]);
        return t2;
      }, pr = nt("document", "documentElement"), gr = Y("IE_PROTO"), hr = function() {
      }, yr = function(t2) {
        return "<script>" + t2 + "<\/script>";
      }, mr = function() {
        try {
          cr = document.domain && new ActiveXObject("htmlfile");
        } catch (t3) {
        }
        var t2, e2;
        mr = cr ? function(t3) {
          t3.write(yr("")), t3.close();
          var e3 = t3.parentWindow.Object;
          return t3 = null, e3;
        }(cr) : ((e2 = E("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t2 = e2.contentWindow.document).open(), t2.write(yr("document.F=Object")), t2.close(), t2.F);
        for (var n2 = gt.length; n2--; )
          delete mr.prototype[gt[n2]];
        return mr();
      };
      G[gr] = true;
      var Sr = Object.create || function(t2, e2) {
        var n2;
        return t2 !== null ? (hr.prototype = A(t2), n2 = new hr(), hr.prototype = null, n2[gr] = t2) : n2 = mr(), e2 === void 0 ? n2 : vr(n2, e2);
      }, xr = ne("unscopables"), br = Array.prototype;
      br[xr] == null && R.f(br, xr, { configurable: true, value: Sr(null) });
      var Er = function(t2) {
        br[xr][t2] = true;
      }, wr = dr.find, Or = true, Tr = Mt("find");
      "find" in [] && Array(1).find(function() {
        Or = false;
      }), It({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t2) {
        return wr(this, t2, arguments.length > 1 ? arguments[1] : void 0);
      } }), Er("find");
      var Ar = dr.findIndex, kr = true, Rr = Mt("findIndex");
      "findIndex" in [] && Array(1).findIndex(function() {
        kr = false;
      }), It({ target: "Array", proto: true, forced: kr || !Rr }, { findIndex: function(t2) {
        return Ar(this, t2, arguments.length > 1 ? arguments[1] : void 0);
      } }), Er("findIndex");
      var Ir = function(t2, e2, n2, r2, o2, i2, u2, a2) {
        for (var c2, l2 = o2, f2 = 0, s2 = !!u2 && lr(u2, a2, 3); f2 < r2; ) {
          if (f2 in n2) {
            if (c2 = s2 ? s2(n2[f2], f2, e2) : n2[f2], i2 > 0 && qt(c2))
              l2 = Ir(t2, e2, c2, at(c2.length), l2, i2 - 1) - 1;
            else {
              if (l2 >= 9007199254740991)
                throw TypeError("Exceed the acceptable array length");
              t2[l2] = c2;
            }
            l2++;
          }
          f2++;
        }
        return l2;
      }, jr = Ir;
      It({ target: "Array", proto: true }, { flat: function() {
        var t2 = arguments.length ? arguments[0] : void 0, e2 = Kt(this), n2 = at(e2.length), r2 = oe(e2, 0);
        return r2.length = jr(r2, e2, e2, n2, 0, t2 === void 0 ? 1 : it(t2)), r2;
      } });
      var Cr = function(t2) {
        var e2 = t2.return;
        if (e2 !== void 0)
          return A(e2.call(t2)).value;
      }, Lr = function(t2, e2, n2, r2) {
        try {
          return r2 ? e2(A(n2)[0], n2[1]) : e2(n2);
        } catch (e3) {
          throw Cr(t2), e3;
        }
      }, Pr = {}, Mr = ne("iterator"), _r = Array.prototype, Dr = function(t2) {
        return t2 !== void 0 && (Pr.Array === t2 || _r[Mr] === t2);
      }, Ur = ne("iterator"), Nr = function(t2) {
        if (t2 != null)
          return t2[Ur] || t2["@@iterator"] || Pr[be(t2)];
      }, Fr = ne("iterator"), Wr = false;
      try {
        var zr = 0, $r = { next: function() {
          return { done: !!zr++ };
        }, return: function() {
          Wr = true;
        } };
        $r[Fr] = function() {
          return this;
        }, Array.from($r, function() {
          throw 2;
        });
      } catch (t2) {
      }
      var Br = function(t2, e2) {
        if (!e2 && !Wr)
          return false;
        var n2 = false;
        try {
          var r2 = {};
          r2[Fr] = function() {
            return { next: function() {
              return { done: n2 = true };
            } };
          }, t2(r2);
        } catch (t3) {
        }
        return n2;
      }, Yr = !Br(function(t2) {
        Array.from(t2);
      });
      It({ target: "Array", stat: true, forced: Yr }, { from: function(t2) {
        var e2, n2, r2, o2, i2, u2, a2 = Kt(t2), c2 = typeof this == "function" ? this : Array, l2 = arguments.length, f2 = l2 > 1 ? arguments[1] : void 0, s2 = f2 !== void 0, d2 = Nr(a2), v2 = 0;
        if (s2 && (f2 = lr(f2, l2 > 2 ? arguments[2] : void 0, 2)), d2 == null || c2 == Array && Dr(d2))
          for (n2 = new c2(e2 = at(a2.length)); e2 > v2; v2++)
            u2 = s2 ? f2(a2[v2], v2) : a2[v2], ie(n2, v2, u2);
        else
          for (i2 = (o2 = d2.call(a2)).next, n2 = new c2(); !(r2 = i2.call(o2)).done; v2++)
            u2 = s2 ? Lr(o2, f2, [r2.value, v2], true) : r2.value, ie(n2, v2, u2);
        return n2.length = v2, n2;
      } });
      var Gr = function(t2) {
        return function(e2, n2, r2, o2) {
          Ve(n2);
          var i2 = Kt(e2), u2 = v(i2), a2 = at(i2.length), c2 = t2 ? a2 - 1 : 0, l2 = t2 ? -1 : 1;
          if (r2 < 2)
            for (; ; ) {
              if (c2 in u2) {
                o2 = u2[c2], c2 += l2;
                break;
              }
              if (c2 += l2, t2 ? c2 < 0 : a2 <= c2)
                throw TypeError("Reduce of empty array with no initial value");
            }
          for (; t2 ? c2 >= 0 : a2 > c2; c2 += l2)
            c2 in u2 && (o2 = n2(o2, u2[c2], c2, i2));
          return o2;
        };
      }, Hr = { left: Gr(false), right: Gr(true) }, Xr = s(r.process) == "process", Vr = Hr.left, Kr = jt("reduce"), qr = Mt("reduce", { 1: 0 });
      It({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe > 79 && fe < 83 }, { reduce: function(t2) {
        return Vr(this, t2, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
      } }), Er("flat");
      var Qr, Jr, Zr, to = !o(function() {
        return Object.isExtensible(Object.preventExtensions({}));
      }), eo = e(function(t2) {
        var e2 = R.f, n2 = $("meta"), r2 = 0, o2 = Object.isExtensible || function() {
          return true;
        }, i2 = function(t3) {
          e2(t3, n2, { value: { objectID: "O" + ++r2, weakData: {} } });
        }, u2 = t2.exports = { REQUIRED: false, fastKey: function(t3, e3) {
          if (!h(t3))
            return typeof t3 == "symbol" ? t3 : (typeof t3 == "string" ? "S" : "P") + t3;
          if (!S(t3, n2)) {
            if (!o2(t3))
              return "F";
            if (!e3)
              return "E";
            i2(t3);
          }
          return t3[n2].objectID;
        }, getWeakData: function(t3, e3) {
          if (!S(t3, n2)) {
            if (!o2(t3))
              return true;
            if (!e3)
              return false;
            i2(t3);
          }
          return t3[n2].weakData;
        }, onFreeze: function(t3) {
          return to && u2.REQUIRED && o2(t3) && !S(t3, n2) && i2(t3), t3;
        } };
        G[n2] = true;
      }), no = function(t2, e2) {
        this.stopped = t2, this.result = e2;
      }, ro = function(t2, e2, n2) {
        var r2, o2, i2, u2, a2, c2, l2, f2 = n2 && n2.that, s2 = !(!n2 || !n2.AS_ENTRIES), d2 = !(!n2 || !n2.IS_ITERATOR), v2 = !(!n2 || !n2.INTERRUPTED), p2 = lr(e2, f2, 1 + s2 + v2), g2 = function(t3) {
          return r2 && Cr(r2), new no(true, t3);
        }, h2 = function(t3) {
          return s2 ? (A(t3), v2 ? p2(t3[0], t3[1], g2) : p2(t3[0], t3[1])) : v2 ? p2(t3, g2) : p2(t3);
        };
        if (d2)
          r2 = t2;
        else {
          if (typeof (o2 = Nr(t2)) != "function")
            throw TypeError("Target is not iterable");
          if (Dr(o2)) {
            for (i2 = 0, u2 = at(t2.length); u2 > i2; i2++)
              if ((a2 = h2(t2[i2])) && a2 instanceof no)
                return a2;
            return new no(false);
          }
          r2 = o2.call(t2);
        }
        for (c2 = r2.next; !(l2 = c2.call(r2)).done; ) {
          try {
            a2 = h2(l2.value);
          } catch (t3) {
            throw Cr(r2), t3;
          }
          if (typeof a2 == "object" && a2 && a2 instanceof no)
            return a2;
        }
        return new no(false);
      }, oo = function(t2, e2, n2) {
        if (!(t2 instanceof e2))
          throw TypeError("Incorrect " + (n2 ? n2 + " " : "") + "invocation");
        return t2;
      }, io = R.f, uo = ne("toStringTag"), ao = function(t2, e2, n2) {
        t2 && !S(t2 = n2 ? t2 : t2.prototype, uo) && io(t2, uo, { configurable: true, value: e2 });
      }, co = Object.setPrototypeOf || ("__proto__" in {} ? function() {
        var t2, e2 = false, n2 = {};
        try {
          (t2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n2, []), e2 = n2 instanceof Array;
        } catch (t3) {
        }
        return function(n3, r2) {
          return A(n3), function(t3) {
            if (!h(t3) && t3 !== null)
              throw TypeError("Can't set " + String(t3) + " as a prototype");
          }(r2), e2 ? t2.call(n3, r2) : n3.__proto__ = r2, n3;
        };
      }() : void 0), lo = function(t2, e2, n2) {
        for (var r2 in e2)
          Z(t2, r2, e2[r2], n2);
        return t2;
      }, fo = !o(function() {
        function t2() {
        }
        return t2.prototype.constructor = null, Object.getPrototypeOf(new t2()) !== t2.prototype;
      }), so = Y("IE_PROTO"), vo = Object.prototype, po = fo ? Object.getPrototypeOf : function(t2) {
        return t2 = Kt(t2), S(t2, so) ? t2[so] : typeof t2.constructor == "function" && t2 instanceof t2.constructor ? t2.constructor.prototype : t2 instanceof Object ? vo : null;
      }, go = ne("iterator"), ho = false;
      [].keys && ("next" in (Zr = [].keys()) ? (Jr = po(po(Zr))) !== Object.prototype && (Qr = Jr) : ho = true), (Qr == null || o(function() {
        var t2 = {};
        return Qr[go].call(t2) !== t2;
      })) && (Qr = {}), S(Qr, go) || I(Qr, go, function() {
        return this;
      });
      var yo = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho }, mo = yo.IteratorPrototype, So = function() {
        return this;
      }, xo = yo.IteratorPrototype, bo = yo.BUGGY_SAFARI_ITERATORS, Eo = ne("iterator"), wo = function() {
        return this;
      }, Oo = function(t2, e2, n2, r2, o2, i2, u2) {
        !function(t3, e3, n3) {
          var r3 = e3 + " Iterator";
          t3.prototype = Sr(mo, { next: l(1, n3) }), ao(t3, r3, false), Pr[r3] = So;
        }(n2, e2, r2);
        var a2, c2, f2, s2 = function(t3) {
          if (t3 === o2 && h2)
            return h2;
          if (!bo && t3 in p2)
            return p2[t3];
          switch (t3) {
            case "keys":
            case "values":
            case "entries":
              return function() {
                return new n2(this, t3);
              };
          }
          return function() {
            return new n2(this);
          };
        }, d2 = e2 + " Iterator", v2 = false, p2 = t2.prototype, g2 = p2[Eo] || p2["@@iterator"] || o2 && p2[o2], h2 = !bo && g2 || s2(o2), y2 = e2 == "Array" && p2.entries || g2;
        if (y2 && (a2 = po(y2.call(new t2())), xo !== Object.prototype && a2.next && (po(a2) !== xo && (co ? co(a2, xo) : typeof a2[Eo] != "function" && I(a2, Eo, wo)), ao(a2, d2, true))), o2 == "values" && g2 && g2.name !== "values" && (v2 = true, h2 = function() {
          return g2.call(this);
        }), p2[Eo] !== h2 && I(p2, Eo, h2), Pr[e2] = h2, o2)
          if (c2 = { values: s2("values"), keys: i2 ? h2 : s2("keys"), entries: s2("entries") }, u2)
            for (f2 in c2)
              (bo || v2 || !(f2 in p2)) && Z(p2, f2, c2[f2]);
          else
            It({ target: e2, proto: true, forced: bo || v2 }, c2);
        return c2;
      }, To = ne("species"), Ao = R.f, ko = eo.fastKey, Ro = J.set, Io = J.getterFor;
      !function(t2, e2, n2) {
        var i2 = t2.indexOf("Map") !== -1, u2 = t2.indexOf("Weak") !== -1, a2 = i2 ? "set" : "add", c2 = r[t2], l2 = c2 && c2.prototype, f2 = c2, s2 = {}, d2 = function(t3) {
          var e3 = l2[t3];
          Z(l2, t3, t3 == "add" ? function(t4) {
            return e3.call(this, t4 === 0 ? 0 : t4), this;
          } : t3 == "delete" ? function(t4) {
            return !(u2 && !h(t4)) && e3.call(this, t4 === 0 ? 0 : t4);
          } : t3 == "get" ? function(t4) {
            return u2 && !h(t4) ? void 0 : e3.call(this, t4 === 0 ? 0 : t4);
          } : t3 == "has" ? function(t4) {
            return !(u2 && !h(t4)) && e3.call(this, t4 === 0 ? 0 : t4);
          } : function(t4, n3) {
            return e3.call(this, t4 === 0 ? 0 : t4, n3), this;
          });
        };
        if (kt(t2, typeof c2 != "function" || !(u2 || l2.forEach && !o(function() {
          new c2().entries().next();
        }))))
          f2 = n2.getConstructor(e2, t2, i2, a2), eo.REQUIRED = true;
        else if (kt(t2, true)) {
          var v2 = new f2(), p2 = v2[a2](u2 ? {} : -0, 1) != v2, g2 = o(function() {
            v2.has(1);
          }), y2 = Br(function(t3) {
            new c2(t3);
          }), m2 = !u2 && o(function() {
            for (var t3 = new c2(), e3 = 5; e3--; )
              t3[a2](e3, e3);
            return !t3.has(-0);
          });
          y2 || ((f2 = e2(function(e3, n3) {
            oo(e3, f2, t2);
            var r2 = function(t3, e4, n4) {
              var r3, o2;
              return co && typeof (r3 = e4.constructor) == "function" && r3 !== n4 && h(o2 = r3.prototype) && o2 !== n4.prototype && co(t3, o2), t3;
            }(new c2(), e3, f2);
            return n3 != null && ro(n3, r2[a2], { that: r2, AS_ENTRIES: i2 }), r2;
          })).prototype = l2, l2.constructor = f2), (g2 || m2) && (d2("delete"), d2("has"), i2 && d2("get")), (m2 || p2) && d2(a2), u2 && l2.clear && delete l2.clear;
        }
        s2[t2] = f2, It({ global: true, forced: f2 != c2 }, s2), ao(f2, t2), u2 || n2.setStrong(f2, t2, i2);
      }("Set", function(t2) {
        return function() {
          return t2(this, arguments.length ? arguments[0] : void 0);
        };
      }, { getConstructor: function(t2, e2, n2, r2) {
        var o2 = t2(function(t3, u3) {
          oo(t3, o2, e2), Ro(t3, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i || (t3.size = 0), u3 != null && ro(u3, t3[r2], { that: t3, AS_ENTRIES: n2 });
        }), u2 = Io(e2), a2 = function(t3, e3, n3) {
          var r3, o3, a3 = u2(t3), l2 = c2(t3, e3);
          return l2 ? l2.value = n3 : (a3.last = l2 = { index: o3 = ko(e3, true), key: e3, value: n3, previous: r3 = a3.last, next: void 0, removed: false }, a3.first || (a3.first = l2), r3 && (r3.next = l2), i ? a3.size++ : t3.size++, o3 !== "F" && (a3.index[o3] = l2)), t3;
        }, c2 = function(t3, e3) {
          var n3, r3 = u2(t3), o3 = ko(e3);
          if (o3 !== "F")
            return r3.index[o3];
          for (n3 = r3.first; n3; n3 = n3.next)
            if (n3.key == e3)
              return n3;
        };
        return lo(o2.prototype, { clear: function() {
          for (var t3 = u2(this), e3 = t3.index, n3 = t3.first; n3; )
            n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete e3[n3.index], n3 = n3.next;
          t3.first = t3.last = void 0, i ? t3.size = 0 : this.size = 0;
        }, delete: function(t3) {
          var e3 = this, n3 = u2(e3), r3 = c2(e3, t3);
          if (r3) {
            var o3 = r3.next, a3 = r3.previous;
            delete n3.index[r3.index], r3.removed = true, a3 && (a3.next = o3), o3 && (o3.previous = a3), n3.first == r3 && (n3.first = o3), n3.last == r3 && (n3.last = a3), i ? n3.size-- : e3.size--;
          }
          return !!r3;
        }, forEach: function(t3) {
          for (var e3, n3 = u2(this), r3 = lr(t3, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n3.first; )
            for (r3(e3.value, e3.key, this); e3 && e3.removed; )
              e3 = e3.previous;
        }, has: function(t3) {
          return !!c2(this, t3);
        } }), lo(o2.prototype, n2 ? { get: function(t3) {
          var e3 = c2(this, t3);
          return e3 && e3.value;
        }, set: function(t3, e3) {
          return a2(this, t3 === 0 ? 0 : t3, e3);
        } } : { add: function(t3) {
          return a2(this, t3 = t3 === 0 ? 0 : t3, t3);
        } }), i && Ao(o2.prototype, "size", { get: function() {
          return u2(this).size;
        } }), o2;
      }, setStrong: function(t2, e2, n2) {
        var r2 = e2 + " Iterator", o2 = Io(e2), u2 = Io(r2);
        Oo(t2, e2, function(t3, e3) {
          Ro(this, { type: r2, target: t3, state: o2(t3), kind: e3, last: void 0 });
        }, function() {
          for (var t3 = u2(this), e3 = t3.kind, n3 = t3.last; n3 && n3.removed; )
            n3 = n3.previous;
          return t3.target && (t3.last = n3 = n3 ? n3.next : t3.state.first) ? e3 == "keys" ? { value: n3.key, done: false } : e3 == "values" ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (t3.target = void 0, { value: void 0, done: true });
        }, n2 ? "entries" : "values", !n2, true), function(t3) {
          var e3 = nt(t3), n3 = R.f;
          i && e3 && !e3[To] && n3(e3, To, { configurable: true, get: function() {
            return this;
          } });
        }(e2);
      } });
      var jo = Qe.charAt, Co = J.set, Lo = J.getterFor("String Iterator");
      Oo(String, "String", function(t2) {
        Co(this, { type: "String Iterator", string: String(t2), index: 0 });
      }, function() {
        var t2, e2 = Lo(this), n2 = e2.string, r2 = e2.index;
        return r2 >= n2.length ? { value: void 0, done: true } : (t2 = jo(n2, r2), e2.index += t2.length, { value: t2, done: false });
      });
      var Po = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Mo = J.set, _o = J.getterFor("Array Iterator"), Do = Oo(Array, "Array", function(t2, e2) {
        Mo(this, { type: "Array Iterator", target: g(t2), index: 0, kind: e2 });
      }, function() {
        var t2 = _o(this), e2 = t2.target, n2 = t2.kind, r2 = t2.index++;
        return !e2 || r2 >= e2.length ? (t2.target = void 0, { value: void 0, done: true }) : n2 == "keys" ? { value: r2, done: false } : n2 == "values" ? { value: e2[r2], done: false } : { value: [r2, e2[r2]], done: false };
      }, "values");
      Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
      var Uo = ne("iterator"), No = ne("toStringTag"), Fo = Do.values;
      for (var Wo in Po) {
        var zo = r[Wo], $o = zo && zo.prototype;
        if ($o) {
          if ($o[Uo] !== Fo)
            try {
              I($o, Uo, Fo);
            } catch (t2) {
              $o[Uo] = Fo;
            }
          if ($o[No] || I($o, No, Wo), Po[Wo]) {
            for (var Bo in Do)
              if ($o[Bo] !== Do[Bo])
                try {
                  I($o, Bo, Do[Bo]);
                } catch (t2) {
                  $o[Bo] = Do[Bo];
                }
          }
        }
      }
      (function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "deduplicate", value: function(t3) {
          return Array.from(new Set(t3));
        } }, { key: "flat", value: function(e2) {
          return e2.reduce(function(e3, n2) {
            var r2 = Array.isArray(n2) ? t2.flat(n2) : n2;
            return e3.concat(r2);
          }, []);
        } }, { key: "find", value: function(t3, e2) {
          return t3.find(e2);
        } }, { key: "findIndex", value: function(t3, e2) {
          return t3.findIndex(e2);
        } }]), t2;
      })();
      (function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "today", value: function() {
          return new Date();
        } }]), t2;
      })();
      (function() {
        function t2() {
          Wt(this, t2);
        }
        return $t(t2, null, [{ key: "range", value: function(t3, e2, n2) {
          return Math.min(Math.max(t3, e2), n2);
        } }, { key: "clamp", value: function(t3, e2, n2) {
          return e2 < n2 ? t3 < e2 ? e2 : t3 > n2 ? n2 : t3 : t3 < n2 ? n2 : t3 > e2 ? e2 : t3;
        } }]), t2;
      })();
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeGlobal$1 = freeGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal$1 || freeSelf || Function("return this")();
      var root$1 = root;
      var Symbol$1 = root$1.Symbol;
      var Symbol$2 = Symbol$1;
      var objectProto$a = Object.prototype;
      var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$a.toString;
      var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$9 = Object.prototype;
      var nativeObjectToString = objectProto$9.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isArray = Array.isArray;
      var isArray$1 = isArray;
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root$1["__core-js_shared__"];
      var coreJsData$1 = coreJsData;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$8 = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      var baseCreate$1 = baseCreate;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var defineProperty$1 = defineProperty;
      var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
        return defineProperty$1(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      var baseSetToString$1 = baseSetToString;
      var setToString = shortOut(baseSetToString$1);
      var setToString$1 = setToString;
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty$1) {
          defineProperty$1(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function copyObject(source, props2, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props2.length;
        while (++index2 < length) {
          var key = props2[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var nativeMax = Math.max;
      function overRest(func, start2, transform) {
        start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
          while (++index2 < length) {
            array[index2] = args[start2 + index2];
          }
          index2 = -1;
          var otherArgs = Array(start2 + 1);
          while (++index2 < start2) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start2] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start2) {
        return setToString$1(overRest(func, start2, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      var objectProto$6 = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
        return value === proto;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      var argsTag$1 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$1;
      }
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
      var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$5.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArguments$1 = isArguments;
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var isBuffer$1 = isBuffer;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal$1.process;
      var nodeUtil = function() {
        try {
          var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeUtil$1 = nodeUtil;
      var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var isTypedArray$1 = isTypedArray;
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$4.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$3 = Object.prototype;
      var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var nativeCreate = getNative(Object, "create");
      var nativeCreate$1 = nativeCreate;
      function hashClear() {
        this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      var objectProto$2 = Object.prototype;
      var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
      function hashGet(key) {
        var data2 = this.__data__;
        if (nativeCreate$1) {
          var result = data2[key];
          return result === HASH_UNDEFINED$1 ? void 0 : result;
        }
        return hasOwnProperty$2.call(data2, key) ? data2[key] : void 0;
      }
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function hashHas(key) {
        var data2 = this.__data__;
        return nativeCreate$1 ? data2[key] !== void 0 : hasOwnProperty$1.call(data2, key);
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data2 = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data2[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        return index2 < 0 ? void 0 : data2[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key);
        if (index2 < 0) {
          ++this.size;
          data2.push([key, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root$1, "Map");
      var Map$2 = Map$1;
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$2 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data2 = map2.__data__;
        return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data2 = getMapData(this, key), size = data2.size;
        data2.set(key, value);
        this.size += data2.size == size ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var getPrototype$1 = getPrototype;
      var objectTag = "[object Object]";
      var funcProto = Function.prototype, objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype$1(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data2 = this.__data__, result = data2["delete"](key);
        this.size = data2.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key, value);
        this.size = data2.size;
        return this;
      }
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      var Uint8Array$1 = root$1.Uint8Array;
      var Uint8Array$2 = Uint8Array$1;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
          while (length--) {
            var key = props2[fromRight ? length : ++index2];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      var baseFor$1 = baseFor;
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray$1(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
            newValue = objValue;
            if (isArguments$1(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor$1(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var merge$1 = merge;
      const calcAngle = (element, event) => {
        const rect = element.getBoundingClientRect();
        const originX = rect.left + rect.width / 2;
        const originY = rect.top + rect.height / 2;
        const x2 = Math.abs(originX - event.clientX);
        const y2 = Math.abs(originY - event.clientY);
        const z2 = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
        const cos = y2 / z2;
        const rad = Math.acos(cos);
        let angle = Math.floor(180 / (Math.PI / rad));
        if (event.clientX > originX && event.clientY > originY) {
          angle = 180 - angle;
        }
        if (event.clientX == originX && event.clientY > originY) {
          angle = 180;
        }
        if (event.clientX > originX && event.clientY == originY) {
          angle = 90;
        }
        if (event.clientX < originX && event.clientY > originY) {
          angle = 180 + angle;
        }
        if (event.clientX < originX && event.clientY == originY) {
          angle = 270;
        }
        if (event.clientX < originX && event.clientY < originY) {
          angle = 360 - angle;
        }
        return angle;
      };
      let isDragging = false;
      const triggerDragEvent = (element, options) => {
        const moveFn = function(event) {
          var _a;
          (_a = options.drag) == null ? void 0 : _a.call(options, event);
        };
        const upFn = function(event) {
          var _a;
          document.removeEventListener("mousemove", moveFn, false);
          document.removeEventListener("mouseup", upFn, false);
          document.onselectstart = null;
          document.ondragstart = null;
          isDragging = false;
          (_a = options.end) == null ? void 0 : _a.call(options, event);
        };
        if (element) {
          element.addEventListener("mousedown", (event) => {
            var _a;
            if (isDragging)
              return;
            document.onselectstart = () => false;
            document.ondragstart = () => false;
            document.addEventListener("mousemove", moveFn, false);
            document.addEventListener("mouseup", upFn, false);
            isDragging = true;
            (_a = options.start) == null ? void 0 : _a.call(options, event);
          });
        }
        return;
      };
      const angleProps = {
        angle: {
          type: Number,
          default: 0
        },
        size: {
          type: Number,
          default: 16,
          validator: (value) => {
            return value >= 16;
          }
        },
        borderWidth: {
          type: Number,
          default: 1,
          validator: (value) => {
            return value >= 1;
          }
        },
        borderColor: {
          type: String,
          default: "#666"
        }
      };
      var Angle = defineComponent({
        name: "Angle",
        props: angleProps,
        emits: ["update:angle", "change"],
        setup(props2, {
          emit: emit2
        }) {
          const angleRef = ref(null);
          const rotate = ref(props2.angle);
          watch(() => props2.angle, (angle) => {
            rotate.value = angle;
          });
          const updateAngle = () => {
            let value = Number(rotate.value);
            if (!isNaN(value)) {
              value = value > 360 || value < 0 ? props2.angle : value;
              rotate.value = value === 360 ? 0 : value;
              emit2("update:angle", rotate.value);
              emit2("change", rotate.value);
            }
          };
          const getStyle = computed(() => {
            return {
              width: props2.size + "px",
              height: props2.size + "px",
              borderWidth: props2.borderWidth + "px",
              borderColor: props2.borderColor,
              transform: `rotate(${rotate.value}deg)`
            };
          });
          const handleDrag = (event) => {
            if (angleRef.value) {
              rotate.value = calcAngle(angleRef.value, event) % 360;
              updateAngle();
            }
          };
          onMounted(() => {
            const dragConfig = {
              drag: (event) => {
                handleDrag(event);
              },
              end: (event) => {
                handleDrag(event);
              }
            };
            if (angleRef.value) {
              triggerDragEvent(angleRef.value, dragConfig);
            }
          });
          return () => {
            return createVNode("div", {
              "class": "bee-angle"
            }, [createVNode("div", {
              "class": "bee-angle__round",
              "ref": angleRef,
              "style": getStyle.value
            }, null)]);
          };
        }
      });
      var style$1 = "";
      var GradientParser = GradientParser || {};
      GradientParser.stringify = function() {
        var visitor = {
          "visit_linear-gradient": function(node) {
            return visitor.visit_gradient(node);
          },
          "visit_repeating-linear-gradient": function(node) {
            return visitor.visit_gradient(node);
          },
          "visit_radial-gradient": function(node) {
            return visitor.visit_gradient(node);
          },
          "visit_repeating-radial-gradient": function(node) {
            return visitor.visit_gradient(node);
          },
          "visit_gradient": function(node) {
            var orientation = visitor.visit(node.orientation);
            if (orientation) {
              orientation += ", ";
            }
            return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
          },
          "visit_shape": function(node) {
            var result = node.value, at2 = visitor.visit(node.at), style2 = visitor.visit(node.style);
            if (style2) {
              result += " " + style2;
            }
            if (at2) {
              result += " at " + at2;
            }
            return result;
          },
          "visit_default-radial": function(node) {
            var result = "", at2 = visitor.visit(node.at);
            if (at2) {
              result += at2;
            }
            return result;
          },
          "visit_extent-keyword": function(node) {
            var result = node.value, at2 = visitor.visit(node.at);
            if (at2) {
              result += " at " + at2;
            }
            return result;
          },
          "visit_position-keyword": function(node) {
            return node.value;
          },
          "visit_position": function(node) {
            return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
          },
          "visit_%": function(node) {
            return node.value + "%";
          },
          "visit_em": function(node) {
            return node.value + "em";
          },
          "visit_px": function(node) {
            return node.value + "px";
          },
          "visit_literal": function(node) {
            return visitor.visit_color(node.value, node);
          },
          "visit_hex": function(node) {
            return visitor.visit_color("#" + node.value, node);
          },
          "visit_rgb": function(node) {
            return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
          },
          "visit_rgba": function(node) {
            return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
          },
          "visit_color": function(resultColor, node) {
            var result = resultColor, length = visitor.visit(node.length);
            if (length) {
              result += " " + length;
            }
            return result;
          },
          "visit_angular": function(node) {
            return node.value + "deg";
          },
          "visit_directional": function(node) {
            return "to " + node.value;
          },
          "visit_array": function(elements) {
            var result = "", size = elements.length;
            elements.forEach(function(element, i2) {
              result += visitor.visit(element);
              if (i2 < size - 1) {
                result += ", ";
              }
            });
            return result;
          },
          "visit": function(element) {
            if (!element) {
              return "";
            }
            var result = "";
            if (element instanceof Array) {
              return visitor.visit_array(element, result);
            } else if (element.type) {
              var nodeVisitor = visitor["visit_" + element.type];
              if (nodeVisitor) {
                return nodeVisitor(element);
              } else {
                throw Error("Missing visitor visit_" + element.type);
              }
            } else {
              throw Error("Invalid node.");
            }
          }
        };
        return function(root2) {
          return visitor.visit(root2);
        };
      }();
      var GradientParser = GradientParser || {};
      GradientParser.parse = function() {
        var tokens = {
          linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
          repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
          radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
          repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
          sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
          extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
          positionKeywords: /^(left|center|right|top|bottom)/i,
          pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
          percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
          emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
          angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
          startCall: /^\(/,
          endCall: /^\)/,
          comma: /^,/,
          hexColor: /^\#([0-9a-fA-F]+)/,
          literalColor: /^([a-zA-Z]+)/,
          rgbColor: /^rgb/i,
          rgbaColor: /^rgba/i,
          number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
        };
        var input2 = "";
        function error(msg) {
          var err = new Error(input2 + ": " + msg);
          err.source = input2;
          throw err;
        }
        function getAST() {
          var ast = matchListDefinitions();
          if (input2.length > 0) {
            error("Invalid input not EOF");
          }
          return ast;
        }
        function matchListDefinitions() {
          return matchListing(matchDefinition);
        }
        function matchDefinition() {
          return matchGradient("linear-gradient", tokens.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens.repeatingRadialGradient, matchListRadialOrientations);
        }
        function matchGradient(gradientType, pattern, orientationMatcher) {
          return matchCall(pattern, function(captures) {
            var orientation = orientationMatcher();
            if (orientation) {
              if (!scan(tokens.comma)) {
                error("Missing comma before color stops");
              }
            }
            return {
              type: gradientType,
              orientation,
              colorStops: matchListing(matchColorStop)
            };
          });
        }
        function matchCall(pattern, callback) {
          var captures = scan(pattern);
          if (captures) {
            if (!scan(tokens.startCall)) {
              error("Missing (");
            }
            var result = callback(captures);
            if (!scan(tokens.endCall)) {
              error("Missing )");
            }
            return result;
          }
        }
        function matchLinearOrientation() {
          return matchSideOrCorner() || matchAngle();
        }
        function matchSideOrCorner() {
          return match("directional", tokens.sideOrCorner, 1);
        }
        function matchAngle() {
          return match("angular", tokens.angleValue, 1);
        }
        function matchListRadialOrientations() {
          var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
          if (radialOrientation) {
            radialOrientations = [];
            radialOrientations.push(radialOrientation);
            lookaheadCache = input2;
            if (scan(tokens.comma)) {
              radialOrientation = matchRadialOrientation();
              if (radialOrientation) {
                radialOrientations.push(radialOrientation);
              } else {
                input2 = lookaheadCache;
              }
            }
          }
          return radialOrientations;
        }
        function matchRadialOrientation() {
          var radialType = matchCircle() || matchEllipse();
          if (radialType) {
            radialType.at = matchAtPosition();
          } else {
            var extent = matchExtentKeyword();
            if (extent) {
              radialType = extent;
              var positionAt = matchAtPosition();
              if (positionAt) {
                radialType.at = positionAt;
              }
            } else {
              var defaultPosition = matchPositioning();
              if (defaultPosition) {
                radialType = {
                  type: "default-radial",
                  at: defaultPosition
                };
              }
            }
          }
          return radialType;
        }
        function matchCircle() {
          var circle = match("shape", /^(circle)/i, 0);
          if (circle) {
            circle.style = matchLength() || matchExtentKeyword();
          }
          return circle;
        }
        function matchEllipse() {
          var ellipse = match("shape", /^(ellipse)/i, 0);
          if (ellipse) {
            ellipse.style = matchDistance() || matchExtentKeyword();
          }
          return ellipse;
        }
        function matchExtentKeyword() {
          return match("extent-keyword", tokens.extentKeywords, 1);
        }
        function matchAtPosition() {
          if (match("position", /^at/, 0)) {
            var positioning = matchPositioning();
            if (!positioning) {
              error("Missing positioning value");
            }
            return positioning;
          }
        }
        function matchPositioning() {
          var location2 = matchCoordinates();
          if (location2.x || location2.y) {
            return {
              type: "position",
              value: location2
            };
          }
        }
        function matchCoordinates() {
          return {
            x: matchDistance(),
            y: matchDistance()
          };
        }
        function matchListing(matcher) {
          var captures = matcher(), result = [];
          if (captures) {
            result.push(captures);
            while (scan(tokens.comma)) {
              captures = matcher();
              if (captures) {
                result.push(captures);
              } else {
                error("One extra comma");
              }
            }
          }
          return result;
        }
        function matchColorStop() {
          var color = matchColor();
          if (!color) {
            error("Expected color definition");
          }
          color.length = matchDistance();
          return color;
        }
        function matchColor() {
          return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
        }
        function matchLiteralColor() {
          return match("literal", tokens.literalColor, 0);
        }
        function matchHexColor() {
          return match("hex", tokens.hexColor, 1);
        }
        function matchRGBColor() {
          return matchCall(tokens.rgbColor, function() {
            return {
              type: "rgb",
              value: matchListing(matchNumber)
            };
          });
        }
        function matchRGBAColor() {
          return matchCall(tokens.rgbaColor, function() {
            return {
              type: "rgba",
              value: matchListing(matchNumber)
            };
          });
        }
        function matchNumber() {
          return scan(tokens.number)[1];
        }
        function matchDistance() {
          return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
        }
        function matchPositionKeyword() {
          return match("position-keyword", tokens.positionKeywords, 1);
        }
        function matchLength() {
          return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
        }
        function match(type, pattern, captureIndex) {
          var captures = scan(pattern);
          if (captures) {
            return {
              type,
              value: captures[captureIndex]
            };
          }
        }
        function scan(regexp) {
          var captures, blankCaptures;
          blankCaptures = /^[\n\r\t\s]+/.exec(input2);
          if (blankCaptures) {
            consume(blankCaptures[0].length);
          }
          captures = regexp.exec(input2);
          if (captures) {
            consume(captures[0].length);
          }
          return captures;
        }
        function consume(size) {
          input2 = input2.substr(size);
        }
        return function(code) {
          input2 = code.toString();
          return getAST();
        };
      }();
      var parse = GradientParser.parse;
      var stringify = GradientParser.stringify;
      var __defProp2 = Object.defineProperty;
      var __defProps2 = Object.defineProperties;
      var __getOwnPropDescs2 = Object.getOwnPropertyDescriptors;
      var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
      var __hasOwnProp2 = Object.prototype.hasOwnProperty;
      var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
      var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues2 = (a2, b2) => {
        for (var prop in b2 || (b2 = {}))
          if (__hasOwnProp2.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        if (__getOwnPropSymbols2)
          for (var prop of __getOwnPropSymbols2(b2)) {
            if (__propIsEnum2.call(b2, prop))
              __defNormalProp2(a2, prop, b2[prop]);
          }
        return a2;
      };
      var __spreadProps2 = (a2, b2) => __defProps2(a2, __getOwnPropDescs2(b2));
      var __publicField = (obj, key, value) => {
        __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
        return value;
      };
      const double = (num) => {
        return Math.round(num * 100) / 100;
      };
      class Color {
        constructor(input2) {
          __publicField(this, "instance");
          __publicField(this, "alphaValue", 0);
          __publicField(this, "redValue", 0);
          __publicField(this, "greenValue", 0);
          __publicField(this, "blueValue", 0);
          __publicField(this, "hueValue", 0);
          __publicField(this, "saturationValue", 0);
          __publicField(this, "brightnessValue", 0);
          __publicField(this, "hslSaturationValue", 0);
          __publicField(this, "lightnessValue", 0);
          __publicField(this, "initAlpha", () => {
            const initAlpha = this.instance.getAlpha();
            this.alphaValue = Math.min(1, initAlpha) * 100;
          });
          __publicField(this, "initLightness", () => {
            const { s: s2, l: l2 } = this.instance.toHsl();
            this.hslSaturationValue = double(s2);
            this.lightnessValue = double(l2);
          });
          __publicField(this, "initRgb", () => {
            const { r: r2, g: g2, b: b2 } = this.instance.toRgb();
            this.redValue = double(r2);
            this.greenValue = double(g2);
            this.blueValue = double(b2);
          });
          __publicField(this, "initHsb", () => {
            const { h: h2, s: s2, v: v2 } = this.instance.toHsv();
            this.hueValue = Math.min(360, Math.ceil(h2));
            this.saturationValue = double(s2);
            this.brightnessValue = double(v2);
          });
          __publicField(this, "toHexString", () => {
            return this.instance.toHexString();
          });
          __publicField(this, "toRgbString", () => {
            return this.instance.toRgbString();
          });
          this.instance = tinycolor(input2);
          this.initRgb();
          this.initHsb();
          this.initLightness();
          this.initAlpha();
        }
        toString(format2) {
          return this.instance.toString(format2);
        }
        get hex() {
          return this.instance.toHex();
        }
        set hex(hexString) {
          this.instance = tinycolor(hexString);
          this.initHsb();
          this.initRgb();
          this.initAlpha();
          this.initLightness();
        }
        set hue(value) {
          if (this.saturation === 0 && this.brightness === 0) {
            this.saturationValue = 1;
            this.brightnessValue = 1;
          }
          this.instance = tinycolor({
            h: double(value),
            s: this.saturation,
            v: this.brightness,
            a: this.alphaValue / 100
          });
          this.initRgb();
          this.initLightness();
          this.hueValue = double(value);
        }
        get hue() {
          return this.hueValue;
        }
        set saturation(value) {
          this.instance = tinycolor({
            h: this.hue,
            s: double(value),
            v: this.brightness,
            a: this.alphaValue / 100
          });
          this.initRgb();
          this.initLightness();
          this.saturationValue = double(value);
        }
        get saturation() {
          return this.saturationValue;
        }
        set brightness(value) {
          this.instance = tinycolor({
            h: this.hue,
            s: this.saturation,
            v: double(value),
            a: this.alphaValue / 100
          });
          this.initRgb();
          this.initLightness();
          this.brightnessValue = double(value);
        }
        get brightness() {
          return this.brightnessValue;
        }
        set lightness(value) {
          this.instance = tinycolor({
            h: this.hue,
            s: this.hslSaturationValue,
            l: double(value),
            a: this.alphaValue / 100
          });
          this.initRgb();
          this.initHsb();
          this.lightnessValue = double(value);
        }
        get lightness() {
          return this.lightnessValue;
        }
        set red(value) {
          const rgb = this.instance.toRgb();
          this.instance = tinycolor(__spreadProps2(__spreadValues2({}, rgb), {
            r: double(value),
            a: this.alphaValue / 100
          }));
          this.initHsb();
          this.initLightness();
          this.redValue = double(value);
        }
        get red() {
          return this.redValue;
        }
        set green(value) {
          const rgb = this.instance.toRgb();
          this.instance = tinycolor(__spreadProps2(__spreadValues2({}, rgb), {
            g: double(value),
            a: this.alphaValue / 100
          }));
          this.initHsb();
          this.initLightness();
          this.greenValue = double(value);
        }
        get green() {
          return this.greenValue;
        }
        set blue(value) {
          const rgb = this.instance.toRgb();
          this.instance = tinycolor(__spreadProps2(__spreadValues2({}, rgb), {
            b: double(value),
            a: this.alphaValue / 100
          }));
          this.initHsb();
          this.initLightness();
          this.blueValue = double(value);
        }
        get blue() {
          return this.blueValue;
        }
        set alpha(value) {
          this.instance.setAlpha(value / 100);
          this.alphaValue = value;
        }
        get alpha() {
          return this.alphaValue;
        }
        get RGB() {
          return [this.red, this.green, this.blue, this.alpha / 100];
        }
        get HSB() {
          return [this.hue, this.saturation, this.brightness, this.alpha / 100];
        }
        get HSL() {
          return [this.hue, this.hslSaturationValue, this.lightness, this.alpha / 100];
        }
      }
      function rgbaColor(r2, g2, b2, a2) {
        return `rgba(${[r2, g2, b2, a2 / 100].join(",")})`;
      }
      const clamp = (value, min2, max2) => {
        return min2 < max2 ? value < min2 ? min2 : value > max2 ? max2 : value : value < max2 ? max2 : value > min2 ? min2 : value;
      };
      const HistoryColorKey = "color-history";
      const MAX_STORAGE_LENGTH = 8;
      var _export_sfc = (sfc, props2) => {
        for (const [key, val] of props2) {
          sfc[key] = val;
        }
        return sfc;
      };
      const _sfc_main$b = defineComponent({
        name: "Alpha",
        props: {
          color: z$1.instanceOf(Color),
          size: z$1.oneOf(["small", "default"]).def("default")
        },
        emits: ["change"],
        setup(props2, { emit: emit2 }) {
          const barElement = ref(null);
          const cursorElement = ref(null);
          let color = props2.color || new Color();
          const state2 = reactive({
            red: color.red,
            green: color.green,
            blue: color.blue,
            alpha: color.alpha
          });
          watch(() => props2.color, (value) => {
            if (value) {
              color = value;
              merge$1(state2, {
                red: value.red,
                green: value.green,
                blue: value.blue,
                alpha: value.alpha
              });
            }
          }, { deep: true });
          const getBackgroundStyle = computed(() => {
            const startColor = rgbaColor(state2.red, state2.green, state2.blue, 0);
            const endColor = rgbaColor(state2.red, state2.green, state2.blue, 100);
            return {
              background: `linear-gradient(to right, ${startColor} , ${endColor})`
            };
          });
          const getCursorLeft = () => {
            if (barElement.value && cursorElement.value) {
              const alpha = state2.alpha / 100;
              const rect = barElement.value.getBoundingClientRect();
              const offsetWidth = cursorElement.value.offsetWidth;
              return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
            }
            return 0;
          };
          const getCursorStyle = computed(() => {
            const left2 = getCursorLeft();
            return {
              left: left2 + "px",
              top: 0
            };
          });
          const onClickSider = (event) => {
            const target = event.target;
            if (target !== barElement.value) {
              onMoveBar(event);
            }
          };
          const onMoveBar = (event) => {
            event.stopPropagation();
            if (barElement.value && cursorElement.value) {
              const rect = barElement.value.getBoundingClientRect();
              const offsetWidth = cursorElement.value.offsetWidth;
              let left2 = event.clientX - rect.left;
              left2 = Math.max(offsetWidth / 2, left2);
              left2 = Math.min(left2, rect.width - offsetWidth / 2);
              const alpha = Math.round((left2 - offsetWidth / 2) / (rect.width - offsetWidth) * 100);
              color.alpha = alpha;
              state2.alpha = alpha;
              emit2("change", alpha);
            }
          };
          tryOnMounted(() => {
            const dragConfig = {
              drag: (event) => {
                onMoveBar(event);
              },
              end: (event) => {
                onMoveBar(event);
              }
            };
            if (barElement.value && cursorElement.value) {
              Vn.triggerDragEvent(barElement.value, dragConfig);
            }
          });
          return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
        }
      });
      const _withScopeId$5 = (n2) => (pushScopeId("data-v-18925ba6"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$a = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
      const _hoisted_2$a = [
        _hoisted_1$a
      ];
      function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": _ctx.size === "small" }])
        }, [
          createElementVNode("div", {
            ref: "barElement",
            class: "vc-alpha-slider__bar",
            style: normalizeStyle(_ctx.getBackgroundStyle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
          }, [
            createElementVNode("div", {
              class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
              ref: "cursorElement",
              style: normalizeStyle(_ctx.getCursorStyle)
            }, _hoisted_2$a, 6)
          ], 4)
        ], 2);
      }
      var Alpha = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-18925ba6"]]);
      const defaultColors = [
        [
          "#fcc02e",
          "#f67c01",
          "#e64a19",
          "#d81b43",
          "#8e24aa",
          "#512da7",
          "#1f87e8",
          "#008781",
          "#05a045"
        ],
        [
          "#fed835",
          "#fb8c00",
          "#f5511e",
          "#eb1d4e",
          "#9c28b1",
          "#5d35b0",
          "#2097f3",
          "#029688",
          "#4cb050"
        ],
        [
          "#ffeb3c",
          "#ffa727",
          "#fe5722",
          "#eb4165",
          "#aa47bc",
          "#673bb7",
          "#42a5f6",
          "#26a59a",
          "#83c683"
        ],
        [
          "#fff176",
          "#ffb74e",
          "#ff8a66",
          "#f1627e",
          "#b968c7",
          "#7986cc",
          "#64b5f6",
          "#80cbc4",
          "#a5d6a7"
        ],
        [
          "#fff59c",
          "#ffcc80",
          "#ffab91",
          "#fb879e",
          "#cf93d9",
          "#9ea8db",
          "#90caf8",
          "#b2dfdc",
          "#c8e6ca"
        ],
        [
          "transparent",
          "#ffffff",
          "#dedede",
          "#a9a9a9",
          "#4b4b4b",
          "#353535",
          "#212121",
          "#000000",
          "advance"
        ]
      ];
      const _sfc_main$a = defineComponent({
        name: "Palette",
        emits: ["change"],
        setup(_props, { emit: emit2 }) {
          const computedBgStyle = (color) => {
            if (color === "transparent") {
              return color;
            }
            if (color === "advance") {
              return {};
            }
            return { background: tinycolor(color).toRgbString() };
          };
          const onColorChange = (color) => {
            emit2("change", color);
          };
          return { palettes: defaultColors, computedBgStyle, onColorChange };
        }
      });
      const _hoisted_1$9 = { class: "vc-compact" };
      const _hoisted_2$9 = ["onClick"];
      function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", _hoisted_1$9, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palettes, (v2, i2) => {
            return openBlock(), createElementBlock("div", {
              key: i2,
              class: "vc-compact__row"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(v2, (v1, k2) => {
                return openBlock(), createElementBlock("div", {
                  key: k2,
                  class: "vc-compact__color-cube--wrap",
                  onClick: ($event) => _ctx.onColorChange(v1)
                }, [
                  createElementVNode("div", {
                    class: normalizeClass([
                      "vc-compact__color_cube",
                      {
                        advance: v1 === "advance",
                        transparent: v1 === "transparent"
                      }
                    ]),
                    style: normalizeStyle(_ctx.computedBgStyle(v1))
                  }, null, 6)
                ], 8, _hoisted_2$9);
              }), 128))
            ]);
          }), 128))
        ]);
      }
      var Palette = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-b969fd48"]]);
      const _sfc_main$9 = defineComponent({
        name: "Board",
        props: {
          color: z$1.instanceOf(Color),
          round: z$1.bool.def(false),
          hide: z$1.bool.def(true)
        },
        emits: ["change"],
        setup(props2, { emit: emit2 }) {
          var _a, _b, _c;
          const instance = getCurrentInstance();
          const hueHsv = {
            h: ((_a = props2.color) == null ? void 0 : _a.hue) || 0,
            s: 1,
            v: 1
          };
          const hueColor = new Color(hueHsv).toHexString();
          const state2 = reactive({
            hueColor,
            saturation: ((_b = props2.color) == null ? void 0 : _b.saturation) || 0,
            brightness: ((_c = props2.color) == null ? void 0 : _c.brightness) || 0
          });
          const cursorTop = ref(0);
          const cursorLeft = ref(0);
          const cursorElement = ref();
          const boardElement = ref();
          const getCursorStyle = computed(() => {
            return {
              top: cursorTop.value + "px",
              left: cursorLeft.value + "px"
            };
          });
          const updatePosition = () => {
            if (instance) {
              const el = instance.vnode.el;
              cursorLeft.value = state2.saturation * (el == null ? void 0 : el.clientWidth);
              cursorTop.value = (1 - state2.brightness) * (el == null ? void 0 : el.clientHeight);
            }
          };
          const onClickBoard = (event) => {
            const target = event.target;
            if (target !== boardElement.value) {
              handleDrag(event);
            }
          };
          const handleDrag = (event) => {
            if (instance) {
              const el = instance.vnode.el;
              const rect = el == null ? void 0 : el.getBoundingClientRect();
              let left2 = event.clientX - rect.left;
              let top2 = event.clientY - rect.top;
              left2 = clamp(left2, 0, rect.width);
              top2 = clamp(top2, 0, rect.height);
              const saturation = left2 / rect.width;
              const bright = clamp(-(top2 / rect.height) + 1, 0, 1);
              cursorLeft.value = left2;
              cursorTop.value = top2;
              state2.saturation = saturation;
              state2.brightness = bright;
              emit2("change", saturation, bright);
            }
          };
          tryOnMounted(() => {
            if (instance && instance.vnode.el && cursorElement.value) {
              Vn.triggerDragEvent(cursorElement.value, {
                drag: (event) => {
                  handleDrag(event);
                },
                end: (event) => {
                  handleDrag(event);
                }
              });
              updatePosition();
            }
          });
          whenever(() => props2.color, (value) => {
            merge$1(state2, {
              hueColor: new Color({ h: value.hue, s: 1, v: 1 }).toHexString(),
              saturation: value.saturation,
              brightness: value.brightness
            });
            updatePosition();
          }, { deep: true });
          return { state: state2, cursorElement, getCursorStyle, onClickBoard };
        }
      });
      const _withScopeId$4 = (n2) => (pushScopeId("data-v-63803390"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__white" }, null, -1));
      const _hoisted_2$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__black" }, null, -1));
      const _hoisted_3$6 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", null, null, -1));
      const _hoisted_4$5 = [
        _hoisted_3$6
      ];
      function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          ref: "boardElement",
          class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": _ctx.round, "vc-saturation__hidden": _ctx.hide }]),
          style: normalizeStyle({ backgroundColor: _ctx.state.hueColor }),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickBoard && _ctx.onClickBoard(...args))
        }, [
          _hoisted_1$8,
          _hoisted_2$8,
          createElementVNode("div", {
            class: "vc-saturation__cursor",
            ref: "cursorElement",
            style: normalizeStyle(_ctx.getCursorStyle)
          }, _hoisted_4$5, 4)
        ], 6);
      }
      var Board = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-63803390"]]);
      const _sfc_main$8 = defineComponent({
        name: "Hue",
        props: {
          color: z$1.instanceOf(Color),
          size: z$1.oneOf(["small", "default"]).def("default")
        },
        emits: ["change"],
        setup(props2, { emit: emit2 }) {
          const barElement = ref(null);
          const cursorElement = ref(null);
          let color = props2.color || new Color();
          const state2 = reactive({
            hue: color.hue || 0
          });
          watch(() => props2.color, (value) => {
            if (value) {
              color = value;
              merge$1(state2, { hue: color.hue });
            }
          }, { deep: true });
          const getCursorLeft = () => {
            if (barElement.value && cursorElement.value) {
              const rect = barElement.value.getBoundingClientRect();
              const offsetWidth = cursorElement.value.offsetWidth;
              if (state2.hue === 360) {
                return rect.width - offsetWidth / 2;
              }
              return state2.hue % 360 * (rect.width - offsetWidth) / 360 + offsetWidth / 2;
            }
            return 0;
          };
          const getCursorStyle = computed(() => {
            const left2 = getCursorLeft();
            return {
              left: left2 + "px",
              top: 0
            };
          });
          const onClickSider = (event) => {
            const target = event.target;
            if (target !== barElement.value) {
              onMoveBar(event);
            }
          };
          const onMoveBar = (event) => {
            event.stopPropagation();
            if (barElement.value && cursorElement.value) {
              const rect = barElement.value.getBoundingClientRect();
              const offsetWidth = cursorElement.value.offsetWidth;
              let left2 = event.clientX - rect.left;
              left2 = Math.min(left2, rect.width - offsetWidth / 2);
              left2 = Math.max(offsetWidth / 2, left2);
              const hue = Math.round((left2 - offsetWidth / 2) / (rect.width - offsetWidth) * 360);
              color.hue = hue;
              state2.hue = hue;
              emit2("change", hue);
            }
          };
          tryOnMounted(() => {
            const dragConfig = {
              drag: (event) => {
                onMoveBar(event);
              },
              end: (event) => {
                onMoveBar(event);
              }
            };
            if (barElement.value && cursorElement.value) {
              Vn.triggerDragEvent(barElement.value, dragConfig);
            }
          });
          return { barElement, cursorElement, getCursorStyle, onClickSider };
        }
      });
      const _withScopeId$3 = (n2) => (pushScopeId("data-v-5c4cae5b"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
      const _hoisted_2$7 = [
        _hoisted_1$7
      ];
      function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["vc-hue-slider", { "small-slider": _ctx.size === "small" }])
        }, [
          createElementVNode("div", {
            ref: "barElement",
            class: "vc-hue-slider__bar",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
          }, [
            createElementVNode("div", {
              class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
              ref: "cursorElement",
              style: normalizeStyle(_ctx.getCursorStyle)
            }, _hoisted_2$7, 6)
          ], 512)
        ], 2);
      }
      var Hue = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-5c4cae5b"]]);
      const _sfc_main$7 = defineComponent({
        name: "Lightness",
        props: {
          color: z$1.instanceOf(Color),
          size: z$1.oneOf(["small", "default"]).def("default")
        },
        emits: ["change"],
        setup(props2, { emit: emit2 }) {
          const barElement = ref(null);
          const cursorElement = ref(null);
          let color = props2.color || new Color();
          const [h2, s2, l2] = color.HSL;
          const state2 = reactive({
            hue: h2,
            saturation: s2,
            lightness: l2
          });
          watch(() => props2.color, (value) => {
            if (value) {
              color = value;
              const [hue, saturation, lightness] = color.HSL;
              merge$1(state2, {
                hue,
                saturation,
                lightness
              });
            }
          }, { deep: true });
          const getBackgroundStyle = computed(() => {
            const color1 = tinycolor({
              h: state2.hue,
              s: state2.saturation,
              l: 0.8
            }).toPercentageRgbString();
            const color2 = tinycolor({
              h: state2.hue,
              s: state2.saturation,
              l: 0.6
            }).toPercentageRgbString();
            const color3 = tinycolor({
              h: state2.hue,
              s: state2.saturation,
              l: 0.4
            }).toPercentageRgbString();
            const color4 = tinycolor({
              h: state2.hue,
              s: state2.saturation,
              l: 0.2
            }).toPercentageRgbString();
            return {
              background: [
                `-webkit-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
                `-moz-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
                `-ms-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`
              ]
            };
          });
          const getCursorLeft = () => {
            if (barElement.value && cursorElement.value) {
              const lightness = state2.lightness;
              const rect = barElement.value.getBoundingClientRect();
              const offsetWidth = cursorElement.value.offsetWidth;
              return (1 - lightness) * (rect.width - offsetWidth) + offsetWidth / 2;
            }
            return 0;
          };
          const getCursorStyle = computed(() => {
            const left2 = getCursorLeft();
            return {
              left: left2 + "px",
              top: 0
            };
          });
          const onClickSider = (event) => {
            const target = event.target;
            if (target !== barElement.value) {
              onMoveBar(event);
            }
          };
          const onMoveBar = (event) => {
            event.stopPropagation();
            if (barElement.value && cursorElement.value) {
              const rect = barElement.value.getBoundingClientRect();
              const offsetWidth = cursorElement.value.offsetWidth;
              let left2 = event.clientX - rect.left;
              left2 = Math.max(offsetWidth / 2, left2);
              left2 = Math.min(left2, rect.width - offsetWidth / 2);
              const light = 1 - (left2 - offsetWidth / 2) / (rect.width - offsetWidth);
              color.lightness = light;
              emit2("change", light);
            }
          };
          tryOnMounted(() => {
            const dragConfig = {
              drag: (event) => {
                onMoveBar(event);
              },
              end: (event) => {
                onMoveBar(event);
              }
            };
            if (barElement.value && cursorElement.value) {
              Vn.triggerDragEvent(barElement.value, dragConfig);
            }
          });
          return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
        }
      });
      const _withScopeId$2 = (n2) => (pushScopeId("data-v-6156acb7"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$6 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
      const _hoisted_2$6 = [
        _hoisted_1$6
      ];
      function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", {
          class: normalizeClass(["vc-lightness-slider", { "small-slider": _ctx.size === "small" }])
        }, [
          createElementVNode("div", {
            ref: "barElement",
            class: "vc-lightness-slider__bar",
            style: normalizeStyle(_ctx.getBackgroundStyle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
          }, [
            createElementVNode("div", {
              class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
              ref: "cursorElement",
              style: normalizeStyle(_ctx.getCursorStyle)
            }, _hoisted_2$6, 6)
          ], 4)
        ], 2);
      }
      var Lightness = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-6156acb7"]]);
      const _sfc_main$6 = defineComponent({
        name: "History",
        props: {
          colors: z$1.arrayOf(String).def(() => []),
          round: z$1.bool.def(false)
        },
        emits: ["change"],
        setup(_props, { emit: emit2 }) {
          const onColorSelect = (v2) => {
            emit2("change", v2);
          };
          return { onColorSelect };
        }
      });
      const _hoisted_1$5 = {
        key: 0,
        class: "vc-colorPicker__record"
      };
      const _hoisted_2$5 = { class: "color-list" };
      const _hoisted_3$5 = ["onClick"];
      function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
        return _ctx.colors && _ctx.colors.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
          createElementVNode("div", _hoisted_2$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colors, (v2, i2) => {
              return openBlock(), createElementBlock("div", {
                key: i2,
                class: normalizeClass(["color-item", "transparent", { "color-item__round": _ctx.round }]),
                onClick: ($event) => _ctx.onColorSelect(v2)
              }, [
                createElementVNode("div", {
                  class: "color-item__display",
                  style: normalizeStyle({ backgroundColor: v2 })
                }, null, 4)
              ], 10, _hoisted_3$5);
            }), 128))
          ])
        ])) : createCommentVNode("", true);
      }
      var History = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-7e6b67ca"]]);
      const _sfc_main$5 = defineComponent({
        name: "Display",
        props: {
          color: z$1.instanceOf(Color),
          disableAlpha: z$1.bool.def(false)
        },
        emits: ["update:color", "change"],
        setup(props2, { emit: emit2 }) {
          var _a, _b, _c;
          const state2 = reactive({
            color: props2.color,
            previewBgColor: (_a = props2.color) == null ? void 0 : _a.toRgbString(),
            alpha: ((_b = props2.color) == null ? void 0 : _b.alpha) || 100,
            hex: (_c = props2.color) == null ? void 0 : _c.hex
          });
          const getBgColorStyle = computed(() => {
            return {
              background: state2.previewBgColor
            };
          });
          const onAlphaBlur = (evt) => {
            const target = evt.target;
            const opacity = parseInt(target.value.replace("%", ""));
            if (!isNaN(opacity) && state2.color) {
              state2.alpha = opacity;
              state2.color.alpha = opacity;
            }
          };
          const onInputChange = (event) => {
            const target = event.target;
            const hex = target.value.replace("#", "");
            if (tinycolor(hex).isValid() && state2.color) {
              state2.color.hex = hex;
            }
          };
          whenever(() => props2.color, (value) => {
            if (value) {
              state2.color = value;
            }
          }, { deep: true });
          whenever(() => state2.color, () => {
            if (state2.color) {
              state2.previewBgColor = state2.color.toRgbString();
              state2.alpha = state2.color.alpha;
              state2.hex = state2.color.hex;
              emit2("update:color", state2.color);
              emit2("change", state2.color);
            }
          }, { deep: true });
          return { state: state2, getBgColorStyle, onAlphaBlur, onInputChange };
        }
      });
      const _hoisted_1$4 = { class: "vc-display" };
      const _hoisted_2$4 = { class: "vc-current-color vc-transparent" };
      const _hoisted_3$4 = { class: "vc-color-input" };
      const _hoisted_4$4 = ["value"];
      const _hoisted_5$4 = {
        key: 0,
        class: "vc-alpha-input"
      };
      const _hoisted_6$2 = ["value"];
      function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", _hoisted_1$4, [
          createElementVNode("div", _hoisted_2$4, [
            createElementVNode("div", {
              class: "color-cube",
              style: normalizeStyle(_ctx.getBgColorStyle)
            }, null, 4)
          ]),
          createElementVNode("div", _hoisted_3$4, [
            createElementVNode("input", {
              value: _ctx.state.hex,
              onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onInputChange && _ctx.onInputChange(...args))
            }, null, 40, _hoisted_4$4)
          ]),
          !_ctx.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_5$4, [
            createElementVNode("input", {
              class: "vc-alpha-input__inner",
              value: _ctx.state.alpha + "%",
              onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onAlphaBlur && _ctx.onAlphaBlur(...args))
            }, null, 40, _hoisted_6$2)
          ])) : createCommentVNode("", true)
        ]);
      }
      var Display = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-0067da1d"]]);
      const _sfc_main$4 = defineComponent({
        name: "FkColorPicker",
        components: { Display, Alpha, Palette, Board, Hue, Lightness, History },
        props: {
          color: z$1.instanceOf(Color),
          disableHistory: z$1.bool.def(false),
          roundHistory: z$1.bool.def(false),
          disableAlpha: z$1.bool.def(false)
        },
        emits: ["update:color", "change", "advanceChange"],
        setup(props2, { emit: emit2 }) {
          const colorInstance = props2.color || new Color();
          const state2 = reactive({
            color: colorInstance,
            hex: colorInstance.toHexString(),
            rgb: colorInstance.toRgbString()
          });
          const advancePanelShow = ref(false);
          const previewStyle = computed(() => {
            return { background: state2.rgb };
          });
          const onBack = () => {
            advancePanelShow.value = false;
            emit2("advanceChange", false);
          };
          const historyColors = useLocalStorage(HistoryColorKey, [], {});
          const updateColorHistoryFn = useDebounceFn(() => {
            if (props2.disableHistory) {
              return;
            }
            const rgbString = state2.color.toRgbString();
            historyColors.value = historyColors.value.filter((value) => {
              return !tinycolor.equals(value, rgbString);
            });
            if (historyColors.value.includes(rgbString)) {
              return;
            }
            while (historyColors.value.length > MAX_STORAGE_LENGTH) {
              historyColors.value.pop();
            }
            historyColors.value.unshift(rgbString);
          }, 500);
          const onCompactChange = (color) => {
            if (color === "advance") {
              advancePanelShow.value = true;
              emit2("advanceChange", true);
            } else {
              state2.color.hex = color;
              emit2("advanceChange", false);
            }
          };
          const onAlphaChange = (alpha) => {
            state2.color.alpha = alpha;
          };
          const onHueChange = (hue) => {
            state2.color.hue = hue;
          };
          const onBoardChange = (saturation, brightness) => {
            state2.color.saturation = saturation;
            state2.color.brightness = brightness;
          };
          const onLightChange = (light) => {
            state2.color.lightness = light;
          };
          const onInputChange = (event) => {
            const target = event.target;
            const hex = target.value.replace("#", "");
            if (tinycolor(hex).isValid()) {
              state2.color.hex = hex;
            }
          };
          whenever(() => props2.color, (value) => {
            if (value) {
              state2.color = value;
            }
          }, { deep: true });
          whenever(() => state2.color, () => {
            state2.hex = state2.color.hex;
            state2.rgb = state2.color.toRgbString();
            updateColorHistoryFn();
            emit2("update:color", state2.color);
            emit2("change", state2.color);
          }, { deep: true });
          return {
            state: state2,
            advancePanelShow,
            onBack,
            onCompactChange,
            onAlphaChange,
            onHueChange,
            onBoardChange,
            onLightChange,
            onInputChange,
            previewStyle,
            historyColors
          };
        }
      });
      const _withScopeId$1 = (n2) => (pushScopeId("data-v-592a5ec3"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$3 = { class: "vc-fk-colorPicker" };
      const _hoisted_2$3 = { class: "vc-fk-colorPicker__inner" };
      const _hoisted_3$3 = { class: "vc-fk-colorPicker__header" };
      const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
      const _hoisted_5$3 = [
        _hoisted_4$3
      ];
      function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_Palette = resolveComponent("Palette");
        const _component_Board = resolveComponent("Board");
        const _component_Hue = resolveComponent("Hue");
        const _component_Lightness = resolveComponent("Lightness");
        const _component_Alpha = resolveComponent("Alpha");
        const _component_Display = resolveComponent("Display");
        const _component_History = resolveComponent("History");
        return openBlock(), createElementBlock("div", _hoisted_1$3, [
          createElementVNode("div", _hoisted_2$3, [
            createElementVNode("div", _hoisted_3$3, [
              _ctx.advancePanelShow ? (openBlock(), createElementBlock("span", {
                key: 0,
                style: { "cursor": "pointer" },
                onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
              }, _hoisted_5$3)) : createCommentVNode("", true)
            ]),
            !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
              key: 0,
              onChange: _ctx.onCompactChange
            }, null, 8, ["onChange"])) : createCommentVNode("", true),
            _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
              key: 1,
              color: _ctx.state.color,
              onChange: _ctx.onBoardChange
            }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
            _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
              key: 2,
              color: _ctx.state.color,
              onChange: _ctx.onHueChange
            }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
            !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
              key: 3,
              color: _ctx.state.color,
              onChange: _ctx.onLightChange
            }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
            !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
              key: 4,
              color: _ctx.state.color,
              onChange: _ctx.onAlphaChange
            }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
            createVNode(_component_Display, {
              color: _ctx.state.color,
              "disable-alpha": _ctx.disableAlpha
            }, null, 8, ["color", "disable-alpha"]),
            !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
              key: 5,
              round: _ctx.roundHistory,
              colors: _ctx.historyColors,
              onChange: _ctx.onCompactChange
            }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
          ])
        ]);
      }
      var FkColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-592a5ec3"]]);
      const _sfc_main$3 = defineComponent({
        name: "ChromeColorPicker",
        components: { Display, Alpha, Board, Hue, History },
        props: {
          color: z$1.instanceOf(Color),
          disableHistory: z$1.bool.def(false),
          roundHistory: z$1.bool.def(false),
          disableAlpha: z$1.bool.def(false)
        },
        emits: ["update:color", "change"],
        setup(props2, { emit: emit2 }) {
          const colorInstance = props2.color || new Color();
          const state2 = reactive({
            color: colorInstance,
            hex: colorInstance.toHexString(),
            rgb: colorInstance.toRgbString()
          });
          const previewStyle = computed(() => {
            return { background: state2.rgb };
          });
          const historyColors = useLocalStorage(HistoryColorKey, [], {});
          const updateColorHistoryFn = useDebounceFn(() => {
            if (props2.disableHistory) {
              return;
            }
            const rgbString = state2.color.toRgbString();
            historyColors.value = historyColors.value.filter((value) => {
              return !tinycolor.equals(value, rgbString);
            });
            if (historyColors.value.includes(rgbString)) {
              return;
            }
            while (historyColors.value.length > MAX_STORAGE_LENGTH) {
              historyColors.value.pop();
            }
            historyColors.value.unshift(rgbString);
          }, 500);
          const onAlphaChange = (alpha) => {
            state2.color.alpha = alpha;
          };
          const onHueChange = (hue) => {
            state2.color.hue = hue;
          };
          const onBoardChange = (saturation, brightness) => {
            state2.color.saturation = saturation;
            state2.color.brightness = brightness;
          };
          const onCompactChange = (color) => {
            if (color !== "advance") {
              state2.color.hex = color;
            }
          };
          whenever(() => props2.color, (value) => {
            if (value) {
              state2.color = value;
            }
          }, { deep: true });
          whenever(() => state2.color, () => {
            state2.hex = state2.color.hex;
            state2.rgb = state2.color.toRgbString();
            updateColorHistoryFn();
            emit2("update:color", state2.color);
            emit2("change", state2.color);
          }, { deep: true });
          return {
            state: state2,
            previewStyle,
            historyColors,
            onAlphaChange,
            onHueChange,
            onBoardChange,
            onCompactChange
          };
        }
      });
      const _hoisted_1$2 = { class: "vc-chrome-colorPicker" };
      const _hoisted_2$2 = { class: "vc-chrome-colorPicker-body" };
      const _hoisted_3$2 = { class: "chrome-controls" };
      const _hoisted_4$2 = { class: "chrome-color-wrap transparent" };
      const _hoisted_5$2 = { class: "chrome-sliders" };
      function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_Board = resolveComponent("Board");
        const _component_Hue = resolveComponent("Hue");
        const _component_Alpha = resolveComponent("Alpha");
        const _component_Display = resolveComponent("Display");
        const _component_History = resolveComponent("History");
        return openBlock(), createElementBlock("div", _hoisted_1$2, [
          createVNode(_component_Board, {
            round: true,
            hide: false,
            color: _ctx.state.color,
            onChange: _ctx.onBoardChange
          }, null, 8, ["color", "onChange"]),
          createElementVNode("div", _hoisted_2$2, [
            createElementVNode("div", _hoisted_3$2, [
              createElementVNode("div", _hoisted_4$2, [
                createElementVNode("div", {
                  class: "current-color",
                  style: normalizeStyle(_ctx.previewStyle)
                }, null, 4)
              ]),
              createElementVNode("div", _hoisted_5$2, [
                createVNode(_component_Hue, {
                  size: "small",
                  color: _ctx.state.color,
                  onChange: _ctx.onHueChange
                }, null, 8, ["color", "onChange"]),
                !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
                  key: 0,
                  size: "small",
                  color: _ctx.state.color,
                  onChange: _ctx.onAlphaChange
                }, null, 8, ["color", "onChange"])) : createCommentVNode("", true)
              ])
            ]),
            createVNode(_component_Display, {
              color: _ctx.state.color,
              "disable-alpha": _ctx.disableAlpha
            }, null, 8, ["color", "disable-alpha"]),
            !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
              key: 0,
              round: _ctx.roundHistory,
              colors: _ctx.historyColors,
              onChange: _ctx.onCompactChange
            }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
          ])
        ]);
      }
      var ChromeColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-61d7303b"]]);
      const ColorPickerProviderKey = "Vue3ColorPickerProvider";
      const _sfc_main$2 = defineComponent({
        name: "GradientColorPicker",
        components: { Angle, Display, Alpha, Palette, Board, Hue, Lightness, History },
        props: {
          startColor: z$1.instanceOf(Color).isRequired,
          endColor: z$1.instanceOf(Color).isRequired,
          startColorStop: z$1.number.def(0),
          endColorStop: z$1.number.def(100),
          angle: z$1.number.def(0),
          disableHistory: z$1.bool.def(false),
          roundHistory: z$1.bool.def(false),
          disableAlpha: z$1.bool.def(false)
        },
        emits: [
          "update:startColor",
          "update:endColor",
          "update:angle",
          "update:startColorStop",
          "update:endColorStop",
          "startColorChange",
          "endColorChange",
          "advanceChange",
          "angleChange",
          "startColorStopChange",
          "endColorStopChange"
        ],
        setup(props2, { emit: emit2 }) {
          const state2 = reactive({
            startActive: true,
            startColor: props2.startColor,
            endColor: props2.endColor,
            startColorStop: props2.startColorStop,
            endColorStop: props2.endColorStop,
            angle: props2.angle,
            startColorRgba: props2.startColor.toRgbString(),
            endColorRgba: props2.endColor.toRgbString()
          });
          const parent2 = inject(ColorPickerProviderKey);
          const advancePanelShow = ref(false);
          const startGradientRef = ref();
          const stopGradientRef = ref();
          const colorRangeRef = ref();
          const currentColor = computed({
            get: () => {
              return state2.startActive ? state2.startColor : state2.endColor;
            },
            set: (v2) => {
              if (state2.startActive) {
                state2.startColor = v2;
                return;
              }
              state2.endColor = v2;
            }
          });
          const getStartColorLeft = computed(() => {
            if (colorRangeRef.value && startGradientRef.value) {
              const alpha = state2.startColorStop / 100;
              const rect = colorRangeRef.value.getBoundingClientRect();
              const offsetWidth = startGradientRef.value.offsetWidth;
              return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
            }
            return 0;
          });
          const getEndColorLeft = computed(() => {
            if (colorRangeRef.value && stopGradientRef.value) {
              const alpha = state2.endColorStop / 100;
              const rect = colorRangeRef.value.getBoundingClientRect();
              const offsetWidth = stopGradientRef.value.offsetWidth;
              return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
            }
            return 0;
          });
          const gradientBg = computed(() => {
            return {
              background: `linear-gradient(${state2.angle}deg, ${state2.startColorRgba} ${state2.startColorStop}%, ${state2.endColorRgba} ${state2.endColorStop}%)`
            };
          });
          const dragStartRange = (evt) => {
            var _a;
            state2.startActive = true;
            if (colorRangeRef.value && startGradientRef.value) {
              const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
              let left2 = evt.clientX - rect.left;
              left2 = Math.max(startGradientRef.value.offsetWidth / 2, left2);
              left2 = Math.min(left2, rect.width - startGradientRef.value.offsetWidth / 2);
              state2.startColorStop = Math.round((left2 - startGradientRef.value.offsetWidth / 2) / (rect.width - startGradientRef.value.offsetWidth) * 100);
              emit2("update:startColorStop", state2.startColorStop);
              emit2("startColorStopChange", state2.startColorStop);
            }
          };
          const dragEndRange = (evt) => {
            var _a;
            state2.startActive = false;
            if (colorRangeRef.value && stopGradientRef.value) {
              const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
              let left2 = evt.clientX - rect.left;
              left2 = Math.max(stopGradientRef.value.offsetWidth / 2, left2);
              left2 = Math.min(left2, rect.width - stopGradientRef.value.offsetWidth / 2);
              state2.endColorStop = Math.round((left2 - stopGradientRef.value.offsetWidth / 2) / (rect.width - stopGradientRef.value.offsetWidth) * 100);
              emit2("update:endColorStop", state2.endColorStop);
              emit2("endColorStopChange", state2.endColorStop);
            }
          };
          const onDegreeBlur = (evt) => {
            const target = evt.target;
            const degree = parseInt(target.value.replace("\xB0", ""));
            if (!isNaN(degree)) {
              state2.angle = degree % 360;
            }
            emit2("update:angle", state2.angle);
            emit2("angleChange", state2.angle);
          };
          const onDegreeChange = (angle) => {
            state2.angle = angle;
            emit2("update:angle", state2.angle);
            emit2("angleChange", state2.angle);
          };
          const onCompactChange = (color) => {
            if (color === "advance") {
              advancePanelShow.value = true;
              emit2("advanceChange", true);
            } else {
              currentColor.value.hex = color;
              emit2("advanceChange", false);
            }
            doColorChange();
          };
          const onAlphaChange = (alpha) => {
            currentColor.value.alpha = alpha;
            doColorChange();
          };
          const onHueChange = (hue) => {
            currentColor.value.hue = hue;
            doColorChange();
          };
          const onBoardChange = (saturation, brightness) => {
            currentColor.value.saturation = saturation;
            currentColor.value.brightness = brightness;
            doColorChange();
          };
          const onLightChange = (light) => {
            currentColor.value.lightness = light;
            doColorChange();
          };
          const doColorChange = () => {
            if (state2.startActive) {
              emit2("update:startColor", state2.startColor);
              emit2("startColorChange", state2.startColor);
            } else {
              emit2("update:endColor", state2.endColor);
              emit2("endColorChange", state2.endColor);
            }
          };
          const onBack = () => {
            advancePanelShow.value = false;
            emit2("advanceChange", false);
          };
          const historyColors = useLocalStorage(HistoryColorKey, [], {});
          const updateColorHistoryFn = useDebounceFn(() => {
            if (props2.disableHistory) {
              return;
            }
            const rgbString = currentColor.value.toRgbString();
            historyColors.value = historyColors.value.filter((value) => {
              return !tinycolor.equals(value, rgbString);
            });
            if (historyColors.value.includes(rgbString)) {
              return;
            }
            while (historyColors.value.length > MAX_STORAGE_LENGTH) {
              historyColors.value.pop();
            }
            historyColors.value.unshift(rgbString);
          }, 500);
          tryOnMounted(() => {
            if (stopGradientRef.value && startGradientRef.value) {
              Vn.triggerDragEvent(stopGradientRef.value, {
                drag: (event) => {
                  dragEndRange(event);
                },
                end: (event) => {
                  dragEndRange(event);
                }
              });
              Vn.triggerDragEvent(startGradientRef.value, {
                drag: (event) => {
                  dragStartRange(event);
                },
                end: (event) => {
                  dragStartRange(event);
                }
              });
            }
          });
          whenever(() => state2.startColor, (value) => {
            state2.startColorRgba = value.toRgbString();
          }, { deep: true });
          whenever(() => state2.endColor, (value) => {
            state2.endColorRgba = value.toRgbString();
          }, { deep: true });
          whenever(() => currentColor.value, () => {
            updateColorHistoryFn();
          }, { deep: true });
          return {
            startGradientRef,
            stopGradientRef,
            colorRangeRef,
            state: state2,
            currentColor,
            getStartColorLeft,
            getEndColorLeft,
            gradientBg,
            advancePanelShow,
            onDegreeBlur,
            onCompactChange,
            onAlphaChange,
            onHueChange,
            onBoardChange,
            onLightChange,
            historyColors,
            onBack,
            onDegreeChange,
            lang: parent2 == null ? void 0 : parent2.lang
          };
        }
      });
      const _withScopeId = (n2) => (pushScopeId("data-v-f63daa7a"), n2 = n2(), popScopeId(), n2);
      const _hoisted_1$1 = { class: "vc-gradient-picker" };
      const _hoisted_2$1 = { class: "vc-gradient-picker__header" };
      const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
      const _hoisted_4$1 = [
        _hoisted_3$1
      ];
      const _hoisted_5$1 = { class: "vc-gradient-picker__body" };
      const _hoisted_6$1 = {
        class: "vc-color-range",
        ref: "colorRangeRef"
      };
      const _hoisted_7 = { class: "vc-color-range__container" };
      const _hoisted_8 = { class: "vc-gradient__stop__container" };
      const _hoisted_9 = ["title"];
      const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
      const _hoisted_11 = [
        _hoisted_10
      ];
      const _hoisted_12 = ["title"];
      const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
      const _hoisted_14 = [
        _hoisted_13
      ];
      const _hoisted_15 = { class: "vc-picker-degree-input vc-degree-input" };
      const _hoisted_16 = { class: "vc-degree-input__control" };
      const _hoisted_17 = ["value"];
      const _hoisted_18 = { class: "vc-degree-input__panel" };
      const _hoisted_19 = { class: "vc-degree-input__disk" };
      function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_Angle = resolveComponent("Angle");
        const _component_Palette = resolveComponent("Palette");
        const _component_Board = resolveComponent("Board");
        const _component_Hue = resolveComponent("Hue");
        const _component_Lightness = resolveComponent("Lightness");
        const _component_Alpha = resolveComponent("Alpha");
        const _component_Display = resolveComponent("Display");
        const _component_History = resolveComponent("History");
        return openBlock(), createElementBlock("div", _hoisted_1$1, [
          withDirectives(createElementVNode("div", _hoisted_2$1, [
            createElementVNode("span", {
              style: { "cursor": "pointer" },
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
            }, _hoisted_4$1)
          ], 512), [
            [vShow, _ctx.advancePanelShow]
          ]),
          createElementVNode("div", _hoisted_5$1, [
            createElementVNode("div", _hoisted_6$1, [
              createElementVNode("div", _hoisted_7, [
                createElementVNode("div", {
                  class: "vc-background",
                  style: normalizeStyle(_ctx.gradientBg)
                }, null, 4),
                createElementVNode("div", _hoisted_8, [
                  createElementVNode("div", {
                    class: normalizeClass([
                      "vc-gradient__stop",
                      {
                        "vc-gradient__stop--current": _ctx.state.startActive
                      }
                    ]),
                    ref: "startGradientRef",
                    title: _ctx.lang === "ZH-cn" ? "\u5F00\u59CB" : "Start",
                    style: normalizeStyle({ left: _ctx.getStartColorLeft + "px" })
                  }, _hoisted_11, 14, _hoisted_9),
                  createElementVNode("div", {
                    class: normalizeClass([
                      "vc-gradient__stop",
                      {
                        "vc-gradient__stop--current": !_ctx.state.startActive
                      }
                    ]),
                    ref: "stopGradientRef",
                    title: _ctx.lang === "ZH-cn" ? "\u7ED3\u675F" : "End",
                    style: normalizeStyle({ left: _ctx.getEndColorLeft + "px" })
                  }, _hoisted_14, 14, _hoisted_12)
                ])
              ])
            ], 512),
            createElementVNode("div", _hoisted_15, [
              createElementVNode("div", _hoisted_16, [
                createElementVNode("input", {
                  value: _ctx.state.angle,
                  onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onDegreeBlur && _ctx.onDegreeBlur(...args))
                }, null, 40, _hoisted_17)
              ]),
              createElementVNode("div", _hoisted_18, [
                createElementVNode("div", _hoisted_19, [
                  createVNode(_component_Angle, {
                    angle: _ctx.state.angle,
                    "onUpdate:angle": _cache[2] || (_cache[2] = ($event) => _ctx.state.angle = $event),
                    size: 40,
                    onChange: _ctx.onDegreeChange
                  }, null, 8, ["angle", "onChange"])
                ])
              ])
            ])
          ]),
          !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
            key: 0,
            onChange: _ctx.onCompactChange
          }, null, 8, ["onChange"])) : createCommentVNode("", true),
          _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
            key: 1,
            color: _ctx.currentColor,
            onChange: _ctx.onBoardChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
            key: 2,
            color: _ctx.currentColor,
            onChange: _ctx.onHueChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
            key: 3,
            color: _ctx.currentColor,
            onChange: _ctx.onLightChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
            key: 4,
            color: _ctx.currentColor,
            onChange: _ctx.onAlphaChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
          createVNode(_component_Display, {
            color: _ctx.currentColor,
            "disable-alpha": _ctx.disableAlpha
          }, null, 8, ["color", "disable-alpha"]),
          !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
            key: 5,
            round: _ctx.roundHistory,
            colors: _ctx.historyColors,
            onChange: _ctx.onCompactChange
          }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
        ]);
      }
      var GradientColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-f63daa7a"]]);
      const _sfc_main$1 = defineComponent({
        name: "WrapContainer",
        props: {
          showTab: z$1.bool.def(false),
          activeKey: z$1.oneOf(["pure", "gradient"]).def("pure")
        },
        emits: ["update:activeKey", "change"],
        setup(props2, { emit: emit2 }) {
          const state2 = reactive({
            activeKey: props2.activeKey
          });
          const parent2 = inject(ColorPickerProviderKey);
          const onActiveKeyChange = (key) => {
            state2.activeKey = key;
            emit2("update:activeKey", key);
            emit2("change", key);
          };
          whenever(() => props2.activeKey, (value) => {
            state2.activeKey = value;
          });
          return { state: state2, onActiveKeyChange, lang: parent2 == null ? void 0 : parent2.lang };
        }
      });
      const _hoisted_1 = { class: "vc-colorpicker" };
      const _hoisted_2 = { class: "vc-colorpicker--container" };
      const _hoisted_3 = {
        key: 0,
        class: "vc-colorpicker--tabs"
      };
      const _hoisted_4 = { class: "vc-colorpicker--tabs__inner" };
      const _hoisted_5 = { class: "vc-btn__content" };
      const _hoisted_6 = { class: "vc-btn__content" };
      function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
        return openBlock(), createElementBlock("div", _hoisted_1, [
          createElementVNode("div", _hoisted_2, [
            _ctx.showTab ? (openBlock(), createElementBlock("div", _hoisted_3, [
              createElementVNode("div", _hoisted_4, [
                createElementVNode("div", {
                  class: normalizeClass([
                    "vc-colorpicker--tabs__btn",
                    {
                      "vc-btn-active": _ctx.state.activeKey === "pure"
                    }
                  ]),
                  onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onActiveKeyChange("pure"))
                }, [
                  createElementVNode("button", null, [
                    createElementVNode("div", _hoisted_5, toDisplayString(_ctx.lang === "ZH-cn" ? "\u7EAF\u8272" : "Pure"), 1)
                  ])
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass([
                    "vc-colorpicker--tabs__btn",
                    {
                      "vc-btn-active": _ctx.state.activeKey === "gradient"
                    }
                  ]),
                  onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onActiveKeyChange("gradient"))
                }, [
                  createElementVNode("button", null, [
                    createElementVNode("div", _hoisted_6, toDisplayString(_ctx.lang === "ZH-cn" ? "\u6E10\u53D8\u8272" : "Gradient"), 1)
                  ])
                ], 2),
                createElementVNode("div", {
                  class: "vc-colorpicker--tabs__bg",
                  style: normalizeStyle({
                    width: `50%`,
                    left: `calc(${_ctx.state.activeKey === "gradient" ? 50 : 0}%)`
                  })
                }, null, 4)
              ])
            ])) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ])
        ]);
      }
      var WrapContainer = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-4afdf3bb"]]);
      const colorPickerProps = {
        isWidget: z$1.bool.def(false),
        pickerType: z$1.oneOf(["fk", "chrome"]).def("fk"),
        shape: z$1.oneOf(["circle", "square"]).def("square"),
        pureColor: {
          type: [String, Object],
          default: "#000000"
        },
        gradientColor: z$1.string.def("#000"),
        format: {
          type: String,
          default: "rgb"
        },
        disableAlpha: z$1.bool.def(false),
        disableHistory: z$1.bool.def(false),
        roundHistory: z$1.bool.def(false),
        useType: z$1.oneOf(["pure", "gradient", "both"]).def("pure"),
        activeKey: z$1.oneOf(["pure", "gradient"]).def("pure"),
        lang: {
          type: String,
          default: "ZH-cn"
        },
        zIndex: z$1.number.def(9999)
      };
      const _sfc_main = defineComponent({
        name: "ColorPicker",
        components: { FkColorPicker, ChromeColorPicker, GradientColorPicker, WrapContainer },
        inheritAttrs: false,
        props: colorPickerProps,
        emits: [
          "update:pureColor",
          "pureColorChange",
          "update:gradientColor",
          "gradientColorChange",
          "update:activeKey",
          "activeKeyChange"
        ],
        setup(props2, { emit: emit2 }) {
          const state2 = reactive({
            pureColor: props2.pureColor || "",
            activeKey: props2.useType === "gradient" ? "gradient" : "pure",
            isAdvanceMode: false
          });
          provide(ColorPickerProviderKey, {
            lang: computed(() => props2.lang || "ZH-cn")
          });
          const instance = new Color(state2.pureColor);
          const colorInstance = ref(instance);
          const startColor = new Color("#000");
          const endColor = new Color("#000");
          const gradientState = reactive({
            startColor,
            endColor,
            startColorStop: 0,
            endColorStop: 100,
            angle: 0,
            gradientColor: props2.gradientColor
          });
          const showPicker = ref(false);
          const colorCubeRef = ref(null);
          const pickerRef = ref(null);
          const getBgColorStyle = computed(() => {
            const bgColor = state2.activeKey !== "gradient" ? tinycolor(state2.pureColor).toRgbString() : gradientState.gradientColor;
            return {
              background: bgColor
            };
          });
          const getComponentName = computed(() => {
            if (state2.activeKey === "gradient") {
              return GradientColorPicker.name;
            }
            return props2.pickerType === "fk" ? FkColorPicker.name : ChromeColorPicker.name;
          });
          const getBindArgs = computed(() => {
            if (state2.activeKey === "gradient") {
              return {
                startColor: gradientState.startColor,
                endColor: gradientState.endColor,
                onStartColorChange: (v2) => {
                  gradientState.startColor = v2;
                  onGradientChange();
                },
                onEndColorChange: (v2) => {
                  gradientState.endColor = v2;
                  onGradientChange();
                },
                angle: gradientState.angle,
                startColorStop: gradientState.startColorStop,
                endColorStop: gradientState.endColorStop,
                onStartColorStopChange: (v2) => {
                  gradientState.startColorStop = v2;
                  onGradientChange();
                },
                onEndColorStopChange: (v2) => {
                  gradientState.endColorStop = v2;
                  onGradientChange();
                },
                onAngleChange: (v2) => {
                  gradientState.angle = v2;
                  onGradientChange();
                },
                onAdvanceChange: (v2) => {
                  state2.isAdvanceMode = v2;
                }
              };
            }
            return {
              disableAlpha: props2.disableAlpha,
              disableHistory: props2.disableHistory,
              roundHistory: props2.roundHistory,
              color: colorInstance.value,
              onChange: onColorChange,
              onAdvanceChange
            };
          });
          const onAdvanceChange = (isAdvance) => {
            state2.isAdvanceMode = isAdvance;
          };
          const onShowPicker = () => {
            showPicker.value = true;
          };
          const onHidePicker = () => {
            showPicker.value = false;
          };
          const parseGradientColor = () => {
            var _a, _b, _c, _d;
            try {
              const [colorNode] = parse(gradientState.gradientColor);
              if (colorNode && colorNode.type === "linear-gradient" && ((_a = colorNode.orientation) == null ? void 0 : _a.type) === "angular" && colorNode.colorStops.length >= 2) {
                const startColorVal = colorNode.colorStops[0];
                const endColorVal = colorNode.colorStops[1];
                gradientState.startColorStop = Number((_b = startColorVal.length) == null ? void 0 : _b.value) || 0;
                gradientState.endColorStop = Number((_c = endColorVal.length) == null ? void 0 : _c.value) || 0;
                gradientState.angle = Number((_d = colorNode.orientation) == null ? void 0 : _d.value) || 0;
                const [r2, g2, b2, a2] = startColorVal.value;
                const [r1, g1, b1, a1] = startColorVal.value;
                gradientState.startColor = new Color({
                  r: Number(r2),
                  g: Number(g2),
                  b: Number(b2),
                  a: Number(a2)
                });
                gradientState.startColor = new Color({
                  r: Number(r1),
                  g: Number(g1),
                  b: Number(b1),
                  a: Number(a1)
                });
              }
            } catch (e2) {
              console.log(`[Parse Color]: ${e2}`);
            }
          };
          const onGradientChange = () => {
            const nodes = color2GradientNode();
            try {
              gradientState.gradientColor = stringify(nodes);
              emit2("update:gradientColor", gradientState.gradientColor);
              emit2("gradientColorChange", gradientState.gradientColor);
            } catch (e2) {
              console.log(e2);
            }
          };
          const color2GradientNode = () => {
            const nodes = [];
            const startColorArr = gradientState.startColor.RGB.map((v2) => v2.toString());
            const endColorArr = gradientState.endColor.RGB.map((v2) => v2.toString());
            nodes.push({
              type: "linear-gradient",
              orientation: { type: "angular", value: gradientState.angle + "" },
              colorStops: [
                {
                  type: "rgba",
                  value: [startColorArr[0], startColorArr[1], startColorArr[2], startColorArr[3]],
                  length: { value: gradientState.startColorStop + "", type: "%" }
                },
                {
                  type: "rgba",
                  value: [endColorArr[0], endColorArr[1], endColorArr[2], endColorArr[3]],
                  length: { value: gradientState.endColorStop + "", type: "%" }
                }
              ]
            });
            return nodes;
          };
          const onInit = () => {
            if (colorCubeRef.value && pickerRef.value) {
              createPopper(colorCubeRef.value, pickerRef.value, {
                placement: "auto",
                modifiers: [
                  {
                    name: "flip",
                    options: {
                      fallbackPlacements: ["top", "left"]
                    }
                  }
                ]
              });
            }
          };
          const onColorChange = (v2) => {
            colorInstance.value = v2;
            state2.pureColor = v2.toString(props2.format);
            emitColorChange();
          };
          const emitColorChange = () => {
            emit2("update:pureColor", state2.pureColor);
            emit2("pureColorChange", state2.pureColor);
          };
          onClickOutside(pickerRef, () => {
            onHidePicker();
          });
          const onActiveKeyChange = (key) => {
            state2.activeKey = key;
            emit2("update:activeKey", key);
            emit2("activeKeyChange", key);
          };
          tryOnMounted(() => {
            onInit();
            emitColorChange();
            parseGradientColor();
            onGradientChange();
          });
          whenever(() => props2.gradientColor, (value) => {
            if (value != gradientState.gradientColor) {
              gradientState.gradientColor = value;
            }
          });
          whenever(() => gradientState.gradientColor, () => {
            parseGradientColor();
          });
          whenever(() => props2.activeKey, (value) => {
            state2.activeKey = value;
          });
          whenever(() => props2.useType, (value) => {
            if (state2.activeKey !== "gradient" && value === "gradient") {
              state2.activeKey = "gradient";
            } else {
              state2.activeKey = "pure";
            }
          });
          whenever(() => props2.pureColor, (value) => {
            const equal = tinycolor.equals(value, state2.pureColor);
            if (!equal) {
              state2.pureColor = value;
              colorInstance.value = new Color(value);
              emitColorChange();
            }
          }, { deep: true });
          return {
            colorCubeRef,
            pickerRef,
            showPicker,
            colorInstance,
            getBgColorStyle,
            onColorChange,
            onShowPicker,
            onActiveKeyChange,
            getComponentName,
            getBindArgs,
            state: state2
          };
        }
      });
      function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
        const _component_WrapContainer = resolveComponent("WrapContainer");
        return openBlock(), createElementBlock(Fragment, null, [
          !_ctx.isWidget ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(["vc-color-wrap", "transparent", { round: _ctx.shape === "circle" }]),
            ref: "colorCubeRef"
          }, [
            createElementVNode("div", {
              class: "current-color",
              style: normalizeStyle(_ctx.getBgColorStyle),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onShowPicker && _ctx.onShowPicker(...args))
            }, null, 4)
          ], 2)) : createCommentVNode("", true),
          _ctx.isWidget ? (openBlock(), createBlock(_component_WrapContainer, {
            key: 1,
            "active-key": _ctx.state.activeKey,
            "onUpdate:active-key": _cache[1] || (_cache[1] = ($event) => _ctx.state.activeKey = $event),
            "show-tab": _ctx.useType === "both",
            onChange: _ctx.onActiveKeyChange,
            style: normalizeStyle({ zIndex: _ctx.zIndex })
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
            ]),
            _: 1
          }, 8, ["active-key", "show-tab", "onChange", "style"])) : createCommentVNode("", true),
          !_ctx.isWidget ? (openBlock(), createBlock(Teleport, {
            key: 2,
            to: "body"
          }, [
            withDirectives(createElementVNode("div", {
              ref: "pickerRef",
              style: normalizeStyle({ zIndex: _ctx.zIndex })
            }, [
              _ctx.showPicker ? (openBlock(), createBlock(_component_WrapContainer, {
                key: 0,
                "show-tab": _ctx.useType === "both" && !_ctx.state.isAdvanceMode,
                "active-key": _ctx.state.activeKey,
                "onUpdate:active-key": _cache[2] || (_cache[2] = ($event) => _ctx.state.activeKey = $event),
                onChange: _ctx.onActiveKeyChange
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
                ]),
                _: 1
              }, 8, ["show-tab", "active-key", "onChange"])) : createCommentVNode("", true)
            ], 4), [
              [vShow, _ctx.showPicker]
            ])
          ])) : createCommentVNode("", true)
        ], 64);
      }
      var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-0aa3a75d"]]);
      const Vue3ColorPicker = {
        install: (app) => {
          app.component(ColorPicker.name, ColorPicker);
          app.component("Vue3" + ColorPicker.name, ColorPicker);
        }
      };
      var vue3PerfectScrollbar = "";
      var index = "";
      var style = "";
      var custom = "";
      const vueLifecycles = u$5({
        createApp,
        appOptions: {
          render() {
            return h$5(_sfc_main$c, {
              customProps: {
                kanbanData: this.kanbanData
              }
            });
          }
        },
        handleInstance: (app) => {
          app.directive("focus", {
            mounted(el) {
              el.focus();
            }
          });
          app.directive("autosize", {
            mounted(el) {
              if (el.tagName === "TEXTAREA")
                d$5(el);
            }
          });
          app.use(store);
          app.use(index$2);
          app.use(setup, {}).component("DatePicker", script);
          app.use(src_default, {
            timeout: 4e3,
            hideProgressBar: true,
            showCloseButtonOnHover: true,
            icon: false
          });
          app.use(Vue3ColorPicker);
          {
            console.log({ "BASE_URL": "/", "MODE": "development", "DEV": true, "PROD": false });
          }
        }
      });
      defineRule("minLength", (value, [limit]) => {
        if (value.length < parseInt(limit)) {
          return `This field must be at least ${limit} character`;
        }
        return true;
      });
      const bootstrap = exports("bootstrap", vueLifecycles.bootstrap);
      const mount = exports("mount", vueLifecycles.mount);
      const unmount = exports("unmount", vueLifecycles.unmount);
    }
  };
});
