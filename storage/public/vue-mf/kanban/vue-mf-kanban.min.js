import { h as h$5, reactive, computed, openBlock, createBlock, createVNode, resolveComponent, renderSlot, toDisplayString, Fragment, renderList, Transition, withCtx, createCommentVNode, createTextVNode, mergeProps, pushScopeId, popScopeId, withModifiers, withScopeId, defineComponent, toRaw, unref, createElementBlock, normalizeStyle, normalizeClass, resolveDynamicComponent, createElementVNode, toHandlers, TransitionGroup, getCurrentInstance, inject, nextTick, createApp, toRef, onMounted, provide, isRef, watch, onBeforeUnmount, ref, warn as warn$1, watchEffect, onUnmounted, markRaw, resolveDirective, withDirectives, vShow, vModelText, withKeys, shallowReactive, createSlots, onBeforeMount, getCurrentScope, onScopeDispose, shallowRef, Teleport } from "vue";
import { Button } from "@vue-mf/styleguide";
var e$4, n$4, t$5 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function r$4(e2, n2) {
  var t13 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r2 = Object.getOwnPropertySymbols(e2);
    n2 && (r2 = r2.filter(function(n3) {
      return Object.getOwnPropertyDescriptor(e2, n3).enumerable;
    })), t13.push.apply(t13, r2);
  }
  return t13;
}
function o$5(e2) {
  for (var n2 = 1; n2 < arguments.length; n2++) {
    var t13 = null != arguments[n2] ? arguments[n2] : {};
    n2 % 2 ? r$4(Object(t13), true).forEach(function(n3) {
      a$5(e2, n3, t13[n3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t13)) : r$4(Object(t13)).forEach(function(n3) {
      Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t13, n3));
    });
  }
  return e2;
}
function a$5(e2, n2, t13) {
  return n2 in e2 ? Object.defineProperty(e2, n2, { value: t13, enumerable: true, configurable: true, writable: true }) : e2[n2] = t13, e2;
}
function i$5(e2) {
  return (i$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  })(e2);
}
(function(e2, n2) {
  var r2;
  r2 = t$5, e2.exports = function(e3) {
    if (e3.CSS && e3.CSS.escape)
      return e3.CSS.escape;
    var n3 = function(e4) {
      if (0 == arguments.length)
        throw new TypeError("`CSS.escape` requires an argument.");
      for (var n4, t13 = String(e4), r3 = t13.length, o2 = -1, a3 = "", i2 = t13.charCodeAt(0); ++o2 < r3; )
        0 != (n4 = t13.charCodeAt(o2)) ? a3 += n4 >= 1 && n4 <= 31 || 127 == n4 || 0 == o2 && n4 >= 48 && n4 <= 57 || 1 == o2 && n4 >= 48 && n4 <= 57 && 45 == i2 ? "\\" + n4.toString(16) + " " : 0 == o2 && 1 == r3 && 45 == n4 || !(n4 >= 128 || 45 == n4 || 95 == n4 || n4 >= 48 && n4 <= 57 || n4 >= 65 && n4 <= 90 || n4 >= 97 && n4 <= 122) ? "\\" + t13.charAt(o2) : t13.charAt(o2) : a3 += "\uFFFD";
      return a3;
    };
    return e3.CSS || (e3.CSS = {}), e3.CSS.escape = n3, n3;
  }(r2);
})(n$4 = { path: e$4, exports: {}, require: function(e2, t13) {
  return function() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }(null == t13 && n$4.path);
} }, n$4.exports), n$4.exports;
var p$6 = { appOptions: null, template: null, Vue: null, createApp: null, handleInstance: null };
function u$5(e2) {
  if ("object" !== i$5(e2))
    throw new Error("single-spa-vue requires a configuration object");
  var n2 = o$5(o$5({}, p$6), e2);
  if (!n2.Vue && !n2.createApp)
    throw Error("single-spa-vue must be passed opts.Vue or opts.createApp");
  if (!n2.appOptions)
    throw Error("single-spa-vue must be passed opts.appOptions");
  if (n2.appOptions.el && "string" != typeof n2.appOptions.el && !(n2.appOptions.el instanceof HTMLElement))
    throw Error("single-spa-vue: appOptions.el must be a string CSS selector, an HTMLElement, or not provided at all. Was given ".concat(i$5(n2.appOptions.el)));
  n2.createApp = n2.createApp || n2.Vue && n2.Vue.createApp;
  var t13 = {};
  return { bootstrap: c$6.bind(null, n2, t13), mount: l$6.bind(null, n2, t13), unmount: f$5.bind(null, n2, t13), update: s$5.bind(null, n2, t13) };
}
function c$6(e2) {
  return e2.loadRootComponent ? e2.loadRootComponent().then(function(n2) {
    return e2.rootComponent = n2;
  }) : Promise.resolve();
}
function l$6(e2, n2, t13) {
  var r2 = {};
  return Promise.resolve().then(function() {
    return function(e3, n3) {
      return "function" == typeof e3.appOptions ? e3.appOptions(n3) : Promise.resolve(o$5({}, e3.appOptions));
    }(e2, t13).then(function(a3) {
      var i2;
      if (t13.domElement && !a3.el && (a3.el = t13.domElement), a3.el)
        if ("string" == typeof a3.el) {
          if (!(i2 = document.querySelector(a3.el)))
            throw Error("If appOptions.el is provided to single-spa-vue, the dom element must exist in the dom. Was provided as ".concat(a3.el));
        } else
          (i2 = a3.el).id || (i2.id = "single-spa-application:".concat(t13.name)), a3.el = "#".concat(CSS.escape(i2.id));
      else {
        var p2 = "single-spa-application:".concat(t13.name);
        a3.el = "#".concat(CSS.escape(p2)), (i2 = document.getElementById(p2)) || ((i2 = document.createElement("div")).id = p2, document.body.appendChild(i2));
      }
      if (e2.replaceMode || (a3.el = a3.el + " .single-spa-container"), !i2.querySelector(".single-spa-container")) {
        var u2 = document.createElement("div");
        u2.className = "single-spa-container", i2.appendChild(u2);
      }
      if (r2.domEl = i2, a3.render || a3.template || !e2.rootComponent || (a3.render = function(n3) {
        return n3(e2.rootComponent);
      }), a3.data || (a3.data = {}), a3.data = function() {
        return o$5(o$5({}, a3.data), t13);
      }, e2.createApp) {
        if (r2.vueInstance = e2.createApp(a3), e2.handleInstance)
          return Promise.resolve(e2.handleInstance(r2.vueInstance, t13)).then(function() {
            return r2.root = r2.vueInstance.mount(a3.el), n2[t13.name] = r2, r2.vueInstance;
          });
        r2.root = r2.vueInstance.mount(a3.el);
      } else if (r2.vueInstance = new e2.Vue(a3), r2.vueInstance.bind && (r2.vueInstance = r2.vueInstance.bind(r2.vueInstance)), e2.handleInstance)
        return Promise.resolve(e2.handleInstance(r2.vueInstance, t13)).then(function() {
          return n2[t13.name] = r2, r2.vueInstance;
        });
      return n2[t13.name] = r2, r2.vueInstance;
    });
  });
}
function s$5(e2, n2, t13) {
  return Promise.resolve().then(function() {
    var r2 = n2[t13.name], a3 = o$5(o$5({}, e2.appOptions.data || {}), t13), i2 = r2.root || r2.vueInstance;
    for (var p2 in a3)
      i2[p2] = a3[p2];
  });
}
function f$5(e2, n2, t13) {
  return Promise.resolve().then(function() {
    var r2 = n2[t13.name];
    e2.createApp ? r2.vueInstance.unmount(r2.domEl) : (r2.vueInstance.$destroy(), r2.vueInstance.$el.innerHTML = ""), delete r2.vueInstance, r2.domEl && (r2.domEl.innerHTML = "", delete r2.domEl);
  });
}
/*!
 * perfect-scrollbar v1.5.3
 * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors
 * Licensed under MIT
 */
function get$1(element) {
  return getComputedStyle(element);
}
function set$2(element, obj) {
  for (var key in obj) {
    var val = obj[key];
    if (typeof val === "number") {
      val = val + "px";
    }
    element.style[key] = val;
  }
  return element;
}
function div(className) {
  var div2 = document.createElement("div");
  div2.className = className;
  return div2;
}
var elMatches = typeof Element !== "undefined" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function matches$1(element, query) {
  if (!elMatches) {
    throw new Error("No element matching method supported");
  }
  return elMatches.call(element, query);
}
function remove(element) {
  if (element.remove) {
    element.remove();
  } else {
    if (element.parentNode) {
      element.parentNode.removeChild(element);
    }
  }
}
function queryChildren(element, selector) {
  return Array.prototype.filter.call(
    element.children,
    function(child) {
      return matches$1(child, selector);
    }
  );
}
var cls = {
  main: "ps",
  rtl: "ps__rtl",
  element: {
    thumb: function(x2) {
      return "ps__thumb-" + x2;
    },
    rail: function(x2) {
      return "ps__rail-" + x2;
    },
    consuming: "ps__child--consume"
  },
  state: {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(x2) {
      return "ps--active-" + x2;
    },
    scrolling: function(x2) {
      return "ps--scrolling-" + x2;
    }
  }
};
var scrollingClassTimeout = { x: null, y: null };
function addScrollingClass(i2, x2) {
  var classList = i2.element.classList;
  var className = cls.state.scrolling(x2);
  if (classList.contains(className)) {
    clearTimeout(scrollingClassTimeout[x2]);
  } else {
    classList.add(className);
  }
}
function removeScrollingClass(i2, x2) {
  scrollingClassTimeout[x2] = setTimeout(
    function() {
      return i2.isAlive && i2.element.classList.remove(cls.state.scrolling(x2));
    },
    i2.settings.scrollingThreshold
  );
}
function setScrollingClassInstantly(i2, x2) {
  addScrollingClass(i2, x2);
  removeScrollingClass(i2, x2);
}
var EventElement = function EventElement2(element) {
  this.element = element;
  this.handlers = {};
};
var prototypeAccessors$2 = { isEmpty: { configurable: true } };
EventElement.prototype.bind = function bind(eventName, handler2) {
  if (typeof this.handlers[eventName] === "undefined") {
    this.handlers[eventName] = [];
  }
  this.handlers[eventName].push(handler2);
  this.element.addEventListener(eventName, handler2, false);
};
EventElement.prototype.unbind = function unbind(eventName, target) {
  var this$1$1 = this;
  this.handlers[eventName] = this.handlers[eventName].filter(function(handler2) {
    if (target && handler2 !== target) {
      return true;
    }
    this$1$1.element.removeEventListener(eventName, handler2, false);
    return false;
  });
};
EventElement.prototype.unbindAll = function unbindAll() {
  for (var name2 in this.handlers) {
    this.unbind(name2);
  }
};
prototypeAccessors$2.isEmpty.get = function() {
  var this$1$1 = this;
  return Object.keys(this.handlers).every(
    function(key) {
      return this$1$1.handlers[key].length === 0;
    }
  );
};
Object.defineProperties(EventElement.prototype, prototypeAccessors$2);
var EventManager = function EventManager2() {
  this.eventElements = [];
};
EventManager.prototype.eventElement = function eventElement(element) {
  var ee2 = this.eventElements.filter(function(ee3) {
    return ee3.element === element;
  })[0];
  if (!ee2) {
    ee2 = new EventElement(element);
    this.eventElements.push(ee2);
  }
  return ee2;
};
EventManager.prototype.bind = function bind2(element, eventName, handler2) {
  this.eventElement(element).bind(eventName, handler2);
};
EventManager.prototype.unbind = function unbind2(element, eventName, handler2) {
  var ee2 = this.eventElement(element);
  ee2.unbind(eventName, handler2);
  if (ee2.isEmpty) {
    this.eventElements.splice(this.eventElements.indexOf(ee2), 1);
  }
};
EventManager.prototype.unbindAll = function unbindAll2() {
  this.eventElements.forEach(function(e2) {
    return e2.unbindAll();
  });
  this.eventElements = [];
};
EventManager.prototype.once = function once(element, eventName, handler2) {
  var ee2 = this.eventElement(element);
  var onceHandler = function(evt) {
    ee2.unbind(eventName, onceHandler);
    handler2(evt);
  };
  ee2.bind(eventName, onceHandler);
};
function createEvent(name2) {
  if (typeof window.CustomEvent === "function") {
    return new CustomEvent(name2);
  } else {
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(name2, false, false, void 0);
    return evt;
  }
}
function processScrollDiff(i2, axis, diff, useScrollingClass, forceFireReachEvent) {
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var fields;
  if (axis === "top") {
    fields = [
      "contentHeight",
      "containerHeight",
      "scrollTop",
      "y",
      "up",
      "down"
    ];
  } else if (axis === "left") {
    fields = [
      "contentWidth",
      "containerWidth",
      "scrollLeft",
      "x",
      "left",
      "right"
    ];
  } else {
    throw new Error("A proper axis should be provided");
  }
  processScrollDiff$1(i2, diff, fields, useScrollingClass, forceFireReachEvent);
}
function processScrollDiff$1(i2, diff, ref2, useScrollingClass, forceFireReachEvent) {
  var contentHeight = ref2[0];
  var containerHeight = ref2[1];
  var scrollTop = ref2[2];
  var y2 = ref2[3];
  var up = ref2[4];
  var down = ref2[5];
  if (useScrollingClass === void 0)
    useScrollingClass = true;
  if (forceFireReachEvent === void 0)
    forceFireReachEvent = false;
  var element = i2.element;
  i2.reach[y2] = null;
  if (element[scrollTop] < 1) {
    i2.reach[y2] = "start";
  }
  if (element[scrollTop] > i2[contentHeight] - i2[containerHeight] - 1) {
    i2.reach[y2] = "end";
  }
  if (diff) {
    element.dispatchEvent(createEvent("ps-scroll-" + y2));
    if (diff < 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + up));
    } else if (diff > 0) {
      element.dispatchEvent(createEvent("ps-scroll-" + down));
    }
    if (useScrollingClass) {
      setScrollingClassInstantly(i2, y2);
    }
  }
  if (i2.reach[y2] && (diff || forceFireReachEvent)) {
    element.dispatchEvent(createEvent("ps-" + y2 + "-reach-" + i2.reach[y2]));
  }
}
function toInt(x2) {
  return parseInt(x2, 10) || 0;
}
function isEditable(el) {
  return matches$1(el, "input,[contenteditable]") || matches$1(el, "select,[contenteditable]") || matches$1(el, "textarea,[contenteditable]") || matches$1(el, "button,[contenteditable]");
}
function outerWidth(element) {
  var styles = get$1(element);
  return toInt(styles.width) + toInt(styles.paddingLeft) + toInt(styles.paddingRight) + toInt(styles.borderLeftWidth) + toInt(styles.borderRightWidth);
}
var env = {
  isWebKit: typeof document !== "undefined" && "WebkitAppearance" in document.documentElement.style,
  supportsTouch: typeof window !== "undefined" && ("ontouchstart" in window || "maxTouchPoints" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
  supportsIePointer: typeof navigator !== "undefined" && navigator.msMaxTouchPoints,
  isChrome: typeof navigator !== "undefined" && /Chrome/i.test(navigator && navigator.userAgent)
};
function updateGeometry(i2) {
  var element = i2.element;
  var roundedScrollTop = Math.floor(element.scrollTop);
  var rect = element.getBoundingClientRect();
  i2.containerWidth = Math.round(rect.width);
  i2.containerHeight = Math.round(rect.height);
  i2.contentWidth = element.scrollWidth;
  i2.contentHeight = element.scrollHeight;
  if (!element.contains(i2.scrollbarXRail)) {
    queryChildren(element, cls.element.rail("x")).forEach(
      function(el) {
        return remove(el);
      }
    );
    element.appendChild(i2.scrollbarXRail);
  }
  if (!element.contains(i2.scrollbarYRail)) {
    queryChildren(element, cls.element.rail("y")).forEach(
      function(el) {
        return remove(el);
      }
    );
    element.appendChild(i2.scrollbarYRail);
  }
  if (!i2.settings.suppressScrollX && i2.containerWidth + i2.settings.scrollXMarginOffset < i2.contentWidth) {
    i2.scrollbarXActive = true;
    i2.railXWidth = i2.containerWidth - i2.railXMarginWidth;
    i2.railXRatio = i2.containerWidth / i2.railXWidth;
    i2.scrollbarXWidth = getThumbSize(
      i2,
      toInt(i2.railXWidth * i2.containerWidth / i2.contentWidth)
    );
    i2.scrollbarXLeft = toInt(
      (i2.negativeScrollAdjustment + element.scrollLeft) * (i2.railXWidth - i2.scrollbarXWidth) / (i2.contentWidth - i2.containerWidth)
    );
  } else {
    i2.scrollbarXActive = false;
  }
  if (!i2.settings.suppressScrollY && i2.containerHeight + i2.settings.scrollYMarginOffset < i2.contentHeight) {
    i2.scrollbarYActive = true;
    i2.railYHeight = i2.containerHeight - i2.railYMarginHeight;
    i2.railYRatio = i2.containerHeight / i2.railYHeight;
    i2.scrollbarYHeight = getThumbSize(
      i2,
      toInt(i2.railYHeight * i2.containerHeight / i2.contentHeight)
    );
    i2.scrollbarYTop = toInt(
      roundedScrollTop * (i2.railYHeight - i2.scrollbarYHeight) / (i2.contentHeight - i2.containerHeight)
    );
  } else {
    i2.scrollbarYActive = false;
  }
  if (i2.scrollbarXLeft >= i2.railXWidth - i2.scrollbarXWidth) {
    i2.scrollbarXLeft = i2.railXWidth - i2.scrollbarXWidth;
  }
  if (i2.scrollbarYTop >= i2.railYHeight - i2.scrollbarYHeight) {
    i2.scrollbarYTop = i2.railYHeight - i2.scrollbarYHeight;
  }
  updateCss(element, i2);
  if (i2.scrollbarXActive) {
    element.classList.add(cls.state.active("x"));
  } else {
    element.classList.remove(cls.state.active("x"));
    i2.scrollbarXWidth = 0;
    i2.scrollbarXLeft = 0;
    element.scrollLeft = i2.isRtl === true ? i2.contentWidth : 0;
  }
  if (i2.scrollbarYActive) {
    element.classList.add(cls.state.active("y"));
  } else {
    element.classList.remove(cls.state.active("y"));
    i2.scrollbarYHeight = 0;
    i2.scrollbarYTop = 0;
    element.scrollTop = 0;
  }
}
function getThumbSize(i2, thumbSize) {
  if (i2.settings.minScrollbarLength) {
    thumbSize = Math.max(thumbSize, i2.settings.minScrollbarLength);
  }
  if (i2.settings.maxScrollbarLength) {
    thumbSize = Math.min(thumbSize, i2.settings.maxScrollbarLength);
  }
  return thumbSize;
}
function updateCss(element, i2) {
  var xRailOffset = { width: i2.railXWidth };
  var roundedScrollTop = Math.floor(element.scrollTop);
  if (i2.isRtl) {
    xRailOffset.left = i2.negativeScrollAdjustment + element.scrollLeft + i2.containerWidth - i2.contentWidth;
  } else {
    xRailOffset.left = element.scrollLeft;
  }
  if (i2.isScrollbarXUsingBottom) {
    xRailOffset.bottom = i2.scrollbarXBottom - roundedScrollTop;
  } else {
    xRailOffset.top = i2.scrollbarXTop + roundedScrollTop;
  }
  set$2(i2.scrollbarXRail, xRailOffset);
  var yRailOffset = { top: roundedScrollTop, height: i2.railYHeight };
  if (i2.isScrollbarYUsingRight) {
    if (i2.isRtl) {
      yRailOffset.right = i2.contentWidth - (i2.negativeScrollAdjustment + element.scrollLeft) - i2.scrollbarYRight - i2.scrollbarYOuterWidth - 9;
    } else {
      yRailOffset.right = i2.scrollbarYRight - element.scrollLeft;
    }
  } else {
    if (i2.isRtl) {
      yRailOffset.left = i2.negativeScrollAdjustment + element.scrollLeft + i2.containerWidth * 2 - i2.contentWidth - i2.scrollbarYLeft - i2.scrollbarYOuterWidth;
    } else {
      yRailOffset.left = i2.scrollbarYLeft + element.scrollLeft;
    }
  }
  set$2(i2.scrollbarYRail, yRailOffset);
  set$2(i2.scrollbarX, {
    left: i2.scrollbarXLeft,
    width: i2.scrollbarXWidth - i2.railBorderXWidth
  });
  set$2(i2.scrollbarY, {
    top: i2.scrollbarYTop,
    height: i2.scrollbarYHeight - i2.railBorderYWidth
  });
}
function clickRail(i2) {
  i2.element;
  i2.event.bind(i2.scrollbarY, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i2.event.bind(i2.scrollbarYRail, "mousedown", function(e2) {
    var positionTop = e2.pageY - window.pageYOffset - i2.scrollbarYRail.getBoundingClientRect().top;
    var direction2 = positionTop > i2.scrollbarYTop ? 1 : -1;
    i2.element.scrollTop += direction2 * i2.containerHeight;
    updateGeometry(i2);
    e2.stopPropagation();
  });
  i2.event.bind(i2.scrollbarX, "mousedown", function(e2) {
    return e2.stopPropagation();
  });
  i2.event.bind(i2.scrollbarXRail, "mousedown", function(e2) {
    var positionLeft = e2.pageX - window.pageXOffset - i2.scrollbarXRail.getBoundingClientRect().left;
    var direction2 = positionLeft > i2.scrollbarXLeft ? 1 : -1;
    i2.element.scrollLeft += direction2 * i2.containerWidth;
    updateGeometry(i2);
    e2.stopPropagation();
  });
}
function dragThumb(i2) {
  bindMouseScrollHandler(i2, [
    "containerWidth",
    "contentWidth",
    "pageX",
    "railXWidth",
    "scrollbarX",
    "scrollbarXWidth",
    "scrollLeft",
    "x",
    "scrollbarXRail"
  ]);
  bindMouseScrollHandler(i2, [
    "containerHeight",
    "contentHeight",
    "pageY",
    "railYHeight",
    "scrollbarY",
    "scrollbarYHeight",
    "scrollTop",
    "y",
    "scrollbarYRail"
  ]);
}
function bindMouseScrollHandler(i2, ref2) {
  var containerHeight = ref2[0];
  var contentHeight = ref2[1];
  var pageY = ref2[2];
  var railYHeight = ref2[3];
  var scrollbarY = ref2[4];
  var scrollbarYHeight = ref2[5];
  var scrollTop = ref2[6];
  var y2 = ref2[7];
  var scrollbarYRail = ref2[8];
  var element = i2.element;
  var startingScrollTop = null;
  var startingMousePageY = null;
  var scrollBy2 = null;
  function mouseMoveHandler(e2) {
    if (e2.touches && e2.touches[0]) {
      e2[pageY] = e2.touches[0].pageY;
    }
    element[scrollTop] = startingScrollTop + scrollBy2 * (e2[pageY] - startingMousePageY);
    addScrollingClass(i2, y2);
    updateGeometry(i2);
    e2.stopPropagation();
    if (e2.type.startsWith("touch") && e2.changedTouches.length > 1) {
      e2.preventDefault();
    }
  }
  function mouseUpHandler() {
    removeScrollingClass(i2, y2);
    i2[scrollbarYRail].classList.remove(cls.state.clicking);
    i2.event.unbind(i2.ownerDocument, "mousemove", mouseMoveHandler);
  }
  function bindMoves(e2, touchMode) {
    startingScrollTop = element[scrollTop];
    if (touchMode && e2.touches) {
      e2[pageY] = e2.touches[0].pageY;
    }
    startingMousePageY = e2[pageY];
    scrollBy2 = (i2[contentHeight] - i2[containerHeight]) / (i2[railYHeight] - i2[scrollbarYHeight]);
    if (!touchMode) {
      i2.event.bind(i2.ownerDocument, "mousemove", mouseMoveHandler);
      i2.event.once(i2.ownerDocument, "mouseup", mouseUpHandler);
      e2.preventDefault();
    } else {
      i2.event.bind(i2.ownerDocument, "touchmove", mouseMoveHandler);
    }
    i2[scrollbarYRail].classList.add(cls.state.clicking);
    e2.stopPropagation();
  }
  i2.event.bind(i2[scrollbarY], "mousedown", function(e2) {
    bindMoves(e2);
  });
  i2.event.bind(i2[scrollbarY], "touchstart", function(e2) {
    bindMoves(e2, true);
  });
}
function keyboard(i2) {
  var element = i2.element;
  var elementHovered = function() {
    return matches$1(element, ":hover");
  };
  var scrollbarFocused = function() {
    return matches$1(i2.scrollbarX, ":focus") || matches$1(i2.scrollbarY, ":focus");
  };
  function shouldPreventDefault(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    if (deltaX === 0) {
      if (!i2.scrollbarYActive) {
        return false;
      }
      if (scrollTop === 0 && deltaY > 0 || scrollTop >= i2.contentHeight - i2.containerHeight && deltaY < 0) {
        return !i2.settings.wheelPropagation;
      }
    }
    var scrollLeft = element.scrollLeft;
    if (deltaY === 0) {
      if (!i2.scrollbarXActive) {
        return false;
      }
      if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= i2.contentWidth - i2.containerWidth && deltaX > 0) {
        return !i2.settings.wheelPropagation;
      }
    }
    return true;
  }
  i2.event.bind(i2.ownerDocument, "keydown", function(e2) {
    if (e2.isDefaultPrevented && e2.isDefaultPrevented() || e2.defaultPrevented) {
      return;
    }
    if (!elementHovered() && !scrollbarFocused()) {
      return;
    }
    var activeElement = document.activeElement ? document.activeElement : i2.ownerDocument.activeElement;
    if (activeElement) {
      if (activeElement.tagName === "IFRAME") {
        activeElement = activeElement.contentDocument.activeElement;
      } else {
        while (activeElement.shadowRoot) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
      }
      if (isEditable(activeElement)) {
        return;
      }
    }
    var deltaX = 0;
    var deltaY = 0;
    switch (e2.which) {
      case 37:
        if (e2.metaKey) {
          deltaX = -i2.contentWidth;
        } else if (e2.altKey) {
          deltaX = -i2.containerWidth;
        } else {
          deltaX = -30;
        }
        break;
      case 38:
        if (e2.metaKey) {
          deltaY = i2.contentHeight;
        } else if (e2.altKey) {
          deltaY = i2.containerHeight;
        } else {
          deltaY = 30;
        }
        break;
      case 39:
        if (e2.metaKey) {
          deltaX = i2.contentWidth;
        } else if (e2.altKey) {
          deltaX = i2.containerWidth;
        } else {
          deltaX = 30;
        }
        break;
      case 40:
        if (e2.metaKey) {
          deltaY = -i2.contentHeight;
        } else if (e2.altKey) {
          deltaY = -i2.containerHeight;
        } else {
          deltaY = -30;
        }
        break;
      case 32:
        if (e2.shiftKey) {
          deltaY = i2.containerHeight;
        } else {
          deltaY = -i2.containerHeight;
        }
        break;
      case 33:
        deltaY = i2.containerHeight;
        break;
      case 34:
        deltaY = -i2.containerHeight;
        break;
      case 36:
        deltaY = i2.contentHeight;
        break;
      case 35:
        deltaY = -i2.contentHeight;
        break;
      default:
        return;
    }
    if (i2.settings.suppressScrollX && deltaX !== 0) {
      return;
    }
    if (i2.settings.suppressScrollY && deltaY !== 0) {
      return;
    }
    element.scrollTop -= deltaY;
    element.scrollLeft += deltaX;
    updateGeometry(i2);
    if (shouldPreventDefault(deltaX, deltaY)) {
      e2.preventDefault();
    }
  });
}
function wheel(i2) {
  var element = i2.element;
  function shouldPreventDefault(deltaX, deltaY) {
    var roundedScrollTop = Math.floor(element.scrollTop);
    var isTop = element.scrollTop === 0;
    var isBottom = roundedScrollTop + element.offsetHeight === element.scrollHeight;
    var isLeft = element.scrollLeft === 0;
    var isRight = element.scrollLeft + element.offsetWidth === element.scrollWidth;
    var hitsBound;
    if (Math.abs(deltaY) > Math.abs(deltaX)) {
      hitsBound = isTop || isBottom;
    } else {
      hitsBound = isLeft || isRight;
    }
    return hitsBound ? !i2.settings.wheelPropagation : true;
  }
  function getDeltaFromEvent(e2) {
    var deltaX = e2.deltaX;
    var deltaY = -1 * e2.deltaY;
    if (typeof deltaX === "undefined" || typeof deltaY === "undefined") {
      deltaX = -1 * e2.wheelDeltaX / 6;
      deltaY = e2.wheelDeltaY / 6;
    }
    if (e2.deltaMode && e2.deltaMode === 1) {
      deltaX *= 10;
      deltaY *= 10;
    }
    if (deltaX !== deltaX && deltaY !== deltaY) {
      deltaX = 0;
      deltaY = e2.wheelDelta;
    }
    if (e2.shiftKey) {
      return [-deltaY, -deltaX];
    }
    return [deltaX, deltaY];
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!env.isWebKit && element.querySelector("select:focus")) {
      return true;
    }
    if (!element.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style2 = get$1(cursor);
      if (deltaY && style2.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style2.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function mousewheelHandler(e2) {
    var ref2 = getDeltaFromEvent(e2);
    var deltaX = ref2[0];
    var deltaY = ref2[1];
    if (shouldBeConsumedByChild(e2.target, deltaX, deltaY)) {
      return;
    }
    var shouldPrevent = false;
    if (!i2.settings.useBothWheelAxes) {
      element.scrollTop -= deltaY * i2.settings.wheelSpeed;
      element.scrollLeft += deltaX * i2.settings.wheelSpeed;
    } else if (i2.scrollbarYActive && !i2.scrollbarXActive) {
      if (deltaY) {
        element.scrollTop -= deltaY * i2.settings.wheelSpeed;
      } else {
        element.scrollTop += deltaX * i2.settings.wheelSpeed;
      }
      shouldPrevent = true;
    } else if (i2.scrollbarXActive && !i2.scrollbarYActive) {
      if (deltaX) {
        element.scrollLeft += deltaX * i2.settings.wheelSpeed;
      } else {
        element.scrollLeft -= deltaY * i2.settings.wheelSpeed;
      }
      shouldPrevent = true;
    }
    updateGeometry(i2);
    shouldPrevent = shouldPrevent || shouldPreventDefault(deltaX, deltaY);
    if (shouldPrevent && !e2.ctrlKey) {
      e2.stopPropagation();
      e2.preventDefault();
    }
  }
  if (typeof window.onwheel !== "undefined") {
    i2.event.bind(element, "wheel", mousewheelHandler);
  } else if (typeof window.onmousewheel !== "undefined") {
    i2.event.bind(element, "mousewheel", mousewheelHandler);
  }
}
function touch$1(i2) {
  if (!env.supportsTouch && !env.supportsIePointer) {
    return;
  }
  var element = i2.element;
  function shouldPrevent(deltaX, deltaY) {
    var scrollTop = Math.floor(element.scrollTop);
    var scrollLeft = element.scrollLeft;
    var magnitudeX = Math.abs(deltaX);
    var magnitudeY = Math.abs(deltaY);
    if (magnitudeY > magnitudeX) {
      if (deltaY < 0 && scrollTop === i2.contentHeight - i2.containerHeight || deltaY > 0 && scrollTop === 0) {
        return window.scrollY === 0 && deltaY > 0 && env.isChrome;
      }
    } else if (magnitudeX > magnitudeY) {
      if (deltaX < 0 && scrollLeft === i2.contentWidth - i2.containerWidth || deltaX > 0 && scrollLeft === 0) {
        return true;
      }
    }
    return true;
  }
  function applyTouchMove(differenceX, differenceY) {
    element.scrollTop -= differenceY;
    element.scrollLeft -= differenceX;
    updateGeometry(i2);
  }
  var startOffset = {};
  var startTime2 = 0;
  var speed = {};
  var easingLoop = null;
  function getTouch(e2) {
    if (e2.targetTouches) {
      return e2.targetTouches[0];
    } else {
      return e2;
    }
  }
  function shouldHandle(e2) {
    if (e2.pointerType && e2.pointerType === "pen" && e2.buttons === 0) {
      return false;
    }
    if (e2.targetTouches && e2.targetTouches.length === 1) {
      return true;
    }
    if (e2.pointerType && e2.pointerType !== "mouse" && e2.pointerType !== e2.MSPOINTER_TYPE_MOUSE) {
      return true;
    }
    return false;
  }
  function touchStart(e2) {
    if (!shouldHandle(e2)) {
      return;
    }
    var touch2 = getTouch(e2);
    startOffset.pageX = touch2.pageX;
    startOffset.pageY = touch2.pageY;
    startTime2 = new Date().getTime();
    if (easingLoop !== null) {
      clearInterval(easingLoop);
    }
  }
  function shouldBeConsumedByChild(target, deltaX, deltaY) {
    if (!element.contains(target)) {
      return false;
    }
    var cursor = target;
    while (cursor && cursor !== element) {
      if (cursor.classList.contains(cls.element.consuming)) {
        return true;
      }
      var style2 = get$1(cursor);
      if (deltaY && style2.overflowY.match(/(scroll|auto)/)) {
        var maxScrollTop = cursor.scrollHeight - cursor.clientHeight;
        if (maxScrollTop > 0) {
          if (cursor.scrollTop > 0 && deltaY < 0 || cursor.scrollTop < maxScrollTop && deltaY > 0) {
            return true;
          }
        }
      }
      if (deltaX && style2.overflowX.match(/(scroll|auto)/)) {
        var maxScrollLeft = cursor.scrollWidth - cursor.clientWidth;
        if (maxScrollLeft > 0) {
          if (cursor.scrollLeft > 0 && deltaX < 0 || cursor.scrollLeft < maxScrollLeft && deltaX > 0) {
            return true;
          }
        }
      }
      cursor = cursor.parentNode;
    }
    return false;
  }
  function touchMove(e2) {
    if (shouldHandle(e2)) {
      var touch2 = getTouch(e2);
      var currentOffset = { pageX: touch2.pageX, pageY: touch2.pageY };
      var differenceX = currentOffset.pageX - startOffset.pageX;
      var differenceY = currentOffset.pageY - startOffset.pageY;
      if (shouldBeConsumedByChild(e2.target, differenceX, differenceY)) {
        return;
      }
      applyTouchMove(differenceX, differenceY);
      startOffset = currentOffset;
      var currentTime = new Date().getTime();
      var timeGap = currentTime - startTime2;
      if (timeGap > 0) {
        speed.x = differenceX / timeGap;
        speed.y = differenceY / timeGap;
        startTime2 = currentTime;
      }
      if (shouldPrevent(differenceX, differenceY)) {
        e2.preventDefault();
      }
    }
  }
  function touchEnd() {
    if (i2.settings.swipeEasing) {
      clearInterval(easingLoop);
      easingLoop = setInterval(function() {
        if (i2.isInitialized) {
          clearInterval(easingLoop);
          return;
        }
        if (!speed.x && !speed.y) {
          clearInterval(easingLoop);
          return;
        }
        if (Math.abs(speed.x) < 0.01 && Math.abs(speed.y) < 0.01) {
          clearInterval(easingLoop);
          return;
        }
        if (!i2.element) {
          clearInterval(easingLoop);
          return;
        }
        applyTouchMove(speed.x * 30, speed.y * 30);
        speed.x *= 0.8;
        speed.y *= 0.8;
      }, 10);
    }
  }
  if (env.supportsTouch) {
    i2.event.bind(element, "touchstart", touchStart);
    i2.event.bind(element, "touchmove", touchMove);
    i2.event.bind(element, "touchend", touchEnd);
  } else if (env.supportsIePointer) {
    if (window.PointerEvent) {
      i2.event.bind(element, "pointerdown", touchStart);
      i2.event.bind(element, "pointermove", touchMove);
      i2.event.bind(element, "pointerup", touchEnd);
    } else if (window.MSPointerEvent) {
      i2.event.bind(element, "MSPointerDown", touchStart);
      i2.event.bind(element, "MSPointerMove", touchMove);
      i2.event.bind(element, "MSPointerUp", touchEnd);
    }
  }
}
var defaultSettings = function() {
  return {
    handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
    maxScrollbarLength: null,
    minScrollbarLength: null,
    scrollingThreshold: 1e3,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    suppressScrollX: false,
    suppressScrollY: false,
    swipeEasing: true,
    useBothWheelAxes: false,
    wheelPropagation: true,
    wheelSpeed: 1
  };
};
var handlers = {
  "click-rail": clickRail,
  "drag-thumb": dragThumb,
  keyboard,
  wheel,
  touch: touch$1
};
var PerfectScrollbar = function PerfectScrollbar2(element, userSettings) {
  var this$1$1 = this;
  if (userSettings === void 0)
    userSettings = {};
  if (typeof element === "string") {
    element = document.querySelector(element);
  }
  if (!element || !element.nodeName) {
    throw new Error("no element is specified to initialize PerfectScrollbar");
  }
  this.element = element;
  element.classList.add(cls.main);
  this.settings = defaultSettings();
  for (var key in userSettings) {
    this.settings[key] = userSettings[key];
  }
  this.containerWidth = null;
  this.containerHeight = null;
  this.contentWidth = null;
  this.contentHeight = null;
  var focus = function() {
    return element.classList.add(cls.state.focus);
  };
  var blur = function() {
    return element.classList.remove(cls.state.focus);
  };
  this.isRtl = get$1(element).direction === "rtl";
  if (this.isRtl === true) {
    element.classList.add(cls.rtl);
  }
  this.isNegativeScroll = function() {
    var originalScrollLeft = element.scrollLeft;
    var result = null;
    element.scrollLeft = -1;
    result = element.scrollLeft < 0;
    element.scrollLeft = originalScrollLeft;
    return result;
  }();
  this.negativeScrollAdjustment = this.isNegativeScroll ? element.scrollWidth - element.clientWidth : 0;
  this.event = new EventManager();
  this.ownerDocument = element.ownerDocument || document;
  this.scrollbarXRail = div(cls.element.rail("x"));
  element.appendChild(this.scrollbarXRail);
  this.scrollbarX = div(cls.element.thumb("x"));
  this.scrollbarXRail.appendChild(this.scrollbarX);
  this.scrollbarX.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarX, "focus", focus);
  this.event.bind(this.scrollbarX, "blur", blur);
  this.scrollbarXActive = null;
  this.scrollbarXWidth = null;
  this.scrollbarXLeft = null;
  var railXStyle = get$1(this.scrollbarXRail);
  this.scrollbarXBottom = parseInt(railXStyle.bottom, 10);
  if (isNaN(this.scrollbarXBottom)) {
    this.isScrollbarXUsingBottom = false;
    this.scrollbarXTop = toInt(railXStyle.top);
  } else {
    this.isScrollbarXUsingBottom = true;
  }
  this.railBorderXWidth = toInt(railXStyle.borderLeftWidth) + toInt(railXStyle.borderRightWidth);
  set$2(this.scrollbarXRail, { display: "block" });
  this.railXMarginWidth = toInt(railXStyle.marginLeft) + toInt(railXStyle.marginRight);
  set$2(this.scrollbarXRail, { display: "" });
  this.railXWidth = null;
  this.railXRatio = null;
  this.scrollbarYRail = div(cls.element.rail("y"));
  element.appendChild(this.scrollbarYRail);
  this.scrollbarY = div(cls.element.thumb("y"));
  this.scrollbarYRail.appendChild(this.scrollbarY);
  this.scrollbarY.setAttribute("tabindex", 0);
  this.event.bind(this.scrollbarY, "focus", focus);
  this.event.bind(this.scrollbarY, "blur", blur);
  this.scrollbarYActive = null;
  this.scrollbarYHeight = null;
  this.scrollbarYTop = null;
  var railYStyle = get$1(this.scrollbarYRail);
  this.scrollbarYRight = parseInt(railYStyle.right, 10);
  if (isNaN(this.scrollbarYRight)) {
    this.isScrollbarYUsingRight = false;
    this.scrollbarYLeft = toInt(railYStyle.left);
  } else {
    this.isScrollbarYUsingRight = true;
  }
  this.scrollbarYOuterWidth = this.isRtl ? outerWidth(this.scrollbarY) : null;
  this.railBorderYWidth = toInt(railYStyle.borderTopWidth) + toInt(railYStyle.borderBottomWidth);
  set$2(this.scrollbarYRail, { display: "block" });
  this.railYMarginHeight = toInt(railYStyle.marginTop) + toInt(railYStyle.marginBottom);
  set$2(this.scrollbarYRail, { display: "" });
  this.railYHeight = null;
  this.railYRatio = null;
  this.reach = {
    x: element.scrollLeft <= 0 ? "start" : element.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
    y: element.scrollTop <= 0 ? "start" : element.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
  };
  this.isAlive = true;
  this.settings.handlers.forEach(function(handlerName) {
    return handlers[handlerName](this$1$1);
  });
  this.lastScrollTop = Math.floor(element.scrollTop);
  this.lastScrollLeft = element.scrollLeft;
  this.event.bind(this.element, "scroll", function(e2) {
    return this$1$1.onScroll(e2);
  });
  updateGeometry(this);
};
PerfectScrollbar.prototype.update = function update() {
  if (!this.isAlive) {
    return;
  }
  this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0;
  set$2(this.scrollbarXRail, { display: "block" });
  set$2(this.scrollbarYRail, { display: "block" });
  this.railXMarginWidth = toInt(get$1(this.scrollbarXRail).marginLeft) + toInt(get$1(this.scrollbarXRail).marginRight);
  this.railYMarginHeight = toInt(get$1(this.scrollbarYRail).marginTop) + toInt(get$1(this.scrollbarYRail).marginBottom);
  set$2(this.scrollbarXRail, { display: "none" });
  set$2(this.scrollbarYRail, { display: "none" });
  updateGeometry(this);
  processScrollDiff(this, "top", 0, false, true);
  processScrollDiff(this, "left", 0, false, true);
  set$2(this.scrollbarXRail, { display: "" });
  set$2(this.scrollbarYRail, { display: "" });
};
PerfectScrollbar.prototype.onScroll = function onScroll(e2) {
  if (!this.isAlive) {
    return;
  }
  updateGeometry(this);
  processScrollDiff(this, "top", this.element.scrollTop - this.lastScrollTop);
  processScrollDiff(
    this,
    "left",
    this.element.scrollLeft - this.lastScrollLeft
  );
  this.lastScrollTop = Math.floor(this.element.scrollTop);
  this.lastScrollLeft = this.element.scrollLeft;
};
PerfectScrollbar.prototype.destroy = function destroy() {
  if (!this.isAlive) {
    return;
  }
  this.event.unbindAll();
  remove(this.scrollbarX);
  remove(this.scrollbarY);
  remove(this.scrollbarXRail);
  remove(this.scrollbarYRail);
  this.removePsClasses();
  this.element = null;
  this.scrollbarX = null;
  this.scrollbarY = null;
  this.scrollbarXRail = null;
  this.scrollbarYRail = null;
  this.isAlive = false;
};
PerfectScrollbar.prototype.removePsClasses = function removePsClasses() {
  this.element.className = this.element.className.split(" ").filter(function(name2) {
    return !name2.match(/^ps([-_].+|)$/);
  }).join(" ");
};
const eventNames = [
  "scroll",
  "ps-scroll-y",
  "ps-scroll-x",
  "ps-scroll-up",
  "ps-scroll-down",
  "ps-scroll-left",
  "ps-scroll-right",
  "ps-y-reach-start",
  "ps-y-reach-end",
  "ps-x-reach-start",
  "ps-x-reach-end"
];
var PerfectScrollbar$1 = {
  name: "PerfectScrollbar",
  props: {
    options: {
      type: Object,
      required: false,
      default: () => {
      }
    },
    tag: {
      type: String,
      required: false,
      default: "div"
    },
    watchOptions: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  emits: eventNames,
  data() {
    return {
      ps: null
    };
  },
  watch: {
    watchOptions(shouldWatch) {
      if (!shouldWatch && this.watcher) {
        this.watcher();
      } else {
        this.createWatcher();
      }
    }
  },
  mounted() {
    this.create();
    if (this.watchOptions) {
      this.createWatcher();
    }
  },
  updated() {
    this.$nextTick(() => {
      this.update();
    });
  },
  beforeUnmount() {
    this.destroy();
  },
  methods: {
    create() {
      if (!(this.ps && this.$isServer)) {
        this.ps = new PerfectScrollbar(this.$el, this.options);
        eventNames.forEach((eventName) => {
          this.ps.element.addEventListener(eventName, (event) => this.$emit(eventName, event));
        });
      }
    },
    createWatcher() {
      this.watcher = this.$watch("options", () => {
        this.destroy();
        this.create();
      }, {
        deep: true
      });
    },
    update() {
      if (this.ps) {
        this.ps.update();
      }
    },
    destroy() {
      if (this.ps) {
        this.ps.destroy();
        this.ps = null;
      }
    }
  },
  render() {
    return h$5(
      this.tag,
      {
        class: "ps"
      },
      this.$slots.default && this.$slots.default()
    );
  }
};
var index$2 = {
  install: (Vue, settings) => {
    if (settings) {
      if (settings.name && typeof settings.name === "string") {
        PerfectScrollbar$1.name = settings.name;
      }
      if (settings.options && typeof settings.options === "object") {
        PerfectScrollbar$1.props.options.default = () => {
          return settings.options;
        };
      }
      if (settings.tag && typeof settings.tag === "string") {
        PerfectScrollbar$1.props.tag.default = settings.tag;
      }
      if (settings.watchOptions && typeof settings.watchOptions === "boolean") {
        PerfectScrollbar$1.props.watchOptions = settings.watchOptions;
      }
    }
    Vue.component(
      PerfectScrollbar$1.name,
      PerfectScrollbar$1
    );
  }
};
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props2) {
  for (var i2 = 0; i2 < props2.length; i2++) {
    var descriptor = props2[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$1(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function ownKeys$1(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _iterableToArrayLimit(arr, i2) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e2 = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e2 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e2;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn3, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(path, base === void 0 || base === null ? module2.path : base);
    }
  }, fn3(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var freeGlobal$2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$2;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$2 = _freeGlobal || freeSelf$1 || Function("return this")();
var _root = root$2;
var Symbol$1$1 = _root.Symbol;
var _Symbol = Symbol$1$1;
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var nativeObjectToString$2 = objectProto$b.toString;
var symToStringTag$2 = _Symbol ? _Symbol.toStringTag : void 0;
function getRawTag$1(value2) {
  var isOwn = hasOwnProperty$9.call(value2, symToStringTag$2), tag = value2[symToStringTag$2];
  try {
    value2[symToStringTag$2] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$2.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$2] = tag;
    } else {
      delete value2[symToStringTag$2];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$1$1 = Object.prototype;
var nativeObjectToString$1$1 = objectProto$1$1.toString;
function objectToString$2(value2) {
  return nativeObjectToString$1$1.call(value2);
}
var _objectToString = objectToString$2;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$1$1 = _Symbol ? _Symbol.toStringTag : void 0;
function baseGetTag$1(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$1$1 && symToStringTag$1$1 in Object(value2) ? _getRawTag(value2) : _objectToString(value2);
}
var _baseGetTag = baseGetTag$1;
function isObjectLike$1(value2) {
  return value2 != null && typeof value2 == "object";
}
var isObjectLike_1 = isObjectLike$1;
var isArray$7 = Array.isArray;
var isArray_1 = isArray$7;
function isObject$6(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$6;
var asyncTag$1 = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag$1 = "[object Proxy]";
function isFunction$3(value2) {
  if (!isObject_1(value2)) {
    return false;
  }
  var tag = _baseGetTag(value2);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag$1 || tag == proxyTag$1;
}
var isFunction_1 = isFunction$3;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
function isLength$1(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$2;
}
var isLength_1 = isLength$1;
function isArrayLike$1(value2) {
  return value2 != null && isLength_1(value2.length) && !isFunction_1(value2);
}
var isArrayLike_1 = isArrayLike$1;
function isArrayLikeObject$1(value2) {
  return isObjectLike_1(value2) && isArrayLike_1(value2);
}
var isArrayLikeObject_1 = isArrayLikeObject$1;
var dateTag$1 = "[object Date]";
function baseIsDate(value2) {
  return isObjectLike_1(value2) && _baseGetTag(value2) == dateTag$1;
}
var _baseIsDate = baseIsDate;
function baseUnary$1(func) {
  return function(value2) {
    return func(value2);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = createCommonjsModule(function(module2, exports2) {
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var freeProcess2 = moduleExports2 && _freeGlobal.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e2) {
    }
  }();
  module2.exports = nodeUtil2;
});
var nodeIsDate = _nodeUtil && _nodeUtil.isDate;
var isDate$2 = nodeIsDate ? _baseUnary(nodeIsDate) : _baseIsDate;
var isDate_1 = isDate$2;
var symbolTag = "[object Symbol]";
function isSymbol$1(value2) {
  return typeof value2 == "symbol" || isObjectLike_1(value2) && _baseGetTag(value2) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value2, object) {
  if (isArray_1(value2)) {
    return false;
  }
  var type = typeof value2;
  if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol_1(value2)) {
    return true;
  }
  return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
}
var _isKey = isKey;
var coreJsData$2 = _root["__core-js_shared__"];
var _coreJsData = coreJsData$2;
var maskSrcKey$1 = function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey$1 && maskSrcKey$1 in func;
}
var _isMasked = isMasked$1;
var funcProto$3 = Function.prototype;
var funcToString$3 = funcProto$3.toString;
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$3.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$1;
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;
var funcProto$1$1 = Function.prototype, objectProto$2$1 = Object.prototype;
var funcToString$1$1 = funcProto$1$1.toString;
var hasOwnProperty$1$1 = objectProto$2$1.hasOwnProperty;
var reIsNative$1 = RegExp(
  "^" + funcToString$1$1.call(hasOwnProperty$1$1).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value2) {
  if (!isObject_1(value2) || _isMasked(value2)) {
    return false;
  }
  var pattern = isFunction_1(value2) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(_toSource(value2));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object, key) {
  return object == null ? void 0 : object[key];
}
var _getValue = getValue$1;
function getNative$1(object, key) {
  var value2 = _getValue(object, key);
  return _baseIsNative(value2) ? value2 : void 0;
}
var _getNative = getNative$1;
var nativeCreate$2 = _getNative(Object, "create");
var _nativeCreate = nativeCreate$2;
function hashClear$1() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$3$1 = Object.prototype;
var hasOwnProperty$2$1 = objectProto$3$1.hasOwnProperty;
function hashGet$1(key) {
  var data9 = this.__data__;
  if (_nativeCreate) {
    var result = data9[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$2$1.call(data9, key) ? data9[key] : void 0;
}
var _hashGet = hashGet$1;
var objectProto$4$1 = Object.prototype;
var hasOwnProperty$3$1 = objectProto$4$1.hasOwnProperty;
function hashHas$1(key) {
  var data9 = this.__data__;
  return _nativeCreate ? data9[key] !== void 0 : hasOwnProperty$3$1.call(data9, key);
}
var _hashHas = hashHas$1;
var HASH_UNDEFINED$1$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value2) {
  var data9 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data9[key] = _nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1$1 : value2;
  return this;
}
var _hashSet = hashSet$1;
function Hash$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = _hashClear;
Hash$1.prototype["delete"] = _hashDelete;
Hash$1.prototype.get = _hashGet;
Hash$1.prototype.has = _hashHas;
Hash$1.prototype.set = _hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$1(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var eq_1 = eq$1;
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$1;
var arrayProto$1 = Array.prototype;
var splice$1 = arrayProto$1.splice;
function listCacheDelete$1(key) {
  var data9 = this.__data__, index2 = _assocIndexOf(data9, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data9.length - 1;
  if (index2 == lastIndex) {
    data9.pop();
  } else {
    splice$1.call(data9, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
function listCacheGet$1(key) {
  var data9 = this.__data__, index2 = _assocIndexOf(data9, key);
  return index2 < 0 ? void 0 : data9[index2][1];
}
var _listCacheGet = listCacheGet$1;
function listCacheHas$1(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
function listCacheSet$1(key, value2) {
  var data9 = this.__data__, index2 = _assocIndexOf(data9, key);
  if (index2 < 0) {
    ++this.size;
    data9.push([key, value2]);
  } else {
    data9[index2][1] = value2;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
function ListCache$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = _listCacheClear;
ListCache$1.prototype["delete"] = _listCacheDelete;
ListCache$1.prototype.get = _listCacheGet;
ListCache$1.prototype.has = _listCacheHas;
ListCache$1.prototype.set = _listCacheSet;
var _ListCache = ListCache$1;
var Map$3 = _getNative(_root, "Map");
var _Map = Map$3;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new _Hash(),
    "map": new (_Map || _ListCache)(),
    "string": new _Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
var _isKeyable = isKeyable$1;
function getMapData$1(map2, key) {
  var data9 = map2.__data__;
  return _isKeyable(key) ? data9[typeof key == "string" ? "string" : "hash"] : data9.map;
}
var _getMapData = getMapData$1;
function mapCacheDelete$1(key) {
  var result = _getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
function mapCacheGet$1(key) {
  return _getMapData(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
function mapCacheHas$1(key) {
  return _getMapData(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
function mapCacheSet$1(key, value2) {
  var data9 = _getMapData(this, key), size = data9.size;
  data9.set(key, value2);
  this.size += data9.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
function MapCache$1(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = _mapCacheClear;
MapCache$1.prototype["delete"] = _mapCacheDelete;
MapCache$1.prototype.get = _mapCacheGet;
MapCache$1.prototype.has = _mapCacheHas;
MapCache$1.prototype.set = _mapCacheSet;
var _MapCache = MapCache$1;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache)();
  return memoized;
}
memoize.Cache = _MapCache;
var memoize_1 = memoize;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped;
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar$1 = /\\(\\)?/g;
var stringToPath$1 = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName$1, function(match, number, quote2, subString) {
    result.push(quote2 ? subString.replace(reEscapeChar$1, "$1") : number || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var _arrayMap = arrayMap;
var INFINITY = 1 / 0;
var symbolProto = _Symbol ? _Symbol.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isArray_1(value2)) {
    return _arrayMap(value2, baseToString) + "";
  }
  if (isSymbol_1(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
var _baseToString = baseToString;
function toString$1(value2) {
  return value2 == null ? "" : _baseToString(value2);
}
var toString_1 = toString$1;
function castPath(value2, object) {
  if (isArray_1(value2)) {
    return value2;
  }
  return _isKey(value2, object) ? [value2] : _stringToPath(toString_1(value2));
}
var _castPath = castPath;
var INFINITY$1 = 1 / 0;
function toKey(value2) {
  if (typeof value2 == "string" || isSymbol_1(value2)) {
    return value2;
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY$1 ? "-0" : result;
}
var _toKey = toKey;
function baseGet(object, path) {
  path = _castPath(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[_toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
var _baseGet = baseGet;
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : _baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
var defineProperty$2 = function() {
  try {
    var func = _getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
var _defineProperty$1$1 = defineProperty$2;
function baseAssignValue$1(object, key, value2) {
  if (key == "__proto__" && _defineProperty$1$1) {
    _defineProperty$1$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
var _baseAssignValue = baseAssignValue$1;
var objectProto$5$1 = Object.prototype;
var hasOwnProperty$4$1 = objectProto$5$1.hasOwnProperty;
function assignValue$1(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$4$1.call(object, key) && eq_1(objValue, value2)) || value2 === void 0 && !(key in object)) {
    _baseAssignValue(object, key, value2);
  }
}
var _assignValue = assignValue$1;
var MAX_SAFE_INTEGER$1$1 = 9007199254740991;
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$2(value2, length) {
  var type = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint$1.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
var _isIndex = isIndex$2;
function baseSet(object, path, value2, customizer) {
  if (!isObject_1(object)) {
    return object;
  }
  path = _castPath(path, object);
  var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
  while (nested != null && ++index2 < length) {
    var key = _toKey(path[index2]), newValue = value2;
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return object;
    }
    if (index2 != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : void 0;
      if (newValue === void 0) {
        newValue = isObject_1(objValue) ? objValue : _isIndex(path[index2 + 1]) ? [] : {};
      }
    }
    _assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
var _baseSet = baseSet;
function createBaseFor$1(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
    while (length--) {
      var key = props2[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var _createBaseFor = createBaseFor$1;
var baseFor$2 = _createBaseFor();
var _baseFor = baseFor$2;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value2) {
  return isObjectLike_1(value2) && _baseGetTag(value2) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var objectProto$6$1 = Object.prototype;
var hasOwnProperty$5$1 = objectProto$6$1.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$6$1.propertyIsEnumerable;
var isArguments$2 = _baseIsArguments(function() {
  return arguments;
}()) ? _baseIsArguments : function(value2) {
  return isObjectLike_1(value2) && hasOwnProperty$5$1.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
};
var isArguments_1 = isArguments$2;
function stubFalse$1() {
  return false;
}
var stubFalse_1 = stubFalse$1;
var isBuffer_1 = createCommonjsModule(function(module2, exports2) {
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? _root.Buffer : void 0;
  var nativeIsBuffer2 = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer3 = nativeIsBuffer2 || stubFalse_1;
  module2.exports = isBuffer3;
});
var argsTag$1$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1$1 = "[object Function]", mapTag$2 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
var typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$1] = typedArrayTags$1[float64Tag$1] = typedArrayTags$1[int8Tag$1] = typedArrayTags$1[int16Tag$1] = typedArrayTags$1[int32Tag$1] = typedArrayTags$1[uint8Tag$1] = typedArrayTags$1[uint8ClampedTag$1] = typedArrayTags$1[uint16Tag$1] = typedArrayTags$1[uint32Tag$1] = true;
typedArrayTags$1[argsTag$1$1] = typedArrayTags$1[arrayTag$1] = typedArrayTags$1[arrayBufferTag$1] = typedArrayTags$1[boolTag$2] = typedArrayTags$1[dataViewTag$1] = typedArrayTags$1[dateTag$1$1] = typedArrayTags$1[errorTag$1] = typedArrayTags$1[funcTag$1$1] = typedArrayTags$1[mapTag$2] = typedArrayTags$1[numberTag$2] = typedArrayTags$1[objectTag$2] = typedArrayTags$1[regexpTag$1] = typedArrayTags$1[setTag$2] = typedArrayTags$1[stringTag$2] = typedArrayTags$1[weakMapTag$1] = false;
function baseIsTypedArray$1(value2) {
  return isObjectLike_1(value2) && isLength_1(value2.length) && !!typedArrayTags$1[_baseGetTag(value2)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
var nodeIsTypedArray$1 = _nodeUtil && _nodeUtil.isTypedArray;
var isTypedArray$3 = nodeIsTypedArray$1 ? _baseUnary(nodeIsTypedArray$1) : _baseIsTypedArray;
var isTypedArray_1 = isTypedArray$3;
var objectProto$7$1 = Object.prototype;
var hasOwnProperty$6$1 = objectProto$7$1.hasOwnProperty;
function arrayLikeKeys$1(value2, inherited) {
  var isArr = isArray_1(value2), isArg = !isArr && isArguments_1(value2), isBuff = !isArr && !isArg && isBuffer_1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray_1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? _baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$6$1.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || _isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$8$1 = Object.prototype;
function isPrototype$1(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8$1;
  return value2 === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var nativeKeys = _overArg(Object.keys, Object);
var _nativeKeys = nativeKeys;
var objectProto$9$1 = Object.prototype;
var hasOwnProperty$7$1 = objectProto$9$1.hasOwnProperty;
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$7$1.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys;
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}
var keys_1 = keys;
function baseForOwn(object, iteratee) {
  return object && _baseFor(object, iteratee, keys_1);
}
var _baseForOwn = baseForOwn;
function stackClear$1() {
  this.__data__ = new _ListCache();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data9 = this.__data__, result = data9["delete"](key);
  this.size = data9.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key, value2) {
  var data9 = this.__data__;
  if (data9 instanceof _ListCache) {
    var pairs = data9.__data__;
    if (!_Map || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value2]);
      this.size = ++data9.size;
      return this;
    }
    data9 = this.__data__ = new _MapCache(pairs);
  }
  data9.set(key, value2);
  this.size = data9.size;
  return this;
}
var _stackSet = stackSet$1;
function Stack$1(entries) {
  var data9 = this.__data__ = new _ListCache(entries);
  this.size = data9.size;
}
Stack$1.prototype.clear = _stackClear;
Stack$1.prototype["delete"] = _stackDelete;
Stack$1.prototype.get = _stackGet;
Stack$1.prototype.has = _stackHas;
Stack$1.prototype.set = _stackSet;
var _Stack = Stack$1;
var HASH_UNDEFINED$2$1 = "__lodash_hash_undefined__";
function setCacheAdd(value2) {
  this.__data__.set(value2, HASH_UNDEFINED$2$1);
  return this;
}
var _setCacheAdd = setCacheAdd;
function setCacheHas(value2) {
  return this.__data__.has(value2);
}
var _setCacheHas = setCacheHas;
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new _MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;
var _SetCache = SetCache;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome;
function cacheHas(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new _SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!_arraySome(other, function(othValue2, othIndex) {
        if (!_cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays;
var Uint8Array$3 = _root.Uint8Array;
var _Uint8Array = Uint8Array$3;
function mapToArray(map2) {
  var index2 = -1, result = Array(map2.size);
  map2.forEach(function(value2, key) {
    result[++index2] = [key, value2];
  });
  return result;
}
var _mapToArray = mapToArray;
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = value2;
  });
  return result;
}
var _setToArray = setToArray;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
var boolTag$1$1 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1$1 = "[object Error]", mapTag$1$1 = "[object Map]", numberTag$1$1 = "[object Number]", regexpTag$1$1 = "[object RegExp]", setTag$1$1 = "[object Set]", stringTag$1$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1$1 = "[object ArrayBuffer]", dataViewTag$1$1 = "[object DataView]";
var symbolProto$1 = _Symbol ? _Symbol.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1$1:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$1$1:
      if (object.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$1$1:
    case dateTag$2:
    case numberTag$1$1:
      return eq_1(+object, +other);
    case errorTag$1$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1$1:
    case stringTag$1$1:
      return object == other + "";
    case mapTag$1$1:
      var convert = _mapToArray;
    case setTag$1$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = _setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag;
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset2 = array.length;
  while (++index2 < length) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var _arrayPush = arrayPush;
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}
var _baseGetAllKeys = baseGetAllKeys;
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value2 = array[index2];
    if (predicate(value2, index2, array)) {
      result[resIndex++] = value2;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter;
function stubArray() {
  return [];
}
var stubArray_1 = stubArray;
var objectProto$a$1 = Object.prototype;
var propertyIsEnumerable$1$1 = objectProto$a$1.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1$1.call(object, symbol);
  });
};
var _getSymbols = getSymbols;
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}
var _getAllKeys = getAllKeys;
var COMPARE_PARTIAL_FLAG$2 = 1;
var objectProto$b$1 = Object.prototype;
var hasOwnProperty$8$1 = objectProto$b$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2, objProps = _getAllKeys(object), objLength = objProps.length, othProps = _getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$8$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects;
var DataView$1 = _getNative(_root, "DataView");
var _DataView = DataView$1;
var Promise$1 = _getNative(_root, "Promise");
var _Promise = Promise$1;
var Set$1 = _getNative(_root, "Set");
var _Set = Set$1;
var WeakMap$1 = _getNative(_root, "WeakMap");
var _WeakMap = WeakMap$1;
var mapTag$2$1 = "[object Map]", objectTag$1$1 = "[object Object]", promiseTag = "[object Promise]", setTag$2$1 = "[object Set]", weakMapTag$1$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = _toSource(_DataView), mapCtorString = _toSource(_Map), promiseCtorString = _toSource(_Promise), setCtorString = _toSource(_Set), weakMapCtorString = _toSource(_WeakMap);
var getTag = _baseGetTag;
if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2 || _Map && getTag(new _Map()) != mapTag$2$1 || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag$2$1 || _WeakMap && getTag(new _WeakMap()) != weakMapTag$1$1) {
  getTag = function(value2) {
    var result = _baseGetTag(value2), Ctor = result == objectTag$1$1 ? value2.constructor : void 0, ctorString = Ctor ? _toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$2$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$2$1;
        case weakMapCtorString:
          return weakMapTag$1$1;
      }
    }
    return result;
  };
}
var _getTag = getTag;
var COMPARE_PARTIAL_FLAG$3 = 1;
var argsTag$2$1 = "[object Arguments]", arrayTag$1$1 = "[object Array]", objectTag$2$1 = "[object Object]";
var objectProto$c = Object.prototype;
var hasOwnProperty$9$1 = objectProto$c.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object), othIsArr = isArray_1(other), objTag = objIsArr ? arrayTag$1$1 : _getTag(object), othTag = othIsArr ? arrayTag$1$1 : _getTag(other);
  objTag = objTag == argsTag$2$1 ? objectTag$2$1 : objTag;
  othTag = othTag == argsTag$2$1 ? objectTag$2$1 : othTag;
  var objIsObj = objTag == objectTag$2$1, othIsObj = othTag == objectTag$2$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack());
    return objIsArr || isTypedArray_1(object) ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$9$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$9$1.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new _Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack());
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep;
function baseIsEqual(value2, other, bitmask, customizer, stack) {
  if (value2 === other) {
    return true;
  }
  if (value2 == null || other == null || !isObjectLike_1(value2) && !isObjectLike_1(other)) {
    return value2 !== value2 && other !== other;
  }
  return _baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
}
var _baseIsEqual = baseIsEqual;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index2--) {
    var data9 = matchData[index2];
    if (noCustomizer && data9[2] ? data9[1] !== object[data9[0]] : !(data9[0] in object)) {
      return false;
    }
  }
  while (++index2 < length) {
    data9 = matchData[index2];
    var key = data9[0], objValue = object[key], srcValue = data9[1];
    if (noCustomizer && data9[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch;
function isStrictComparable(value2) {
  return value2 === value2 && !isObject_1(value2);
}
var _isStrictComparable = isStrictComparable;
function getMatchData(object) {
  var result = keys_1(object), length = result.length;
  while (length--) {
    var key = result[length], value2 = object[key];
    result[length] = [key, value2, _isStrictComparable(value2)];
  }
  return result;
}
var _getMatchData = getMatchData;
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
var _matchesStrictComparable = matchesStrictComparable;
function baseMatches(source) {
  var matchData = _getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || _baseIsMatch(object, source, matchData);
  };
}
var _baseMatches = baseMatches;
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
var _baseHasIn = baseHasIn;
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = _toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_1(length) && _isIndex(key, length) && (isArray_1(object) || isArguments_1(object));
}
var _hasPath = hasPath;
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}
var hasIn_1 = hasIn;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get_1(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_1(object, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}
var _baseMatchesProperty = baseMatchesProperty;
function identity$1(value2) {
  return value2;
}
var identity_1 = identity$1;
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
var _baseProperty = baseProperty;
function basePropertyDeep(path) {
  return function(object) {
    return _baseGet(object, path);
  };
}
var _basePropertyDeep = basePropertyDeep;
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}
var property_1 = property;
function baseIteratee(value2) {
  if (typeof value2 == "function") {
    return value2;
  }
  if (value2 == null) {
    return identity_1;
  }
  if (typeof value2 == "object") {
    return isArray_1(value2) ? _baseMatchesProperty(value2[0], value2[1]) : _baseMatches(value2);
  }
  return property_1(value2);
}
var _baseIteratee = baseIteratee;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var nativeMax$1 = Math.max;
function overRest$1(func, start2, transform) {
  start2 = nativeMax$1(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax$1(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return _apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$1(value2) {
  return function() {
    return value2;
  };
}
var constant_1 = constant$1;
var baseSetToString$2 = !_defineProperty$1$1 ? identity_1 : function(func, string) {
  return _defineProperty$1$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_1(string),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$2;
var HOT_COUNT$1 = 800, HOT_SPAN$1 = 16;
var nativeNow$1 = Date.now;
function shortOut$1(func) {
  var count3 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow$1(), remaining = HOT_SPAN$1 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count3 >= HOT_COUNT$1) {
        return arguments[0];
      }
    } else {
      count3 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var setToString$2 = _shortOut(_baseSetToString);
var _setToString = setToString$2;
function baseRest$1(func, start2) {
  return _setToString(_overRest(func, start2, identity_1), func + "");
}
var _baseRest = baseRest$1;
function isIterateeCall$1(value2, index2, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike_1(object) && _isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq_1(object[index2], value2);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$1;
function nativeKeysIn$1(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn$1;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
function baseKeysIn$1(object) {
  if (!isObject_1(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$a.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn$1;
function keysIn$1(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}
var keysIn_1 = keysIn$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var defaults$7 = _baseRest(function(object, sources) {
  object = Object(object);
  var index2 = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index2 < length) {
    var source = sources[index2];
    var props2 = keysIn_1(source);
    var propsIndex = -1;
    var propsLength = props2.length;
    while (++propsIndex < propsLength) {
      var key = props2[propsIndex];
      var value2 = object[key];
      if (value2 === void 0 || eq_1(value2, objectProto$e[key]) && !hasOwnProperty$b.call(object, key)) {
        object[key] = source[key];
      }
    }
  }
  return object;
});
var defaults_1$1 = defaults$7;
function assignMergeValue$1(object, key, value2) {
  if (value2 !== void 0 && !eq_1(object[key], value2) || value2 === void 0 && !(key in object)) {
    _baseAssignValue(object, key, value2);
  }
}
var _assignMergeValue = assignMergeValue$1;
var _cloneBuffer = createCommonjsModule(function(module2, exports2) {
  var freeExports2 = exports2 && !exports2.nodeType && exports2;
  var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
  var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
  var Buffer2 = moduleExports2 ? _root.Buffer : void 0, allocUnsafe2 = Buffer2 ? Buffer2.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
});
function cloneArrayBuffer$1(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer$1;
function cloneTypedArray$1(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray$1;
function copyArray$1(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var _copyArray = copyArray$1;
var objectCreate$1 = Object.create;
var baseCreate$2 = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_1(proto)) {
      return {};
    }
    if (objectCreate$1) {
      return objectCreate$1(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate$2;
var getPrototype$2 = _overArg(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype$2;
function initCloneObject$1(object) {
  return typeof object.constructor == "function" && !_isPrototype(object) ? _baseCreate(_getPrototype(object)) : {};
}
var _initCloneObject = initCloneObject$1;
var objectTag$3 = "[object Object]";
var funcProto$2$1 = Function.prototype, objectProto$f = Object.prototype;
var funcToString$2$1 = funcProto$2$1.toString;
var hasOwnProperty$c = objectProto$f.hasOwnProperty;
var objectCtorString$1 = funcToString$2$1.call(Object);
function isPlainObject$3(value2) {
  if (!isObjectLike_1(value2) || _baseGetTag(value2) != objectTag$3) {
    return false;
  }
  var proto = _getPrototype(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$c.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString$2$1.call(Ctor) == objectCtorString$1;
}
var isPlainObject_1 = isPlainObject$3;
function safeGet$1(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var _safeGet = safeGet$1;
function copyObject$1(source, props2, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key = props2[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}
var _copyObject = copyObject$1;
function toPlainObject$1(value2) {
  return _copyObject(value2, keysIn_1(value2));
}
var toPlainObject_1 = toPlainObject$1;
function baseMergeDeep$1(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key), srcValue = _safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_1(srcValue), isBuff = !isArr && isBuffer_1(srcValue), isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_1(objValue)) {
        newValue = _copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
      newValue = objValue;
      if (isArguments_1(objValue)) {
        newValue = toPlainObject_1(objValue);
      } else if (!isObject_1(objValue) || isFunction_1(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}
var _baseMergeDeep = baseMergeDeep$1;
function baseMerge$1(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack());
    if (isObject_1(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge$1, customizer, stack);
    } else {
      var newValue = customizer ? customizer(_safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, keysIn_1);
}
var _baseMerge = baseMerge$1;
function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  if (isObject_1(objValue) && isObject_1(srcValue)) {
    stack.set(srcValue, objValue);
    _baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var _customDefaultsMerge = customDefaultsMerge;
function createAssigner$1(assigner) {
  return _baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var _createAssigner = createAssigner$1;
var mergeWith = _createAssigner(function(object, source, srcIndex, customizer) {
  _baseMerge(object, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;
var defaultsDeep = _baseRest(function(args) {
  args.push(void 0, _customDefaultsMerge);
  return _apply(mergeWith_1, void 0, args);
});
var defaultsDeep_1 = defaultsDeep;
function basePickBy(object, paths, predicate) {
  var index2 = -1, length = paths.length, result = {};
  while (++index2 < length) {
    var path = paths[index2], value2 = _baseGet(object, path);
    if (predicate(value2, path)) {
      _baseSet(result, _castPath(path, object), value2);
    }
  }
  return result;
}
var _basePickBy = basePickBy;
function basePick(object, paths) {
  return _basePickBy(object, paths, function(value2, path) {
    return hasIn_1(object, path);
  });
}
var _basePick = basePick;
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : void 0;
function isFlattenable(value2) {
  return isArray_1(value2) || isArguments_1(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
}
var _isFlattenable = isFlattenable;
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index2 = -1, length = array.length;
  predicate || (predicate = _isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value2 = array[index2];
    if (depth > 0 && predicate(value2)) {
      if (depth > 1) {
        baseFlatten(value2, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value2);
      }
    } else if (!isStrict) {
      result[result.length] = value2;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten;
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? _baseFlatten(array, 1) : [];
}
var flatten_1 = flatten;
function flatRest(func) {
  return _setToString(_overRest(func, void 0, flatten_1), func + "");
}
var _flatRest = flatRest;
var pick = _flatRest(function(object, paths) {
  return object == null ? {} : _basePick(object, paths);
});
var pick_1 = pick;
function arrayEach(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (iteratee(array[index2], index2, array) === false) {
      break;
    }
  }
  return array;
}
var _arrayEach = arrayEach;
function baseAssign(object, source) {
  return object && _copyObject(source, keys_1(source), object);
}
var _baseAssign = baseAssign;
function baseAssignIn(object, source) {
  return object && _copyObject(source, keysIn_1(source), object);
}
var _baseAssignIn = baseAssignIn;
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}
var _copySymbols = copySymbols;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn;
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}
var _copySymbolsIn = copySymbolsIn;
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty$d.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var _initCloneArray = initCloneArray;
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView;
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp;
var symbolProto$2 = _Symbol ? _Symbol.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol;
var boolTag$2$1 = "[object Boolean]", dateTag$3 = "[object Date]", mapTag$3 = "[object Map]", numberTag$2$1 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$2$1 = "[object String]", symbolTag$2 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$1$1 = "[object Float32Array]", float64Tag$1$1 = "[object Float64Array]", int8Tag$1$1 = "[object Int8Array]", int16Tag$1$1 = "[object Int16Array]", int32Tag$1$1 = "[object Int32Array]", uint8Tag$1$1 = "[object Uint8Array]", uint8ClampedTag$1$1 = "[object Uint8ClampedArray]", uint16Tag$1$1 = "[object Uint16Array]", uint32Tag$1$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$2:
      return _cloneArrayBuffer(object);
    case boolTag$2$1:
    case dateTag$3:
      return new Ctor(+object);
    case dataViewTag$3:
      return _cloneDataView(object, isDeep);
    case float32Tag$1$1:
    case float64Tag$1$1:
    case int8Tag$1$1:
    case int16Tag$1$1:
    case int32Tag$1$1:
    case uint8Tag$1$1:
    case uint8ClampedTag$1$1:
    case uint16Tag$1$1:
    case uint32Tag$1$1:
      return _cloneTypedArray(object, isDeep);
    case mapTag$3:
      return new Ctor();
    case numberTag$2$1:
    case stringTag$2$1:
      return new Ctor(object);
    case regexpTag$2:
      return _cloneRegExp(object);
    case setTag$3:
      return new Ctor();
    case symbolTag$2:
      return _cloneSymbol(object);
  }
}
var _initCloneByTag = initCloneByTag;
var mapTag$4 = "[object Map]";
function baseIsMap(value2) {
  return isObjectLike_1(value2) && _getTag(value2) == mapTag$4;
}
var _baseIsMap = baseIsMap;
var nodeIsMap = _nodeUtil && _nodeUtil.isMap;
var isMap$1 = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;
var isMap_1 = isMap$1;
var setTag$4 = "[object Set]";
function baseIsSet(value2) {
  return isObjectLike_1(value2) && _getTag(value2) == setTag$4;
}
var _baseIsSet = baseIsSet;
var nodeIsSet = _nodeUtil && _nodeUtil.isSet;
var isSet$1 = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;
var isSet_1 = isSet$1;
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
var argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$4 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2$1 = "[object Function]", genTag$1$1 = "[object GeneratorFunction]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$4 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", symbolTag$3 = "[object Symbol]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag$3] = cloneableTags[arrayTag$2] = cloneableTags[arrayBufferTag$3] = cloneableTags[dataViewTag$4] = cloneableTags[boolTag$3] = cloneableTags[dateTag$4] = cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] = cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] = cloneableTags[int32Tag$2] = cloneableTags[mapTag$5] = cloneableTags[numberTag$3] = cloneableTags[objectTag$4] = cloneableTags[regexpTag$3] = cloneableTags[setTag$5] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$3] = cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] = cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
cloneableTags[errorTag$2] = cloneableTags[funcTag$2$1] = cloneableTags[weakMapTag$2] = false;
function baseClone(value2, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value2, key, object, stack) : customizer(value2);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_1(value2)) {
    return value2;
  }
  var isArr = isArray_1(value2);
  if (isArr) {
    result = _initCloneArray(value2);
    if (!isDeep) {
      return _copyArray(value2, result);
    }
  } else {
    var tag = _getTag(value2), isFunc = tag == funcTag$2$1 || tag == genTag$1$1;
    if (isBuffer_1(value2)) {
      return _cloneBuffer(value2, isDeep);
    }
    if (tag == objectTag$4 || tag == argsTag$3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : _initCloneObject(value2);
      if (!isDeep) {
        return isFlat ? _copySymbolsIn(value2, _baseAssignIn(result, value2)) : _copySymbols(value2, _baseAssign(result, value2));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value2 : {};
      }
      result = _initCloneByTag(value2, tag, isDeep);
    }
  }
  stack || (stack = new _Stack());
  var stacked = stack.get(value2);
  if (stacked) {
    return stacked;
  }
  stack.set(value2, result);
  if (isSet_1(value2)) {
    value2.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
    });
  } else if (isMap_1(value2)) {
    value2.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn_1 : keys_1;
  var props2 = isArr ? void 0 : keysFunc(value2);
  _arrayEach(props2 || value2, function(subValue, key2) {
    if (props2) {
      key2 = subValue;
      subValue = value2[key2];
    }
    _assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
  });
  return result;
}
var _baseClone = baseClone;
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : void 0;
}
var last_1 = last;
function baseSlice(array, start2, end2) {
  var index2 = -1, length = array.length;
  if (start2 < 0) {
    start2 = -start2 > length ? 0 : length + start2;
  }
  end2 = end2 > length ? length : end2;
  if (end2 < 0) {
    end2 += length;
  }
  length = start2 > end2 ? 0 : end2 - start2 >>> 0;
  start2 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array[index2 + start2];
  }
  return result;
}
var _baseSlice = baseSlice;
function parent(object, path) {
  return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
}
var _parent = parent;
function baseUnset(object, path) {
  path = _castPath(path, object);
  object = _parent(object, path);
  return object == null || delete object[_toKey(last_1(path))];
}
var _baseUnset = baseUnset;
function customOmitClone(value2) {
  return isPlainObject_1(value2) ? void 0 : value2;
}
var _customOmitClone = customOmitClone;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var omit = _flatRest(function(object, paths) {
  var result = {};
  if (object == null) {
    return result;
  }
  var isDeep = false;
  paths = _arrayMap(paths, function(path) {
    path = _castPath(path, object);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  _copyObject(object, _getAllKeysIn(object), result);
  if (isDeep) {
    result = _baseClone(result, CLONE_DEEP_FLAG$1 | CLONE_FLAT_FLAG$1 | CLONE_SYMBOLS_FLAG$1, _customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    _baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var objectProto$h = Object.prototype;
var hasOwnProperty$e = objectProto$h.hasOwnProperty;
function baseHas(object, key) {
  return object != null && hasOwnProperty$e.call(object, key);
}
var _baseHas = baseHas;
function has$4(object, path) {
  return object != null && _hasPath(object, path, _baseHas);
}
var has_1 = has$4;
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach;
var baseEach = _createBaseEach(_baseForOwn);
var _baseEach = baseEach;
function baseSome(collection, predicate) {
  var result;
  _baseEach(collection, function(value2, index2, collection2) {
    result = predicate(value2, index2, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome;
function some(collection, predicate, guard) {
  var func = isArray_1(collection) ? _arraySome : _baseSome;
  if (guard && _isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, _baseIteratee(predicate));
}
var some_1 = some;
const getType = (value2) => Object.prototype.toString.call(value2).slice(8, -1);
const isDate$1$1 = (value2) => isDate_1(value2) && !isNaN(value2.getTime());
const isObject$1$1 = (value2) => getType(value2) === "Object";
const has$1$1 = has_1;
const hasAny = (obj, props2) => some_1(props2, (p2) => has_1(obj, p2));
const some$1 = some_1;
const pad$1 = (val, len, char = "0") => {
  val = val !== null && val !== void 0 ? String(val) : "";
  len = len || 2;
  while (val.length < len) {
    val = `${char}${val}`;
  }
  return val;
};
const mergeEvents = (...args) => {
  const result = {};
  args.forEach((e2) => Object.entries(e2).forEach(([key, value2]) => {
    if (!result[key]) {
      result[key] = value2;
    } else if (isArrayLikeObject_1(result[key])) {
      result[key].push(value2);
    } else {
      result[key] = [result[key], value2];
    }
  }));
  return result;
};
const pageIsValid = (page) => !!(page && page.month && page.year);
const pageIsBeforePage = (page, comparePage) => {
  if (!pageIsValid(page) || !pageIsValid(comparePage))
    return false;
  if (page.year === comparePage.year)
    return page.month < comparePage.month;
  return page.year < comparePage.year;
};
const pageIsAfterPage = (page, comparePage) => {
  if (!pageIsValid(page) || !pageIsValid(comparePage))
    return false;
  if (page.year === comparePage.year)
    return page.month > comparePage.month;
  return page.year > comparePage.year;
};
const pageIsBetweenPages = (page, fromPage2, toPage2) => (page || false) && !pageIsBeforePage(page, fromPage2) && !pageIsAfterPage(page, toPage2);
const pageIsEqualToPage = (aPage, bPage) => {
  if (!aPage && bPage)
    return false;
  if (aPage && !bPage)
    return false;
  if (!aPage && !bPage)
    return true;
  return aPage.month === bPage.month && aPage.year === bPage.year;
};
const addPages = ({ month: month2, year: year3 }, count3) => {
  const incr = count3 > 0 ? 1 : -1;
  for (let i2 = 0; i2 < Math.abs(count3); i2++) {
    month2 += incr;
    if (month2 > 12) {
      month2 = 1;
      year3++;
    } else if (month2 < 1) {
      month2 = 12;
      year3--;
    }
  }
  return {
    month: month2,
    year: year3
  };
};
const pageRangeToArray = (from, to2) => {
  if (!pageIsValid(from) || !pageIsValid(to2))
    return [];
  const result = [];
  while (!pageIsAfterPage(from, to2)) {
    result.push(from);
    from = addPages(from, 1);
  }
  return result;
};
function datesAreEqual(a3, b2) {
  const aIsDate = isDate$1$1(a3);
  const bIsDate = isDate$1$1(b2);
  if (!aIsDate && !bIsDate)
    return true;
  if (aIsDate !== bIsDate)
    return false;
  return a3.getTime() === b2.getTime();
}
const arrayHasItems = (array) => isArrayLikeObject_1(array) && array.length > 0;
const mixinOptionalProps = (source, target, props2) => {
  const assigned = [];
  props2.forEach((p2) => {
    const name2 = p2.name || p2.toString();
    const mixin = p2.mixin;
    const validate2 = p2.validate;
    if (Object.prototype.hasOwnProperty.call(source, name2)) {
      const value2 = validate2 ? validate2(source[name2]) : source[name2];
      target[name2] = mixin && isObject$1$1(value2) ? { ...mixin, ...value2 } : value2;
      assigned.push(name2);
    }
  });
  return {
    target,
    assigned: assigned.length ? assigned : null
  };
};
const on$2 = (element, event, handler2, opts2) => {
  if (element && event && handler2) {
    element.addEventListener(event, handler2, opts2);
  }
};
const off$1 = (element, event, handler2, opts2) => {
  if (element && event) {
    element.removeEventListener(event, handler2, opts2);
  }
};
const elementContains = (element, child) => !!element && !!child && (element === child || element.contains(child));
const onSpaceOrEnter = (event, handler2) => {
  if (event.key === " " || event.key === "Enter") {
    handler2(event);
    event.preventDefault();
  }
};
const createGuid = () => {
  function S4() {
    return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
  }
  return `${S4() + S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;
};
function hash$2(str) {
  let hashcode = 0;
  let i2 = 0;
  let chr;
  if (str.length === 0)
    return hashcode;
  for (i2 = 0; i2 < str.length; i2++) {
    chr = str.charCodeAt(i2);
    hashcode = (hashcode << 5) - hashcode + chr;
    hashcode |= 0;
  }
  return hashcode;
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date2;
  }
  date2.setDate(date2.getDate() + amount);
  return date2;
}
var numberTag$1 = "[object Number]";
function isNumber$3(value2) {
  return typeof value2 == "number" || isObjectLike_1(value2) && _baseGetTag(value2) == numberTag$1;
}
var isNumber_1 = isNumber$3;
var stringTag$1 = "[object String]";
function isString$4(value2) {
  return typeof value2 == "string" || !isArray_1(value2) && isObjectLike_1(value2) && _baseGetTag(value2) == stringTag$1;
}
var isString_1 = isString$4;
function isUndefined$2(value2) {
  return value2 === void 0;
}
var isUndefined_1 = isUndefined$2;
function baseClamp(number, lower, upper) {
  if (number === number) {
    if (upper !== void 0) {
      number = number <= upper ? number : upper;
    }
    if (lower !== void 0) {
      number = number >= lower ? number : lower;
    }
  }
  return number;
}
var _baseClamp = baseClamp;
var NAN = 0 / 0;
var reTrim = /^\s+|\s+$/g;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value2) {
  if (typeof value2 == "number") {
    return value2;
  }
  if (isSymbol_1(value2)) {
    return NAN;
  }
  if (isObject_1(value2)) {
    var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
    value2 = isObject_1(other) ? other + "" : other;
  }
  if (typeof value2 != "string") {
    return value2 === 0 ? value2 : +value2;
  }
  value2 = value2.replace(reTrim, "");
  var isBinary = reIsBinary.test(value2);
  return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
}
var toNumber_1 = toNumber$1;
function clamp$1(number, lower, upper) {
  if (upper === void 0) {
    upper = lower;
    lower = void 0;
  }
  if (upper !== void 0) {
    upper = toNumber_1(upper);
    upper = upper === upper ? upper : 0;
  }
  if (lower !== void 0) {
    lower = toNumber_1(lower);
    lower = lower === lower ? lower : 0;
  }
  return _baseClamp(toNumber_1(number), lower, upper);
}
var clamp_1 = clamp$1;
function set$1(object, path, value2) {
  return object == null ? object : _baseSet(object, path, value2);
}
var set_1 = set$1;
function mapValues(object, iteratee) {
  var result = {};
  iteratee = _baseIteratee(iteratee);
  _baseForOwn(object, function(value2, key, object2) {
    _baseAssignValue(result, key, iteratee(value2, key, object2));
  });
  return result;
}
var mapValues_1 = mapValues;
function baseToPairs(object, props2) {
  return _arrayMap(props2, function(key) {
    return [key, object[key]];
  });
}
var _baseToPairs = baseToPairs;
function setToPairs(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value2) {
    result[++index2] = [value2, value2];
  });
  return result;
}
var _setToPairs = setToPairs;
var mapTag$1 = "[object Map]", setTag$1 = "[object Set]";
function createToPairs(keysFunc) {
  return function(object) {
    var tag = _getTag(object);
    if (tag == mapTag$1) {
      return _mapToArray(object);
    }
    if (tag == setTag$1) {
      return _setToPairs(object);
    }
    return _baseToPairs(object, keysFunc(object));
  };
}
var _createToPairs = createToPairs;
var toPairs = _createToPairs(keys_1);
var toPairs_1 = toPairs;
var childMixin = {
  inject: ["sharedState"],
  computed: {
    masks: function masks() {
      return this.sharedState.masks;
    },
    theme: function theme() {
      return this.sharedState.theme;
    },
    locale: function locale() {
      return this.sharedState.locale;
    },
    dayPopoverId: function dayPopoverId() {
      return this.sharedState.dayPopoverId;
    }
  },
  methods: {
    format: function format(date2, mask) {
      return this.locale.format(date2, mask);
    },
    pageForDate: function pageForDate(date2) {
      return this.locale.getDateParts(this.locale.normalizeDate(date2));
    }
  }
};
var targetProps = ["base", "start", "end", "startEnd"];
var displayProps = ["class", "contentClass", "style", "contentStyle", "color", "fillMode"];
var defConfig = {
  color: "blue",
  isDark: false,
  highlight: {
    base: {
      fillMode: "light"
    },
    start: {
      fillMode: "solid"
    },
    end: {
      fillMode: "solid"
    }
  },
  dot: {
    base: {
      fillMode: "solid"
    },
    start: {
      fillMode: "solid"
    },
    end: {
      fillMode: "solid"
    }
  },
  bar: {
    base: {
      fillMode: "solid"
    },
    start: {
      fillMode: "solid"
    },
    end: {
      fillMode: "solid"
    }
  },
  content: {
    base: {},
    start: {},
    end: {}
  }
};
var Theme = /* @__PURE__ */ function() {
  function Theme2(config) {
    _classCallCheck(this, Theme2);
    Object.assign(this, defConfig, config);
  }
  _createClass(Theme2, [{
    key: "normalizeAttr",
    value: function normalizeAttr(_ref) {
      var config = _ref.config, type = _ref.type;
      var rootColor = this.color;
      var root2 = {};
      var normAttr = this[type];
      if (config === true || isString_1(config)) {
        rootColor = isString_1(config) ? config : rootColor;
        root2 = _objectSpread2$1({}, normAttr);
      } else if (isObject$1$1(config)) {
        if (hasAny(config, targetProps)) {
          root2 = _objectSpread2$1({}, config);
        } else {
          root2 = {
            base: _objectSpread2$1({}, config),
            start: _objectSpread2$1({}, config),
            end: _objectSpread2$1({}, config)
          };
        }
      } else {
        return null;
      }
      defaults_1$1(root2, {
        start: root2.startEnd,
        end: root2.startEnd
      }, normAttr);
      toPairs_1(root2).forEach(function(_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2), targetType = _ref3[0], targetConfig = _ref3[1];
        var targetColor = rootColor;
        if (targetConfig === true || isString_1(targetConfig)) {
          targetColor = isString_1(targetConfig) ? targetConfig : targetColor;
          root2[targetType] = {
            color: targetColor
          };
        } else if (isObject$1$1(targetConfig)) {
          if (hasAny(targetConfig, displayProps)) {
            root2[targetType] = _objectSpread2$1({}, targetConfig);
          } else {
            root2[targetType] = {};
          }
        }
        if (!has$1$1(root2, "".concat(targetType, ".color"))) {
          set_1(root2, "".concat(targetType, ".color"), targetColor);
        }
      });
      return root2;
    }
  }, {
    key: "normalizeHighlight",
    value: function normalizeHighlight(config) {
      var _this = this;
      var highlight = this.normalizeAttr({
        config,
        type: "highlight"
      });
      toPairs_1(highlight).forEach(function(_ref4) {
        var _ref5 = _slicedToArray(_ref4, 2);
        _ref5[0];
        var targetConfig = _ref5[1];
        var c2 = defaults_1$1(targetConfig, {
          isDark: _this.isDark,
          color: _this.color
        });
        targetConfig.style = _objectSpread2$1(_objectSpread2$1({}, _this.getHighlightBgStyle(c2)), targetConfig.style);
        targetConfig.contentStyle = _objectSpread2$1(_objectSpread2$1({}, _this.getHighlightContentStyle(c2)), targetConfig.contentStyle);
      });
      return highlight;
    }
  }, {
    key: "getHighlightBgStyle",
    value: function getHighlightBgStyle(_ref6) {
      var fillMode = _ref6.fillMode, color = _ref6.color, isDark = _ref6.isDark;
      switch (fillMode) {
        case "outline":
        case "none":
          return {
            backgroundColor: isDark ? "var(--gray-900)" : "var(--white)",
            border: "2px solid",
            borderColor: isDark ? "var(--".concat(color, "-200)") : "var(--".concat(color, "-700)"),
            borderRadius: "var(--rounded-full)"
          };
        case "light":
          return {
            backgroundColor: isDark ? "var(--".concat(color, "-800)") : "var(--".concat(color, "-200)"),
            opacity: isDark ? 0.75 : 1,
            borderRadius: "var(--rounded-full)"
          };
        case "solid":
          return {
            backgroundColor: isDark ? "var(--".concat(color, "-500)") : "var(--".concat(color, "-600)"),
            borderRadius: "var(--rounded-full)"
          };
        default:
          return {
            borderRadius: "var(--rounded-full)"
          };
      }
    }
  }, {
    key: "getHighlightContentStyle",
    value: function getHighlightContentStyle(_ref7) {
      var fillMode = _ref7.fillMode, color = _ref7.color, isDark = _ref7.isDark;
      switch (fillMode) {
        case "outline":
        case "none":
          return {
            fontWeight: "var(--font-bold)",
            color: isDark ? "var(--".concat(color, "-100)") : "var(--".concat(color, "-900)")
          };
        case "light":
          return {
            fontWeight: "var(--font-bold)",
            color: isDark ? "var(--".concat(color, "-100)") : "var(--".concat(color, "-900)")
          };
        case "solid":
          return {
            fontWeight: "var(--font-bold)",
            color: "var(--white)"
          };
        default:
          return "";
      }
    }
  }, {
    key: "bgAccentHigh",
    value: function bgAccentHigh(_ref8) {
      var color = _ref8.color, isDark = _ref8.isDark;
      return {
        backgroundColor: isDark ? "var(--".concat(color, "-500)") : "var(--".concat(color, "-600)")
      };
    }
  }, {
    key: "contentAccent",
    value: function contentAccent(_ref9) {
      var color = _ref9.color, isDark = _ref9.isDark;
      if (!color)
        return null;
      return {
        fontWeight: "var(--font-bold)",
        color: isDark ? "var(--".concat(color, "-100)") : "var(--".concat(color, "-900)")
      };
    }
  }, {
    key: "normalizeDot",
    value: function normalizeDot(config) {
      return this.normalizeNonHighlight("dot", config, this.bgAccentHigh);
    }
  }, {
    key: "normalizeBar",
    value: function normalizeBar(config) {
      return this.normalizeNonHighlight("bar", config, this.bgAccentHigh);
    }
  }, {
    key: "normalizeContent",
    value: function normalizeContent(config) {
      return this.normalizeNonHighlight("content", config, this.contentAccent);
    }
  }, {
    key: "normalizeNonHighlight",
    value: function normalizeNonHighlight(type, config, styleFn) {
      var _this2 = this;
      var attr = this.normalizeAttr({
        type,
        config
      });
      toPairs_1(attr).forEach(function(_ref10) {
        var _ref11 = _slicedToArray(_ref10, 2);
        _ref11[0];
        var targetConfig = _ref11[1];
        defaults_1$1(targetConfig, {
          isDark: _this2.isDark,
          color: _this2.color
        });
        targetConfig.style = _objectSpread2$1(_objectSpread2$1({}, styleFn(targetConfig)), targetConfig.style);
      });
      return attr;
    }
  }]);
  return Theme2;
}();
var MILLISECONDS_IN_MINUTE = 6e4;
function getDateMillisecondsPart(date2) {
  return date2.getTime() % MILLISECONDS_IN_MINUTE;
}
function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date2 = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = Math.ceil(date2.getTimezoneOffset());
  date2.setSeconds(0, 0);
  var hasNegativeUTCOffset = baseTimezoneOffset > 0;
  var millisecondsPartOfTimezoneOffset = hasNegativeUTCOffset ? (MILLISECONDS_IN_MINUTE + getDateMillisecondsPart(date2)) % MILLISECONDS_IN_MINUTE : getDateMillisecondsPart(date2);
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
}
function tzTokenizeDate(date2, timeZone) {
  var dtf = getDateTimeFormat(timeZone);
  return dtf.formatToParts ? partsOffset(dtf, date2) : hackyOffset(dtf, date2);
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date2) {
  var formatted = dtf.formatToParts(date2);
  var filled = [];
  for (var i2 = 0; i2 < formatted.length; i2++) {
    var pos = typeToPos[formatted[i2].type];
    if (pos >= 0) {
      filled[pos] = parseInt(formatted[i2].value, 10);
    }
  }
  return filled;
}
function hackyOffset(dtf, date2) {
  var formatted = dtf.format(date2).replace(/\u200E/g, "");
  var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]];
}
var dtfCache = {};
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    var testDateFormatted = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: "America/New_York",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(new Date("2014-06-25T04:00:00.123Z"));
    var hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE$1 = 6e4;
var patterns = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-])(\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/,
  timezoneIANA: /(UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
};
function tzParseTimezone(timezoneString, date2) {
  var token2;
  var absoluteOffset;
  token2 = patterns.timezoneZ.exec(timezoneString);
  if (token2) {
    return 0;
  }
  var hours2;
  token2 = patterns.timezoneHH.exec(timezoneString);
  if (token2) {
    hours2 = parseInt(token2[2], 10);
    if (!validateTimezone()) {
      return NaN;
    }
    absoluteOffset = hours2 * MILLISECONDS_IN_HOUR;
    return token2[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  token2 = patterns.timezoneHHMM.exec(timezoneString);
  if (token2) {
    hours2 = parseInt(token2[2], 10);
    var minutes2 = parseInt(token2[3], 10);
    if (!validateTimezone(hours2, minutes2)) {
      return NaN;
    }
    absoluteOffset = hours2 * MILLISECONDS_IN_HOUR + minutes2 * MILLISECONDS_IN_MINUTE$1;
    return token2[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  token2 = patterns.timezoneIANA.exec(timezoneString);
  if (token2) {
    var tokens = tzTokenizeDate(date2, timezoneString);
    var asUTC = Date.UTC(
      tokens[0],
      tokens[1] - 1,
      tokens[2],
      tokens[3],
      tokens[4],
      tokens[5]
    );
    var timestampWithMsZeroed = date2.getTime() - date2.getTime() % 1e3;
    return -(asUTC - timestampWithMsZeroed);
  }
  return 0;
}
function validateTimezone(hours2, minutes2) {
  if (minutes2 != null && (minutes2 < 0 || minutes2 > 59)) {
    return false;
  }
  return true;
}
var MILLISECONDS_IN_HOUR$1 = 36e5;
var MILLISECONDS_IN_MINUTE$2 = 6e4;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns$1 = {
  dateTimeDelimeter: /[T ]/,
  plainTime: /:/,
  timeZoneDelimeter: /[Z ]/i,
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    /^([+-]\d{3})$/,
    /^([+-]\d{4})$/
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    /^([+-]\d{5})/,
    /^([+-]\d{6})/
  ],
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  timezone: /([Z+-].*| UTC|(?:[a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?))$/
};
function toDate$1(argument, dirtyOptions) {
  if (arguments.length < 1) {
    throw new TypeError(
      "1 argument required, but only " + arguments.length + " present"
    );
  }
  if (argument === null) {
    return new Date(NaN);
  }
  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : toInteger(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year3 = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date2 = parseDate(restDateString, year3);
  if (isNaN(date2)) {
    return new Date(NaN);
  }
  if (date2) {
    var timestamp = date2.getTime();
    var time = 0;
    var offset2;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return new Date(NaN);
      }
    }
    if (dateStrings.timezone || options.timeZone) {
      offset2 = tzParseTimezone(
        dateStrings.timezone || options.timeZone,
        new Date(timestamp + time)
      );
      if (isNaN(offset2)) {
        return new Date(NaN);
      }
      offset2 = tzParseTimezone(
        dateStrings.timezone || options.timeZone,
        new Date(timestamp + time + offset2)
      );
      if (isNaN(offset2)) {
        return new Date(NaN);
      }
    } else {
      offset2 = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
      offset2 = getTimezoneOffsetInMilliseconds(
        new Date(timestamp + time + offset2)
      );
    }
    return new Date(timestamp + time + offset2);
  } else {
    return new Date(NaN);
  }
}
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns$1.dateTimeDelimeter);
  var timeString;
  if (patterns$1.plainTime.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    dateStrings.timezone = array[2];
    if (patterns$1.timeZoneDelimeter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns$1.timeZoneDelimeter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token2 = patterns$1.timezone.exec(timeString);
    if (token2) {
      dateStrings.time = timeString.replace(token2[1], "");
      dateStrings.timezone = token2[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var patternYYY = patterns$1.YYY[additionalDigits];
  var patternYYYYY = patterns$1.YYYYY[additionalDigits];
  var token2;
  token2 = patterns$1.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
  if (token2) {
    var yearString = token2[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  }
  token2 = patterns$1.YY.exec(dateString) || patternYYY.exec(dateString);
  if (token2) {
    var centuryString = token2[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  }
  return {
    year: null
  };
}
function parseDate(dateString, year3) {
  if (year3 === null) {
    return null;
  }
  var token2;
  var date2;
  var month2;
  var week;
  if (dateString.length === 0) {
    date2 = new Date(0);
    date2.setUTCFullYear(year3);
    return date2;
  }
  token2 = patterns$1.MM.exec(dateString);
  if (token2) {
    date2 = new Date(0);
    month2 = parseInt(token2[1], 10) - 1;
    if (!validateDate(year3, month2)) {
      return new Date(NaN);
    }
    date2.setUTCFullYear(year3, month2);
    return date2;
  }
  token2 = patterns$1.DDD.exec(dateString);
  if (token2) {
    date2 = new Date(0);
    var dayOfYear = parseInt(token2[1], 10);
    if (!validateDayOfYearDate(year3, dayOfYear)) {
      return new Date(NaN);
    }
    date2.setUTCFullYear(year3, 0, dayOfYear);
    return date2;
  }
  token2 = patterns$1.MMDD.exec(dateString);
  if (token2) {
    date2 = new Date(0);
    month2 = parseInt(token2[1], 10) - 1;
    var day = parseInt(token2[2], 10);
    if (!validateDate(year3, month2, day)) {
      return new Date(NaN);
    }
    date2.setUTCFullYear(year3, month2, day);
    return date2;
  }
  token2 = patterns$1.Www.exec(dateString);
  if (token2) {
    week = parseInt(token2[1], 10) - 1;
    if (!validateWeekDate(year3, week)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year3, week);
  }
  token2 = patterns$1.WwwD.exec(dateString);
  if (token2) {
    week = parseInt(token2[1], 10) - 1;
    var dayOfWeek = parseInt(token2[2], 10) - 1;
    if (!validateWeekDate(year3, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year3, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  var token2;
  var hours2;
  var minutes2;
  token2 = patterns$1.HH.exec(timeString);
  if (token2) {
    hours2 = parseFloat(token2[1].replace(",", "."));
    if (!validateTime(hours2)) {
      return NaN;
    }
    return hours2 % 24 * MILLISECONDS_IN_HOUR$1;
  }
  token2 = patterns$1.HHMM.exec(timeString);
  if (token2) {
    hours2 = parseInt(token2[1], 10);
    minutes2 = parseFloat(token2[2].replace(",", "."));
    if (!validateTime(hours2, minutes2)) {
      return NaN;
    }
    return hours2 % 24 * MILLISECONDS_IN_HOUR$1 + minutes2 * MILLISECONDS_IN_MINUTE$2;
  }
  token2 = patterns$1.HHMMSS.exec(timeString);
  if (token2) {
    hours2 = parseInt(token2[1], 10);
    minutes2 = parseInt(token2[2], 10);
    var seconds = parseFloat(token2[3].replace(",", "."));
    if (!validateTime(hours2, minutes2, seconds)) {
      return NaN;
    }
    return hours2 % 24 * MILLISECONDS_IN_HOUR$1 + minutes2 * MILLISECONDS_IN_MINUTE$2 + seconds * 1e3;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date2 = new Date(0);
  date2.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date2.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date2.setUTCDate(date2.getUTCDate() + diff);
  return date2;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year3) {
  return year3 % 400 === 0 || year3 % 4 === 0 && year3 % 100 !== 0;
}
function validateDate(year3, month2, date2) {
  if (month2 < 0 || month2 > 11) {
    return false;
  }
  if (date2 != null) {
    if (date2 < 1) {
      return false;
    }
    var isLeapYear = isLeapYearIndex(year3);
    if (isLeapYear && date2 > DAYS_IN_MONTH_LEAP_YEAR[month2]) {
      return false;
    }
    if (!isLeapYear && date2 > DAYS_IN_MONTH[month2]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year3, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  var isLeapYear = isLeapYearIndex(year3);
  if (isLeapYear && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(year3, week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours2, minutes2, seconds) {
  if (hours2 != null && (hours2 < 0 || hours2 >= 25)) {
    return false;
  }
  if (minutes2 != null && (minutes2 < 0 || minutes2 >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}
function startOfWeek(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeWeekStartsOn = locale2 && locale2.options && locale2.options.weekStartsOn;
  var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
  var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date2 = toDate(dirtyDate);
  var day = date2.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date2.setDate(date2.getDate() - diff);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year3 = date2.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year3 + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year3, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year3 + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year3;
  } else {
    return year3 - 1;
  }
}
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year3 = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year3, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date2 = startOfISOWeek(fourthOfJanuary);
  return date2;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff = startOfISOWeek(date2).getTime() - startOfISOWeekYear(date2).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function getWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var year3 = date2.getFullYear();
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year3 + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, dirtyOptions);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year3, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, dirtyOptions);
  if (date2.getTime() >= startOfNextYear.getTime()) {
    return year3 + 1;
  } else if (date2.getTime() >= startOfThisYear.getTime()) {
    return year3;
  } else {
    return year3 - 1;
  }
}
function startOfWeekYear(dirtyDate, dirtyOptions) {
  requiredArgs(1, arguments);
  var options = dirtyOptions || {};
  var locale2 = options.locale;
  var localeFirstWeekContainsDate = locale2 && locale2.options && locale2.options.firstWeekContainsDate;
  var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
  var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
  var year3 = getWeekYear(dirtyDate, dirtyOptions);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year3, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date2 = startOfWeek(firstWeek, dirtyOptions);
  return date2;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var diff = startOfWeek(date2, options).getTime() - startOfWeekYear(date2, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
var MILLISECONDS_IN_WEEK$2 = 6048e5;
function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, dirtyOptions) {
  requiredArgs(2, arguments);
  var startOfWeekLeft = startOfWeek(dirtyDateLeft, dirtyOptions);
  var startOfWeekRight = startOfWeek(dirtyDateRight, dirtyOptions);
  var timestampLeft = startOfWeekLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekLeft);
  var timestampRight = startOfWeekRight.getTime() - getTimezoneOffsetInMilliseconds(startOfWeekRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK$2);
}
function lastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  var month2 = date2.getMonth();
  date2.setFullYear(date2.getFullYear(), month2 + 1, 0);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date2 = toDate(dirtyDate);
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
  return date2;
}
function getWeeksInMonth(date2, options) {
  requiredArgs(1, arguments);
  return differenceInCalendarWeeks(lastDayOfMonth(date2), startOfMonth(date2), options) + 1;
}
var millisecondsPerDay = 24 * 60 * 60 * 1e3;
var DateInfo = /* @__PURE__ */ function() {
  function DateInfo2(config) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$order = _ref.order, order2 = _ref$order === void 0 ? 0 : _ref$order, locale2 = _ref.locale, isFullDay = _ref.isFullDay;
    _classCallCheck(this, DateInfo2);
    this.isDateInfo = true;
    this.order = order2;
    this.locale = locale2 instanceof Locale ? locale2 : new Locale(locale2);
    this.firstDayOfWeek = this.locale.firstDayOfWeek;
    if (!isObject$1$1(config)) {
      var date2 = this.locale.normalizeDate(config);
      if (isFullDay) {
        config = {
          start: date2,
          end: date2
        };
      } else {
        config = {
          startOn: date2,
          endOn: date2
        };
      }
    }
    var start2 = null;
    var end2 = null;
    if (config.start) {
      start2 = this.locale.normalizeDate(config.start, _objectSpread2$1(_objectSpread2$1({}, this.opts), {}, {
        time: "00:00:00"
      }));
    } else if (config.startOn) {
      start2 = this.locale.normalizeDate(config.startOn, this.opts);
    }
    if (config.end) {
      end2 = this.locale.normalizeDate(config.end, _objectSpread2$1(_objectSpread2$1({}, this.opts), {}, {
        time: "23:59:59"
      }));
    } else if (config.endOn) {
      end2 = this.locale.normalizeDate(config.endOn, this.opts);
    }
    if (start2 && end2 && start2 > end2) {
      var temp = start2;
      start2 = end2;
      end2 = temp;
    } else if (start2 && config.span >= 1) {
      end2 = addDays(start2, config.span - 1);
    }
    this.start = start2;
    this.startTime = start2 ? start2.getTime() : NaN;
    this.end = end2;
    this.endTime = end2 ? end2.getTime() : NaN;
    this.isDate = this.startTime && this.startTime === this.endTime;
    this.isRange = !this.isDate;
    var andOpt = mixinOptionalProps(config, {}, DateInfo2.patternProps);
    if (andOpt.assigned) {
      this.on = {
        and: andOpt.target
      };
    }
    if (config.on) {
      var or2 = (isArrayLikeObject_1(config.on) ? config.on : [config.on]).map(function(o2) {
        if (isFunction_1(o2))
          return o2;
        var opt = mixinOptionalProps(o2, {}, DateInfo2.patternProps);
        return opt.assigned ? opt.target : null;
      }).filter(function(o2) {
        return o2;
      });
      if (or2.length)
        this.on = _objectSpread2$1(_objectSpread2$1({}, this.on), {}, {
          or: or2
        });
    }
    this.isComplex = !!this.on;
  }
  _createClass(DateInfo2, [{
    key: "toDateInfo",
    value: function toDateInfo(date2) {
      return date2.isDateInfo ? date2 : new DateInfo2(date2, this.opts);
    }
  }, {
    key: "startOfWeek",
    value: function startOfWeek2(date2) {
      var day = date2.getDay() + 1;
      var daysToAdd = day >= this.firstDayOfWeek ? this.firstDayOfWeek - day : -(7 - (this.firstDayOfWeek - day));
      return addDays(date2, daysToAdd);
    }
  }, {
    key: "diffInDays",
    value: function diffInDays(d1, d22) {
      return Math.round((d22 - d1) / millisecondsPerDay);
    }
  }, {
    key: "diffInWeeks",
    value: function diffInWeeks(d1, d22) {
      return this.diffInDays(this.startOfWeek(d1), this.startOfWeek(d22));
    }
  }, {
    key: "diffInYears",
    value: function diffInYears(d1, d22) {
      return d22.getUTCFullYear() - d1.getUTCFullYear();
    }
  }, {
    key: "diffInMonths",
    value: function diffInMonths(d1, d22) {
      return this.diffInYears(d1, d22) * 12 + (d22.getMonth() - d1.getMonth());
    }
  }, {
    key: "iterateDatesInRange",
    value: function iterateDatesInRange(_ref2, fn3) {
      var start2 = _ref2.start, end2 = _ref2.end;
      if (!start2 || !end2 || !isFunction_1(fn3))
        return null;
      start2 = this.locale.normalizeDate(start2, _objectSpread2$1(_objectSpread2$1({}, this.opts), {}, {
        time: "00:00:00"
      }));
      var state2 = {
        i: 0,
        date: start2,
        day: this.locale.getDateParts(start2),
        finished: false
      };
      var result = null;
      for (; !state2.finished && state2.date <= end2; state2.i++) {
        result = fn3(state2);
        state2.date = addDays(state2.date, 1);
        state2.day = this.locale.getDateParts(state2.date);
      }
      return result;
    }
  }, {
    key: "shallowIntersectingRange",
    value: function shallowIntersectingRange(other) {
      return this.rangeShallowIntersectingRange(this, this.toDateInfo(other));
    }
  }, {
    key: "rangeShallowIntersectingRange",
    value: function rangeShallowIntersectingRange(date1, date2) {
      if (!this.dateShallowIntersectsDate(date1, date2)) {
        return null;
      }
      var thisRange = date1.toRange();
      var otherRange = date2.toRange();
      var start2 = null;
      var end2 = null;
      if (thisRange.start) {
        if (!otherRange.start) {
          start2 = thisRange.start;
        } else {
          start2 = thisRange.start > otherRange.start ? thisRange.start : otherRange.start;
        }
      } else if (otherRange.start) {
        start2 = otherRange.start;
      }
      if (thisRange.end) {
        if (!otherRange.end) {
          end2 = thisRange.end;
        } else {
          end2 = thisRange.end < otherRange.end ? thisRange.end : otherRange.end;
        }
      } else if (otherRange.end) {
        end2 = otherRange.end;
      }
      return {
        start: start2,
        end: end2
      };
    }
  }, {
    key: "intersectsDate",
    value: function intersectsDate(other) {
      var _this = this;
      var date2 = this.toDateInfo(other);
      if (!this.shallowIntersectsDate(date2))
        return null;
      if (!this.on)
        return this;
      var range = this.rangeShallowIntersectingRange(this, date2);
      var result = false;
      this.iterateDatesInRange(range, function(state2) {
        if (_this.matchesDay(state2.day)) {
          result = result || date2.matchesDay(state2.day);
          state2.finished = result;
        }
      });
      return result;
    }
  }, {
    key: "shallowIntersectsDate",
    value: function shallowIntersectsDate(other) {
      return this.dateShallowIntersectsDate(this, this.toDateInfo(other));
    }
  }, {
    key: "dateShallowIntersectsDate",
    value: function dateShallowIntersectsDate(date1, date2) {
      if (date1.isDate) {
        return date2.isDate ? date1.startTime === date2.startTime : this.dateShallowIncludesDate(date2, date1);
      }
      if (date2.isDate) {
        return this.dateShallowIncludesDate(date1, date2);
      }
      if (date1.start && date2.end && date1.start > date2.end) {
        return false;
      }
      if (date1.end && date2.start && date1.end < date2.start) {
        return false;
      }
      return true;
    }
  }, {
    key: "includesDate",
    value: function includesDate(other) {
      var _this2 = this;
      var date2 = this.toDateInfo(other);
      if (!this.shallowIncludesDate(date2)) {
        return false;
      }
      if (!this.on) {
        return true;
      }
      var range = this.rangeShallowIntersectingRange(this, date2);
      var result = true;
      this.iterateDatesInRange(range, function(state2) {
        if (_this2.matchesDay(state2.day)) {
          result = result && date2.matchesDay(state2.day);
          state2.finished = !result;
        }
      });
      return result;
    }
  }, {
    key: "shallowIncludesDate",
    value: function shallowIncludesDate(other) {
      return this.dateShallowIncludesDate(this, other.isDate ? other : new DateInfo2(other, this.opts));
    }
  }, {
    key: "dateShallowIncludesDate",
    value: function dateShallowIncludesDate(date1, date2) {
      if (date1.isDate) {
        if (date2.isDate) {
          return date1.startTime === date2.startTime;
        }
        if (!date2.startTime || !date2.endTime) {
          return false;
        }
        return date1.startTime === date2.startTime && date1.startTime === date2.endTime;
      }
      if (date2.isDate) {
        if (date1.start && date2.start < date1.start) {
          return false;
        }
        if (date1.end && date2.start > date1.end) {
          return false;
        }
        return true;
      }
      if (date1.start && (!date2.start || date2.start < date1.start)) {
        return false;
      }
      if (date1.end && (!date2.end || date2.end > date1.end)) {
        return false;
      }
      return true;
    }
  }, {
    key: "intersectsDay",
    value: function intersectsDay(day) {
      if (!this.shallowIntersectsDate(day.range))
        return null;
      return this.matchesDay(day) ? this : null;
    }
  }, {
    key: "matchesDay",
    value: function matchesDay(day) {
      var _this3 = this;
      if (!this.on)
        return true;
      if (this.on.and && !DateInfo2.testConfig(this.on.and, day, this)) {
        return false;
      }
      if (this.on.or && !this.on.or.some(function(or2) {
        return DateInfo2.testConfig(or2, day, _this3);
      })) {
        return false;
      }
      return true;
    }
  }, {
    key: "toRange",
    value: function toRange() {
      return new DateInfo2({
        start: this.start,
        end: this.end
      }, this.opts);
    }
  }, {
    key: "compare",
    value: function compare(other) {
      if (this.order !== other.order)
        return this.order - other.order;
      if (this.isDate !== other.isDate)
        return this.isDate ? 1 : -1;
      if (this.isDate)
        return 0;
      var diff = this.start - other.start;
      return diff !== 0 ? diff : this.end - other.end;
    }
  }, {
    key: "opts",
    get: function get3() {
      return {
        order: this.order,
        locale: this.locale
      };
    }
  }], [{
    key: "testConfig",
    value: function testConfig(config, day, dateInfo) {
      if (isFunction_1(config))
        return config(day);
      if (isObject$1$1(config)) {
        return Object.keys(config).every(function(k2) {
          return DateInfo2.patterns[k2].test(day, config[k2], dateInfo);
        });
      }
      return null;
    }
  }, {
    key: "patterns",
    get: function get3() {
      return {
        dailyInterval: {
          test: function test(day, interval, di) {
            return di.diffInDays(di.start || new Date(), day.date) % interval === 0;
          }
        },
        weeklyInterval: {
          test: function test(day, interval, di) {
            return di.diffInWeeks(di.start || new Date(), day.date) % interval === 0;
          }
        },
        monthlyInterval: {
          test: function test(day, interval, di) {
            return di.diffInMonths(di.start || new Date(), day.date) % interval === 0;
          }
        },
        yearlyInterval: {
          test: function test() {
            return function(day, interval, di) {
              return di.diffInYears(di.start || new Date(), day.date) % interval === 0;
            };
          }
        },
        days: {
          validate: function validate2(days) {
            return isArrayLikeObject_1(days) ? days : [parseInt(days, 10)];
          },
          test: function test(day, days) {
            return days.includes(day.day) || days.includes(-day.dayFromEnd);
          }
        },
        weekdays: {
          validate: function validate2(weekdays2) {
            return isArrayLikeObject_1(weekdays2) ? weekdays2 : [parseInt(weekdays2, 10)];
          },
          test: function test(day, weekdays2) {
            return weekdays2.includes(day.weekday);
          }
        },
        ordinalWeekdays: {
          validate: function validate2(ordinalWeekdays) {
            return Object.keys(ordinalWeekdays).reduce(function(obj, ck) {
              var weekdays2 = ordinalWeekdays[ck];
              if (!weekdays2)
                return obj;
              obj[ck] = isArrayLikeObject_1(weekdays2) ? weekdays2 : [parseInt(weekdays2, 10)];
              return obj;
            }, {});
          },
          test: function test(day, ordinalWeekdays) {
            return Object.keys(ordinalWeekdays).map(function(k2) {
              return parseInt(k2, 10);
            }).find(function(k2) {
              return ordinalWeekdays[k2].includes(day.weekday) && (k2 === day.weekdayOrdinal || k2 === -day.weekdayOrdinalFromEnd);
            });
          }
        },
        weekends: {
          validate: function validate2(config) {
            return config;
          },
          test: function test(day) {
            return day.weekday === 1 || day.weekday === 7;
          }
        },
        workweek: {
          validate: function validate2(config) {
            return config;
          },
          test: function test(day) {
            return day.weekday >= 2 && day.weekday <= 6;
          }
        },
        weeks: {
          validate: function validate2(weeks) {
            return isArrayLikeObject_1(weeks) ? weeks : [parseInt(weeks, 10)];
          },
          test: function test(day, weeks) {
            return weeks.includes(day.week) || weeks.includes(-day.weekFromEnd);
          }
        },
        months: {
          validate: function validate2(months) {
            return isArrayLikeObject_1(months) ? months : [parseInt(months, 10)];
          },
          test: function test(day, months) {
            return months.includes(day.month);
          }
        },
        years: {
          validate: function validate2(years) {
            return isArrayLikeObject_1(years) ? years : [parseInt(years, 10)];
          },
          test: function test(day, years) {
            return years.includes(day.year);
          }
        }
      };
    }
  }, {
    key: "patternProps",
    get: function get3() {
      return Object.keys(DateInfo2.patterns).map(function(k2) {
        return {
          name: k2,
          validate: DateInfo2.patterns[k2].validate
        };
      });
    }
  }]);
  return DateInfo2;
}();
const locales = {
  ar: { dow: 7, L: "D/\u200FM/\u200FYYYY" },
  bg: { dow: 2, L: "D.MM.YYYY" },
  ca: { dow: 2, L: "DD/MM/YYYY" },
  "zh-CN": { dow: 2, L: "YYYY/MM/DD" },
  "zh-TW": { dow: 1, L: "YYYY/MM/DD" },
  hr: { dow: 2, L: "DD.MM.YYYY" },
  cs: { dow: 2, L: "DD.MM.YYYY" },
  da: { dow: 2, L: "DD.MM.YYYY" },
  nl: { dow: 2, L: "DD-MM-YYYY" },
  "en-US": { dow: 1, L: "MM/DD/YYYY" },
  "en-AU": { dow: 2, L: "DD/MM/YYYY" },
  "en-CA": { dow: 1, L: "YYYY-MM-DD" },
  "en-GB": { dow: 2, L: "DD/MM/YYYY" },
  "en-IE": { dow: 2, L: "DD-MM-YYYY" },
  "en-NZ": { dow: 2, L: "DD/MM/YYYY" },
  "en-ZA": { dow: 1, L: "YYYY/MM/DD" },
  eo: { dow: 2, L: "YYYY-MM-DD" },
  et: { dow: 2, L: "DD.MM.YYYY" },
  fi: { dow: 2, L: "DD.MM.YYYY" },
  fr: { dow: 2, L: "DD/MM/YYYY" },
  "fr-CA": { dow: 1, L: "YYYY-MM-DD" },
  "fr-CH": { dow: 2, L: "DD.MM.YYYY" },
  de: { dow: 2, L: "DD.MM.YYYY" },
  he: { dow: 1, L: "DD.MM.YYYY" },
  id: { dow: 2, L: "DD/MM/YYYY" },
  it: { dow: 2, L: "DD/MM/YYYY" },
  ja: { dow: 1, L: "YYYY\u5E74M\u6708D\u65E5" },
  ko: { dow: 1, L: "YYYY.MM.DD" },
  lv: { dow: 2, L: "DD.MM.YYYY" },
  lt: { dow: 2, L: "DD.MM.YYYY" },
  mk: { dow: 2, L: "D.MM.YYYY" },
  nb: { dow: 2, L: "D. MMMM YYYY" },
  nn: { dow: 2, L: "D. MMMM YYYY" },
  pl: { dow: 2, L: "DD.MM.YYYY" },
  pt: { dow: 2, L: "DD/MM/YYYY" },
  ro: { dow: 2, L: "DD.MM.YYYY" },
  ru: { dow: 2, L: "DD.MM.YYYY" },
  sk: { dow: 2, L: "DD.MM.YYYY" },
  "es-ES": { dow: 2, L: "DD/MM/YYYY" },
  "es-MX": { dow: 2, L: "DD/MM/YYYY" },
  sv: { dow: 2, L: "YYYY-MM-DD" },
  th: { dow: 1, L: "DD/MM/YYYY" },
  tr: { dow: 2, L: "DD.MM.YYYY" },
  uk: { dow: 2, L: "DD.MM.YYYY" },
  vi: { dow: 2, L: "DD/MM/YYYY" }
};
locales.en = locales["en-US"];
locales.es = locales["es-ES"];
locales.no = locales.nb;
locales.zh = locales["zh-CN"];
toPairs_1(locales).forEach(([id, { dow, L: L2 }]) => {
  locales[id] = {
    id,
    firstDayOfWeek: dow,
    masks: { L: L2 }
  };
});
var PATCH = {
  DATE_TIME: 1,
  DATE: 2,
  TIME: 3
};
var PATCH_KEYS = {
  1: ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds"],
  2: ["year", "month", "day"],
  3: ["hours", "minutes", "seconds", "milliseconds"]
};
var token = /d{1,2}|W{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|Z{1,4}|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigits = /\d\d?/;
var threeDigits = /\d{3}/;
var fourDigits = /\d{4}/;
var word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
var literal = /\[([^]*?)\]/gm;
var noop$1 = function noop() {
};
var monthUpdate = function monthUpdate2(arrName) {
  return function(d3, v2, l2) {
    var index2 = l2[arrName].indexOf(v2.charAt(0).toUpperCase() + v2.substr(1).toLowerCase());
    if (~index2) {
      d3.month = index2;
    }
  };
};
var maskMacros = ["L", "iso"];
var daysInWeek = 7;
var daysInMonths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var formatFlags = {
  D: function D(d3) {
    return d3.day;
  },
  DD: function DD(d3) {
    return pad$1(d3.day);
  },
  Do: function Do(d3, l2) {
    return l2.DoFn(d3.day);
  },
  d: function d(_d) {
    return _d.weekday - 1;
  },
  dd: function dd(d3) {
    return pad$1(d3.weekday - 1);
  },
  W: function W(d3, l2) {
    return l2.dayNamesNarrow[d3.weekday - 1];
  },
  WW: function WW(d3, l2) {
    return l2.dayNamesShorter[d3.weekday - 1];
  },
  WWW: function WWW(d3, l2) {
    return l2.dayNamesShort[d3.weekday - 1];
  },
  WWWW: function WWWW(d3, l2) {
    return l2.dayNames[d3.weekday - 1];
  },
  M: function M(d3) {
    return d3.month;
  },
  MM: function MM(d3) {
    return pad$1(d3.month);
  },
  MMM: function MMM(d3, l2) {
    return l2.monthNamesShort[d3.month - 1];
  },
  MMMM: function MMMM(d3, l2) {
    return l2.monthNames[d3.month - 1];
  },
  YY: function YY(d3) {
    return String(d3.year).substr(2);
  },
  YYYY: function YYYY(d3) {
    return pad$1(d3.year, 4);
  },
  h: function h(d3) {
    return d3.hours % 12 || 12;
  },
  hh: function hh(d3) {
    return pad$1(d3.hours % 12 || 12);
  },
  H: function H(d3) {
    return d3.hours;
  },
  HH: function HH(d3) {
    return pad$1(d3.hours);
  },
  m: function m(d3) {
    return d3.minutes;
  },
  mm: function mm(d3) {
    return pad$1(d3.minutes);
  },
  s: function s(d3) {
    return d3.seconds;
  },
  ss: function ss(d3) {
    return pad$1(d3.seconds);
  },
  S: function S(d3) {
    return Math.round(d3.milliseconds / 100);
  },
  SS: function SS(d3) {
    return pad$1(Math.round(d3.milliseconds / 10), 2);
  },
  SSS: function SSS(d3) {
    return pad$1(d3.milliseconds, 3);
  },
  a: function a(d3, l2) {
    return d3.hours < 12 ? l2.amPm[0] : l2.amPm[1];
  },
  A: function A(d3, l2) {
    return d3.hours < 12 ? l2.amPm[0].toUpperCase() : l2.amPm[1].toUpperCase();
  },
  Z: function Z() {
    return "Z";
  },
  ZZ: function ZZ(d3) {
    var o2 = d3.timezoneOffset;
    return "".concat(o2 > 0 ? "-" : "+").concat(pad$1(Math.floor(Math.abs(o2) / 60), 2));
  },
  ZZZ: function ZZZ(d3) {
    var o2 = d3.timezoneOffset;
    return "".concat(o2 > 0 ? "-" : "+").concat(pad$1(Math.floor(Math.abs(o2) / 60) * 100 + Math.abs(o2) % 60, 4));
  },
  ZZZZ: function ZZZZ(d3) {
    var o2 = d3.timezoneOffset;
    return "".concat(o2 > 0 ? "-" : "+").concat(pad$1(Math.floor(Math.abs(o2) / 60), 2), ":").concat(pad$1(Math.abs(o2) % 60, 2));
  }
};
var parseFlags = {
  D: [twoDigits, function(d3, v2) {
    d3.day = v2;
  }],
  Do: [new RegExp(twoDigits.source + word.source), function(d3, v2) {
    d3.day = parseInt(v2, 10);
  }],
  d: [twoDigits, noop$1],
  W: [word, noop$1],
  M: [twoDigits, function(d3, v2) {
    d3.month = v2 - 1;
  }],
  MMM: [word, monthUpdate("monthNamesShort")],
  MMMM: [word, monthUpdate("monthNames")],
  YY: [twoDigits, function(d3, v2) {
    var da = new Date();
    var cent = +da.getFullYear().toString().substr(0, 2);
    d3.year = "".concat(v2 > 68 ? cent - 1 : cent).concat(v2);
  }],
  YYYY: [fourDigits, function(d3, v2) {
    d3.year = v2;
  }],
  S: [/\d/, function(d3, v2) {
    d3.millisecond = v2 * 100;
  }],
  SS: [/\d{2}/, function(d3, v2) {
    d3.millisecond = v2 * 10;
  }],
  SSS: [threeDigits, function(d3, v2) {
    d3.millisecond = v2;
  }],
  h: [twoDigits, function(d3, v2) {
    d3.hour = v2;
  }],
  m: [twoDigits, function(d3, v2) {
    d3.minute = v2;
  }],
  s: [twoDigits, function(d3, v2) {
    d3.second = v2;
  }],
  a: [word, function(d3, v2, l2) {
    var val = v2.toLowerCase();
    if (val === l2.amPm[0]) {
      d3.isPm = false;
    } else if (val === l2.amPm[1]) {
      d3.isPm = true;
    }
  }],
  Z: [/[^\s]*?[+-]\d\d:?\d\d|[^\s]*?Z?/, function(d3, v2) {
    if (v2 === "Z")
      v2 = "+00:00";
    var parts = "".concat(v2).match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes2 = +(parts[1] * 60) + parseInt(parts[2], 10);
      d3.timezoneOffset = parts[0] === "+" ? minutes2 : -minutes2;
    }
  }]
};
parseFlags.DD = parseFlags.D;
parseFlags.dd = parseFlags.d;
parseFlags.WWWW = parseFlags.WWW = parseFlags.WW = parseFlags.W;
parseFlags.MM = parseFlags.M;
parseFlags.mm = parseFlags.m;
parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
parseFlags.ss = parseFlags.s;
parseFlags.A = parseFlags.a;
parseFlags.ZZZZ = parseFlags.ZZZ = parseFlags.ZZ = parseFlags.Z;
function resolveConfig(config, locales2) {
  var detLocale = new Intl.DateTimeFormat().resolvedOptions().locale;
  var id;
  if (isString_1(config)) {
    id = config;
  } else if (has$1$1(config, "id")) {
    id = config.id;
  }
  id = (id || detLocale).toLowerCase();
  var localeKeys = Object.keys(locales2);
  var validKey = function validKey2(k2) {
    return localeKeys.find(function(lk) {
      return lk.toLowerCase() === k2;
    });
  };
  id = validKey(id) || validKey(id.substring(0, 2)) || detLocale;
  var defLocale = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, locales2["en-IE"]), locales2[id]), {}, {
    id
  });
  config = isObject$1$1(config) ? defaultsDeep_1(config, defLocale) : defLocale;
  return config;
}
var Locale = /* @__PURE__ */ function() {
  function Locale2(config) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$locales = _ref.locales, locales$1 = _ref$locales === void 0 ? locales : _ref$locales, timezone2 = _ref.timezone;
    _classCallCheck(this, Locale2);
    var _resolveConfig = resolveConfig(config, locales$1), id = _resolveConfig.id, firstDayOfWeek = _resolveConfig.firstDayOfWeek, masks3 = _resolveConfig.masks;
    this.id = id;
    this.daysInWeek = daysInWeek;
    this.firstDayOfWeek = clamp_1(firstDayOfWeek, 1, daysInWeek);
    this.masks = masks3;
    this.timezone = timezone2 || void 0;
    this.dayNames = this.getDayNames("long");
    this.dayNamesShort = this.getDayNames("short");
    this.dayNamesShorter = this.dayNamesShort.map(function(s3) {
      return s3.substring(0, 2);
    });
    this.dayNamesNarrow = this.getDayNames("narrow");
    this.monthNames = this.getMonthNames("long");
    this.monthNamesShort = this.getMonthNames("short");
    this.amPm = ["am", "pm"];
    this.monthData = {};
    this.getMonthComps = this.getMonthComps.bind(this);
    this.parse = this.parse.bind(this);
    this.format = this.format.bind(this);
    this.toPage = this.toPage.bind(this);
  }
  _createClass(Locale2, [{
    key: "format",
    value: function format3(date2, mask) {
      var _this = this;
      date2 = this.normalizeDate(date2);
      if (!date2)
        return "";
      mask = this.normalizeMasks(mask)[0];
      var literals = [];
      mask = mask.replace(literal, function($0, $1) {
        literals.push($1);
        return "??";
      });
      var timezone2 = /Z$/.test(mask) ? "utc" : this.timezone;
      var dateParts = this.getDateParts(date2, timezone2);
      mask = mask.replace(token, function($0) {
        return $0 in formatFlags ? formatFlags[$0](dateParts, _this) : $0.slice(1, $0.length - 1);
      });
      return mask.replace(/\?\?/g, function() {
        return literals.shift();
      });
    }
  }, {
    key: "parse",
    value: function parse2(dateString, mask) {
      var _this2 = this;
      var masks3 = this.normalizeMasks(mask);
      return masks3.map(function(m3) {
        if (typeof m3 !== "string") {
          throw new Error("Invalid mask in fecha.parse");
        }
        var str = dateString;
        if (str.length > 1e3) {
          return false;
        }
        var isValid = true;
        var dateInfo = {};
        m3.replace(token, function($0) {
          if (parseFlags[$0]) {
            var info = parseFlags[$0];
            var index2 = str.search(info[0]);
            if (!~index2) {
              isValid = false;
            } else {
              str.replace(info[0], function(result) {
                info[1](dateInfo, result, _this2);
                str = str.substr(index2 + result.length);
                return result;
              });
            }
          }
          return parseFlags[$0] ? "" : $0.slice(1, $0.length - 1);
        });
        if (!isValid) {
          return false;
        }
        var today = new Date();
        if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
          dateInfo.hour = +dateInfo.hour + 12;
        } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
          dateInfo.hour = 0;
        }
        var date2;
        if (dateInfo.timezoneOffset != null) {
          dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
          date2 = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
        } else {
          date2 = _this2.getDateFromParts({
            year: dateInfo.year || today.getFullYear(),
            month: (dateInfo.month || 0) + 1,
            day: dateInfo.day || 1,
            hours: dateInfo.hour || 0,
            minutes: dateInfo.minute || 0,
            seconds: dateInfo.second || 0,
            milliseconds: dateInfo.millisecond || 0
          });
        }
        return date2;
      }).find(function(d3) {
        return d3;
      }) || new Date(dateString);
    }
  }, {
    key: "normalizeMasks",
    value: function normalizeMasks(masks3) {
      var _this3 = this;
      return (arrayHasItems(masks3) && masks3 || [isString_1(masks3) && masks3 || "YYYY-MM-DD"]).map(function(m3) {
        return maskMacros.reduce(function(prev, curr) {
          return prev.replace(curr, _this3.masks[curr] || "");
        }, m3);
      });
    }
  }, {
    key: "normalizeDate",
    value: function normalizeDate2(d3) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var result = null;
      var type = config.type, fillDate = config.fillDate;
      var mask = config.mask, patch = config.patch, time = config.time;
      var auto2 = type === "auto" || !type;
      if (isNumber_1(d3)) {
        type = "number";
        result = new Date(+d3);
      } else if (isString_1(d3)) {
        type = "string";
        result = d3 ? this.parse(d3, mask || "iso") : null;
      } else if (isObject$1$1(d3)) {
        type = "object";
        result = this.getDateFromParts(d3);
      } else {
        type = "date";
        result = isDate$1$1(d3) ? new Date(d3.getTime()) : null;
      }
      if (result && patch) {
        fillDate = fillDate == null ? new Date() : this.normalizeDate(fillDate);
        var parts = _objectSpread2$1(_objectSpread2$1({}, this.getDateParts(fillDate)), pick_1(this.getDateParts(result), PATCH_KEYS[patch]));
        result = this.getDateFromParts(parts);
      }
      if (auto2)
        config.type = type;
      if (result && !isNaN(result.getTime())) {
        if (time) {
          result = this.adjustTimeForDate(result, {
            timeAdjust: time
          });
        }
        return result;
      }
      return null;
    }
  }, {
    key: "denormalizeDate",
    value: function denormalizeDate(date2) {
      var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, type = _ref2.type, mask = _ref2.mask;
      switch (type) {
        case "number":
          return date2 ? date2.getTime() : NaN;
        case "string":
          return date2 ? this.format(date2, mask || "iso") : "";
        default:
          return date2 ? new Date(date2) : null;
      }
    }
  }, {
    key: "adjustTimeForDate",
    value: function adjustTimeForDate(date2, _ref3) {
      var timeAdjust = _ref3.timeAdjust;
      if (timeAdjust) {
        var dateParts = this.getDateParts(date2);
        if (timeAdjust === "now") {
          var timeParts = this.getDateParts(new Date());
          dateParts.hours = timeParts.hours;
          dateParts.minutes = timeParts.minutes;
          dateParts.seconds = timeParts.seconds;
          dateParts.milliseconds = timeParts.milliseconds;
        } else {
          var d3 = new Date("2000-01-01T".concat(timeAdjust, "Z"));
          dateParts.hours = d3.getUTCHours();
          dateParts.minutes = d3.getUTCMinutes();
          dateParts.seconds = d3.getUTCSeconds();
          dateParts.milliseconds = d3.getUTCMilliseconds();
        }
        date2 = this.getDateFromParts(dateParts);
      }
      return date2;
    }
  }, {
    key: "normalizeDates",
    value: function normalizeDates2(dates, opts2) {
      opts2 = opts2 || {};
      opts2.locale = this;
      return (isArrayLikeObject_1(dates) ? dates : [dates]).map(function(d3) {
        return d3 && (d3 instanceof DateInfo ? d3 : new DateInfo(d3, opts2));
      }).filter(function(d3) {
        return d3;
      });
    }
  }, {
    key: "getDateParts",
    value: function getDateParts2(date2) {
      var timezone2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.timezone;
      if (!date2)
        return null;
      var tzDate = date2;
      if (timezone2) {
        var normDate = new Date(date2.toLocaleString("en-US", {
          timeZone: timezone2
        }));
        normDate.setMilliseconds(date2.getMilliseconds());
        var diff = normDate.getTime() - date2.getTime();
        tzDate = new Date(date2.getTime() + diff);
      }
      var milliseconds = tzDate.getMilliseconds();
      var seconds = tzDate.getSeconds();
      var minutes2 = tzDate.getMinutes();
      var hours2 = tzDate.getHours();
      var month2 = tzDate.getMonth() + 1;
      var year3 = tzDate.getFullYear();
      var comps = this.getMonthComps(month2, year3);
      var day = tzDate.getDate();
      var dayFromEnd = comps.days - day + 1;
      var weekday = tzDate.getDay() + 1;
      var weekdayOrdinal = Math.floor((day - 1) / 7 + 1);
      var weekdayOrdinalFromEnd = Math.floor((comps.days - day) / 7 + 1);
      var week = Math.ceil((day + Math.abs(comps.firstWeekday - comps.firstDayOfWeek)) / 7);
      var weekFromEnd = comps.weeks - week + 1;
      var parts = {
        milliseconds,
        seconds,
        minutes: minutes2,
        hours: hours2,
        day,
        dayFromEnd,
        weekday,
        weekdayOrdinal,
        weekdayOrdinalFromEnd,
        week,
        weekFromEnd,
        month: month2,
        year: year3,
        date: date2,
        isValid: true
      };
      parts.timezoneOffset = this.getTimezoneOffset(parts);
      return parts;
    }
  }, {
    key: "getDateFromParts",
    value: function getDateFromParts2(parts) {
      if (!parts)
        return null;
      var d3 = new Date();
      var _parts$year = parts.year, year3 = _parts$year === void 0 ? d3.getFullYear() : _parts$year, _parts$month = parts.month, month2 = _parts$month === void 0 ? d3.getMonth() + 1 : _parts$month, _parts$day = parts.day, day = _parts$day === void 0 ? d3.getDate() : _parts$day, _parts$hours = parts.hours, hrs = _parts$hours === void 0 ? 0 : _parts$hours, _parts$minutes = parts.minutes, min2 = _parts$minutes === void 0 ? 0 : _parts$minutes, _parts$seconds = parts.seconds, sec = _parts$seconds === void 0 ? 0 : _parts$seconds, _parts$milliseconds = parts.milliseconds, ms = _parts$milliseconds === void 0 ? 0 : _parts$milliseconds;
      if (this.timezone) {
        var dateString = "".concat(pad$1(year3, 4), "-").concat(pad$1(month2, 2), "-").concat(pad$1(day, 2), "T").concat(pad$1(hrs, 2), ":").concat(pad$1(min2, 2), ":").concat(pad$1(sec, 2), ".").concat(pad$1(ms, 3));
        return toDate$1(dateString, {
          timeZone: this.timezone
        });
      }
      return new Date(year3, month2 - 1, day, hrs, min2, sec, ms);
    }
  }, {
    key: "getTimezoneOffset",
    value: function getTimezoneOffset(parts) {
      var y2 = parts.year, m3 = parts.month, d3 = parts.day, _parts$hours2 = parts.hours, hrs = _parts$hours2 === void 0 ? 0 : _parts$hours2, _parts$minutes2 = parts.minutes, min2 = _parts$minutes2 === void 0 ? 0 : _parts$minutes2, _parts$seconds2 = parts.seconds, sec = _parts$seconds2 === void 0 ? 0 : _parts$seconds2, _parts$milliseconds2 = parts.milliseconds, ms = _parts$milliseconds2 === void 0 ? 0 : _parts$milliseconds2;
      var date2;
      var utcDate = new Date(Date.UTC(y2, m3 - 1, d3, hrs, min2, sec, ms));
      if (this.timezone) {
        var dateString = "".concat(pad$1(y2, 4), "-").concat(pad$1(m3, 2), "-").concat(pad$1(d3, 2), "T").concat(pad$1(hrs, 2), ":").concat(pad$1(min2, 2), ":").concat(pad$1(sec, 2), ".").concat(pad$1(ms, 3));
        date2 = toDate$1(dateString, {
          timeZone: this.timezone
        });
      } else {
        date2 = new Date(y2, m3 - 1, d3, hrs, min2, sec, ms);
      }
      return (date2 - utcDate) / 6e4;
    }
  }, {
    key: "toPage",
    value: function toPage2(arg, fromPage2) {
      if (isNumber_1(arg)) {
        return addPages(fromPage2, arg);
      }
      if (isString_1(arg)) {
        return this.getDateParts(this.normalizeDate(arg));
      }
      if (isDate$1$1(arg)) {
        return this.getDateParts(arg);
      }
      if (isObject$1$1(arg)) {
        return arg;
      }
      return null;
    }
  }, {
    key: "getMonthDates",
    value: function getMonthDates() {
      var year3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2e3;
      var dates = [];
      for (var i2 = 0; i2 < 12; i2++) {
        dates.push(new Date(year3, i2, 15));
      }
      return dates;
    }
  }, {
    key: "getMonthNames",
    value: function getMonthNames(length) {
      var dtf = new Intl.DateTimeFormat(this.id, {
        month: length,
        timezome: "UTC"
      });
      return this.getMonthDates().map(function(d3) {
        return dtf.format(d3);
      });
    }
  }, {
    key: "getWeekdayDates",
    value: function getWeekdayDates() {
      var firstDayOfWeek = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.firstDayOfWeek;
      var dates = [];
      var year3 = 2020;
      var month2 = 1;
      var day = 5 + firstDayOfWeek - 1;
      for (var i2 = 0; i2 < daysInWeek; i2++) {
        dates.push(this.getDateFromParts({
          year: year3,
          month: month2,
          day: day + i2,
          hours: 12
        }));
      }
      return dates;
    }
  }, {
    key: "getDayNames",
    value: function getDayNames(length) {
      var dtf = new Intl.DateTimeFormat(this.id, {
        weekday: length,
        timeZone: this.timezone
      });
      return this.getWeekdayDates(1).map(function(d3) {
        return dtf.format(d3);
      });
    }
  }, {
    key: "getMonthComps",
    value: function getMonthComps(month2, year3) {
      var key = "".concat(month2, "-").concat(year3);
      var comps = this.monthData[key];
      if (!comps) {
        var inLeapYear = year3 % 4 === 0 && year3 % 100 !== 0 || year3 % 400 === 0;
        var firstDayOfMonth = new Date(year3, month2 - 1, 1);
        var firstWeekday = firstDayOfMonth.getDay() + 1;
        var days = month2 === 2 && inLeapYear ? 29 : daysInMonths[month2 - 1];
        var weekStartsOn = this.firstDayOfWeek - 1;
        var weeks = getWeeksInMonth(firstDayOfMonth, {
          weekStartsOn
        });
        var weeknumbers = [];
        var isoWeeknumbers = [];
        for (var i2 = 0; i2 < weeks; i2++) {
          var date2 = addDays(firstDayOfMonth, i2 * 7);
          weeknumbers.push(getWeek(date2, {
            weekStartsOn
          }));
          isoWeeknumbers.push(getISOWeek(date2));
        }
        comps = {
          firstDayOfWeek: this.firstDayOfWeek,
          inLeapYear,
          firstWeekday,
          days,
          weeks,
          month: month2,
          year: year3,
          weeknumbers,
          isoWeeknumbers
        };
        this.monthData[key] = comps;
      }
      return comps;
    }
  }, {
    key: "getThisMonthComps",
    value: function getThisMonthComps() {
      var _this$getDateParts = this.getDateParts(new Date()), month2 = _this$getDateParts.month, year3 = _this$getDateParts.year;
      return this.getMonthComps(month2, year3);
    }
  }, {
    key: "getPrevMonthComps",
    value: function getPrevMonthComps(month2, year3) {
      if (month2 === 1)
        return this.getMonthComps(12, year3 - 1);
      return this.getMonthComps(month2 - 1, year3);
    }
  }, {
    key: "getNextMonthComps",
    value: function getNextMonthComps(month2, year3) {
      if (month2 === 12)
        return this.getMonthComps(1, year3 + 1);
      return this.getMonthComps(month2 + 1, year3);
    }
  }, {
    key: "getDayId",
    value: function getDayId(date2) {
      return this.format(date2, "YYYY-MM-DD");
    }
  }, {
    key: "getCalendarDays",
    value: function getCalendarDays(_ref4) {
      var _this4 = this;
      var weeks = _ref4.weeks, monthComps = _ref4.monthComps, prevMonthComps = _ref4.prevMonthComps, nextMonthComps = _ref4.nextMonthComps;
      var days = [];
      var firstDayOfWeek = monthComps.firstDayOfWeek, firstWeekday = monthComps.firstWeekday, isoWeeknumbers = monthComps.isoWeeknumbers, weeknumbers = monthComps.weeknumbers;
      var prevMonthDaysToShow = firstWeekday + (firstWeekday < firstDayOfWeek ? daysInWeek : 0) - firstDayOfWeek;
      var prevMonth = true;
      var thisMonth = false;
      var nextMonth = false;
      var formatter = new Intl.DateTimeFormat(this.id, {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric"
      });
      var day = prevMonthComps.days - prevMonthDaysToShow + 1;
      var dayFromEnd = prevMonthComps.days - day + 1;
      var weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);
      var weekdayOrdinalFromEnd = 1;
      var week = prevMonthComps.weeks;
      var weekFromEnd = 1;
      var month2 = prevMonthComps.month;
      var year3 = prevMonthComps.year;
      var today = new Date();
      var todayDay = today.getDate();
      var todayMonth = today.getMonth() + 1;
      var todayYear = today.getFullYear();
      var dft = function dft2(y2, m3, d3) {
        return function(hours2, minutes2, seconds, milliseconds) {
          return _this4.normalizeDate({
            year: y2,
            month: m3,
            day: d3,
            hours: hours2,
            minutes: minutes2,
            seconds,
            milliseconds
          });
        };
      };
      for (var w2 = 1; w2 <= weeks; w2++) {
        for (var i2 = 1, weekday = firstDayOfWeek; i2 <= daysInWeek; i2++, weekday += weekday === daysInWeek ? 1 - daysInWeek : 1) {
          if (prevMonth && weekday === firstWeekday) {
            day = 1;
            dayFromEnd = monthComps.days;
            weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);
            weekdayOrdinalFromEnd = Math.floor((monthComps.days - day) / daysInWeek + 1);
            week = 1;
            weekFromEnd = monthComps.weeks;
            month2 = monthComps.month;
            year3 = monthComps.year;
            prevMonth = false;
            thisMonth = true;
          }
          var dateFromTime = dft(year3, month2, day);
          var range = {
            start: dateFromTime(0, 0, 0),
            end: dateFromTime(23, 59, 59, 999)
          };
          var date2 = range.start;
          var id = "".concat(pad$1(year3, 4), "-").concat(pad$1(month2, 2), "-").concat(pad$1(day, 2));
          var weekdayPosition = i2;
          var weekdayPositionFromEnd = daysInWeek - i2;
          var weeknumber = weeknumbers[w2 - 1];
          var isoWeeknumber = isoWeeknumbers[w2 - 1];
          var isToday = day === todayDay && month2 === todayMonth && year3 === todayYear;
          var isFirstDay = thisMonth && day === 1;
          var isLastDay = thisMonth && day === monthComps.days;
          var onTop = w2 === 1;
          var onBottom = w2 === weeks;
          var onLeft = i2 === 1;
          var onRight = i2 === daysInWeek;
          days.push({
            id,
            label: day.toString(),
            ariaLabel: formatter.format(new Date(year3, month2 - 1, day)),
            day,
            dayFromEnd,
            weekday,
            weekdayPosition,
            weekdayPositionFromEnd,
            weekdayOrdinal,
            weekdayOrdinalFromEnd,
            week,
            weekFromEnd,
            weeknumber,
            isoWeeknumber,
            month: month2,
            year: year3,
            dateFromTime,
            date: date2,
            range,
            isToday,
            isFirstDay,
            isLastDay,
            inMonth: thisMonth,
            inPrevMonth: prevMonth,
            inNextMonth: nextMonth,
            onTop,
            onBottom,
            onLeft,
            onRight,
            classes: ["id-".concat(id), "day-".concat(day), "day-from-end-".concat(dayFromEnd), "weekday-".concat(weekday), "weekday-position-".concat(weekdayPosition), "weekday-ordinal-".concat(weekdayOrdinal), "weekday-ordinal-from-end-".concat(weekdayOrdinalFromEnd), "week-".concat(week), "week-from-end-".concat(weekFromEnd), {
              "is-today": isToday,
              "is-first-day": isFirstDay,
              "is-last-day": isLastDay,
              "in-month": thisMonth,
              "in-prev-month": prevMonth,
              "in-next-month": nextMonth,
              "on-top": onTop,
              "on-bottom": onBottom,
              "on-left": onLeft,
              "on-right": onRight
            }]
          });
          if (thisMonth && isLastDay) {
            thisMonth = false;
            nextMonth = true;
            day = 1;
            dayFromEnd = nextMonthComps.days;
            weekdayOrdinal = 1;
            weekdayOrdinalFromEnd = Math.floor((nextMonthComps.days - day) / daysInWeek + 1);
            week = 1;
            weekFromEnd = nextMonthComps.weeks;
            month2 = nextMonthComps.month;
            year3 = nextMonthComps.year;
          } else {
            day++;
            dayFromEnd--;
            weekdayOrdinal = Math.floor((day - 1) / daysInWeek + 1);
            weekdayOrdinalFromEnd = Math.floor((monthComps.days - day) / daysInWeek + 1);
          }
        }
        week++;
        weekFromEnd--;
      }
      return days;
    }
  }]);
  return Locale2;
}();
var Attribute = /* @__PURE__ */ function() {
  function Attribute2(_ref, theme3, locale2) {
    var key = _ref.key, hashcode = _ref.hashcode, highlight = _ref.highlight, content3 = _ref.content, dot = _ref.dot, bar = _ref.bar, popover = _ref.popover, dates = _ref.dates, excludeDates = _ref.excludeDates, excludeMode = _ref.excludeMode, customData = _ref.customData, order2 = _ref.order, pinPage = _ref.pinPage;
    _classCallCheck(this, Attribute2);
    this.key = isUndefined_1(key) ? createGuid() : key;
    this.hashcode = hashcode;
    this.customData = customData;
    this.order = order2 || 0;
    this.dateOpts = {
      order: order2,
      locale: locale2
    };
    this.pinPage = pinPage;
    if (highlight) {
      this.highlight = theme3.normalizeHighlight(highlight);
    }
    if (content3) {
      this.content = theme3.normalizeContent(content3);
    }
    if (dot) {
      this.dot = theme3.normalizeDot(dot);
    }
    if (bar) {
      this.bar = theme3.normalizeBar(bar);
    }
    if (popover) {
      this.popover = popover;
    }
    this.dates = locale2.normalizeDates(dates, this.dateOpts);
    this.hasDates = !!arrayHasItems(this.dates);
    this.excludeDates = locale2.normalizeDates(excludeDates, this.dateOpts);
    this.hasExcludeDates = !!arrayHasItems(this.excludeDates);
    this.excludeMode = excludeMode || "intersects";
    if (this.hasExcludeDates && !this.hasDates) {
      this.dates.push(new DateInfo({}, this.dateOpts));
      this.hasDates = true;
    }
    this.isComplex = some$1(this.dates, function(d3) {
      return d3.isComplex;
    });
  }
  _createClass(Attribute2, [{
    key: "intersectsDate",
    value: function intersectsDate(date2) {
      date2 = date2 instanceof DateInfo ? date2 : new DateInfo(date2, this.dateOpts);
      return !this.excludesDate(date2) && (this.dates.find(function(d3) {
        return d3.intersectsDate(date2);
      }) || false);
    }
  }, {
    key: "includesDate",
    value: function includesDate(date2) {
      date2 = date2 instanceof DateInfo ? date2 : new DateInfo(date2, this.dateOpts);
      return !this.excludesDate(date2) && (this.dates.find(function(d3) {
        return d3.includesDate(date2);
      }) || false);
    }
  }, {
    key: "excludesDate",
    value: function excludesDate(date2) {
      var _this = this;
      date2 = date2 instanceof DateInfo ? date2 : new DateInfo(date2, this.dateOpts);
      return this.hasExcludeDates && this.excludeDates.find(function(ed) {
        return _this.excludeMode === "intersects" && ed.intersectsDate(date2) || _this.excludeMode === "includes" && ed.includesDate(date2);
      });
    }
  }, {
    key: "intersectsDay",
    value: function intersectsDay(day) {
      return !this.excludesDay(day) && (this.dates.find(function(d3) {
        return d3.intersectsDay(day);
      }) || false);
    }
  }, {
    key: "excludesDay",
    value: function excludesDay(day) {
      return this.hasExcludeDates && this.excludeDates.find(function(ed) {
        return ed.intersectsDay(day);
      });
    }
  }]);
  return Attribute2;
}();
var maxSwipeTime = 300;
var minHorizontalSwipeDistance = 60;
var maxVerticalSwipeDistance = 80;
var touch = {
  maxSwipeTime,
  minHorizontalSwipeDistance,
  maxVerticalSwipeDistance
};
var title = "MMMM YYYY";
var weekdays = "W";
var navMonths = "MMM";
var input = [
  "L",
  "YYYY-MM-DD",
  "YYYY/MM/DD"
];
var inputDateTime = [
  "L h:mm A",
  "YYYY-MM-DD h:mm A",
  "YYYY/MM/DD h:mm A"
];
var inputDateTime24hr = [
  "L HH:mm",
  "YYYY-MM-DD HH:mm",
  "YYYY/MM/DD HH:mm"
];
var inputTime = [
  "h:mm A"
];
var inputTime24hr = [
  "HH:mm"
];
var dayPopover = "WWW, MMM D, YYYY";
var data$1 = [
  "L",
  "YYYY-MM-DD",
  "YYYY/MM/DD"
];
var model = "iso";
var iso = "YYYY-MM-DDTHH:mm:ssXXX";
var masks2 = {
  title,
  weekdays,
  navMonths,
  input,
  inputDateTime,
  inputDateTime24hr,
  inputTime,
  inputTime24hr,
  dayPopover,
  data: data$1,
  model,
  iso
};
var sm = "640px";
var md = "768px";
var lg = "1024px";
var xl = "1280px";
var defaultScreens = {
  sm,
  md,
  lg,
  xl
};
const defaultConfig = {
  componentPrefix: "v",
  color: "blue",
  isDark: false,
  navVisibility: "click",
  titlePosition: "center",
  transition: "slide-h",
  touch,
  masks: masks2,
  screens: defaultScreens,
  locales,
  datePicker: {
    updateOnInput: true,
    inputDebounce: 1e3,
    popover: {
      visibility: "hover-focus",
      placement: "bottom-start",
      keepVisibleOnInput: false,
      isInteractive: true
    }
  }
};
const state = reactive(defaultConfig);
const computedLocales = computed(() => {
  return mapValues_1(state.locales, (v2) => {
    v2.masks = defaultsDeep_1(v2.masks, state.masks);
    return v2;
  });
});
const getDefault = (path) => {
  if (window && has$1$1(window.__vcalendar__, path)) {
    return get_1(window.__vcalendar__, path);
  }
  return get_1(state, path);
};
const setup$1 = (userDefaults) => {
  return defaultsDeep_1(state, userDefaults);
};
var rootMixin = {
  props: {
    color: {
      type: String,
      default: getDefault("color")
    },
    isDark: {
      type: Boolean,
      default: getDefault("isDark")
    },
    firstDayOfWeek: Number,
    masks: Object,
    locale: [String, Object],
    timezone: String,
    minDate: null,
    maxDate: null,
    minDateExact: null,
    maxDateExact: null,
    disabledDates: null,
    availableDates: null,
    theme: null
  },
  computed: {
    $theme: function $theme() {
      if (this.theme instanceof Theme)
        return this.theme;
      return new Theme({
        color: this.color,
        isDark: this.isDark
      });
    },
    $locale: function $locale() {
      if (this.locale instanceof Locale)
        return this.locale;
      var config = isObject$1$1(this.locale) ? this.locale : {
        id: this.locale,
        firstDayOfWeek: this.firstDayOfWeek,
        masks: this.masks
      };
      return new Locale(config, {
        locales: computedLocales.value,
        timezone: this.timezone
      });
    },
    disabledDates_: function disabledDates_() {
      var dates = this.normalizeDates(this.disabledDates);
      var minDate = this.minDate, minDateExact = this.minDateExact, maxDate = this.maxDate, maxDateExact = this.maxDateExact;
      if (minDateExact || minDate) {
        var end2 = minDateExact ? this.normalizeDate(minDateExact) : this.normalizeDate(minDate, {
          time: "00:00:00"
        });
        dates.push({
          start: null,
          end: new Date(end2.getTime() - 1e3)
        });
      }
      if (maxDateExact || maxDate) {
        var start2 = maxDateExact ? this.normalizeDate(maxDateExact) : this.normalizeDate(maxDate, {
          time: "23:59:59"
        });
        dates.push({
          start: new Date(start2.getTime() + 1e3),
          end: null
        });
      }
      return dates;
    },
    availableDates_: function availableDates_() {
      return this.normalizeDates(this.availableDates);
    },
    disabledAttribute: function disabledAttribute() {
      return new Attribute({
        key: "disabled",
        dates: this.disabledDates_,
        excludeDates: this.availableDates_,
        excludeMode: "includes",
        order: 100
      }, this.$theme, this.$locale);
    }
  },
  methods: {
    formatDate: function formatDate(date2, mask) {
      return this.$locale ? this.$locale.format(date2, mask) : "";
    },
    parseDate: function parseDate2(text, mask) {
      if (!this.$locale)
        return null;
      var value2 = this.$locale.parse(text, mask);
      return isDate$1$1(value2) ? value2 : null;
    },
    normalizeDate: function normalizeDate(date2, config) {
      return this.$locale ? this.$locale.normalizeDate(date2, config) : date2;
    },
    normalizeDates: function normalizeDates(dates) {
      return this.$locale.normalizeDates(dates, {
        isFullDay: true
      });
    },
    pageForDate: function pageForDate2(date2) {
      return this.$locale.getDateParts(this.normalizeDate(date2));
    },
    pageForThisMonth: function pageForThisMonth() {
      return this.pageForDate(new Date());
    }
  }
};
var slotMixin = {
  methods: {
    safeSlot: function safeSlot(name2, args) {
      var def = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      return isFunction_1(this.$slots[name2]) ? this.$slots[name2](args) : def;
    }
  }
};
var childMixin$1 = childMixin;
var rootMixin$1 = rootMixin;
var slotMixin$1 = slotMixin;
function styleInject(css2, ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var insertAt = ref2.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head2 = document.head || document.getElementsByTagName("head")[0];
  var style2 = document.createElement("style");
  style2.type = "text/css";
  if (insertAt === "top") {
    if (head2.firstChild) {
      head2.insertBefore(style2, head2.firstChild);
    } else {
      head2.appendChild(style2);
    }
  } else {
    head2.appendChild(style2);
  }
  if (style2.styleSheet) {
    style2.styleSheet.cssText = css2;
  } else {
    style2.appendChild(document.createTextNode(css2));
  }
}
function showPopover(opts2) {
  if (document) {
    document.dispatchEvent(new CustomEvent("show-popover", {
      detail: opts2
    }));
  }
}
function hidePopover(opts2) {
  if (document) {
    document.dispatchEvent(new CustomEvent("hide-popover", {
      detail: opts2
    }));
  }
}
function togglePopover(opts2) {
  if (document) {
    document.dispatchEvent(new CustomEvent("toggle-popover", {
      detail: opts2
    }));
  }
}
function updatePopover(opts2) {
  if (document) {
    document.dispatchEvent(new CustomEvent("update-popover", {
      detail: opts2
    }));
  }
}
function getPopoverTriggerEvents(opts2) {
  var _ref;
  var visibility = opts2.visibility;
  var click2 = visibility === "click";
  var hover = visibility === "hover";
  var hoverFocus = visibility === "hover-focus";
  var focus = visibility === "focus";
  opts2.autoHide = !click2;
  var hovered = false;
  var focused = false;
  var isRenderFn = opts2.isRenderFn;
  var events2 = {
    click: isRenderFn ? "onClick" : "click",
    mousemove: isRenderFn ? "onMousemove" : "mousemove",
    mouseleave: isRenderFn ? "onMouseleave" : "mouseleave",
    focusin: isRenderFn ? "onFocusin" : "focusin",
    focusout: isRenderFn ? "onFocusout" : "focusout"
  };
  return _ref = {}, _defineProperty$1(_ref, events2.click, function(e2) {
    if (click2) {
      opts2.ref = e2.target;
      togglePopover(opts2);
      e2.stopPropagation();
    }
  }), _defineProperty$1(_ref, events2.mousemove, function(e2) {
    opts2.ref = e2.currentTarget;
    if (!hovered) {
      hovered = true;
      if (hover || hoverFocus) {
        showPopover(opts2);
      }
    }
  }), _defineProperty$1(_ref, events2.mouseleave, function(e2) {
    opts2.ref = e2.target;
    if (hovered) {
      hovered = false;
      if (hover || hoverFocus && !focused) {
        hidePopover(opts2);
      }
    }
  }), _defineProperty$1(_ref, events2.focusin, function(e2) {
    opts2.ref = e2.currentTarget;
    if (!focused) {
      focused = true;
      if (focus || hoverFocus) {
        showPopover(opts2);
      }
    }
  }), _defineProperty$1(_ref, events2.focusout, function(e2) {
    opts2.ref = e2.currentTarget;
    if (focused && !elementContains(opts2.ref, e2.relatedTarget)) {
      focused = false;
      if (focus || hoverFocus && !hovered) {
        hidePopover(opts2);
      }
    }
  }), _ref;
}
var script$a = {
  name: "CalendarDay",
  emits: ["dayclick", "daymouseenter", "daymouseleave", "dayfocusin", "dayfocusout", "daykeydown"],
  mixins: [childMixin$1, slotMixin$1],
  inheritAttrs: false,
  render: function render() {
    var _this = this;
    var backgroundsLayer = function backgroundsLayer2() {
      return _this.hasBackgrounds && h$5("div", {
        class: "vc-highlights vc-day-layer"
      }, _this.backgrounds.map(function(_ref) {
        var key = _ref.key, wrapperClass = _ref.wrapperClass, bgClass = _ref.class, style2 = _ref.style;
        return h$5("div", {
          key,
          class: wrapperClass
        }, [h$5("div", {
          class: bgClass,
          style: style2
        })]);
      }));
    };
    var contentLayer = function contentLayer2() {
      return _this.safeSlot("day-content", {
        day: _this.day,
        attributes: _this.day.attributes,
        attributesMap: _this.day.attributesMap,
        dayProps: _this.dayContentProps,
        dayEvents: _this.dayContentEvents
      }) || h$5("span", _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.dayContentProps), {}, {
        class: _this.dayContentClass,
        style: _this.dayContentStyle
      }, _this.dayContentEvents), {}, {
        ref: "content"
      }), [_this.day.label]);
    };
    var dotsLayer = function dotsLayer2() {
      return _this.hasDots && h$5("div", {
        class: "vc-day-layer vc-day-box-center-bottom"
      }, [h$5("div", {
        class: "vc-dots"
      }, _this.dots.map(function(_ref2) {
        var key = _ref2.key, bgClass = _ref2.class, style2 = _ref2.style;
        return h$5("span", {
          key,
          class: bgClass,
          style: style2
        });
      }))]);
    };
    var barsLayer = function barsLayer2() {
      return _this.hasBars && h$5("div", {
        class: "vc-day-layer vc-day-box-center-bottom"
      }, [h$5("div", {
        class: "vc-bars"
      }, _this.bars.map(function(_ref3) {
        var key = _ref3.key, bgClass = _ref3.class, style2 = _ref3.style;
        return h$5("span", {
          key,
          class: bgClass,
          style: style2
        });
      }))]);
    };
    return h$5("div", {
      class: ["vc-day"].concat(_toConsumableArray(this.day.classes), [{
        "vc-day-box-center-center": !this.$slots["day-content"]
      }, {
        "is-not-in-month": !this.inMonth
      }])
    }, [backgroundsLayer(), contentLayer(), dotsLayer(), barsLayer()]);
  },
  inject: ["sharedState"],
  props: {
    day: {
      type: Object,
      required: true
    }
  },
  data: function data() {
    return {
      glyphs: {},
      dayContentEvents: {}
    };
  },
  computed: {
    label: function label() {
      return this.day.label;
    },
    startTime: function startTime() {
      return this.day.range.start.getTime();
    },
    endTime: function endTime() {
      return this.day.range.end.getTime();
    },
    inMonth: function inMonth() {
      return this.day.inMonth;
    },
    isDisabled: function isDisabled() {
      return this.day.isDisabled;
    },
    backgrounds: function backgrounds() {
      return this.glyphs.backgrounds;
    },
    hasBackgrounds: function hasBackgrounds() {
      return !!arrayHasItems(this.backgrounds);
    },
    content: function content() {
      return this.glyphs.content;
    },
    dots: function dots() {
      return this.glyphs.dots;
    },
    hasDots: function hasDots() {
      return !!arrayHasItems(this.dots);
    },
    bars: function bars() {
      return this.glyphs.bars;
    },
    hasBars: function hasBars() {
      return !!arrayHasItems(this.bars);
    },
    popovers: function popovers() {
      return this.glyphs.popovers;
    },
    hasPopovers: function hasPopovers() {
      return !!arrayHasItems(this.popovers);
    },
    dayContentClass: function dayContentClass() {
      return ["vc-day-content vc-focusable", {
        "is-disabled": this.isDisabled
      }, get_1(last_1(this.content), "class") || ""];
    },
    dayContentStyle: function dayContentStyle() {
      return get_1(last_1(this.content), "style");
    },
    dayContentProps: function dayContentProps() {
      var tabindex;
      if (this.day.isFocusable) {
        tabindex = "0";
      } else if (this.day.inMonth) {
        tabindex = "-1";
      }
      return {
        tabindex,
        "aria-label": this.day.ariaLabel,
        "aria-disabled": this.day.isDisabled ? "true" : "false",
        role: "button"
      };
    },
    dayEvent: function dayEvent() {
      return _objectSpread2$1(_objectSpread2$1({}, this.day), {}, {
        el: this.$refs.content,
        popovers: this.popovers
      });
    }
  },
  watch: {
    theme: function theme2() {
      this.refresh();
    },
    popovers: function popovers2() {
      this.refreshPopovers();
    },
    "day.shouldRefresh": function dayShouldRefresh() {
      this.refresh();
    }
  },
  mounted: function mounted() {
    this.refreshPopovers();
    this.refresh();
  },
  methods: {
    getDayEvent: function getDayEvent(origEvent) {
      return _objectSpread2$1(_objectSpread2$1({}, this.dayEvent), {}, {
        event: origEvent
      });
    },
    click: function click(e2) {
      this.$emit("dayclick", this.getDayEvent(e2));
    },
    mouseenter: function mouseenter(e2) {
      this.$emit("daymouseenter", this.getDayEvent(e2));
    },
    mouseleave: function mouseleave(e2) {
      this.$emit("daymouseleave", this.getDayEvent(e2));
    },
    focusin: function focusin(e2) {
      this.$emit("dayfocusin", this.getDayEvent(e2));
    },
    focusout: function focusout(e2) {
      this.$emit("dayfocusout", this.getDayEvent(e2));
    },
    keydown: function keydown(e2) {
      this.$emit("daykeydown", this.getDayEvent(e2));
    },
    refresh: function refresh() {
      var _this2 = this;
      if (!this.day.shouldRefresh)
        return;
      this.day.shouldRefresh = false;
      var glyphs = {
        backgrounds: [],
        dots: [],
        bars: [],
        popovers: [],
        content: []
      };
      this.day.attributes = Object.values(this.day.attributesMap || {}).sort(function(a3, b2) {
        return a3.order - b2.order;
      });
      this.day.attributes.forEach(function(attr) {
        var targetDate = attr.targetDate;
        var isDate3 = targetDate.isDate, isComplex = targetDate.isComplex, startTime2 = targetDate.startTime, endTime2 = targetDate.endTime;
        var onStart = _this2.startTime <= startTime2;
        var onEnd = _this2.endTime >= endTime2;
        var onStartAndEnd = onStart && onEnd;
        var onStartOrEnd = onStart || onEnd;
        var dateInfo = {
          isDate: isDate3,
          isComplex,
          onStart,
          onEnd,
          onStartAndEnd,
          onStartOrEnd
        };
        _this2.processHighlight(attr, dateInfo, glyphs);
        _this2.processNonHighlight(attr, "content", dateInfo, glyphs.content);
        _this2.processNonHighlight(attr, "dot", dateInfo, glyphs.dots);
        _this2.processNonHighlight(attr, "bar", dateInfo, glyphs.bars);
        _this2.processPopover(attr, glyphs);
      });
      this.glyphs = glyphs;
    },
    processHighlight: function processHighlight(_ref4, _ref5, _ref6) {
      var key = _ref4.key, highlight = _ref4.highlight;
      var isDate3 = _ref5.isDate, isComplex = _ref5.isComplex, onStart = _ref5.onStart, onEnd = _ref5.onEnd, onStartAndEnd = _ref5.onStartAndEnd;
      var backgrounds2 = _ref6.backgrounds, content3 = _ref6.content;
      if (!highlight)
        return;
      var base = highlight.base, start2 = highlight.start, end2 = highlight.end;
      if (isDate3 || isComplex) {
        backgrounds2.push({
          key,
          wrapperClass: "vc-day-layer vc-day-box-center-center",
          class: ["vc-highlight", start2.class],
          style: start2.style
        });
        content3.push({
          key: "".concat(key, "-content"),
          class: start2.contentClass,
          style: start2.contentStyle
        });
      } else if (onStartAndEnd) {
        backgrounds2.push({
          key,
          wrapperClass: "vc-day-layer vc-day-box-center-center",
          class: ["vc-highlight", start2.class],
          style: start2.style
        });
        content3.push({
          key: "".concat(key, "-content"),
          class: start2.contentClass,
          style: start2.contentStyle
        });
      } else if (onStart) {
        backgrounds2.push({
          key: "".concat(key, "-base"),
          wrapperClass: "vc-day-layer vc-day-box-right-center",
          class: ["vc-highlight vc-highlight-base-start", base.class],
          style: base.style
        });
        backgrounds2.push({
          key,
          wrapperClass: "vc-day-layer vc-day-box-center-center",
          class: ["vc-highlight", start2.class],
          style: start2.style
        });
        content3.push({
          key: "".concat(key, "-content"),
          class: start2.contentClass,
          style: start2.contentStyle
        });
      } else if (onEnd) {
        backgrounds2.push({
          key: "".concat(key, "-base"),
          wrapperClass: "vc-day-layer vc-day-box-left-center",
          class: ["vc-highlight vc-highlight-base-end", base.class],
          style: base.style
        });
        backgrounds2.push({
          key,
          wrapperClass: "vc-day-layer vc-day-box-center-center",
          class: ["vc-highlight", end2.class],
          style: end2.style
        });
        content3.push({
          key: "".concat(key, "-content"),
          class: end2.contentClass,
          style: end2.contentStyle
        });
      } else {
        backgrounds2.push({
          key: "".concat(key, "-middle"),
          wrapperClass: "vc-day-layer vc-day-box-center-center",
          class: ["vc-highlight vc-highlight-base-middle", base.class],
          style: base.style
        });
        content3.push({
          key: "".concat(key, "-content"),
          class: base.contentClass,
          style: base.contentStyle
        });
      }
    },
    processNonHighlight: function processNonHighlight(attr, itemKey, _ref7, list) {
      var isDate3 = _ref7.isDate, onStart = _ref7.onStart, onEnd = _ref7.onEnd;
      if (!attr[itemKey])
        return;
      var key = attr.key;
      var className = "vc-".concat(itemKey);
      var _attr$itemKey = attr[itemKey], base = _attr$itemKey.base, start2 = _attr$itemKey.start, end2 = _attr$itemKey.end;
      if (isDate3 || onStart) {
        list.push({
          key,
          class: [className, start2.class],
          style: start2.style
        });
      } else if (onEnd) {
        list.push({
          key,
          class: [className, end2.class],
          style: end2.style
        });
      } else {
        list.push({
          key,
          class: [className, base.class],
          style: base.style
        });
      }
    },
    processPopover: function processPopover(attribute, _ref8) {
      var popovers3 = _ref8.popovers;
      var key = attribute.key, customData = attribute.customData, popover = attribute.popover;
      if (!popover)
        return;
      var resolvedPopover = defaults_1$1({
        key,
        customData,
        attribute
      }, _objectSpread2$1({}, popover), {
        visibility: popover.label ? "hover" : "click",
        placement: "bottom",
        isInteractive: !popover.label
      });
      popovers3.splice(0, 0, resolvedPopover);
    },
    refreshPopovers: function refreshPopovers() {
      var popoverEvents = {};
      if (arrayHasItems(this.popovers)) {
        popoverEvents = getPopoverTriggerEvents(defaults_1$1.apply(void 0, [{
          id: this.dayPopoverId,
          data: this.day,
          isRenderFn: true
        }].concat(_toConsumableArray(this.popovers))));
      }
      this.dayContentEvents = mergeEvents({
        onClick: this.click,
        onMouseenter: this.mouseenter,
        onMouseleave: this.mouseleave,
        onFocusin: this.focusin,
        onFocusout: this.focusout,
        onKeydown: this.keydown
      }, popoverEvents);
      updatePopover({
        id: this.dayPopoverId,
        data: this.day
      });
    }
  }
};
var css_248z$9 = ".vc-day {\n  position: relative;\n  min-height: 32px;\n  z-index: 1;\n}\n.vc-day.is-not-in-month * {\n    opacity: 0;\n    pointer-events: none;\n}\n.vc-day-layer {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n}\n.vc-day-box-center-center {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-transform-origin: 50% 50%;\n          transform-origin: 50% 50%;\n}\n.vc-day-box-left-center {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: flex-start;\n      -ms-flex-pack: start;\n          justify-content: flex-start;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-transform-origin: 0% 50%;\n          transform-origin: 0% 50%;\n}\n.vc-day-box-right-center {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: flex-end;\n      -ms-flex-pack: end;\n          justify-content: flex-end;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-transform-origin: 100% 50%;\n          transform-origin: 100% 50%;\n}\n.vc-day-box-center-bottom {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: flex-end;\n      -ms-flex-align: end;\n          align-items: flex-end;\n}\n.vc-day-content {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  font-size: var(--text-sm);\n  font-weight: var(--font-medium);\n  width: 28px;\n  height: 28px;\n  line-height: 28px;\n  border-radius: var(--rounded-full);\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  cursor: pointer;\n}\n.vc-day-content:hover {\n    background-color: hsla(211, 25%, 84%, 0.3);\n}\n.vc-day-content:focus {\n    font-weight: var(--font-bold);\n    background-color: hsla(211, 25%, 84%, 0.4);\n}\n.vc-day-content.is-disabled {\n    color: var(--gray-400);\n}\n.vc-is-dark .vc-day-content:hover {\n      background-color: hsla(216, 15%, 52%, 0.3);\n}\n.vc-is-dark .vc-day-content:focus {\n      background-color: hsla(216, 15%, 52%, 0.4);\n}\n.vc-is-dark .vc-day-content.is-disabled {\n      color: var(--gray-600);\n}\n.vc-highlights {\n  overflow: hidden;\n  pointer-events: none;\n  z-index: -1;\n}\n.vc-highlight {\n  width: 28px;\n  height: 28px;\n}\n.vc-highlight.vc-highlight-base-start {\n    width: 50% !important;\n    border-radius: 0 !important;\n    border-right-width: 0 !important;\n}\n.vc-highlight.vc-highlight-base-end {\n    width: 50% !important;\n    border-radius: 0 !important;\n    border-left-width: 0 !important;\n}\n.vc-highlight.vc-highlight-base-middle {\n    width: 100%;\n    border-radius: 0 !important;\n    border-left-width: 0 !important;\n    border-right-width: 0 !important;\n    margin: 0 -1px;\n}\n.vc-dots {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n.vc-dot {\n  width: 5px;\n  height: 5px;\n  border-radius: 50%;\n  transition: all var(--day-content-transition-time);\n}\n.vc-dot:not(:last-child) {\n    margin-right: 3px;\n}\n.vc-bars {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: flex-start;\n      -ms-flex-pack: start;\n          justify-content: flex-start;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  width: 75%;\n}\n.vc-bar {\n  -webkit-flex-grow: 1;\n      -ms-flex-positive: 1;\n          flex-grow: 1;\n  height: 3px;\n  transition: all var(--day-content-transition-time);\n}\n";
styleInject(css_248z$9);
var boolTag$1 = "[object Boolean]";
function isBoolean$1(value2) {
  return value2 === true || value2 === false || isObjectLike_1(value2) && _baseGetTag(value2) == boolTag$1;
}
var isBoolean_1 = isBoolean$1;
var script$9 = {
  name: "CalendarPane",
  emits: ["update:page", "weeknumberclick"],
  mixins: [childMixin$1, slotMixin$1],
  inheritAttrs: false,
  render: function render2() {
    var _this = this;
    var header = this.safeSlot("header", this.page) || h$5("div", {
      class: "vc-header align-".concat(this.titlePosition)
    }, [
      h$5("div", _objectSpread2$1({
        class: "vc-title"
      }, this.navPopoverEvents), [this.safeSlot("header-title", this.page, this.page.title)])
    ]);
    var weekdayCells = this.weekdayLabels.map(function(wl, i2) {
      return h$5("div", {
        key: i2 + 1,
        class: "vc-weekday"
      }, [wl]);
    });
    var showWeeknumbersLeft = this.showWeeknumbers_.startsWith("left");
    var showWeeknumbersRight = this.showWeeknumbers_.startsWith("right");
    if (showWeeknumbersLeft) {
      weekdayCells.unshift(h$5("div", {
        class: "vc-weekday"
      }));
    } else if (showWeeknumbersRight) {
      weekdayCells.push(h$5("div", {
        class: "vc-weekday"
      }));
    }
    var getWeeknumberCell = function getWeeknumberCell2(weeknumber) {
      return h$5("div", {
        class: ["vc-weeknumber"]
      }, [h$5("span", {
        class: ["vc-weeknumber-content", "is-".concat(_this.showWeeknumbers_)],
        onClick: function onClick2(event) {
          _this.$emit("weeknumberclick", {
            weeknumber,
            days: _this.page.days.filter(function(d3) {
              return d3[_this.weeknumberKey] === weeknumber;
            }),
            event
          });
        }
      }, [weeknumber])]);
    };
    var dayCells = [];
    var daysInWeek2 = this.locale.daysInWeek;
    this.page.days.forEach(function(day, i2) {
      var mod = i2 % daysInWeek2;
      if (showWeeknumbersLeft && mod === 0 || showWeeknumbersRight && mod === daysInWeek2) {
        dayCells.push(getWeeknumberCell(day[_this.weeknumberKey]));
      }
      dayCells.push(h$5(script$a, _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
        day
      }), _this.$slots));
      if (showWeeknumbersRight && mod === daysInWeek2 - 1) {
        dayCells.push(getWeeknumberCell(day[_this.weeknumberKey]));
      }
    });
    var weeks = h$5("div", {
      class: {
        "vc-weeks": true,
        "vc-show-weeknumbers": this.showWeeknumbers_,
        "is-left": showWeeknumbersLeft,
        "is-right": showWeeknumbersRight
      }
    }, [weekdayCells, dayCells]);
    return h$5("div", {
      class: ["vc-pane", "row-from-end-".concat(this.rowFromEnd), "column-from-end-".concat(this.columnFromEnd)],
      ref: "pane"
    }, [header, weeks]);
  },
  props: {
    page: Object,
    position: Number,
    row: Number,
    rowFromEnd: Number,
    column: Number,
    columnFromEnd: Number,
    titlePosition: String,
    navVisibility: {
      type: String,
      default: getDefault("navVisibility")
    },
    showWeeknumbers: [Boolean, String],
    showIsoWeeknumbers: [Boolean, String]
  },
  computed: {
    weeknumberKey: function weeknumberKey() {
      return this.showWeeknumbers ? "weeknumber" : "isoWeeknumber";
    },
    showWeeknumbers_: function showWeeknumbers_() {
      var showWeeknumbers = this.showWeeknumbers || this.showIsoWeeknumbers;
      if (showWeeknumbers == null)
        return "";
      if (isBoolean_1(showWeeknumbers)) {
        return showWeeknumbers ? "left" : "";
      }
      if (showWeeknumbers.startsWith("right")) {
        return this.columnFromEnd > 1 ? "right" : showWeeknumbers;
      }
      return this.column > 1 ? "left" : showWeeknumbers;
    },
    navPlacement: function navPlacement() {
      switch (this.titlePosition) {
        case "left":
          return "bottom-start";
        case "right":
          return "bottom-end";
        default:
          return "bottom";
      }
    },
    navPopoverEvents: function navPopoverEvents() {
      var sharedState = this.sharedState, navVisibility = this.navVisibility, navPlacement2 = this.navPlacement, page = this.page, position = this.position;
      return getPopoverTriggerEvents({
        id: sharedState.navPopoverId,
        visibility: navVisibility,
        placement: navPlacement2,
        modifiers: [{
          name: "flip",
          options: {
            fallbackPlacements: ["bottom"]
          }
        }],
        data: {
          page,
          position
        },
        isInteractive: true,
        isRenderFn: true
      });
    },
    weekdayLabels: function weekdayLabels() {
      var _this2 = this;
      return this.locale.getWeekdayDates().map(function(d3) {
        return _this2.format(d3, _this2.masks.weekdays);
      });
    }
  }
};
var css_248z$8 = ".vc-pane {\n  min-width: 250px;\n}\n.vc-header {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  padding: 10px 16px 0px 16px;\n}\n.vc-header.align-left {\n    -webkit-justify-content: flex-start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n}\n.vc-header.align-right {\n    -webkit-justify-content: flex-end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n}\n.vc-title {\n  font-size: var(--text-lg);\n  color: var(--gray-800);\n  font-weight: var(--font-semibold);\n  line-height: 28px;\n  cursor: pointer;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  white-space: nowrap;\n}\n.vc-title:hover {\n    opacity: 0.75;\n}\n.vc-weeknumber {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  position: relative;\n}\n.vc-weeknumber-content {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  font-style: italic;\n  width: 28px;\n  height: 28px;\n  margin-top: 2px;\n  color: var(--gray-500);\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-weeknumber-content.is-left-outside {\n    position: absolute;\n    left: var(--weeknumber-offset);\n}\n.vc-weeknumber-content.is-right-outside {\n    position: absolute;\n    right: var(--weeknumber-offset);\n}\n.vc-weeks {\n  display: grid;\n  grid-template-columns: repeat(7, 1fr);\n  position: relative;\n  /* overflow: auto; */\n  -webkit-overflow-scrolling: touch;\n  padding: 6px;\n  min-width: 250px;\n}\n.vc-weeks.vc-show-weeknumbers {\n    grid-template-columns: auto repeat(7, 1fr);\n}\n.vc-weeks.vc-show-weeknumbers.is-right {\n      grid-template-columns: repeat(7, 1fr) auto;\n}\n.vc-weekday {\n  text-align: center;\n  color: var(--gray-500);\n  font-size: var(--text-sm);\n  font-weight: var(--font-bold);\n  line-height: 14px;\n  padding-top: 4px;\n  padding-bottom: 8px;\n  cursor: default;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-weekdays {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.vc-nav-popover-container {\n  color: var(--white);\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  background-color: var(--gray-800);\n  border: 1px solid;\n  border-color: var(--gray-700);\n  border-radius: var(--rounded-lg);\n  padding: 4px;\n  box-shadow: var(--shadow);\n}\n.vc-is-dark .vc-header {\n    color: var(--gray-200);\n}\n.vc-is-dark .vc-title {\n    color: var(--gray-100);\n}\n.vc-is-dark .vc-weekday {\n    color: var(--accent-200);\n}\n.vc-is-dark .vc-nav-popover-container {\n    color: var(--gray-800);\n    background-color: var(--white);\n    border-color: var(--gray-100);\n}\n";
styleInject(css_248z$8);
var _defSize = "26px";
var _defViewBox = "0 0 32 32";
var icons = {
  "left-arrow": {
    viewBox: "0 -1 16 34",
    path: "M11.196 10c0 0.143-0.071 0.304-0.179 0.411l-7.018 7.018 7.018 7.018c0.107 0.107 0.179 0.268 0.179 0.411s-0.071 0.304-0.179 0.411l-0.893 0.893c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-8.321-8.321c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l8.321-8.321c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l0.893 0.893c0.107 0.107 0.179 0.25 0.179 0.411z"
  },
  "right-arrow": {
    viewBox: "-5 -1 16 34",
    path: "M10.625 17.429c0 0.143-0.071 0.304-0.179 0.411l-8.321 8.321c-0.107 0.107-0.268 0.179-0.411 0.179s-0.304-0.071-0.411-0.179l-0.893-0.893c-0.107-0.107-0.179-0.25-0.179-0.411 0-0.143 0.071-0.304 0.179-0.411l7.018-7.018-7.018-7.018c-0.107-0.107-0.179-0.268-0.179-0.411s0.071-0.304 0.179-0.411l0.893-0.893c0.107-0.107 0.268-0.179 0.411-0.179s0.304 0.071 0.411 0.179l8.321 8.321c0.107 0.107 0.179 0.268 0.179 0.411z"
  }
};
var script$8 = {
  props: ["name"],
  data: function data2() {
    return {
      width: _defSize,
      height: _defSize,
      viewBox: _defViewBox,
      path: "",
      isBaseline: false
    };
  },
  mounted: function mounted2() {
    this.updateIcon();
  },
  watch: {
    name: function name() {
      this.updateIcon();
    }
  },
  methods: {
    updateIcon: function updateIcon() {
      var icon = icons[this.name];
      if (icon) {
        this.width = icon.width || _defSize;
        this.height = icon.height || _defSize;
        this.viewBox = icon.viewBox;
        this.path = icon.path;
      }
    }
  }
};
function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("svg", {
    class: "vc-svg-icon",
    width: $data.width,
    height: $data.height,
    viewBox: $data.viewBox
  }, [createVNode("path", {
    d: $data.path
  }, null, 8, ["d"])], 8, ["width", "height", "viewBox"]);
}
var css_248z$7 = ".vc-svg-icon {\n  display: inline-block;\n  stroke: currentColor;\n  stroke-width: 0;\n}\n.vc-svg-icon path {\n    fill: currentColor;\n}\n";
styleInject(css_248z$7);
script$8.render = render$6;
function head(array) {
  return array && array.length ? array[0] : void 0;
}
var head_1 = head;
var _yearGroupCount = 12;
var script$7 = {
  name: "CalendarNav",
  emits: ["input"],
  components: {
    SvgIcon: script$8
  },
  mixins: [childMixin$1],
  props: {
    value: {
      type: Object,
      default: function _default() {
        return {
          month: 0,
          year: 0
        };
      }
    },
    validator: {
      type: Function,
      default: function _default2() {
        return function() {
          return true;
        };
      }
    }
  },
  data: function data3() {
    return {
      monthMode: true,
      yearIndex: 0,
      yearGroupIndex: 0,
      onSpaceOrEnter
    };
  },
  computed: {
    month: function month() {
      return this.value ? this.value.month || 0 : 0;
    },
    year: function year() {
      return this.value ? this.value.year || 0 : 0;
    },
    title: function title2() {
      return this.monthMode ? this.yearIndex : "".concat(this.firstYear, " - ").concat(this.lastYear);
    },
    monthItems: function monthItems() {
      return this.getMonthItems(this.yearIndex);
    },
    yearItems: function yearItems() {
      return this.getYearItems(this.yearGroupIndex);
    },
    prevItemsEnabled: function prevItemsEnabled() {
      return this.monthMode ? this.prevMonthItemsEnabled : this.prevYearItemsEnabled;
    },
    nextItemsEnabled: function nextItemsEnabled() {
      return this.monthMode ? this.nextMonthItemsEnabled : this.nextYearItemsEnabled;
    },
    prevMonthItemsEnabled: function prevMonthItemsEnabled() {
      return this.getMonthItems(this.yearIndex - 1).some(function(i2) {
        return !i2.isDisabled;
      });
    },
    nextMonthItemsEnabled: function nextMonthItemsEnabled() {
      return this.getMonthItems(this.yearIndex + 1).some(function(i2) {
        return !i2.isDisabled;
      });
    },
    prevYearItemsEnabled: function prevYearItemsEnabled() {
      return this.getYearItems(this.yearGroupIndex - 1).some(function(i2) {
        return !i2.isDisabled;
      });
    },
    nextYearItemsEnabled: function nextYearItemsEnabled() {
      return this.getYearItems(this.yearGroupIndex + 1).some(function(i2) {
        return !i2.isDisabled;
      });
    },
    activeItems: function activeItems() {
      return this.monthMode ? this.monthItems : this.yearItems;
    },
    firstYear: function firstYear() {
      return head_1(this.yearItems.map(function(i2) {
        return i2.year;
      }));
    },
    lastYear: function lastYear() {
      return last_1(this.yearItems.map(function(i2) {
        return i2.year;
      }));
    }
  },
  watch: {
    year: function year2() {
      this.yearIndex = this.year;
    },
    yearIndex: function yearIndex(val) {
      this.yearGroupIndex = this.getYearGroupIndex(val);
    },
    value: function value() {
      this.focusFirstItem();
    }
  },
  created: function created() {
    this.yearIndex = this.year;
  },
  mounted: function mounted3() {
    this.focusFirstItem();
  },
  methods: {
    focusFirstItem: function focusFirstItem() {
      var _this = this;
      this.$nextTick(function() {
        var focusableEl = _this.$refs.navContainer.querySelector(".vc-nav-item:not(.is-disabled)");
        if (focusableEl) {
          focusableEl.focus();
        }
      });
    },
    getItemClasses: function getItemClasses(_ref) {
      var isActive = _ref.isActive, isCurrent = _ref.isCurrent, isDisabled2 = _ref.isDisabled;
      var classes = ["vc-nav-item"];
      if (isActive) {
        classes.push("is-active");
      } else if (isCurrent) {
        classes.push("is-current");
      }
      if (isDisabled2) {
        classes.push("is-disabled");
      }
      return classes;
    },
    getYearGroupIndex: function getYearGroupIndex(year3) {
      return Math.floor(year3 / _yearGroupCount);
    },
    getMonthItems: function getMonthItems(year3) {
      var _this2 = this;
      var _this$pageForDate = this.pageForDate(new Date()), thisMonth = _this$pageForDate.month, thisYear = _this$pageForDate.year;
      return this.locale.getMonthDates().map(function(d3, i2) {
        var month2 = i2 + 1;
        return {
          month: month2,
          year: year3,
          id: "".concat(year3, ".").concat(pad$1(month2, 2)),
          label: _this2.locale.format(d3, _this2.masks.navMonths),
          ariaLabel: _this2.locale.format(d3, "MMMM YYYY"),
          isActive: month2 === _this2.month && year3 === _this2.year,
          isCurrent: month2 === thisMonth && year3 === thisYear,
          isDisabled: !_this2.validator({
            month: month2,
            year: year3
          }),
          click: function click2() {
            return _this2.monthClick(month2, year3);
          }
        };
      });
    },
    getYearItems: function getYearItems(yearGroupIndex) {
      var _this3 = this;
      var _this$pageForDate2 = this.pageForDate(new Date());
      _this$pageForDate2._;
      var thisYear = _this$pageForDate2.year;
      var startYear = yearGroupIndex * _yearGroupCount;
      var endYear = startYear + _yearGroupCount;
      var items = [];
      var _loop = function _loop2(year4) {
        var enabled = false;
        for (var month2 = 1; month2 < 12; month2++) {
          enabled = _this3.validator({
            month: month2,
            year: year4
          });
          if (enabled)
            break;
        }
        items.push({
          year: year4,
          id: year4,
          label: year4,
          ariaLabel: year4,
          isActive: year4 === _this3.year,
          isCurrent: year4 === thisYear,
          isDisabled: !enabled,
          click: function click2() {
            return _this3.yearClick(year4);
          }
        });
      };
      for (var year3 = startYear; year3 < endYear; year3 += 1) {
        _loop(year3);
      }
      return items;
    },
    monthClick: function monthClick(month2, year3) {
      if (this.validator({
        month: month2,
        year: year3
      })) {
        this.$emit("input", {
          month: month2,
          year: year3
        });
      }
    },
    yearClick: function yearClick(year3) {
      this.yearIndex = year3;
      this.monthMode = true;
      this.focusFirstItem();
    },
    toggleMode: function toggleMode() {
      this.monthMode = !this.monthMode;
    },
    movePrev: function movePrev() {
      if (!this.prevItemsEnabled)
        return;
      if (this.monthMode) {
        this.movePrevYear();
      }
      this.movePrevYearGroup();
    },
    moveNext: function moveNext() {
      if (!this.nextItemsEnabled)
        return;
      if (this.monthMode) {
        this.moveNextYear();
      }
      this.moveNextYearGroup();
    },
    movePrevYear: function movePrevYear() {
      this.yearIndex--;
    },
    moveNextYear: function moveNextYear() {
      this.yearIndex++;
    },
    movePrevYearGroup: function movePrevYearGroup() {
      this.yearGroupIndex--;
    },
    moveNextYearGroup: function moveNextYearGroup() {
      this.yearGroupIndex++;
    }
  }
};
var _hoisted_1$o = {
  class: "vc-nav-container",
  ref: "navContainer"
};
var _hoisted_2$n = {
  class: "vc-nav-header"
};
var _hoisted_3$g = {
  class: "vc-nav-items"
};
function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_svg_icon = resolveComponent("svg-icon");
  return openBlock(), createBlock("div", _hoisted_1$o, [createVNode("div", _hoisted_2$n, [createVNode("span", {
    role: "button",
    class: ["vc-nav-arrow is-left", {
      "is-disabled": !$options.prevItemsEnabled
    }],
    tabindex: $options.prevItemsEnabled ? 0 : void 0,
    onClick: _cache[1] || (_cache[1] = function() {
      return $options.movePrev.apply($options, arguments);
    }),
    onKeydown: _cache[2] || (_cache[2] = function(e2) {
      return $data.onSpaceOrEnter(e2, $options.movePrev);
    })
  }, [renderSlot(_ctx.$slots, "nav-left-button", {}, function() {
    return [createVNode(_component_svg_icon, {
      name: "left-arrow",
      width: "20px",
      height: "24px"
    })];
  })], 42, ["tabindex"]), createVNode("span", {
    role: "button",
    class: ["vc-nav-title vc-grid-focus", {
      "is-disabled": !$options.nextItemsEnabled
    }],
    style: {
      whiteSpace: "nowrap"
    },
    tabindex: $options.nextItemsEnabled ? 0 : void 0,
    onClick: _cache[3] || (_cache[3] = function() {
      return $options.toggleMode.apply($options, arguments);
    }),
    onKeydown: _cache[4] || (_cache[4] = function(e2) {
      return $data.onSpaceOrEnter(e2, $options.toggleMode);
    })
  }, toDisplayString($options.title), 43, ["tabindex"]), createVNode("span", {
    role: "button",
    class: "vc-nav-arrow is-right",
    tabindex: "0",
    onClick: _cache[5] || (_cache[5] = function() {
      return $options.moveNext.apply($options, arguments);
    }),
    onKeydown: _cache[6] || (_cache[6] = function(e2) {
      return $data.onSpaceOrEnter(e2, $options.moveNext);
    })
  }, [renderSlot(_ctx.$slots, "nav-right-button", {}, function() {
    return [createVNode(_component_svg_icon, {
      name: "right-arrow",
      width: "20px",
      height: "24px"
    })];
  })], 32)]), createVNode("div", _hoisted_3$g, [(openBlock(true), createBlock(
    Fragment,
    null,
    renderList($options.activeItems, function(item) {
      return openBlock(), createBlock("span", {
        key: item.label,
        role: "button",
        "data-id": item.id,
        "aria-label": item.ariaLabel,
        class: $options.getItemClasses(item),
        tabindex: item.isDisabled ? void 0 : 0,
        onClick: item.click,
        onKeydown: function onKeydown(e2) {
          return $data.onSpaceOrEnter(e2, item.click);
        }
      }, toDisplayString(item.label), 43, ["data-id", "aria-label", "tabindex", "onClick", "onKeydown"]);
    }),
    128
  ))])], 512);
}
var css_248z$6 = ".vc-nav-header {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: space-between;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n}\n.vc-nav-arrow {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  cursor: pointer;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  line-height: var(--leading-snug);\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: var(--rounded);\n}\n.vc-nav-arrow.is-left {\n    margin-right: auto;\n}\n.vc-nav-arrow.is-right {\n    margin-left: auto;\n}\n.vc-nav-arrow.is-disabled {\n    opacity: 0.25;\n    pointer-events: none;\n    cursor: not-allowed;\n}\n.vc-nav-arrow:hover {\n    background-color: var(--gray-900);\n}\n.vc-nav-arrow:focus {\n    border-color: var(--accent-600);\n}\n.vc-nav-title {\n  color: var(--accent-100);\n  font-weight: var(--font-bold);\n  line-height: var(--leading-snug);\n  padding: 4px 8px;\n  border-radius: var(--rounded);\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-nav-title:hover {\n    background-color: var(--gray-900);\n}\n.vc-nav-title:focus {\n    border-color: var(--accent-600);\n}\n.vc-nav-items {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  grid-row-gap: 2px;\n  grid-column-gap: 5px;\n}\n.vc-nav-item {\n  width: 48px;\n  text-align: center;\n  line-height: var(--leading-snug);\n  font-weight: var(--font-semibold);\n  padding: 4px 0;\n  cursor: pointer;\n  border-width: 2px;\n  border-style: solid;\n  border-color: transparent;\n  border-radius: var(--rounded);\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vc-nav-item:hover {\n    color: var(--white);\n    background-color: var(--gray-900);\n    box-shadow: var(--shadow-inner);\n}\n.vc-nav-item.is-active {\n    color: var(--accent-900);\n    background: var(--accent-100);\n    font-weight: var(--font-bold);\n    box-shadow: var(--shadow);\n}\n.vc-nav-item.is-current {\n    color: var(--accent-100);\n    font-weight: var(--bold);\n    border-color: var(--accent-100);\n}\n.vc-nav-item:focus {\n    border-color: var(--accent-600);\n}\n.vc-nav-item.is-disabled {\n    opacity: 0.25;\n    pointer-events: none;\n}\n.vc-is-dark .vc-nav-title {\n    color: var(--gray-900);\n}\n.vc-is-dark .vc-nav-title:hover {\n      background-color: var(--gray-200);\n}\n.vc-is-dark .vc-nav-title:focus {\n      border-color: var(--accent-400);\n}\n.vc-is-dark .vc-nav-arrow:hover {\n      background-color: var(--gray-200);\n}\n.vc-is-dark .vc-nav-arrow:focus {\n      border-color: var(--accent-400);\n}\n.vc-is-dark .vc-nav-item:hover {\n      color: var(--gray-900);\n      background-color: var(--gray-200);\n      box-shadow: none;\n}\n.vc-is-dark .vc-nav-item.is-active {\n      color: var(--white);\n      background: var(--accent-500);\n}\n.vc-is-dark .vc-nav-item.is-current {\n      color: var(--accent-600);\n      border-color: var(--accent-500);\n}\n.vc-is-dark .vc-nav-item:focus {\n      border-color: var(--accent-400);\n}\n";
styleInject(css_248z$6);
script$7.render = render$5;
var script$6 = {
  name: "CustomTransition",
  emits: ["before-enter", "before-transition", "after-enter", "after-transition"],
  props: {
    name: String,
    appear: Boolean
  },
  computed: {
    name_: function name_() {
      return "vc-".concat(this.name || "none");
    }
  },
  methods: {
    beforeEnter: function beforeEnter(el) {
      this.$emit("before-enter", el);
      this.$emit("before-transition", el);
    },
    afterEnter: function afterEnter(el) {
      this.$emit("after-enter", el);
      this.$emit("after-transition", el);
    }
  }
};
function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: $options.name_,
    appear: $props.appear,
    onBeforeEnter: $options.beforeEnter,
    onAfterEnter: $options.afterEnter
  }, {
    default: withCtx(function() {
      return [renderSlot(_ctx.$slots, "default")];
    }),
    _: 3
  }, 8, ["name", "appear", "onBeforeEnter", "onAfterEnter"]);
}
var css_248z$5 = ".vc-none-enter-active,\n.vc-none-leave-active {\n  transition-duration: 0s;\n}\n.vc-fade-enter-active,\n.vc-fade-leave-active,\n.vc-slide-left-enter-active,\n.vc-slide-left-leave-active,\n.vc-slide-right-enter-active,\n.vc-slide-right-leave-active,\n.vc-slide-up-enter-active,\n.vc-slide-up-leave-active,\n.vc-slide-down-enter-active,\n.vc-slide-down-leave-active,\n.vc-slide-fade-enter-active,\n.vc-slide-fade-leave-active {\n  transition: opacity var(--slide-duration) var(--slide-timing),\n    -webkit-transform var(--slide-duration) var(--slide-timing);\n  transition: transform var(--slide-duration) var(--slide-timing),\n    opacity var(--slide-duration) var(--slide-timing);\n  transition: transform var(--slide-duration) var(--slide-timing),\n    opacity var(--slide-duration) var(--slide-timing),\n    -webkit-transform var(--slide-duration) var(--slide-timing);\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  pointer-events: none;\n}\n.vc-none-leave-active,\n.vc-fade-leave-active,\n.vc-slide-left-leave-active,\n.vc-slide-right-leave-active,\n.vc-slide-up-leave-active,\n.vc-slide-down-leave-active {\n  position: absolute !important;\n  width: 100%;\n}\n.vc-none-enter-from,\n.vc-none-leave-to,\n.vc-fade-enter-from,\n.vc-fade-leave-to,\n.vc-slide-left-enter-from,\n.vc-slide-left-leave-to,\n.vc-slide-right-enter-from,\n.vc-slide-right-leave-to,\n.vc-slide-up-enter-from,\n.vc-slide-up-leave-to,\n.vc-slide-down-enter-from,\n.vc-slide-down-leave-to,\n.vc-slide-fade-enter-from,\n.vc-slide-fade-leave-to {\n  opacity: 0;\n}\n.vc-slide-left-enter-from,\n.vc-slide-right-leave-to,\n.vc-slide-fade-enter-from.direction-left,\n.vc-slide-fade-leave-to.direction-left {\n  -webkit-transform: translateX(var(--slide-translate));\n          transform: translateX(var(--slide-translate));\n}\n.vc-slide-right-enter-from,\n.vc-slide-left-leave-to,\n.vc-slide-fade-enter-from.direction-right,\n.vc-slide-fade-leave-to.direction-right {\n  -webkit-transform: translateX(calc(-1 * var(--slide-translate)));\n          transform: translateX(calc(-1 * var(--slide-translate)));\n}\n.vc-slide-up-enter-from,\n.vc-slide-down-leave-to,\n.vc-slide-fade-enter-from.direction-top,\n.vc-slide-fade-leave-to.direction-top {\n  -webkit-transform: translateY(var(--slide-translate));\n          transform: translateY(var(--slide-translate));\n}\n.vc-slide-down-enter-from,\n.vc-slide-up-leave-to,\n.vc-slide-fade-enter-from.direction-bottom,\n.vc-slide-fade-leave-to.direction-bottom {\n  -webkit-transform: translateY(calc(-1 * var(--slide-translate)));\n          transform: translateY(calc(-1 * var(--slide-translate)));\n}\n";
styleInject(css_248z$5);
script$6.render = render$4;
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name2) {
    var style2 = state2.styles[name2] || {};
    var attributes = state2.attributes[name2] || {};
    var element = state2.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name3) {
      var value2 = attributes[name3];
      if (value2 === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value2 === true ? "" : value2);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name2) {
      var element = state2.elements[name2];
      var attributes = state2.attributes[name2] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name2) ? state2.styles[name2] : initialStyles[name2]);
      var style2 = styleProperties.reduce(function(style3, property2) {
        style3[property2] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent2, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent2.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent2.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value2, max$1) {
  return max(min$1, min(value2, max$1));
}
function withinMaxClamp(min2, value2, max2) {
  var v2 = within(min2, value2, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value2, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value2;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state2.elements.popper, arrowElement)) {
    {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x2 = _ref.x, y2 = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  {
    var transitionProperty = getComputedStyle$1(state2.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property2) {
      return transitionProperty.indexOf(property2) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
    {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a3, b2) {
    return overflows[a3] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state2.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i2 = 0; i2 < placements2.length; i2++) {
    var placement = placements2[i2];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name2]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data9 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data9[state2.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x2;
    state2.modifiersData.popperOffsets.y += y2;
  }
  state2.modifiersData[name2] = data9;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  state2.modifiersData[name2] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data9 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data9[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data9[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name2] = data9;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}
function format2(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p2, c2) {
    return p2.replace(/%s/, c2);
  }, str);
}
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value2, index2, self2) {
      return self2.indexOf(value2) === index2;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format2(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format2(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s3) {
            return '"' + s3 + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format2(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}
function uniqueBy(arr, fn3) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn3(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions, state2.options, options2);
        state2.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m3) {
          return m3.enabled;
        });
        {
          var modifiers = uniqueBy([].concat(orderedModifiers, state2.options.modifiers), function(_ref) {
            var name2 = _ref.name;
            return name2;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state2.options.placement) === auto) {
            var flipModifier = state2.orderedModifiers.find(function(_ref2) {
              var name2 = _ref2.name;
              return name2 === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle$1(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
          {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state2.reset === true) {
            state2.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state2 = fn3({
              state: state2,
              options: _options,
              name: name2,
              instance
            }) || state2;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy3() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state3) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref3) {
        var name2 = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state: state2,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var script$5 = {
  name: "Popover",
  emits: ["before-show", "after-show", "before-hide", "after-hide"],
  render: function render3() {
    var _this = this;
    return h$5("div", {
      class: ["vc-popover-content-wrapper", {
        "is-interactive": this.isInteractive
      }],
      ref: "popover"
    }, [h$5(script$6, {
      name: this.transition,
      appear: true,
      "on-before-enter": this.beforeEnter,
      "on-after-enter": this.afterEnter,
      "on-before-leave": this.beforeLeave,
      "on-after-leave": this.afterLeave
    }, {
      default: function _default5() {
        return _this.isVisible ? h$5("div", {
          tabindex: -1,
          class: ["vc-popover-content", "direction-".concat(_this.direction), _this.contentClass],
          style: _this.contentStyle
        }, [_this.content, h$5("span", {
          class: ["vc-popover-caret", "direction-".concat(_this.direction), "align-".concat(_this.alignment)]
        })]) : null;
      }
    })]);
  },
  props: {
    id: {
      type: String,
      required: true
    },
    contentClass: String
  },
  data: function data4() {
    return {
      ref: null,
      opts: null,
      data: null,
      transition: "slide-fade",
      transitionTranslate: "15px",
      transitionDuration: "0.15s",
      placement: "bottom",
      positionFixed: false,
      modifiers: [],
      isInteractive: false,
      isHovered: false,
      isFocused: false,
      showDelay: 0,
      hideDelay: 110,
      autoHide: false,
      popperEl: null
    };
  },
  computed: {
    content: function content2() {
      var _this2 = this;
      return isFunction_1(this.$slots.default) && this.$slots.default({
        direction: this.direction,
        alignment: this.alignment,
        data: this.data,
        updateLayout: this.setupPopper,
        hide: function hide3(opts2) {
          return _this2.hide(opts2);
        }
      }) || this.$slots.default;
    },
    contentStyle: function contentStyle() {
      return {
        "--slide-translate": this.transitionTranslate,
        "--slide-duration": this.transitionDuration
      };
    },
    popperOptions: function popperOptions() {
      return {
        placement: this.placement,
        strategy: this.positionFixed ? "fixed" : "absolute",
        modifiers: [{
          name: "onUpdate",
          enabled: true,
          phase: "afterWrite",
          fn: this.onPopperUpdate
        }].concat(_toConsumableArray(this.modifiers || [])),
        onFirstUpdate: this.onPopperUpdate
      };
    },
    isVisible: function isVisible() {
      return !!(this.ref && this.content);
    },
    direction: function direction() {
      return this.placement && this.placement.split("-")[0] || "bottom";
    },
    alignment: function alignment() {
      var isLeftRight = this.direction === "left" || this.direction === "right";
      var alignment2 = this.placement.split("-");
      alignment2 = alignment2.length > 1 ? alignment2[1] : "";
      if (["start", "top", "left"].includes(alignment2)) {
        return isLeftRight ? "top" : "left";
      }
      if (["end", "bottom", "right"].includes(alignment2)) {
        return isLeftRight ? "bottom" : "right";
      }
      return isLeftRight ? "middle" : "center";
    }
  },
  watch: {
    opts: function opts(val, oldVal) {
      if (oldVal && oldVal.callback) {
        oldVal.callback(_objectSpread2$1(_objectSpread2$1({}, oldVal), {}, {
          completed: !val,
          reason: val ? "Overridden by action" : null
        }));
      }
    }
  },
  mounted: function mounted4() {
    this.popoverEl = this.$refs.popover;
    this.addEvents();
  },
  beforeUnmount: function beforeUnmount() {
    this.destroyPopper();
    this.removeEvents();
    this.popoverEl = null;
  },
  methods: {
    addEvents: function addEvents() {
      on$2(this.popoverEl, "click", this.onClick);
      on$2(this.popoverEl, "mouseover", this.onMouseOver);
      on$2(this.popoverEl, "mouseleave", this.onMouseLeave);
      on$2(this.popoverEl, "focusin", this.onFocusIn);
      on$2(this.popoverEl, "focusout", this.onFocusOut);
      on$2(document, "keydown", this.onDocumentKeydown);
      on$2(document, "click", this.onDocumentClick);
      on$2(document, "show-popover", this.onDocumentShowPopover);
      on$2(document, "hide-popover", this.onDocumentHidePopover);
      on$2(document, "toggle-popover", this.onDocumentTogglePopover);
      on$2(document, "update-popover", this.onDocumentUpdatePopover);
    },
    removeEvents: function removeEvents() {
      off$1(this.popoverEl, "click", this.onClick);
      off$1(this.popoverEl, "mouseover", this.onMouseOver);
      off$1(this.popoverEl, "mouseleave", this.onMouseLeave);
      off$1(this.popoverEl, "focusin", this.onFocusIn);
      off$1(this.popoverEl, "focusout", this.onFocusOut);
      off$1(document, "keydown", this.onDocumentKeydown);
      off$1(document, "click", this.onDocumentClick);
      off$1(document, "show-popover", this.onDocumentShowPopover);
      off$1(document, "hide-popover", this.onDocumentHidePopover);
      off$1(document, "toggle-popover", this.onDocumentTogglePopover);
      off$1(document, "update-popover", this.onDocumentUpdatePopover);
    },
    onClick: function onClick(e2) {
      e2.stopPropagation();
    },
    onMouseOver: function onMouseOver() {
      this.isHovered = true;
      if (this.isInteractive)
        this.show();
    },
    onMouseLeave: function onMouseLeave() {
      this.isHovered = false;
      if (this.autoHide && !this.isFocused && (!this.ref || this.ref !== document.activeElement)) {
        this.hide();
      }
    },
    onFocusIn: function onFocusIn() {
      this.isFocused = true;
      if (this.isInteractive)
        this.show();
    },
    onFocusOut: function onFocusOut(e2) {
      if (!e2.relatedTarget || !elementContains(this.popoverEl, e2.relatedTarget)) {
        this.isFocused = false;
        if (!this.isHovered && this.autoHide)
          this.hide();
      }
    },
    onDocumentClick: function onDocumentClick(e2) {
      if (!this.$refs.popover || !this.ref) {
        return;
      }
      if (elementContains(this.popoverEl, e2.target) || elementContains(this.ref, e2.target)) {
        return;
      }
      this.hide();
    },
    onDocumentKeydown: function onDocumentKeydown(e2) {
      if (e2.key === "Esc" || e2.key === "Escape") {
        this.hide();
      }
    },
    onDocumentShowPopover: function onDocumentShowPopover(_ref) {
      var detail = _ref.detail;
      if (!detail.id || detail.id !== this.id)
        return;
      this.show(detail);
    },
    onDocumentHidePopover: function onDocumentHidePopover(_ref2) {
      var detail = _ref2.detail;
      if (!detail.id || detail.id !== this.id)
        return;
      this.hide(detail);
    },
    onDocumentTogglePopover: function onDocumentTogglePopover(_ref3) {
      var detail = _ref3.detail;
      if (!detail.id || detail.id !== this.id)
        return;
      this.toggle(detail);
    },
    onDocumentUpdatePopover: function onDocumentUpdatePopover(_ref4) {
      var detail = _ref4.detail;
      if (!detail.id || detail.id !== this.id)
        return;
      this.update(detail);
    },
    show: function show() {
      var _this3 = this;
      var opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      opts2.action = "show";
      var ref2 = opts2.ref || this.ref;
      var delay = opts2.showDelay >= 0 ? opts2.showDelay : this.showDelay;
      if (!ref2) {
        if (opts2.callback) {
          opts2.callback({
            completed: false,
            reason: "Invalid reference element provided"
          });
        }
        return;
      }
      clearTimeout(this.timeout);
      this.opts = opts2;
      var fn3 = function fn4() {
        Object.assign(_this3, omit_1(opts2, ["id"]));
        _this3.setupPopper();
        _this3.opts = null;
      };
      if (delay > 0) {
        this.timeout = setTimeout(function() {
          return fn3();
        }, delay);
      } else {
        fn3();
      }
    },
    hide: function hide2() {
      var _this4 = this;
      var opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      opts2.action = "hide";
      var ref2 = opts2.ref || this.ref;
      var delay = opts2.hideDelay >= 0 ? opts2.hideDelay : this.hideDelay;
      if (!this.ref || ref2 !== this.ref) {
        if (opts2.callback) {
          opts2.callback(_objectSpread2$1(_objectSpread2$1({}, opts2), {}, {
            completed: false,
            reason: this.ref ? "Invalid reference element provided" : "Popover already hidden"
          }));
        }
        return;
      }
      var fn3 = function fn4() {
        _this4.ref = null;
        _this4.opts = null;
      };
      clearTimeout(this.timeout);
      this.opts = opts2;
      if (delay > 0) {
        this.timeout = setTimeout(fn3, delay);
      } else {
        fn3();
      }
    },
    toggle: function toggle() {
      var opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this.isVisible && opts2.ref === this.ref) {
        this.hide(opts2);
      } else {
        this.show(opts2);
      }
    },
    update: function update2() {
      var opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.assign(this, omit_1(opts2, ["id"]));
      this.setupPopper();
    },
    setupPopper: function setupPopper() {
      var _this5 = this;
      this.$nextTick(function() {
        if (!_this5.ref || !_this5.$refs.popover)
          return;
        if (_this5.popper && _this5.popper.reference !== _this5.ref) {
          _this5.destroyPopper();
        }
        if (!_this5.popper) {
          _this5.popper = createPopper(_this5.ref, _this5.popoverEl, _this5.popperOptions);
        } else {
          _this5.popper.update();
        }
      });
    },
    onPopperUpdate: function onPopperUpdate(args) {
      if (args.placement) {
        this.placement = args.placement;
      } else if (args.state) {
        this.placement = args.state.placement;
      }
    },
    beforeEnter: function beforeEnter2(e2) {
      this.$emit("before-show", e2);
    },
    afterEnter: function afterEnter2(e2) {
      this.$emit("after-show", e2);
    },
    beforeLeave: function beforeLeave(e2) {
      this.$emit("before-hide", e2);
    },
    afterLeave: function afterLeave(e2) {
      this.destroyPopper();
      this.$emit("after-hide", e2);
    },
    destroyPopper: function destroyPopper() {
      if (this.popper) {
        this.popper.destroy();
        this.popper = null;
      }
    }
  }
};
var css_248z$4 = ".vc-popover-content-wrapper {\n  --popover-horizontal-content-offset: 8px;\n  --popover-vertical-content-offset: 10px;\n  --popover-caret-horizontal-offset: 18px;\n  --popover-caret-vertical-offset: 8px;\n\n  position: absolute;\n  display: block;\n  outline: none;\n  z-index: 10;\n}\n.vc-popover-content-wrapper:not(.is-interactive) {\n    pointer-events: none;\n}\n.vc-popover-content {\n  position: relative;\n  outline: none;\n  z-index: 10;\n  box-shadow: var(--shadow-lg);\n}\n.vc-popover-content.direction-bottom {\n    margin-top: var(--popover-vertical-content-offset);\n}\n.vc-popover-content.direction-top {\n    margin-bottom: var(--popover-vertical-content-offset);\n}\n.vc-popover-content.direction-left {\n    margin-right: var(--popover-horizontal-content-offset);\n}\n.vc-popover-content.direction-right {\n    margin-left: var(--popover-horizontal-content-offset);\n}\n.vc-popover-caret {\n  content: '';\n  position: absolute;\n  display: block;\n  width: 12px;\n  height: 12px;\n  border-top: inherit;\n  border-left: inherit;\n  background-color: inherit;\n  z-index: -1;\n}\n.vc-popover-caret.direction-bottom {\n    top: 0;\n}\n.vc-popover-caret.direction-bottom.align-left {\n      -webkit-transform: translateY(-50%) rotate(45deg);\n              transform: translateY(-50%) rotate(45deg);\n}\n.vc-popover-caret.direction-bottom.align-center {\n      -webkit-transform: translateX(-50%) translateY(-50%) rotate(45deg);\n              transform: translateX(-50%) translateY(-50%) rotate(45deg);\n}\n.vc-popover-caret.direction-bottom.align-right {\n      -webkit-transform: translateY(-50%) rotate(45deg);\n              transform: translateY(-50%) rotate(45deg);\n}\n.vc-popover-caret.direction-top {\n    top: 100%;\n}\n.vc-popover-caret.direction-top.align-left {\n      -webkit-transform: translateY(-50%) rotate(-135deg);\n              transform: translateY(-50%) rotate(-135deg);\n}\n.vc-popover-caret.direction-top.align-center {\n      -webkit-transform: translateX(-50%) translateY(-50%) rotate(-135deg);\n              transform: translateX(-50%) translateY(-50%) rotate(-135deg);\n}\n.vc-popover-caret.direction-top.align-right {\n      -webkit-transform: translateY(-50%) rotate(-135deg);\n              transform: translateY(-50%) rotate(-135deg);\n}\n.vc-popover-caret.direction-left {\n    left: 100%;\n}\n.vc-popover-caret.direction-left.align-top {\n      -webkit-transform: translateX(-50%) rotate(135deg);\n              transform: translateX(-50%) rotate(135deg);\n}\n.vc-popover-caret.direction-left.align-middle {\n      -webkit-transform: translateY(-50%) translateX(-50%) rotate(135deg);\n              transform: translateY(-50%) translateX(-50%) rotate(135deg);\n}\n.vc-popover-caret.direction-left.align-bottom {\n      -webkit-transform: translateX(-50%) rotate(135deg);\n              transform: translateX(-50%) rotate(135deg);\n}\n.vc-popover-caret.direction-right {\n    left: 0;\n}\n.vc-popover-caret.direction-right.align-top {\n      -webkit-transform: translateX(-50%) rotate(-45deg);\n              transform: translateX(-50%) rotate(-45deg);\n}\n.vc-popover-caret.direction-right.align-middle {\n      -webkit-transform: translateY(-50%) translateX(-50%) rotate(-45deg);\n              transform: translateY(-50%) translateX(-50%) rotate(-45deg);\n}\n.vc-popover-caret.direction-right.align-bottom {\n      -webkit-transform: translateX(-50%) rotate(-45deg);\n              transform: translateX(-50%) rotate(-45deg);\n}\n.vc-popover-caret.align-left {\n    left: var(--popover-caret-horizontal-offset);\n}\n.vc-popover-caret.align-center {\n    left: 50%;\n}\n.vc-popover-caret.align-right {\n    right: var(--popover-caret-horizontal-offset);\n}\n.vc-popover-caret.align-top {\n    top: var(--popover-caret-vertical-offset);\n}\n.vc-popover-caret.align-middle {\n    top: 50%;\n}\n.vc-popover-caret.align-bottom {\n    bottom: var(--popover-caret-vertical-offset);\n}\n";
styleInject(css_248z$4);
var script$4 = {
  name: "PopoverRow",
  mixins: [childMixin$1],
  props: {
    attribute: Object
  },
  computed: {
    indicator: function indicator() {
      var _this$attribute = this.attribute, highlight = _this$attribute.highlight, dot = _this$attribute.dot, bar = _this$attribute.bar, popover = _this$attribute.popover;
      if (popover && popover.hideIndicator)
        return null;
      if (highlight) {
        var _highlight$start = highlight.start, color = _highlight$start.color, isDark = _highlight$start.isDark;
        return {
          style: _objectSpread2$1(_objectSpread2$1({}, this.theme.bgAccentHigh({
            color,
            isDark: !isDark
          })), {}, {
            width: "10px",
            height: "5px",
            borderRadius: "3px"
          })
        };
      }
      if (dot) {
        var _dot$start = dot.start, _color = _dot$start.color, _isDark = _dot$start.isDark;
        return {
          style: _objectSpread2$1(_objectSpread2$1({}, this.theme.bgAccentHigh({
            color: _color,
            isDark: !_isDark
          })), {}, {
            width: "5px",
            height: "5px",
            borderRadius: "50%"
          })
        };
      }
      if (bar) {
        var _bar$start = bar.start, _color2 = _bar$start.color, _isDark2 = _bar$start.isDark;
        return {
          style: _objectSpread2$1(_objectSpread2$1({}, this.theme.bgAccentHigh({
            color: _color2,
            isDark: !_isDark2
          })), {}, {
            width: "10px",
            height: "3px"
          })
        };
      }
      return null;
    }
  }
};
var _hoisted_1$n = {
  class: "vc-day-popover-row"
};
var _hoisted_2$m = {
  key: 0,
  class: "vc-day-popover-row-indicator"
};
var _hoisted_3$f = {
  class: "vc-day-popover-row-content"
};
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("div", _hoisted_1$n, [$options.indicator ? (openBlock(), createBlock("div", _hoisted_2$m, [createVNode("span", {
    style: $options.indicator.style,
    class: $options.indicator.class
  }, null, 6)])) : createCommentVNode("", true), createVNode("div", _hoisted_3$f, [renderSlot(_ctx.$slots, "default", {}, function() {
    return [createTextVNode(
      toDisplayString($props.attribute.popover ? $props.attribute.popover.label : "No content provided"),
      1
    )];
  })])]);
}
var css_248z$3 = ".vc-day-popover-row {\n  --day-content-transition-time: 0.13s ease-in;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  transition: all var(--day-content-transition-time);\n}\n.vc-day-popover-row:not(:first-child) {\n    margin-top: 3px;\n}\n.vc-day-popover-row-indicator {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-flex-grow: 0;\n      -ms-flex-positive: 0;\n          flex-grow: 0;\n  width: 15px;\n  margin-right: 3px;\n}\n.vc-day-popover-row-indicator span {\n    transition: all var(--day-content-transition-time);\n}\n.vc-day-popover-row-content {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-flex-wrap: none;\n      -ms-flex-wrap: none;\n          flex-wrap: none;\n  -webkit-flex-grow: 1;\n      -ms-flex-positive: 1;\n          flex-grow: 1;\n  width: -webkit-max-content;\n  width: max-content;\n}\n";
styleInject(css_248z$3);
script$4.render = render$3;
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date2 = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date2;
  }
  var dayOfMonth = date2.getDate();
  var endOfDesiredMonth = new Date(date2.getTime());
  endOfDesiredMonth.setMonth(date2.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date2.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date2;
  }
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
var AttributeStore = /* @__PURE__ */ function() {
  function AttributeStore2(theme3, locale2, attrs) {
    _classCallCheck(this, AttributeStore2);
    this.theme = theme3;
    this.locale = locale2;
    this.map = {};
    this.refresh(attrs, true);
  }
  _createClass(AttributeStore2, [{
    key: "destroy",
    value: function destroy3() {
      this.theme = null;
      this.locale = null;
      this.map = {};
      this.list = [];
      this.pinAttr = null;
    }
  }, {
    key: "refresh",
    value: function refresh2(attrs, reset) {
      var _this = this;
      var map2 = {};
      var list = [];
      var pinAttr = null;
      var adds = [];
      var deletes = reset ? /* @__PURE__ */ new Set() : new Set(Object.keys(this.map));
      if (arrayHasItems(attrs)) {
        attrs.forEach(function(attr, i2) {
          if (!attr || !attr.dates)
            return;
          var key = attr.key ? attr.key.toString() : i2.toString();
          var order2 = attr.order || 0;
          var hashcode = hash$2(JSON.stringify(attr));
          var exAttr = _this.map[key];
          if (!reset && exAttr && exAttr.hashcode === hashcode) {
            deletes.delete(key);
          } else {
            exAttr = new Attribute(_objectSpread2$1({
              key,
              order: order2,
              hashcode
            }, attr), _this.theme, _this.locale);
            adds.push(exAttr);
          }
          if (exAttr && exAttr.pinPage) {
            pinAttr = exAttr;
          }
          map2[key] = exAttr;
          list.push(exAttr);
        });
      }
      this.map = map2;
      this.list = list;
      this.pinAttr = pinAttr;
      return {
        adds,
        deletes: Array.from(deletes)
      };
    }
  }]);
  return AttributeStore2;
}();
var addHorizontalSwipeHandler = function addHorizontalSwipeHandler2(element, handler2, _ref) {
  var maxSwipeTime2 = _ref.maxSwipeTime, minHorizontalSwipeDistance2 = _ref.minHorizontalSwipeDistance, maxVerticalSwipeDistance2 = _ref.maxVerticalSwipeDistance;
  if (!element || !element.addEventListener || !isFunction_1(handler2)) {
    return null;
  }
  var startX = 0;
  var startY = 0;
  var startTime2 = null;
  var isSwiping = false;
  function touchStart(e2) {
    var t13 = e2.changedTouches[0];
    startX = t13.screenX;
    startY = t13.screenY;
    startTime2 = new Date().getTime();
    isSwiping = true;
  }
  function touchEnd(e2) {
    if (!isSwiping)
      return;
    isSwiping = false;
    var t13 = e2.changedTouches[0];
    var deltaX = t13.screenX - startX;
    var deltaY = t13.screenY - startY;
    var deltaTime = new Date().getTime() - startTime2;
    if (deltaTime < maxSwipeTime2) {
      if (Math.abs(deltaX) >= minHorizontalSwipeDistance2 && Math.abs(deltaY) <= maxVerticalSwipeDistance2) {
        var arg = {
          toLeft: false,
          toRight: false
        };
        if (deltaX < 0) {
          arg.toLeft = true;
        } else {
          arg.toRight = true;
        }
        handler2(arg);
      }
    }
  }
  on$2(element, "touchstart", touchStart, {
    passive: true
  });
  on$2(element, "touchend", touchEnd, {
    passive: true
  });
  return function() {
    off$1(element, "touchstart", touchStart);
    off$1(element, "touchend", touchEnd);
  };
};
var script$3 = {
  name: "Calendar",
  emits: ["dayfocusin", "dayfocusout", "transition-start", "transition-end", "update:from-page", "update:to-page"],
  render: function render4() {
    var _this = this;
    var panes = this.pages.map(function(page, i2) {
      var position = i2 + 1;
      var row = Math.ceil((i2 + 1) / _this.columns);
      var rowFromEnd = _this.rows - row + 1;
      var column = position % _this.columns || _this.columns;
      var columnFromEnd = _this.columns - column + 1;
      return h$5(script$9, _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
        key: page.key,
        attributes: _this.store,
        page,
        position,
        row,
        rowFromEnd,
        column,
        columnFromEnd,
        titlePosition: _this.titlePosition,
        canMove: _this.canMove,
        "onUpdate:page": function onUpdatePage(e2) {
          return _this.move(e2, {
            position: i2 + 1
          });
        },
        onDayfocusin: function onDayfocusin(e2) {
          _this.lastFocusedDay = e2;
          _this.$emit("dayfocusin", e2);
        },
        onDayfocusout: function onDayfocusout(e2) {
          _this.lastFocusedDay = null;
          _this.$emit("dayfocusout", e2);
        }
      }), _this.$slots);
    });
    var getArrowButton = function getArrowButton2(isPrev) {
      var click2 = function click3() {
        return _this.move(isPrev ? -_this.step_ : _this.step_);
      };
      var keydown2 = function keydown3(e2) {
        return onSpaceOrEnter(e2, click2);
      };
      var isDisabled2 = isPrev ? !_this.canMovePrev : !_this.canMoveNext;
      return h$5("div", {
        class: ["vc-arrow", "is-".concat(isPrev ? "left" : "right"), {
          "is-disabled": isDisabled2
        }],
        role: "button",
        onClick: click2,
        onKeydown: keydown2
      }, [(isPrev ? _this.safeSlot("header-left-button", {
        click: click2
      }) : _this.safeSlot("header-right-button", {
        click: click2
      })) || h$5(script$8, {
        name: isPrev ? "left-arrow" : "right-arrow"
      })]);
    };
    var getNavPopover = function getNavPopover2() {
      return h$5(script$5, {
        id: _this.sharedState.navPopoverId,
        contentClass: "vc-nav-popover-container",
        ref: "navPopover"
      }, {
        default: function _default5(_ref) {
          var data9 = _ref.data;
          var position = data9.position, page = data9.page;
          return h$5(script$7, {
            value: page,
            position,
            validator: function validator2(e2) {
              return _this.canMove(e2, {
                position
              });
            },
            onInput: function onInput(e2) {
              return _this.move(e2);
            }
          }, _objectSpread2$1({}, _this.$slots));
        }
      });
    };
    var getDayPopover = function getDayPopover2() {
      return h$5(script$5, {
        id: _this.sharedState.dayPopoverId,
        contentClass: "vc-day-popover-container"
      }, {
        default: function _default5(_ref2) {
          var day = _ref2.data, updateLayout = _ref2.updateLayout, hide3 = _ref2.hide;
          var attributes = Object.values(day.attributes).filter(function(a3) {
            return a3.popover;
          });
          var masks3 = _this.$locale.masks;
          var format3 = _this.formatDate;
          var dayTitle = format3(day.date, masks3.dayPopover);
          return _this.safeSlot("day-popover", {
            day,
            attributes,
            masks: masks3,
            format: format3,
            dayTitle,
            updateLayout,
            hide: hide3
          }, h$5("div", [
            masks3.dayPopover && h$5("div", {
              class: ["vc-day-popover-header"]
            }, [dayTitle]),
            attributes.map(function(attribute) {
              return h$5(script$4, {
                key: attribute.key,
                attribute
              });
            })
          ]));
        }
      });
    };
    return h$5("div", {
      "data-helptext": "Press the arrow keys to navigate by day, Home and End to navigate to week ends, PageUp and PageDown to navigate by month, Alt+PageUp and Alt+PageDown to navigate by year",
      class: ["vc-container", "vc-".concat(this.$theme.color), {
        "vc-is-expanded": this.isExpanded,
        "vc-is-dark": this.$theme.isDark
      }],
      onKeydown: this.handleKeydown,
      onMouseup: function onMouseup(e2) {
        return e2.preventDefault();
      },
      ref: "container"
    }, [getNavPopover(), h$5("div", {
      class: ["vc-pane-container", {
        "in-transition": this.inTransition
      }]
    }, [h$5(script$6, {
      name: this.transitionName,
      "on-before-enter": function onBeforeEnter() {
        _this.inTransition = true;
      },
      "on-after-enter": function onAfterEnter() {
        _this.inTransition = false;
      }
    }, {
      default: function _default5() {
        return h$5("div", _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
          class: "vc-pane-layout",
          style: {
            gridTemplateColumns: "repeat(".concat(_this.columns, ", 1fr)")
          },
          key: _this.firstPage ? _this.firstPage.key : ""
        }), panes);
      }
    }), h$5("div", {
      class: ["vc-arrows-container title-".concat(this.titlePosition)]
    }, [getArrowButton(true), getArrowButton(false)]), this.$slots.footer && this.$slots.footer()]), getDayPopover()]);
  },
  mixins: [rootMixin$1, slotMixin$1],
  provide: function provide2() {
    return {
      sharedState: this.sharedState
    };
  },
  props: {
    rows: {
      type: Number,
      default: 1
    },
    columns: {
      type: Number,
      default: 1
    },
    step: Number,
    titlePosition: {
      type: String,
      default: getDefault("titlePosition")
    },
    isExpanded: Boolean,
    fromDate: Date,
    toDate: Date,
    fromPage: Object,
    toPage: Object,
    minPage: Object,
    maxPage: Object,
    transition: String,
    attributes: [Object, Array],
    trimWeeks: Boolean,
    disablePageSwipe: Boolean
  },
  data: function data5() {
    return {
      pages: [],
      store: null,
      lastFocusedDay: null,
      focusableDay: new Date().getDate(),
      transitionName: "",
      inTransition: false,
      sharedState: {
        navPopoverId: createGuid(),
        dayPopoverId: createGuid(),
        theme: {},
        masks: {},
        locale: {}
      }
    };
  },
  computed: {
    firstPage: function firstPage() {
      return head_1(this.pages);
    },
    lastPage: function lastPage() {
      return last_1(this.pages);
    },
    minPage_: function minPage_() {
      return this.minPage || this.pageForDate(this.minDate);
    },
    maxPage_: function maxPage_() {
      return this.maxPage || this.pageForDate(this.maxDate);
    },
    count: function count() {
      return this.rows * this.columns;
    },
    step_: function step_() {
      return this.step || this.count;
    },
    canMovePrev: function canMovePrev() {
      return this.canMove(-this.step_);
    },
    canMoveNext: function canMoveNext() {
      return this.canMove(this.step_);
    }
  },
  watch: {
    $locale: function $locale2() {
      this.refreshLocale();
      this.refreshPages({
        page: this.firstPage,
        ignoreCache: true
      });
      this.initStore();
    },
    $theme: function $theme2() {
      this.refreshTheme();
      this.initStore();
    },
    fromDate: function fromDate() {
      this.refreshPages();
    },
    fromPage: function fromPage(val) {
      var firstPage2 = this.pages && this.pages[0];
      if (pageIsEqualToPage(val, firstPage2))
        return;
      this.refreshPages();
    },
    toPage: function toPage(val) {
      var lastPage2 = this.pages && this.pages[this.pages.length - 1];
      if (pageIsEqualToPage(val, lastPage2))
        return;
      this.refreshPages();
    },
    count: function count2() {
      this.refreshPages();
    },
    attributes: {
      handler: function handler(val) {
        var _this$store$refresh = this.store.refresh(val), adds = _this$store$refresh.adds, deletes = _this$store$refresh.deletes;
        this.refreshAttrs(this.pages, adds, deletes);
      },
      deep: true
    },
    pages: function pages(val) {
      this.refreshAttrs(val, this.store.list, null, true);
    },
    disabledAttribute: function disabledAttribute2() {
      this.refreshDisabledDays();
    },
    lastFocusedDay: function lastFocusedDay(val) {
      if (val) {
        this.focusableDay = val.day;
        this.refreshFocusableDays();
      }
    },
    inTransition: function inTransition(val) {
      if (val) {
        this.$emit("transition-start");
      } else {
        this.$emit("transition-end");
        if (this.transitionPromise) {
          this.transitionPromise.resolve(true);
          this.transitionPromise = null;
        }
      }
    }
  },
  created: function created2() {
    this.refreshLocale();
    this.refreshTheme();
    this.initStore();
    this.refreshPages();
  },
  mounted: function mounted5() {
    var _this2 = this;
    if (!this.disablePageSwipe) {
      this.removeHandlers = addHorizontalSwipeHandler(this.$refs.container, function(_ref3) {
        var toLeft = _ref3.toLeft, toRight = _ref3.toRight;
        if (toLeft) {
          _this2.moveNext();
        } else if (toRight) {
          _this2.movePrev();
        }
      }, getDefault("touch"));
    }
  },
  beforeUnmount: function beforeUnmount2() {
    this.pages = [];
    this.store.destroy();
    this.store = null;
    this.sharedState = null;
    if (this.removeHandlers)
      this.removeHandlers();
  },
  methods: {
    refreshLocale: function refreshLocale() {
      this.sharedState.locale = this.$locale;
      this.sharedState.masks = this.$locale.masks;
    },
    refreshTheme: function refreshTheme() {
      this.sharedState.theme = this.$theme;
    },
    canMove: function canMove(arg) {
      var _this3 = this;
      var opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var page = this.firstPage && this.$locale.toPage(arg, this.firstPage);
      if (!page)
        return false;
      var position = opts2.position;
      if (isNumber_1(arg))
        position = 1;
      if (!position) {
        if (pageIsBeforePage(page, this.firstPage)) {
          position = -1;
        } else if (pageIsAfterPage(page, this.lastPage)) {
          position = 1;
        } else {
          return true;
        }
      }
      Object.assign(opts2, this.getTargetPageRange(page, {
        position,
        force: true
      }));
      return pageRangeToArray(opts2.fromPage, opts2.toPage).some(function(p2) {
        return pageIsBetweenPages(p2, _this3.minPage_, _this3.maxPage_);
      });
    },
    movePrev: function movePrev2(opts2) {
      return this.move(-this.step_, opts2);
    },
    moveNext: function moveNext2(opts2) {
      return this.move(this.step_, opts2);
    },
    move: function move(arg) {
      var opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var canMove2 = this.canMove(arg, opts2);
      if (!opts2.force && !canMove2) {
        return Promise.reject(new Error("Move target is disabled: ".concat(JSON.stringify(opts2))));
      }
      this.$refs.navPopover.hide({
        hideDelay: 0
      });
      if (opts2.fromPage && !pageIsEqualToPage(opts2.fromPage, this.firstPage)) {
        return this.refreshPages(_objectSpread2$1(_objectSpread2$1({}, opts2), {}, {
          page: opts2.fromPage,
          position: 1,
          force: true
        }));
      }
      return Promise.resolve(true);
    },
    focusDate: function focusDate(date2) {
      var _this4 = this;
      var opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return this.move(date2, opts2).then(function() {
        var focusableEl = _this4.$el.querySelector(".id-".concat(_this4.$locale.getDayId(date2), ".in-month .vc-focusable"));
        if (focusableEl) {
          focusableEl.focus();
          return Promise.resolve(true);
        }
        return Promise.resolve(false);
      });
    },
    showPageRange: function showPageRange(range, opts2) {
      var fromPage2;
      var toPage2;
      if (isDate$1$1(range)) {
        fromPage2 = this.pageForDate(range);
      } else if (isObject$1$1(range)) {
        var month2 = range.month, year3 = range.year;
        var from = range.from, to2 = range.to;
        if (isNumber_1(month2) && isNumber_1(year3)) {
          fromPage2 = range;
        } else if (from || to2) {
          fromPage2 = isDate$1$1(from) ? this.pageForDate(from) : from;
          toPage2 = isDate$1$1(to2) ? this.pageForDate(to2) : to2;
        }
      } else {
        return Promise.reject(new Error("Invalid page range provided."));
      }
      var lastPage2 = this.lastPage;
      var page = fromPage2;
      if (pageIsAfterPage(toPage2, lastPage2)) {
        page = addPages(toPage2, -(this.pages.length - 1));
      }
      if (pageIsBeforePage(page, fromPage2)) {
        page = fromPage2;
      }
      return this.refreshPages(_objectSpread2$1(_objectSpread2$1({}, opts2), {}, {
        page
      }));
    },
    getTargetPageRange: function getTargetPageRange(page) {
      var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, position = _ref4.position, force = _ref4.force;
      var fromPage2 = null;
      var toPage2 = null;
      if (pageIsValid(page)) {
        var pagesToAdd = 0;
        position = +position;
        if (!isNaN(position)) {
          pagesToAdd = position > 0 ? 1 - position : -(this.count + position);
        }
        fromPage2 = addPages(page, pagesToAdd);
      } else {
        fromPage2 = this.getDefaultInitialPage();
      }
      toPage2 = addPages(fromPage2, this.count - 1);
      if (!force) {
        if (pageIsBeforePage(fromPage2, this.minPage_)) {
          fromPage2 = this.minPage_;
        } else if (pageIsAfterPage(toPage2, this.maxPage_)) {
          fromPage2 = addPages(this.maxPage_, 1 - this.count);
        }
        toPage2 = addPages(fromPage2, this.count - 1);
      }
      return {
        fromPage: fromPage2,
        toPage: toPage2
      };
    },
    getDefaultInitialPage: function getDefaultInitialPage() {
      var page = this.fromPage || this.pageForDate(this.fromDate);
      if (!pageIsValid(page)) {
        var toPage2 = this.toPage || this.pageForDate(this.toPage);
        if (pageIsValid(toPage2)) {
          page = addPages(toPage2, 1 - this.count);
        }
      }
      if (!pageIsValid(page)) {
        page = this.getPageForAttributes();
      }
      if (!pageIsValid(page)) {
        page = this.pageForThisMonth();
      }
      return page;
    },
    refreshPages: function refreshPages() {
      var _this5 = this;
      var _ref5 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, page = _ref5.page, _ref5$position = _ref5.position, position = _ref5$position === void 0 ? 1 : _ref5$position, force = _ref5.force, transition = _ref5.transition, ignoreCache = _ref5.ignoreCache;
      return new Promise(function(resolve, reject) {
        var _this5$getTargetPageR = _this5.getTargetPageRange(page, {
          position,
          force
        }), fromPage2 = _this5$getTargetPageR.fromPage, toPage2 = _this5$getTargetPageR.toPage;
        var pages2 = [];
        for (var i2 = 0; i2 < _this5.count; i2++) {
          pages2.push(_this5.buildPage(addPages(fromPage2, i2), ignoreCache));
        }
        _this5.refreshDisabledDays(pages2);
        _this5.refreshFocusableDays(pages2);
        _this5.transitionName = _this5.getPageTransition(_this5.pages[0], pages2[0], transition);
        _this5.pages = pages2;
        _this5.$emit("update:from-page", fromPage2);
        _this5.$emit("update:to-page", toPage2);
        if (_this5.transitionName && _this5.transitionName !== "none") {
          _this5.transitionPromise = {
            resolve,
            reject
          };
        } else {
          resolve(true);
        }
      });
    },
    refreshDisabledDays: function refreshDisabledDays(pages2) {
      var _this6 = this;
      this.getPageDays(pages2).forEach(function(d3) {
        d3.isDisabled = !!_this6.disabledAttribute && _this6.disabledAttribute.intersectsDay(d3);
      });
    },
    refreshFocusableDays: function refreshFocusableDays(pages2) {
      var _this7 = this;
      this.getPageDays(pages2).forEach(function(d3) {
        d3.isFocusable = d3.inMonth && d3.day === _this7.focusableDay;
      });
    },
    getPageDays: function getPageDays() {
      var pages2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.pages;
      return pages2.reduce(function(prev, curr) {
        return prev.concat(curr.days);
      }, []);
    },
    getPageTransition: function getPageTransition(oldPage, newPage) {
      var transition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.transition;
      if (transition === "none")
        return transition;
      if (transition === "fade" || !transition && this.count > 1 || !pageIsValid(oldPage) || !pageIsValid(newPage)) {
        return "fade";
      }
      var movePrev3 = pageIsBeforePage(newPage, oldPage);
      if (transition === "slide-v") {
        return movePrev3 ? "slide-down" : "slide-up";
      }
      return movePrev3 ? "slide-right" : "slide-left";
    },
    getPageForAttributes: function getPageForAttributes() {
      var page = null;
      var attr = this.store.pinAttr;
      if (attr && attr.hasDates) {
        var _attr$dates = _slicedToArray(attr.dates, 1), date2 = _attr$dates[0];
        date2 = date2.start || date2.date;
        page = this.pageForDate(date2);
      }
      return page;
    },
    buildPage: function buildPage(_ref6, ignoreCache) {
      var _this8 = this;
      var month2 = _ref6.month, year3 = _ref6.year;
      var key = "".concat(year3.toString(), "-").concat(month2.toString());
      var page = this.pages.find(function(p2) {
        return p2.key === key;
      });
      if (!page || ignoreCache) {
        var date2 = new Date(year3, month2 - 1, 15);
        var monthComps = this.$locale.getMonthComps(month2, year3);
        var prevMonthComps = this.$locale.getPrevMonthComps(month2, year3);
        var nextMonthComps = this.$locale.getNextMonthComps(month2, year3);
        page = {
          key,
          month: month2,
          year: year3,
          weeks: this.trimWeeks ? monthComps.weeks : 6,
          title: this.$locale.format(date2, this.$locale.masks.title),
          shortMonthLabel: this.$locale.format(date2, "MMM"),
          monthLabel: this.$locale.format(date2, "MMMM"),
          shortYearLabel: year3.toString().substring(2),
          yearLabel: year3.toString(),
          monthComps,
          prevMonthComps,
          nextMonthComps,
          canMove: function canMove2(pg) {
            return _this8.canMove(pg);
          },
          move: function move3(pg) {
            return _this8.move(pg);
          },
          moveThisMonth: function moveThisMonth() {
            return _this8.moveThisMonth();
          },
          movePrevMonth: function movePrevMonth() {
            return _this8.move(prevMonthComps);
          },
          moveNextMonth: function moveNextMonth() {
            return _this8.move(nextMonthComps);
          },
          refresh: true
        };
        page.days = this.$locale.getCalendarDays(page);
      }
      return page;
    },
    initStore: function initStore() {
      this.store = new AttributeStore(this.$theme, this.$locale, this.attributes);
      this.refreshAttrs(this.pages, this.store.list, [], true);
    },
    refreshAttrs: function refreshAttrs() {
      var pages2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var adds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var deletes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      var reset = arguments.length > 3 ? arguments[3] : void 0;
      if (!arrayHasItems(pages2))
        return;
      pages2.forEach(function(p2) {
        p2.days.forEach(function(d3) {
          var shouldRefresh = false;
          var map2 = {};
          if (reset) {
            shouldRefresh = true;
          } else if (hasAny(d3.attributesMap, deletes)) {
            map2 = omit_1(d3.attributesMap, deletes);
            shouldRefresh = true;
          } else {
            map2 = d3.attributesMap || {};
          }
          adds.forEach(function(attr) {
            var targetDate = attr.intersectsDay(d3);
            if (targetDate) {
              var newAttr = _objectSpread2$1(_objectSpread2$1({}, attr), {}, {
                targetDate
              });
              map2[attr.key] = newAttr;
              shouldRefresh = true;
            }
          });
          if (shouldRefresh) {
            d3.attributesMap = map2;
            d3.shouldRefresh = true;
          }
        });
      });
    },
    handleKeydown: function handleKeydown(e2) {
      var day = this.lastFocusedDay;
      if (day != null) {
        day.event = e2;
        this.handleDayKeydown(day);
      }
    },
    handleDayKeydown: function handleDayKeydown(day) {
      var dateFromTime = day.dateFromTime, event = day.event;
      var date2 = dateFromTime(12);
      var newDate = null;
      switch (event.key) {
        case "ArrowLeft": {
          newDate = addDays(date2, -1);
          break;
        }
        case "ArrowRight": {
          newDate = addDays(date2, 1);
          break;
        }
        case "ArrowUp": {
          newDate = addDays(date2, -7);
          break;
        }
        case "ArrowDown": {
          newDate = addDays(date2, 7);
          break;
        }
        case "Home": {
          newDate = addDays(date2, -day.weekdayPosition + 1);
          break;
        }
        case "End": {
          newDate = addDays(date2, day.weekdayPositionFromEnd);
          break;
        }
        case "PageUp": {
          if (event.altKey) {
            newDate = addYears(date2, -1);
          } else {
            newDate = addMonths(date2, -1);
          }
          break;
        }
        case "PageDown": {
          if (event.altKey) {
            newDate = addYears(date2, 1);
          } else {
            newDate = addMonths(date2, 1);
          }
          break;
        }
      }
      if (newDate) {
        event.preventDefault();
        this.focusDate(newDate).catch();
      }
    }
  }
};
var css_248z$2 = ".vc-container {\n  --white: #ffffff;\n  --black: #000000;\n\n  --gray-100: #f7fafc;\n  --gray-200: #edf2f7;\n  --gray-300: #e2e8f0;\n  --gray-400: #cbd5e0;\n  --gray-500: #a0aec0;\n  --gray-600: #718096;\n  --gray-700: #4a5568;\n  --gray-800: #2d3748;\n  --gray-900: #1a202c;\n\n  --red-100: #fff5f5;\n  --red-200: #fed7d7;\n  --red-300: #feb2b2;\n  --red-400: #fc8181;\n  --red-500: #f56565;\n  --red-600: #e53e3e;\n  --red-700: #c53030;\n  --red-800: #9b2c2c;\n  --red-900: #742a2a;\n\n  --orange-100: #fffaf0;\n  --orange-200: #feebc8;\n  --orange-300: #fbd38d;\n  --orange-400: #f6ad55;\n  --orange-500: #ed8936;\n  --orange-600: #dd6b20;\n  --orange-700: #c05621;\n  --orange-800: #9c4221;\n  --orange-900: #7b341e;\n\n  --yellow-100: #fffff0;\n  --yellow-200: #fefcbf;\n  --yellow-300: #faf089;\n  --yellow-400: #f6e05e;\n  --yellow-500: #ecc94b;\n  --yellow-600: #d69e2e;\n  --yellow-700: #b7791f;\n  --yellow-800: #975a16;\n  --yellow-900: #744210;\n\n  --green-100: #f0fff4;\n  --green-200: #c6f6d5;\n  --green-300: #9ae6b4;\n  --green-400: #68d391;\n  --green-500: #48bb78;\n  --green-600: #38a169;\n  --green-700: #2f855a;\n  --green-800: #276749;\n  --green-900: #22543d;\n\n  --teal-100: #e6fffa;\n  --teal-200: #b2f5ea;\n  --teal-300: #81e6d9;\n  --teal-400: #4fd1c5;\n  --teal-500: #38b2ac;\n  --teal-600: #319795;\n  --teal-700: #2c7a7b;\n  --teal-800: #285e61;\n  --teal-900: #234e52;\n\n  --blue-100: #ebf8ff;\n  --blue-200: #bee3f8;\n  --blue-300: #90cdf4;\n  --blue-400: #63b3ed;\n  --blue-500: #4299e1;\n  --blue-600: #3182ce;\n  --blue-700: #2b6cb0;\n  --blue-800: #2c5282;\n  --blue-900: #2a4365;\n\n  --indigo-100: #ebf4ff;\n  --indigo-200: #c3dafe;\n  --indigo-300: #a3bffa;\n  --indigo-400: #7f9cf5;\n  --indigo-500: #667eea;\n  --indigo-600: #5a67d8;\n  --indigo-700: #4c51bf;\n  --indigo-800: #434190;\n  --indigo-900: #3c366b;\n\n  --purple-100: #faf5ff;\n  --purple-200: #e9d8fd;\n  --purple-300: #d6bcfa;\n  --purple-400: #b794f4;\n  --purple-500: #9f7aea;\n  --purple-600: #805ad5;\n  --purple-700: #6b46c1;\n  --purple-800: #553c9a;\n  --purple-900: #44337a;\n\n  --pink-100: #fff5f7;\n  --pink-200: #fed7e2;\n  --pink-300: #fbb6ce;\n  --pink-400: #f687b3;\n  --pink-500: #ed64a6;\n  --pink-600: #d53f8c;\n  --pink-700: #b83280;\n  --pink-800: #97266d;\n  --pink-900: #702459;\n}\n.vc-container.vc-red {\n    --accent-100: var(--red-100);\n    --accent-200: var(--red-200);\n    --accent-300: var(--red-300);\n    --accent-400: var(--red-400);\n    --accent-500: var(--red-500);\n    --accent-600: var(--red-600);\n    --accent-700: var(--red-700);\n    --accent-800: var(--red-800);\n    --accent-900: var(--red-900);\n}\n.vc-container.vc-orange {\n    --accent-100: var(--orange-100);\n    --accent-200: var(--orange-200);\n    --accent-300: var(--orange-300);\n    --accent-400: var(--orange-400);\n    --accent-500: var(--orange-500);\n    --accent-600: var(--orange-600);\n    --accent-700: var(--orange-700);\n    --accent-800: var(--orange-800);\n    --accent-900: var(--orange-900);\n}\n.vc-container.vc-yellow {\n    --accent-100: var(--yellow-100);\n    --accent-200: var(--yellow-200);\n    --accent-300: var(--yellow-300);\n    --accent-400: var(--yellow-400);\n    --accent-500: var(--yellow-500);\n    --accent-600: var(--yellow-600);\n    --accent-700: var(--yellow-700);\n    --accent-800: var(--yellow-800);\n    --accent-900: var(--yellow-900);\n}\n.vc-container.vc-green {\n    --accent-100: var(--green-100);\n    --accent-200: var(--green-200);\n    --accent-300: var(--green-300);\n    --accent-400: var(--green-400);\n    --accent-500: var(--green-500);\n    --accent-600: var(--green-600);\n    --accent-700: var(--green-700);\n    --accent-800: var(--green-800);\n    --accent-900: var(--green-900);\n}\n.vc-container.vc-teal {\n    --accent-100: var(--teal-100);\n    --accent-200: var(--teal-200);\n    --accent-300: var(--teal-300);\n    --accent-400: var(--teal-400);\n    --accent-500: var(--teal-500);\n    --accent-600: var(--teal-600);\n    --accent-700: var(--teal-700);\n    --accent-800: var(--teal-800);\n    --accent-900: var(--teal-900);\n}\n.vc-container.vc-blue {\n    --accent-100: var(--blue-100);\n    --accent-200: var(--blue-200);\n    --accent-300: var(--blue-300);\n    --accent-400: var(--blue-400);\n    --accent-500: var(--blue-500);\n    --accent-600: var(--blue-600);\n    --accent-700: var(--blue-700);\n    --accent-800: var(--blue-800);\n    --accent-900: var(--blue-900);\n}\n.vc-container.vc-indigo {\n    --accent-100: var(--indigo-100);\n    --accent-200: var(--indigo-200);\n    --accent-300: var(--indigo-300);\n    --accent-400: var(--indigo-400);\n    --accent-500: var(--indigo-500);\n    --accent-600: var(--indigo-600);\n    --accent-700: var(--indigo-700);\n    --accent-800: var(--indigo-800);\n    --accent-900: var(--indigo-900);\n}\n.vc-container.vc-purple {\n    --accent-100: var(--purple-100);\n    --accent-200: var(--purple-200);\n    --accent-300: var(--purple-300);\n    --accent-400: var(--purple-400);\n    --accent-500: var(--purple-500);\n    --accent-600: var(--purple-600);\n    --accent-700: var(--purple-700);\n    --accent-800: var(--purple-800);\n    --accent-900: var(--purple-900);\n}\n.vc-container.vc-pink {\n    --accent-100: var(--pink-100);\n    --accent-200: var(--pink-200);\n    --accent-300: var(--pink-300);\n    --accent-400: var(--pink-400);\n    --accent-500: var(--pink-500);\n    --accent-600: var(--pink-600);\n    --accent-700: var(--pink-700);\n    --accent-800: var(--pink-800);\n    --accent-900: var(--pink-900);\n}\n.vc-container {\n\n  --font-normal: 400;\n  --font-medium: 500;\n  --font-semibold: 600;\n  --font-bold: 700;\n\n  --text-xs: 12px;\n  --text-sm: 14px;\n  --text-base: 16px;\n  --text-lg: 18px;\n\n  --leading-snug: 1.375;\n\n  --rounded: 0.25rem;\n  --rounded-lg: 0.5rem;\n  --rounded-full: 9999px;\n\n  --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);\n  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1),\n    0 4px 6px -2px rgba(0, 0, 0, 0.05);\n  --shadow-inner: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);\n\n  --slide-translate: 22px;\n  --slide-duration: 0.15s;\n  --slide-timing: ease;\n\n  --day-content-transition-time: 0.13s ease-in;\n  --weeknumber-offset: -34px;\n\n  position: relative;\n  display: -webkit-inline-flex;\n  display: -ms-inline-flexbox;\n  display: inline-flex;\n  width: -webkit-max-content;\n  width: max-content;\n  height: -webkit-max-content;\n  height: max-content;\n  font-family: BlinkMacSystemFont, -apple-system, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    'Helvetica', 'Arial', sans-serif;\n  color: var(--gray-900);\n  background-color: var(--white);\n  border: 1px solid;\n  border-color: var(--gray-400);\n  border-radius: var(--rounded-lg);\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-tap-highlight-color: transparent;\n}\n.vc-container,\n  .vc-container * {\n    box-sizing: border-box;\n}\n.vc-container:focus, .vc-container *:focus {\n      outline: none;\n}\n.vc-container button,\n  .vc-container [role='button'] {\n    cursor: pointer;\n}\n.vc-container.vc-is-expanded {\n    min-width: 100%;\n}\n/* Hides double border within popovers */\n.vc-container .vc-container {\n    border: none;\n}\n.vc-container.vc-is-dark {\n    color: var(--gray-100);\n    background-color: var(--gray-900);\n    border-color: var(--gray-700);\n}\n.vc-pane-container {\n  width: 100%;\n  position: relative;\n}\n.vc-pane-container.in-transition {\n    overflow: hidden;\n}\n.vc-pane-layout {\n  display: grid;\n}\n.vc-arrow {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  cursor: pointer;\n  -webkit-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  pointer-events: auto;\n  color: var(--gray-600);\n  border-width: 2px;\n  border-style: solid;\n  border-radius: var(--rounded);\n  border-color: transparent;\n}\n.vc-arrow:hover {\n    background: var(--gray-200);\n}\n.vc-arrow:focus {\n    border-color: var(--gray-300);\n}\n.vc-arrow.is-disabled {\n    opacity: 0.25;\n    pointer-events: none;\n    cursor: not-allowed;\n}\n.vc-day-popover-container {\n  color: var(--white);\n  background-color: var(--gray-800);\n  border: 1px solid;\n  border-color: var(--gray-700);\n  border-radius: var(--rounded);\n  font-size: var(--text-xs);\n  font-weight: var(--font-medium);\n  padding: 4px 8px;\n  box-shadow: var(--shadow);\n}\n.vc-day-popover-header {\n  font-size: var(--text-xs);\n  color: var(--gray-300);\n  font-weight: var(--font-semibold);\n  text-align: center;\n}\n.vc-arrows-container {\n  width: 100%;\n  position: absolute;\n  top: 0;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-justify-content: space-between;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n  padding: 8px 10px;\n  pointer-events: none;\n}\n.vc-arrows-container.title-left {\n    -webkit-justify-content: flex-end;\n        -ms-flex-pack: end;\n            justify-content: flex-end;\n}\n.vc-arrows-container.title-right {\n    -webkit-justify-content: flex-start;\n        -ms-flex-pack: start;\n            justify-content: flex-start;\n}\n.vc-is-dark .vc-arrow {\n    color: var(--white);\n}\n.vc-is-dark .vc-arrow:hover {\n      background: var(--gray-800);\n}\n.vc-is-dark .vc-arrow:focus {\n      border-color: var(--gray-700);\n}\n.vc-is-dark .vc-day-popover-container {\n    color: var(--gray-800);\n    background-color: var(--white);\n    border-color: var(--gray-100);\n}\n.vc-is-dark .vc-day-popover-header {\n    color: var(--gray-700);\n}\n";
styleInject(css_248z$2);
var script$2 = {
  inheritAttrs: false,
  emits: ["update:modelValue"],
  props: {
    options: Array,
    modelValue: null
  }
};
var _hoisted_1$m = {
  class: "vc-select"
};
var _hoisted_2$l = /* @__PURE__ */ createVNode("div", {
  class: "vc-select-arrow"
}, [/* @__PURE__ */ createVNode("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 20 20"
}, [/* @__PURE__ */ createVNode("path", {
  d: "M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"
})])], -1);
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock("div", _hoisted_1$m, [createVNode("select", mergeProps(_ctx.$attrs, {
    value: $props.modelValue,
    onChange: _cache[1] || (_cache[1] = function($event) {
      return _ctx.$emit("update:modelValue", $event.target.value);
    })
  }), [(openBlock(true), createBlock(
    Fragment,
    null,
    renderList($props.options, function(option2) {
      return openBlock(), createBlock("option", {
        key: option2.value,
        value: option2.value,
        disabled: option2.disabled
      }, toDisplayString(option2.label), 9, ["value", "disabled"]);
    }),
    128
  ))], 16, ["value"]), _hoisted_2$l]);
}
var css_248z$1 = ".vc-select {\n  position: relative;\n}\n.vc-select select {\n    -webkit-flex-grow: 1;\n        -ms-flex-positive: 1;\n            flex-grow: 1;\n    display: block;\n    -webkit-appearance: none;\n            appearance: none;\n    width: 52px;\n    height: 30px;\n    font-size: var(--text-base);\n    font-weight: var(--font-medium);\n    text-align: left;\n    background-color: var(--gray-200);\n    border: 2px solid;\n    border-color: var(--gray-200);\n    color: var(--gray-900);\n    padding: 0 20px 0 8px;\n    border-radius: var(--rounded);\n    line-height: var(--leading-tight);\n    text-indent: 0px;\n    cursor: pointer;\n    -moz-padding-start: 3px;\n}\n.vc-select select:hover {\n      color: var(--gray-600);\n}\n.vc-select select:focus {\n      outline: 0;\n      border-color: var(--accent-400);\n      background-color: var(--white);\n}\n.vc-select-arrow {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  right: 0;\n  padding: 0 4px 0 0;\n  color: var(--gray-500);\n}\n.vc-select-arrow svg {\n    width: 16px;\n    height: 16px;\n    fill: currentColor;\n}\n.vc-is-dark select {\n    background: var(--gray-700);\n    color: var(--gray-100);\n    border-color: var(--gray-700);\n}\n.vc-is-dark select:hover {\n      color: var(--gray-400);\n}\n.vc-is-dark select:focus {\n      border-color: var(--accent-500);\n      background-color: var(--gray-800);\n}\n";
styleInject(css_248z$1);
script$2.render = render$2;
var script$1 = {
  name: "TimePicker",
  components: {
    TimeSelect: script$2
  },
  emits: ["update:modelValue"],
  props: {
    modelValue: {
      type: Object,
      required: true
    },
    locale: {
      type: Object,
      required: true
    },
    theme: {
      type: Object,
      required: true
    },
    is24hr: {
      type: Boolean,
      default: true
    },
    minuteIncrement: {
      type: Number,
      default: 1
    },
    showBorder: Boolean
  },
  data: function data6() {
    return {
      hours: 0,
      minutes: 0,
      isAM: true
    };
  },
  computed: {
    date: function date() {
      var date2 = this.locale.normalizeDate(this.modelValue);
      if (this.modelValue.hours === 24) {
        date2 = new Date(date2.getTime() - 1);
      }
      return date2;
    },
    hourOptions: function hourOptions() {
      var options12 = [{
        value: 0,
        label: "12"
      }, {
        value: 1,
        label: "1"
      }, {
        value: 2,
        label: "2"
      }, {
        value: 3,
        label: "3"
      }, {
        value: 4,
        label: "4"
      }, {
        value: 5,
        label: "5"
      }, {
        value: 6,
        label: "6"
      }, {
        value: 7,
        label: "7"
      }, {
        value: 8,
        label: "8"
      }, {
        value: 9,
        label: "9"
      }, {
        value: 10,
        label: "10"
      }, {
        value: 11,
        label: "11"
      }];
      var options24 = [{
        value: 0,
        label: "00"
      }, {
        value: 1,
        label: "01"
      }, {
        value: 2,
        label: "02"
      }, {
        value: 3,
        label: "03"
      }, {
        value: 4,
        label: "04"
      }, {
        value: 5,
        label: "05"
      }, {
        value: 6,
        label: "06"
      }, {
        value: 7,
        label: "07"
      }, {
        value: 8,
        label: "08"
      }, {
        value: 9,
        label: "09"
      }, {
        value: 10,
        label: "10"
      }, {
        value: 11,
        label: "11"
      }, {
        value: 12,
        label: "12"
      }, {
        value: 13,
        label: "13"
      }, {
        value: 14,
        label: "14"
      }, {
        value: 15,
        label: "15"
      }, {
        value: 16,
        label: "16"
      }, {
        value: 17,
        label: "17"
      }, {
        value: 18,
        label: "18"
      }, {
        value: 19,
        label: "19"
      }, {
        value: 20,
        label: "20"
      }, {
        value: 21,
        label: "21"
      }, {
        value: 22,
        label: "22"
      }, {
        value: 23,
        label: "23"
      }];
      if (this.is24hr)
        return options24;
      return options12;
    },
    minuteOptions: function minuteOptions() {
      var options = [];
      var m3 = 0;
      var added = false;
      while (m3 <= 59) {
        options.push({
          value: m3,
          label: pad$1(m3, 2)
        });
        added = added || m3 === this.minutes;
        m3 += this.minuteIncrement;
        if (!added && m3 > this.minutes) {
          added = true;
          options.push({
            value: this.minutes,
            label: pad$1(this.minutes, 2),
            disabled: true
          });
        }
      }
      return options;
    }
  },
  watch: {
    modelValue: function modelValue() {
      this.setup();
    },
    hours: function hours() {
      this.updateValue();
    },
    minutes: function minutes() {
      this.updateValue();
    },
    isAM: function isAM() {
      this.updateValue();
    }
  },
  created: function created3() {
    this.setup();
  },
  methods: {
    protected: function _protected(fn3) {
      var _this = this;
      if (this.busy)
        return;
      this.busy = true;
      fn3();
      this.$nextTick(function() {
        return _this.busy = false;
      });
    },
    setup: function setup() {
      var _this2 = this;
      this.protected(function() {
        var hours2 = _this2.modelValue.hours;
        if (hours2 === 24)
          hours2 = 0;
        var isAM2 = true;
        if (!_this2.is24hr && hours2 >= 12) {
          hours2 -= 12;
          isAM2 = false;
        }
        _this2.hours = hours2;
        _this2.minutes = _this2.modelValue.minutes;
        _this2.isAM = isAM2;
      });
    },
    updateValue: function updateValue() {
      var _this3 = this;
      this.protected(function() {
        var hours2 = _this3.hours;
        if (!_this3.is24hr && !_this3.isAM) {
          hours2 += 12;
        }
        _this3.$emit("update:modelValue", _objectSpread2$1(_objectSpread2$1({}, _this3.modelValue), {}, {
          hours: hours2,
          minutes: _this3.minutes,
          seconds: 0,
          milliseconds: 0
        }));
      });
    }
  }
};
var _withId = /* @__PURE__ */ withScopeId("data-v-63f66eaa");
pushScopeId("data-v-63f66eaa");
var _hoisted_1$l = /* @__PURE__ */ createVNode("div", null, [/* @__PURE__ */ createVNode("svg", {
  fill: "none",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  "stroke-width": "2",
  viewBox: "0 0 24 24",
  class: "vc-time-icon",
  stroke: "currentColor"
}, [/* @__PURE__ */ createVNode("path", {
  d: "M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"
})])], -1);
var _hoisted_2$k = {
  class: "vc-time-content"
};
var _hoisted_3$e = {
  key: 0,
  class: "vc-time-date"
};
var _hoisted_4$b = {
  class: "vc-time-weekday"
};
var _hoisted_5$8 = {
  class: "vc-time-month"
};
var _hoisted_6$5 = {
  class: "vc-time-day"
};
var _hoisted_7$4 = {
  class: "vc-time-year"
};
var _hoisted_8$5 = {
  class: "vc-time-select"
};
var _hoisted_9$4 = /* @__PURE__ */ createVNode("span", {
  style: {
    "margin": "0 4px"
  }
}, ":", -1);
var _hoisted_10$3 = {
  key: 0,
  class: "vc-am-pm"
};
popScopeId();
var render$1 = /* @__PURE__ */ _withId(function render5(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_time_select = resolveComponent("time-select");
  return openBlock(), createBlock("div", {
    class: ["vc-time-picker", [{
      "vc-invalid": !$props.modelValue.isValid,
      "vc-bordered": $props.showBorder
    }]]
  }, [_hoisted_1$l, createVNode("div", _hoisted_2$k, [$options.date ? (openBlock(), createBlock("div", _hoisted_3$e, [createVNode("span", _hoisted_4$b, toDisplayString($props.locale.format($options.date, "WWW")), 1), createVNode("span", _hoisted_5$8, toDisplayString($props.locale.format($options.date, "MMM")), 1), createVNode("span", _hoisted_6$5, toDisplayString($props.locale.format($options.date, "D")), 1), createVNode("span", _hoisted_7$4, toDisplayString($props.locale.format($options.date, "YYYY")), 1)])) : createCommentVNode("", true), createVNode("div", _hoisted_8$5, [createVNode(_component_time_select, {
    modelValue: $data.hours,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = function($event) {
      return $data.hours = $event;
    }),
    modelModifiers: {
      number: true
    },
    options: $options.hourOptions
  }, null, 8, ["modelValue", "options"]), _hoisted_9$4, createVNode(_component_time_select, {
    modelValue: $data.minutes,
    "onUpdate:modelValue": _cache[2] || (_cache[2] = function($event) {
      return $data.minutes = $event;
    }),
    modelModifiers: {
      number: true
    },
    options: $options.minuteOptions
  }, null, 8, ["modelValue", "options"]), !$props.is24hr ? (openBlock(), createBlock("div", _hoisted_10$3, [createVNode("button", {
    class: {
      active: $data.isAM
    },
    onClick: _cache[3] || (_cache[3] = withModifiers(function($event) {
      return $data.isAM = true;
    }, ["prevent"])),
    type: "button"
  }, " AM ", 2), createVNode("button", {
    class: {
      active: !$data.isAM
    },
    onClick: _cache[4] || (_cache[4] = withModifiers(function($event) {
      return $data.isAM = false;
    }, ["prevent"])),
    type: "button"
  }, " PM ", 2)])) : createCommentVNode("", true)])])], 2);
});
var css_248z = ".vc-time-picker[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  padding: 8px;\n}\n.vc-time-picker.vc-invalid[data-v-63f66eaa] {\n    pointer-events: none;\n    opacity: 0.5;\n}\n.vc-time-picker.vc-bordered[data-v-63f66eaa] {\n    border-top: 1px solid var(--gray-400);\n}\n.vc-time-icon[data-v-63f66eaa] {\n  width: 16px;\n  height: 16px;\n  color: var(--gray-600);\n}\n.vc-time-content[data-v-63f66eaa] {\n  margin-left: 8px;\n}\n.vc-time-date[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  font-size: var(--text-sm);\n  font-weight: var(--font-semibold);\n  text-transform: uppercase;\n  padding: 0 0 4px 4px;\n  margin-top: -4px;\n  line-height: 21px;\n}\n.vc-time-weekday[data-v-63f66eaa] {\n  color: var(--gray-700);\n  letter-spacing: var(--tracking-wide);\n}\n.vc-time-month[data-v-63f66eaa] {\n  color: var(--accent-600);\n  margin-left: 8px;\n}\n.vc-time-day[data-v-63f66eaa] {\n  color: var(--accent-600);\n  margin-left: 4px;\n}\n.vc-time-year[data-v-63f66eaa] {\n  color: var(--gray-500);\n  margin-left: 8px;\n}\n.vc-time-select[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n}\n.vc-am-pm[data-v-63f66eaa] {\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  background: var(--gray-200);\n  color: var(--gray-800);\n  margin-left: 8px;\n  padding: 4px;\n  border-radius: var(--rounded);\n  height: 30px;\n}\n.vc-am-pm button[data-v-63f66eaa] {\n    font-size: var(--text-sm);\n    font-weight: var(--font-medium);\n    padding: 0 4px;\n    background: transparent;\n    border: 2px solid transparent;\n    border-radius: var(--rounded);\n    line-height: var(--leading-snug);\n}\n.vc-am-pm button[data-v-63f66eaa]:hover {\n      color: var(--gray-600);\n}\n.vc-am-pm button[data-v-63f66eaa]:focus {\n      border-color: var(--accent-400);\n}\n.vc-am-pm button.active[data-v-63f66eaa] {\n      background: var(--accent-600);\n      color: var(--white);\n}\n.vc-am-pm button.active[data-v-63f66eaa]:hover {\n        background: var(--accent-500);\n}\n.vc-am-pm button.active[data-v-63f66eaa]:focus {\n        border-color: var(--accent-400);\n}\n.vc-is-dark .vc-time-picker[data-v-63f66eaa] {\n    border-color: var(--gray-700);\n}\n.vc-is-dark .vc-time-icon[data-v-63f66eaa] {\n    color: var(--gray-400);\n}\n.vc-is-dark .vc-time-weekday[data-v-63f66eaa] {\n    color: var(--gray-400);\n}\n.vc-is-dark .vc-time-month[data-v-63f66eaa] {\n    color: var(--accent-400);\n}\n.vc-is-dark .vc-time-day[data-v-63f66eaa] {\n    color: var(--accent-400);\n}\n.vc-is-dark .vc-time-year[data-v-63f66eaa] {\n    color: var(--gray-500);\n}\n.vc-is-dark .vc-am-pm[data-v-63f66eaa] {\n    background: var(--gray-700);\n}\n.vc-is-dark .vc-am-pm[data-v-63f66eaa]:focus {\n      border-color: var(--accent-500);\n}\n.vc-is-dark .vc-am-pm button[data-v-63f66eaa] {\n      color: var(--gray-100);\n}\n.vc-is-dark .vc-am-pm button[data-v-63f66eaa]:hover {\n        color: var(--gray-400);\n}\n.vc-is-dark .vc-am-pm button[data-v-63f66eaa]:focus {\n        border-color: var(--accent-500);\n}\n.vc-is-dark .vc-am-pm button.active[data-v-63f66eaa] {\n        background: var(--accent-500);\n        color: var(--white);\n}\n.vc-is-dark .vc-am-pm button.active[data-v-63f66eaa]:hover {\n          background: var(--accent-600);\n}\n.vc-is-dark .vc-am-pm button.active[data-v-63f66eaa]:focus {\n          border-color: var(--accent-500);\n}\n";
styleInject(css_248z);
script$1.render = render$1;
script$1.__scopeId = "data-v-63f66eaa";
var _dateConfig = {
  type: "auto",
  mask: "iso",
  timeAdjust: ""
};
var _rangeConfig = {
  start: _objectSpread2$1({}, _dateConfig),
  end: _objectSpread2$1({}, _dateConfig)
};
var MODE = {
  DATE: "date",
  DATE_TIME: "datetime",
  TIME: "time"
};
var RANGE_PRIORITY = {
  NONE: 0,
  START: 1,
  END: 2,
  BOTH: 3
};
var script = {
  name: "DatePicker",
  emits: ["update:modelValue", "drag", "dayclick", "daykeydown", "popover-will-show", "popover-did-show", "popover-will-hide", "popover-did-hide"],
  render: function render6() {
    var _this = this;
    var _footer = function footer(wrap, wrapperEl) {
      if (!_this.$slots.footer)
        return wrap;
      var children = [wrap, _this.$slots.footer()];
      return wrapperEl ? h$5(wrapperEl, children) : children;
    };
    var timePicker = function timePicker2() {
      if (!_this.dateParts)
        return null;
      var parts = _this.isRange ? _this.dateParts : [_this.dateParts[0]];
      return h$5("div", {}, _objectSpread2$1(_objectSpread2$1({}, _this.$slots), {}, {
        default: function _default5() {
          return parts.map(function(dp, idx) {
            return h$5(script$1, {
              modelValue: dp,
              locale: _this.$locale,
              theme: _this.$theme,
              is24hr: _this.is24hr,
              minuteIncrement: _this.minuteIncrement,
              showBorder: !_this.isTime,
              isDisabled: _this.isDateTime && !dp.isValid || _this.isDragging,
              "onUpdate:modelValue": function onUpdateModelValue(p2) {
                return _this.onTimeInput(p2, idx === 0);
              }
            });
          });
        }
      }));
    };
    var calendar = function calendar2() {
      return h$5(script$3, _objectSpread2$1(_objectSpread2$1({}, _this.$attrs), {}, {
        attributes: _this.attributes_,
        theme: _this.$theme,
        locale: _this.$locale,
        minDate: _this.minDateExact || _this.minDate,
        maxDate: _this.maxDateExact || _this.maxDate,
        disabledDates: _this.disabledDates,
        availableDates: _this.availableDates,
        onDayclick: _this.onDayClick,
        onDaykeydown: _this.onDayKeydown,
        onDaymouseenter: _this.onDayMouseEnter,
        ref: "calendar"
      }), _objectSpread2$1(_objectSpread2$1({}, _this.$slots), {}, {
        footer: function footer() {
          return _this.isDateTime ? _footer(timePicker()) : _footer();
        }
      }));
    };
    var content3 = function content4() {
      if (_this.isTime) {
        return h$5("div", {
          class: ["vc-container", "vc-".concat(_this.$theme.color), {
            "vc-is-dark": _this.$theme.isDark
          }]
        }, _footer(timePicker(), "div"));
      }
      return calendar();
    };
    return this.$slots.default ? h$5("div", [
      this.$slots.default(this.slotArgs),
      h$5(script$5, {
        id: this.datePickerPopoverId,
        placement: "bottom-start",
        contentClass: "vc-container".concat(this.isDark ? " vc-is-dark" : ""),
        "on-before-show": function onBeforeShow(e2) {
          return _this.$emit("popover-will-show", e2);
        },
        "on-after-show": function onAfterShow(e2) {
          return _this.$emit("popover-did-show", e2);
        },
        "on-before-hide": function onBeforeHide(e2) {
          return _this.$emit("popover-will-hide", e2);
        },
        "on-after-hide": function onAfterHide(e2) {
          return _this.$emit("popover-did-hide", e2);
        },
        ref: "popover"
      }, {
        default: content3
      })
    ]) : content3();
  },
  mixins: [rootMixin$1],
  props: {
    mode: {
      type: String,
      default: MODE.DATE
    },
    modelValue: {
      type: null,
      required: true
    },
    modelConfig: {
      type: Object,
      default: function _default3() {
        return _objectSpread2$1({}, _dateConfig);
      }
    },
    is24hr: Boolean,
    minuteIncrement: Number,
    isRequired: Boolean,
    isRange: Boolean,
    updateOnInput: {
      type: Boolean,
      default: getDefault("datePicker.updateOnInput")
    },
    inputDebounce: {
      type: Number,
      default: getDefault("datePicker.inputDebounce")
    },
    popover: {
      type: Object,
      default: function _default4() {
        return {};
      }
    },
    dragAttribute: Object,
    selectAttribute: Object,
    attributes: Array
  },
  data: function data7() {
    return {
      value_: null,
      dateParts: null,
      activeDate: "",
      dragValue: null,
      inputValues: ["", ""],
      updateTimeout: null,
      watchValue: true,
      datePickerPopoverId: createGuid()
    };
  },
  computed: {
    isDate: function isDate() {
      return this.mode.toLowerCase() === MODE.DATE;
    },
    isDateTime: function isDateTime() {
      return this.mode.toLowerCase() === MODE.DATE_TIME;
    },
    isTime: function isTime() {
      return this.mode.toLowerCase() === MODE.TIME;
    },
    isDragging: function isDragging() {
      return !!this.dragValue;
    },
    modelConfig_: function modelConfig_() {
      if (this.isRange) {
        return {
          start: _objectSpread2$1(_objectSpread2$1({}, _rangeConfig.start), this.modelConfig.start || this.modelConfig),
          end: _objectSpread2$1(_objectSpread2$1({}, _rangeConfig.end), this.modelConfig.end || this.modelConfig)
        };
      }
      return _objectSpread2$1(_objectSpread2$1({}, _dateConfig), this.modelConfig);
    },
    inputMask: function inputMask() {
      var masks3 = this.$locale.masks;
      if (this.isTime) {
        return this.is24hr ? masks3.inputTime24hr : masks3.inputTime;
      }
      if (this.isDateTime) {
        return this.is24hr ? masks3.inputDateTime24hr : masks3.inputDateTime;
      }
      return this.$locale.masks.input;
    },
    inputMaskHasTime: function inputMaskHasTime() {
      return /[Hh]/g.test(this.inputMask);
    },
    inputMaskHasDate: function inputMaskHasDate() {
      return /[dD]{1,2}|Do|W{1,4}|M{1,4}|YY(?:YY)?/g.test(this.inputMask);
    },
    inputMaskPatch: function inputMaskPatch() {
      if (this.inputMaskHasTime && this.inputMaskHasDate) {
        return PATCH.DATE_TIME;
      }
      if (this.inputMaskHasDate)
        return PATCH.DATE;
      if (this.inputMaskHasTime)
        return PATCH.TIME;
      return void 0;
    },
    slotArgs: function slotArgs() {
      var _this2 = this;
      var isRange = this.isRange, isDragging3 = this.isDragging, updateValue3 = this.updateValue, showPopover2 = this.showPopover, hidePopover2 = this.hidePopover, togglePopover2 = this.togglePopover;
      var inputValue = isRange ? {
        start: this.inputValues[0],
        end: this.inputValues[1]
      } : this.inputValues[0];
      var events2 = [true, false].map(function(isStart) {
        return _objectSpread2$1({
          input: _this2.onInputInput(isStart),
          change: _this2.onInputChange(isStart),
          keyup: _this2.onInputKeyup
        }, getPopoverTriggerEvents(_objectSpread2$1(_objectSpread2$1({}, _this2.popover_), {}, {
          id: _this2.datePickerPopoverId,
          callback: function callback(e2) {
            if (e2.action === "show" && e2.completed) {
              _this2.onInputShow(isStart);
            }
          }
        })));
      });
      var inputEvents = isRange ? {
        start: events2[0],
        end: events2[1]
      } : events2[0];
      return {
        inputValue,
        inputEvents,
        isDragging: isDragging3,
        updateValue: updateValue3,
        showPopover: showPopover2,
        hidePopover: hidePopover2,
        togglePopover: togglePopover2,
        getPopoverTriggerEvents
      };
    },
    popover_: function popover_() {
      return defaultsDeep_1(this.popover, getDefault("datePicker.popover"));
    },
    selectAttribute_: function selectAttribute_() {
      if (!this.hasValue(this.value_))
        return null;
      var attribute = _objectSpread2$1(_objectSpread2$1({
        key: "select-drag"
      }, this.selectAttribute), {}, {
        dates: this.value_,
        pinPage: true
      });
      var dot = attribute.dot, bar = attribute.bar, highlight = attribute.highlight, content3 = attribute.content;
      if (!dot && !bar && !highlight && !content3) {
        attribute.highlight = true;
      }
      return attribute;
    },
    dragAttribute_: function dragAttribute_() {
      if (!this.isRange || !this.hasValue(this.dragValue)) {
        return null;
      }
      var attribute = _objectSpread2$1(_objectSpread2$1({
        key: "select-drag"
      }, this.dragAttribute), {}, {
        dates: this.dragValue
      });
      var dot = attribute.dot, bar = attribute.bar, highlight = attribute.highlight, content3 = attribute.content;
      if (!dot && !bar && !highlight && !content3) {
        attribute.highlight = {
          startEnd: {
            fillMode: "outline"
          }
        };
      }
      return attribute;
    },
    attributes_: function attributes_() {
      var attrs = isArrayLikeObject_1(this.attributes) ? _toConsumableArray(this.attributes) : [];
      if (this.dragAttribute_) {
        attrs.push(this.dragAttribute_);
      } else if (this.selectAttribute_) {
        attrs.push(this.selectAttribute_);
      }
      return attrs;
    }
  },
  watch: {
    inputMask: function inputMask2() {
      this.formatInput();
    },
    modelValue: function modelValue2(val) {
      if (!this.watchValue)
        return;
      this.forceUpdateValue(val, {
        config: this.modelConfig,
        notify: false,
        formatInput: true,
        hidePopover: false
      });
    },
    value_: function value_() {
      this.refreshDateParts();
    },
    dragValue: function dragValue() {
      this.refreshDateParts();
    },
    timezone: function timezone() {
      this.refreshDateParts();
      this.forceUpdateValue(this.value_, {
        notify: true,
        formatInput: true
      });
    }
  },
  created: function created4() {
    this.forceUpdateValue(this.modelValue, {
      config: this.modelConfig_,
      notify: false,
      formatInput: true,
      hidePopover: false
    });
    this.refreshDateParts();
  },
  mounted: function mounted6() {
    on$2(document, "keydown", this.onDocumentKeyDown);
    on$2(document, "click", this.onDocumentClick);
  },
  beforeUnmount: function beforeUnmount3() {
    off$1(document, "keydown", this.onDocumentKeyDown);
    off$1(document, "click", this.onDocumentClick);
  },
  methods: {
    getDateParts: function getDateParts(date2) {
      return this.$locale.getDateParts(date2);
    },
    getDateFromParts: function getDateFromParts(parts) {
      return this.$locale.getDateFromParts(parts);
    },
    refreshDateParts: function refreshDateParts() {
      var _this3 = this;
      var value2 = this.dragValue || this.value_;
      var dateParts = [];
      if (this.isRange) {
        if (value2 && value2.start) {
          dateParts.push(this.getDateParts(value2.start));
        } else {
          dateParts.push({});
        }
        if (value2 && value2.end) {
          dateParts.push(this.getDateParts(value2.end));
        } else {
          dateParts.push({});
        }
      } else if (value2) {
        dateParts.push(this.getDateParts(value2));
      } else {
        dateParts.push({});
      }
      this.$nextTick(function() {
        return _this3.dateParts = dateParts;
      });
    },
    onDocumentKeyDown: function onDocumentKeyDown(e2) {
      if (this.dragValue && e2.key === "Escape") {
        this.dragValue = null;
      }
    },
    onDocumentClick: function onDocumentClick2(e2) {
      if (document.body.contains(e2.target) && !elementContains(this.$el, e2.target)) {
        this.dragValue = null;
        this.formatInput();
      }
    },
    onDayClick: function onDayClick(day) {
      this.handleDayClick(day);
      this.$emit("dayclick", day);
    },
    onDayKeydown: function onDayKeydown(day) {
      switch (day.event.key) {
        case " ":
        case "Enter": {
          this.handleDayClick(day);
          day.event.preventDefault();
          break;
        }
        case "Escape": {
          this.hidePopover();
        }
      }
      this.$emit("daykeydown", day);
    },
    handleDayClick: function handleDayClick(day) {
      var _this$popover_ = this.popover_, keepVisibleOnInput = _this$popover_.keepVisibleOnInput, visibility = _this$popover_.visibility;
      var opts2 = {
        patch: PATCH.DATE,
        adjustTime: true,
        formatInput: true,
        hidePopover: this.isDate && !keepVisibleOnInput && visibility !== "visible"
      };
      if (this.isRange) {
        if (!this.isDragging) {
          this.dragTrackingValue = _objectSpread2$1({}, day.range);
        } else {
          this.dragTrackingValue.end = day.date;
        }
        opts2.isDragging = !this.isDragging;
        opts2.rangePriority = opts2.isDragging ? RANGE_PRIORITY.NONE : RANGE_PRIORITY.BOTH;
        opts2.hidePopover = opts2.hidePopover && !opts2.isDragging;
        this.updateValue(this.dragTrackingValue, opts2);
      } else {
        opts2.clearIfEqual = !this.isRequired;
        this.updateValue(day.date, opts2);
      }
    },
    onDayMouseEnter: function onDayMouseEnter(day) {
      if (!this.isDragging)
        return;
      this.dragTrackingValue.end = day.date;
      this.updateValue(this.dragTrackingValue, {
        patch: PATCH.DATE,
        adjustTime: true,
        formatInput: true,
        hidePriority: false,
        rangePriority: RANGE_PRIORITY.NONE
      });
    },
    onTimeInput: function onTimeInput(parts, isStart) {
      var _this4 = this;
      var value2 = null;
      if (this.isRange) {
        var start2 = isStart ? parts : this.dateParts[0];
        var end2 = isStart ? this.dateParts[1] : parts;
        value2 = {
          start: start2,
          end: end2
        };
      } else {
        value2 = parts;
      }
      this.updateValue(value2, {
        patch: PATCH.TIME,
        rangePriority: isStart ? RANGE_PRIORITY.START : RANGE_PRIORITY.END
      }).then(function() {
        return _this4.adjustPageRange(isStart);
      });
    },
    onInputInput: function onInputInput(isStart) {
      var _this5 = this;
      return function(e2) {
        if (!_this5.updateOnInput)
          return;
        _this5.onInputUpdate(e2.target.value, isStart, {
          formatInput: false,
          hidePopover: false,
          debounce: _this5.inputDebounce
        });
      };
    },
    onInputChange: function onInputChange(isStart) {
      var _this6 = this;
      return function(e2) {
        _this6.onInputUpdate(e2.target.value, isStart, {
          formatInput: true,
          hidePopover: false
        });
      };
    },
    onInputUpdate: function onInputUpdate(inputValue, isStart, opts2) {
      var _this7 = this;
      this.inputValues.splice(isStart ? 0 : 1, 1, inputValue);
      var value2 = this.isRange ? {
        start: this.inputValues[0],
        end: this.inputValues[1] || this.inputValues[0]
      } : inputValue;
      var config = {
        type: "string",
        mask: this.inputMask
      };
      this.updateValue(value2, _objectSpread2$1(_objectSpread2$1({}, opts2), {}, {
        config,
        patch: this.inputMaskPatch,
        rangePriority: isStart ? RANGE_PRIORITY.START : RANGE_PRIORITY.END
      })).then(function() {
        return _this7.adjustPageRange(isStart);
      });
    },
    onInputShow: function onInputShow(isStart) {
      this.adjustPageRange(isStart);
    },
    onInputKeyup: function onInputKeyup(e2) {
      if (e2.key !== "Escape")
        return;
      this.updateValue(this.value_, {
        formatInput: true,
        hidePopover: true
      });
    },
    updateValue: function updateValue2(value2) {
      var _this8 = this;
      var opts2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      clearTimeout(this.updateTimeout);
      return new Promise(function(resolve) {
        var debounce2 = opts2.debounce, args = _objectWithoutProperties$1(opts2, ["debounce"]);
        if (debounce2 > 0) {
          _this8.updateTimeout = setTimeout(function() {
            _this8.forceUpdateValue(value2, args);
            resolve(_this8.value_);
          }, debounce2);
        } else {
          _this8.forceUpdateValue(value2, args);
          resolve(_this8.value_);
        }
      });
    },
    forceUpdateValue: function forceUpdateValue(value2) {
      var _this9 = this;
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$config = _ref.config, config = _ref$config === void 0 ? this.modelConfig_ : _ref$config, _ref$patch = _ref.patch, patch = _ref$patch === void 0 ? PATCH.DATE_TIME : _ref$patch, _ref$notify = _ref.notify, notify = _ref$notify === void 0 ? true : _ref$notify, _ref$clearIfEqual = _ref.clearIfEqual, clearIfEqual = _ref$clearIfEqual === void 0 ? false : _ref$clearIfEqual, _ref$formatInput = _ref.formatInput, formatInput2 = _ref$formatInput === void 0 ? true : _ref$formatInput, _ref$hidePopover = _ref.hidePopover, hidePopover2 = _ref$hidePopover === void 0 ? false : _ref$hidePopover, _ref$adjustTime = _ref.adjustTime, adjustTime = _ref$adjustTime === void 0 ? false : _ref$adjustTime, _ref$isDragging = _ref.isDragging, isDragging3 = _ref$isDragging === void 0 ? this.isDragging : _ref$isDragging, _ref$rangePriority = _ref.rangePriority, rangePriority = _ref$rangePriority === void 0 ? RANGE_PRIORITY.BOTH : _ref$rangePriority;
      var normalizedValue = this.normalizeValue(value2, config, patch, rangePriority);
      if (!normalizedValue && this.isRequired) {
        normalizedValue = this.value_;
      }
      if (adjustTime) {
        normalizedValue = this.adjustTimeForValue(normalizedValue, config);
      }
      var isDisabled2 = this.valueIsDisabled(normalizedValue);
      if (isDisabled2) {
        if (isDragging3)
          return;
        normalizedValue = this.value_;
        hidePopover2 = false;
      }
      var valueKey = isDragging3 ? "dragValue" : "value_";
      var valueChanged = !this.valuesAreEqual(this[valueKey], normalizedValue);
      if (!isDisabled2 && !valueChanged && clearIfEqual) {
        normalizedValue = null;
        valueChanged = true;
      }
      if (valueChanged) {
        this[valueKey] = normalizedValue;
        if (!isDragging3)
          this.dragValue = null;
      }
      if (notify && valueChanged) {
        var denormalizedValue = this.denormalizeValue(normalizedValue, this.dateConfig);
        var event = this.isDragging ? "drag" : "update:modelValue";
        this.watchValue = false;
        this.$emit(event, denormalizedValue);
        this.$nextTick(function() {
          return _this9.watchValue = true;
        });
      }
      if (hidePopover2)
        this.hidePopover();
      if (formatInput2)
        this.formatInput();
    },
    hasValue: function hasValue(value2) {
      if (this.isRange) {
        return isObject$1$1(value2) && value2.start && value2.end;
      }
      return !!value2;
    },
    normalizeValue: function normalizeValue(value2, config, patch, rangePriority) {
      if (!this.hasValue(value2))
        return null;
      if (this.isRange) {
        var result = {};
        var start2 = value2.start > value2.end ? value2.end : value2.start;
        var startFillDate = this.value_ && this.value_.start || this.modelConfig_.start.fillDate;
        var startConfig = config.start || config;
        result.start = this.normalizeDate(start2, _objectSpread2$1(_objectSpread2$1({}, startConfig), {}, {
          fillDate: startFillDate,
          patch
        }));
        var end2 = value2.start > value2.end ? value2.start : value2.end;
        var endFillDate = this.value_ && this.value_.end || this.modelConfig_.end.fillDate;
        var endConfig = config.end || config;
        result.end = this.normalizeDate(end2, _objectSpread2$1(_objectSpread2$1({}, endConfig), {}, {
          fillDate: endFillDate,
          patch
        }));
        return this.sortRange(result, rangePriority);
      }
      return this.normalizeDate(value2, _objectSpread2$1(_objectSpread2$1({}, config), {}, {
        fillDate: this.value_ || this.modelConfig_.fillDate,
        patch
      }));
    },
    adjustTimeForValue: function adjustTimeForValue(value2, config) {
      if (!this.hasValue(value2))
        return null;
      if (this.isRange) {
        return {
          start: this.$locale.adjustTimeForDate(value2.start, config.start || config),
          end: this.$locale.adjustTimeForDate(value2.end, config.end || config)
        };
      }
      return this.$locale.adjustTimeForDate(value2, config);
    },
    sortRange: function sortRange(range) {
      var priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : RANGE_PRIORITY.NONE;
      var start2 = range.start, end2 = range.end;
      if (start2 > end2) {
        switch (priority) {
          case RANGE_PRIORITY.START:
            return {
              start: start2,
              end: start2
            };
          case RANGE_PRIORITY.END:
            return {
              start: end2,
              end: end2
            };
          case RANGE_PRIORITY.BOTH:
            return {
              start: end2,
              end: start2
            };
        }
      }
      return {
        start: start2,
        end: end2
      };
    },
    denormalizeValue: function denormalizeValue(value2) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.modelConfig_;
      if (this.isRange) {
        if (!this.hasValue(value2))
          return null;
        return {
          start: this.$locale.denormalizeDate(value2.start, config.start || config),
          end: this.$locale.denormalizeDate(value2.end, config.end || config)
        };
      }
      return this.$locale.denormalizeDate(value2, config);
    },
    valuesAreEqual: function valuesAreEqual(a3, b2) {
      if (this.isRange) {
        var aHasValue = this.hasValue(a3);
        var bHasValue = this.hasValue(b2);
        if (!aHasValue && !bHasValue)
          return true;
        if (aHasValue !== bHasValue)
          return false;
        return datesAreEqual(a3.start, b2.start) && datesAreEqual(a3.end, b2.end);
      }
      return datesAreEqual(a3, b2);
    },
    valueIsDisabled: function valueIsDisabled(value2) {
      return this.hasValue(value2) && this.disabledAttribute && this.disabledAttribute.intersectsDate(value2);
    },
    formatInput: function formatInput() {
      var _this10 = this;
      this.$nextTick(function() {
        var opts2 = {
          type: "string",
          mask: _this10.inputMask
        };
        var value2 = _this10.denormalizeValue(_this10.dragValue || _this10.value_, opts2);
        if (_this10.isRange) {
          _this10.inputValues = [value2 && value2.start, value2 && value2.end];
        } else {
          _this10.inputValues = [value2, ""];
        }
      });
    },
    showPopover: function showPopover$1() {
      var opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      showPopover(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        ref: this.$el
      }, this.popover_), opts2), {}, {
        isInteractive: true,
        id: this.datePickerPopoverId
      }));
    },
    hidePopover: function hidePopover$1() {
      var opts2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      hidePopover(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        hideDelay: 10
      }, this.showPopover_), opts2), {}, {
        id: this.datePickerPopoverId
      }));
    },
    togglePopover: function togglePopover$1(opts2) {
      togglePopover(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        ref: this.$el
      }, this.popover_), opts2), {}, {
        isInteractive: true,
        id: this.datePickerPopoverId
      }));
    },
    adjustPageRange: function adjustPageRange(isStart) {
      var _this11 = this;
      this.$nextTick(function() {
        var calendar = _this11.$refs.calendar;
        var page = _this11.getPageForValue(isStart);
        var position = isStart ? 1 : -1;
        if (page && calendar && !pageIsBetweenPages(page, calendar.firstPage, calendar.lastPage)) {
          calendar.move(page, {
            position,
            transition: "fade"
          });
        }
      });
    },
    getPageForValue: function getPageForValue(isStart) {
      if (this.hasValue(this.value_)) {
        return this.pageForDate(this.isRange ? this.value_[isStart ? "start" : "end"] : this.value_);
      }
      return null;
    },
    move: function move2(args, opts2) {
      if (this.$refs.calendar) {
        return this.$refs.calendar.move(args, opts2);
      }
      return Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"));
    },
    focusDate: function focusDate2(date2, opts2) {
      if (this.$refs.calendar) {
        return this.$refs.calendar.focusDate(date2, opts2);
      }
      return Promise.reject(new Error("Navigation disabled while calendar is not yet displayed"));
    }
  }
};
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike_1(collection) ? Array(collection.length) : [];
  _baseEach(collection, function(value2, key, collection2) {
    result[++index2] = iteratee(value2, key, collection2);
  });
  return result;
}
var _baseMap = baseMap;
function map(collection, iteratee) {
  var func = isArray_1(collection) ? _arrayMap : _baseMap;
  return func(collection, _baseIteratee(iteratee));
}
var map_1 = map;
function buildMediaQuery(screens) {
  if (isString_1(screens)) {
    screens = { min: screens };
  }
  if (!isArrayLikeObject_1(screens)) {
    screens = [screens];
  }
  return screens.map((screen) => {
    if (has$1$1(screen, "raw")) {
      return screen.raw;
    }
    return map_1(screen, (value2, feature) => {
      feature = get_1({
        min: "min-width",
        max: "max-width"
      }, feature, feature);
      return `(${feature}: ${value2})`;
    }).join(" and ");
  }).join(", ");
}
var screensPlugin = {
  install: (app, screens) => {
    screens = defaultsDeep_1(screens, window && window.__screens__, defaultScreens);
    let shouldRefreshQueries = true;
    const state2 = reactive({
      matches: [],
      queries: []
    });
    const refreshMatches = () => {
      state2.matches = toPairs_1(state2.queries).filter((p2) => p2[1].matches).map((p2) => p2[0]);
    };
    const refreshQueries = () => {
      if (!shouldRefreshQueries || !window || !window.matchMedia)
        return;
      state2.queries = mapValues_1(screens, (v2) => {
        const query = window.matchMedia(buildMediaQuery(v2));
        if (isFunction_1(query.addEventListener)) {
          query.addEventListener("change", refreshMatches);
        } else {
          query.addListener(refreshMatches);
        }
        return query;
      });
      shouldRefreshQueries = false;
      refreshMatches();
    };
    app.mixin({
      mounted() {
        refreshQueries();
      },
      computed: {
        $screens() {
          return (config, def) => state2.matches.reduce((prev, curr) => has$1$1(config, curr) ? config[curr] : prev, isUndefined_1(def) ? config.default : def);
        }
      }
    });
  }
};
var setup2 = (app, defaults2) => {
  defaults2 = setup$1(defaults2);
  app.use(screensPlugin, defaults2.screens);
  return defaults2;
};
var __defProp$1 = Object.defineProperty;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value2) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1 = (a3, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a3, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b2)) {
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a3, prop, b2[prop]);
    }
  return a3;
};
var isFunction$2 = (value2) => typeof value2 === "function";
var isString$3 = (value2) => typeof value2 === "string";
var isNonEmptyString = (value2) => isString$3(value2) && value2.trim().length > 0;
var isNumber$2 = (value2) => typeof value2 === "number";
var isUndefined$1 = (value2) => typeof value2 === "undefined";
var isObject$5 = (value2) => typeof value2 === "object" && value2 !== null;
var isJSX = (obj) => hasProp(obj, "tag") && isNonEmptyString(obj.tag);
var isTouchEvent = (event) => window.TouchEvent && event instanceof TouchEvent;
var isToastComponent = (obj) => hasProp(obj, "component") && isToastContent(obj.component);
var isVueComponent = (c2) => isFunction$2(c2) || isObject$5(c2);
var isToastContent = (obj) => !isUndefined$1(obj) && (isString$3(obj) || isVueComponent(obj) || isToastComponent(obj));
var isDOMRect = (obj) => isObject$5(obj) && ["height", "width", "right", "left", "top", "bottom"].every((p2) => isNumber$2(obj[p2]));
var hasProp = (obj, propKey) => (isObject$5(obj) || isFunction$2(obj)) && propKey in obj;
var getId = ((i2) => () => i2++)(0);
function getX(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientX : event.clientX;
}
function getY(event) {
  return isTouchEvent(event) ? event.targetTouches[0].clientY : event.clientY;
}
var removeElement = (el) => {
  if (!isUndefined$1(el.remove)) {
    el.remove();
  } else if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
};
var getVueComponentFromObj = (obj) => {
  if (isToastComponent(obj)) {
    return getVueComponentFromObj(obj.component);
  }
  if (isJSX(obj)) {
    return defineComponent({
      render() {
        return obj;
      }
    });
  }
  return typeof obj === "string" ? obj : toRaw(unref(obj));
};
var normalizeToastComponent = (obj) => {
  if (typeof obj === "string") {
    return obj;
  }
  const props2 = hasProp(obj, "props") && isObject$5(obj.props) ? obj.props : {};
  const listeners = hasProp(obj, "listeners") && isObject$5(obj.listeners) ? obj.listeners : {};
  return { component: getVueComponentFromObj(obj), props: props2, listeners };
};
var isBrowser = () => typeof window !== "undefined";
var EventBus = class {
  constructor() {
    this.allHandlers = {};
  }
  getHandlers(eventType) {
    return this.allHandlers[eventType] || [];
  }
  on(eventType, handler2) {
    const handlers2 = this.getHandlers(eventType);
    handlers2.push(handler2);
    this.allHandlers[eventType] = handlers2;
  }
  off(eventType, handler2) {
    const handlers2 = this.getHandlers(eventType);
    handlers2.splice(handlers2.indexOf(handler2) >>> 0, 1);
  }
  emit(eventType, event) {
    const handlers2 = this.getHandlers(eventType);
    handlers2.forEach((handler2) => handler2(event));
  }
};
var isEventBusInterface = (e2) => ["on", "off", "emit"].every((f2) => hasProp(e2, f2) && isFunction$2(e2[f2]));
var TYPE;
(function(TYPE2) {
  TYPE2["SUCCESS"] = "success";
  TYPE2["ERROR"] = "error";
  TYPE2["WARNING"] = "warning";
  TYPE2["INFO"] = "info";
  TYPE2["DEFAULT"] = "default";
})(TYPE || (TYPE = {}));
var POSITION;
(function(POSITION2) {
  POSITION2["TOP_LEFT"] = "top-left";
  POSITION2["TOP_CENTER"] = "top-center";
  POSITION2["TOP_RIGHT"] = "top-right";
  POSITION2["BOTTOM_LEFT"] = "bottom-left";
  POSITION2["BOTTOM_CENTER"] = "bottom-center";
  POSITION2["BOTTOM_RIGHT"] = "bottom-right";
})(POSITION || (POSITION = {}));
var EVENTS;
(function(EVENTS2) {
  EVENTS2["ADD"] = "add";
  EVENTS2["DISMISS"] = "dismiss";
  EVENTS2["UPDATE"] = "update";
  EVENTS2["CLEAR"] = "clear";
  EVENTS2["UPDATE_DEFAULTS"] = "update_defaults";
})(EVENTS || (EVENTS = {}));
var VT_NAMESPACE = "Vue-Toastification";
var COMMON = {
  type: {
    type: String,
    default: TYPE.DEFAULT
  },
  classNames: {
    type: [String, Array],
    default: () => []
  },
  trueBoolean: {
    type: Boolean,
    default: true
  }
};
var ICON = {
  type: COMMON.type,
  customIcon: {
    type: [String, Boolean, Object, Function],
    default: true
  }
};
var CLOSE_BUTTON = {
  component: {
    type: [String, Object, Function, Boolean],
    default: "button"
  },
  classNames: COMMON.classNames,
  showOnHover: {
    type: Boolean,
    default: false
  },
  ariaLabel: {
    type: String,
    default: "close"
  }
};
var PROGRESS_BAR = {
  timeout: {
    type: [Number, Boolean],
    default: 5e3
  },
  hideProgressBar: {
    type: Boolean,
    default: false
  },
  isRunning: {
    type: Boolean,
    default: false
  }
};
var TRANSITION = {
  transition: {
    type: [Object, String],
    default: `${VT_NAMESPACE}__bounce`
  }
};
var CORE_TOAST = {
  position: {
    type: String,
    default: POSITION.TOP_RIGHT
  },
  draggable: COMMON.trueBoolean,
  draggablePercent: {
    type: Number,
    default: 0.6
  },
  pauseOnFocusLoss: COMMON.trueBoolean,
  pauseOnHover: COMMON.trueBoolean,
  closeOnClick: COMMON.trueBoolean,
  timeout: PROGRESS_BAR.timeout,
  hideProgressBar: PROGRESS_BAR.hideProgressBar,
  toastClassName: COMMON.classNames,
  bodyClassName: COMMON.classNames,
  icon: ICON.customIcon,
  closeButton: CLOSE_BUTTON.component,
  closeButtonClassName: CLOSE_BUTTON.classNames,
  showCloseButtonOnHover: CLOSE_BUTTON.showOnHover,
  accessibility: {
    type: Object,
    default: () => ({
      toastRole: "alert",
      closeButtonLabel: "close"
    })
  },
  rtl: {
    type: Boolean,
    default: false
  },
  eventBus: {
    type: Object,
    required: false,
    default: () => new EventBus()
  }
};
var TOAST = {
  id: {
    type: [String, Number],
    required: true,
    default: 0
  },
  type: COMMON.type,
  content: {
    type: [String, Object, Function],
    required: true,
    default: ""
  },
  onClick: {
    type: Function,
    default: void 0
  },
  onClose: {
    type: Function,
    default: void 0
  }
};
var CONTAINER = {
  container: {
    type: [
      Object,
      Function
    ],
    default: () => document.body
  },
  newestOnTop: COMMON.trueBoolean,
  maxToasts: {
    type: Number,
    default: 20
  },
  transition: TRANSITION.transition,
  toastDefaults: Object,
  filterBeforeCreate: {
    type: Function,
    default: (toast) => toast
  },
  filterToasts: {
    type: Function,
    default: (toasts) => toasts
  },
  containerClassName: COMMON.classNames,
  onMounted: Function,
  shareAppContext: [Boolean, Object]
};
var propValidators_default = {
  CORE_TOAST,
  TOAST,
  CONTAINER,
  PROGRESS_BAR,
  ICON,
  TRANSITION,
  CLOSE_BUTTON
};
var VtProgressBar_default = defineComponent({
  name: "VtProgressBar",
  props: propValidators_default.PROGRESS_BAR,
  data() {
    return {
      hasClass: true
    };
  },
  computed: {
    style() {
      return {
        animationDuration: `${this.timeout}ms`,
        animationPlayState: this.isRunning ? "running" : "paused",
        opacity: this.hideProgressBar ? 0 : 1
      };
    },
    cpClass() {
      return this.hasClass ? `${VT_NAMESPACE}__progress-bar` : "";
    }
  },
  watch: {
    timeout() {
      this.hasClass = false;
      this.$nextTick(() => this.hasClass = true);
    }
  },
  mounted() {
    this.$el.addEventListener("animationend", this.animationEnded);
  },
  beforeUnmount() {
    this.$el.removeEventListener("animationend", this.animationEnded);
  },
  methods: {
    animationEnded() {
      this.$emit("close-toast");
    }
  }
});
function render7(_ctx, _cache) {
  return openBlock(), createElementBlock("div", {
    style: normalizeStyle(_ctx.style),
    class: normalizeClass(_ctx.cpClass)
  }, null, 6);
}
VtProgressBar_default.render = render7;
var VtProgressBar_default2 = VtProgressBar_default;
var VtCloseButton_default = defineComponent({
  name: "VtCloseButton",
  props: propValidators_default.CLOSE_BUTTON,
  computed: {
    buttonComponent() {
      if (this.component !== false) {
        return getVueComponentFromObj(this.component);
      }
      return "button";
    },
    classes() {
      const classes = [`${VT_NAMESPACE}__close-button`];
      if (this.showOnHover) {
        classes.push("show-on-hover");
      }
      return classes.concat(this.classNames);
    }
  }
});
var _hoisted_1$k = /* @__PURE__ */ createTextVNode(" \xD7 ");
function render22(_ctx, _cache) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.buttonComponent), mergeProps({
    "aria-label": _ctx.ariaLabel,
    class: _ctx.classes
  }, _ctx.$attrs), {
    default: withCtx(() => [
      _hoisted_1$k
    ]),
    _: 1
  }, 16, ["aria-label", "class"]);
}
VtCloseButton_default.render = render22;
var VtCloseButton_default2 = VtCloseButton_default;
var VtSuccessIcon_default = {};
var _hoisted_12$2 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "check-circle",
  class: "svg-inline--fa fa-check-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_2$j = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"
}, null, -1);
var _hoisted_3$d = [
  _hoisted_2$j
];
function render32(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_12$2, _hoisted_3$d);
}
VtSuccessIcon_default.render = render32;
var VtSuccessIcon_default2 = VtSuccessIcon_default;
var VtInfoIcon_default = {};
var _hoisted_13$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "info-circle",
  class: "svg-inline--fa fa-info-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_22 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M256 8C119.043 8 8 119.083 8 256c0 136.997 111.043 248 248 248s248-111.003 248-248C504 119.083 392.957 8 256 8zm0 110c23.196 0 42 18.804 42 42s-18.804 42-42 42-42-18.804-42-42 18.804-42 42-42zm56 254c0 6.627-5.373 12-12 12h-88c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h12v-64h-12c-6.627 0-12-5.373-12-12v-24c0-6.627 5.373-12 12-12h64c6.627 0 12 5.373 12 12v100h12c6.627 0 12 5.373 12 12v24z"
}, null, -1);
var _hoisted_32 = [
  _hoisted_22
];
function render42(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_13$1, _hoisted_32);
}
VtInfoIcon_default.render = render42;
var VtInfoIcon_default2 = VtInfoIcon_default;
var VtWarningIcon_default = {};
var _hoisted_14$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-circle",
  class: "svg-inline--fa fa-exclamation-circle fa-w-16",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 512 512"
};
var _hoisted_23 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1);
var _hoisted_33 = [
  _hoisted_23
];
function render52(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_14$1, _hoisted_33);
}
VtWarningIcon_default.render = render52;
var VtWarningIcon_default2 = VtWarningIcon_default;
var VtErrorIcon_default = {};
var _hoisted_15$1 = {
  "aria-hidden": "true",
  focusable: "false",
  "data-prefix": "fas",
  "data-icon": "exclamation-triangle",
  class: "svg-inline--fa fa-exclamation-triangle fa-w-18",
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 576 512"
};
var _hoisted_24 = /* @__PURE__ */ createElementVNode("path", {
  fill: "currentColor",
  d: "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"
}, null, -1);
var _hoisted_34 = [
  _hoisted_24
];
function render62(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_15$1, _hoisted_34);
}
VtErrorIcon_default.render = render62;
var VtErrorIcon_default2 = VtErrorIcon_default;
var VtIcon_default = defineComponent({
  name: "VtIcon",
  props: propValidators_default.ICON,
  computed: {
    customIconChildren() {
      return hasProp(this.customIcon, "iconChildren") ? this.trimValue(this.customIcon.iconChildren) : "";
    },
    customIconClass() {
      if (isString$3(this.customIcon)) {
        return this.trimValue(this.customIcon);
      } else if (hasProp(this.customIcon, "iconClass")) {
        return this.trimValue(this.customIcon.iconClass);
      }
      return "";
    },
    customIconTag() {
      if (hasProp(this.customIcon, "iconTag")) {
        return this.trimValue(this.customIcon.iconTag, "i");
      }
      return "i";
    },
    hasCustomIcon() {
      return this.customIconClass.length > 0;
    },
    component() {
      if (this.hasCustomIcon) {
        return this.customIconTag;
      }
      if (isToastContent(this.customIcon)) {
        return getVueComponentFromObj(this.customIcon);
      }
      return this.iconTypeComponent;
    },
    iconTypeComponent() {
      const types = {
        [TYPE.DEFAULT]: VtInfoIcon_default2,
        [TYPE.INFO]: VtInfoIcon_default2,
        [TYPE.SUCCESS]: VtSuccessIcon_default2,
        [TYPE.ERROR]: VtErrorIcon_default2,
        [TYPE.WARNING]: VtWarningIcon_default2
      };
      return types[this.type];
    },
    iconClasses() {
      const classes = [`${VT_NAMESPACE}__icon`];
      if (this.hasCustomIcon) {
        return classes.concat(this.customIconClass);
      }
      return classes;
    }
  },
  methods: {
    trimValue(value2, empty = "") {
      return isNonEmptyString(value2) ? value2.trim() : empty;
    }
  }
});
function render72(_ctx, _cache) {
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
    class: normalizeClass(_ctx.iconClasses)
  }, {
    default: withCtx(() => [
      createTextVNode(toDisplayString(_ctx.customIconChildren), 1)
    ]),
    _: 1
  }, 8, ["class"]);
}
VtIcon_default.render = render72;
var VtIcon_default2 = VtIcon_default;
var VtToast_default = defineComponent({
  name: "VtToast",
  components: { ProgressBar: VtProgressBar_default2, CloseButton: VtCloseButton_default2, Icon: VtIcon_default2 },
  inheritAttrs: false,
  props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.TOAST),
  data() {
    const data9 = {
      isRunning: true,
      disableTransitions: false,
      beingDragged: false,
      dragStart: 0,
      dragPos: { x: 0, y: 0 },
      dragRect: {}
    };
    return data9;
  },
  computed: {
    classes() {
      const classes = [
        `${VT_NAMESPACE}__toast`,
        `${VT_NAMESPACE}__toast--${this.type}`,
        `${this.position}`
      ].concat(this.toastClassName);
      if (this.disableTransitions) {
        classes.push("disable-transition");
      }
      if (this.rtl) {
        classes.push(`${VT_NAMESPACE}__toast--rtl`);
      }
      return classes;
    },
    bodyClasses() {
      const classes = [
        `${VT_NAMESPACE}__toast-${isString$3(this.content) ? "body" : "component-body"}`
      ].concat(this.bodyClassName);
      return classes;
    },
    draggableStyle() {
      if (this.dragStart === this.dragPos.x) {
        return {};
      } else if (this.beingDragged) {
        return {
          transform: `translateX(${this.dragDelta}px)`,
          opacity: 1 - Math.abs(this.dragDelta / this.removalDistance)
        };
      } else {
        return {
          transition: "transform 0.2s, opacity 0.2s",
          transform: "translateX(0)",
          opacity: 1
        };
      }
    },
    dragDelta() {
      return this.beingDragged ? this.dragPos.x - this.dragStart : 0;
    },
    removalDistance() {
      if (isDOMRect(this.dragRect)) {
        return (this.dragRect.right - this.dragRect.left) * this.draggablePercent;
      }
      return 0;
    }
  },
  mounted() {
    if (this.draggable) {
      this.draggableSetup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusSetup();
    }
  },
  beforeUnmount() {
    if (this.draggable) {
      this.draggableCleanup();
    }
    if (this.pauseOnFocusLoss) {
      this.focusCleanup();
    }
  },
  methods: {
    hasProp,
    getVueComponentFromObj,
    closeToast() {
      this.eventBus.emit(EVENTS.DISMISS, this.id);
    },
    clickHandler() {
      if (this.onClick) {
        this.onClick(this.closeToast);
      }
      if (this.closeOnClick) {
        if (!this.beingDragged || this.dragStart === this.dragPos.x) {
          this.closeToast();
        }
      }
    },
    timeoutHandler() {
      this.closeToast();
    },
    hoverPause() {
      if (this.pauseOnHover) {
        this.isRunning = false;
      }
    },
    hoverPlay() {
      if (this.pauseOnHover) {
        this.isRunning = true;
      }
    },
    focusPause() {
      this.isRunning = false;
    },
    focusPlay() {
      this.isRunning = true;
    },
    focusSetup() {
      addEventListener("blur", this.focusPause);
      addEventListener("focus", this.focusPlay);
    },
    focusCleanup() {
      removeEventListener("blur", this.focusPause);
      removeEventListener("focus", this.focusPlay);
    },
    draggableSetup() {
      const element = this.$el;
      element.addEventListener("touchstart", this.onDragStart, {
        passive: true
      });
      element.addEventListener("mousedown", this.onDragStart);
      addEventListener("touchmove", this.onDragMove, { passive: false });
      addEventListener("mousemove", this.onDragMove);
      addEventListener("touchend", this.onDragEnd);
      addEventListener("mouseup", this.onDragEnd);
    },
    draggableCleanup() {
      const element = this.$el;
      element.removeEventListener("touchstart", this.onDragStart);
      element.removeEventListener("mousedown", this.onDragStart);
      removeEventListener("touchmove", this.onDragMove);
      removeEventListener("mousemove", this.onDragMove);
      removeEventListener("touchend", this.onDragEnd);
      removeEventListener("mouseup", this.onDragEnd);
    },
    onDragStart(event) {
      this.beingDragged = true;
      this.dragPos = { x: getX(event), y: getY(event) };
      this.dragStart = getX(event);
      this.dragRect = this.$el.getBoundingClientRect();
    },
    onDragMove(event) {
      if (this.beingDragged) {
        event.preventDefault();
        if (this.isRunning) {
          this.isRunning = false;
        }
        this.dragPos = { x: getX(event), y: getY(event) };
      }
    },
    onDragEnd() {
      if (this.beingDragged) {
        if (Math.abs(this.dragDelta) >= this.removalDistance) {
          this.disableTransitions = true;
          this.$nextTick(() => this.closeToast());
        } else {
          setTimeout(() => {
            this.beingDragged = false;
            if (isDOMRect(this.dragRect) && this.pauseOnHover && this.dragRect.bottom >= this.dragPos.y && this.dragPos.y >= this.dragRect.top && this.dragRect.left <= this.dragPos.x && this.dragPos.x <= this.dragRect.right) {
              this.isRunning = false;
            } else {
              this.isRunning = true;
            }
          });
        }
      }
    }
  }
});
var _hoisted_16$1 = ["role"];
function render8(_ctx, _cache) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CloseButton = resolveComponent("CloseButton");
  const _component_ProgressBar = resolveComponent("ProgressBar");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.draggableStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickHandler && _ctx.clickHandler(...args)),
    onMouseenter: _cache[1] || (_cache[1] = (...args) => _ctx.hoverPause && _ctx.hoverPause(...args)),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => _ctx.hoverPlay && _ctx.hoverPlay(...args))
  }, [
    _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
      key: 0,
      "custom-icon": _ctx.icon,
      type: _ctx.type
    }, null, 8, ["custom-icon", "type"])) : createCommentVNode("v-if", true),
    createElementVNode("div", {
      role: _ctx.accessibility.toastRole || "alert",
      class: normalizeClass(_ctx.bodyClasses)
    }, [
      typeof _ctx.content === "string" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.content), 1)
      ], 2112)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.getVueComponentFromObj(_ctx.content)), mergeProps({
        key: 1,
        "toast-id": _ctx.id
      }, _ctx.hasProp(_ctx.content, "props") ? _ctx.content.props : {}, toHandlers(_ctx.hasProp(_ctx.content, "listeners") ? _ctx.content.listeners : {}), { onCloseToast: _ctx.closeToast }), null, 16, ["toast-id", "onCloseToast"]))
    ], 10, _hoisted_16$1),
    !!_ctx.closeButton ? (openBlock(), createBlock(_component_CloseButton, {
      key: 1,
      component: _ctx.closeButton,
      "class-names": _ctx.closeButtonClassName,
      "show-on-hover": _ctx.showCloseButtonOnHover,
      "aria-label": _ctx.accessibility.closeButtonLabel,
      onClick: withModifiers(_ctx.closeToast, ["stop"])
    }, null, 8, ["component", "class-names", "show-on-hover", "aria-label", "onClick"])) : createCommentVNode("v-if", true),
    _ctx.timeout ? (openBlock(), createBlock(_component_ProgressBar, {
      key: 2,
      "is-running": _ctx.isRunning,
      "hide-progress-bar": _ctx.hideProgressBar,
      timeout: _ctx.timeout,
      onCloseToast: _ctx.timeoutHandler
    }, null, 8, ["is-running", "hide-progress-bar", "timeout", "onCloseToast"])) : createCommentVNode("v-if", true)
  ], 38);
}
VtToast_default.render = render8;
var VtToast_default2 = VtToast_default;
var VtTransition_default = defineComponent({
  name: "VtTransition",
  props: propValidators_default.TRANSITION,
  emits: ["leave"],
  methods: {
    hasProp,
    leave(el) {
      if (el instanceof HTMLElement) {
        el.style.left = el.offsetLeft + "px";
        el.style.top = el.offsetTop + "px";
        el.style.width = getComputedStyle(el).width;
        el.style.position = "absolute";
      }
    }
  }
});
function render9(_ctx, _cache) {
  return openBlock(), createBlock(TransitionGroup, {
    tag: "div",
    "enter-active-class": _ctx.transition.enter ? _ctx.transition.enter : `${_ctx.transition}-enter-active`,
    "move-class": _ctx.transition.move ? _ctx.transition.move : `${_ctx.transition}-move`,
    "leave-active-class": _ctx.transition.leave ? _ctx.transition.leave : `${_ctx.transition}-leave-active`,
    onLeave: _ctx.leave
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["enter-active-class", "move-class", "leave-active-class", "onLeave"]);
}
VtTransition_default.render = render9;
var VtTransition_default2 = VtTransition_default;
var VtToastContainer_default = defineComponent({
  name: "VueToastification",
  devtools: {
    hide: true
  },
  components: { Toast: VtToast_default2, VtTransition: VtTransition_default2 },
  props: Object.assign({}, propValidators_default.CORE_TOAST, propValidators_default.CONTAINER, propValidators_default.TRANSITION),
  data() {
    const data9 = {
      count: 0,
      positions: Object.values(POSITION),
      toasts: {},
      defaults: {}
    };
    return data9;
  },
  computed: {
    toastArray() {
      return Object.values(this.toasts);
    },
    filteredToasts() {
      return this.defaults.filterToasts(this.toastArray);
    }
  },
  beforeMount() {
    const events2 = this.eventBus;
    events2.on(EVENTS.ADD, this.addToast);
    events2.on(EVENTS.CLEAR, this.clearToasts);
    events2.on(EVENTS.DISMISS, this.dismissToast);
    events2.on(EVENTS.UPDATE, this.updateToast);
    events2.on(EVENTS.UPDATE_DEFAULTS, this.updateDefaults);
    this.defaults = this.$props;
  },
  mounted() {
    this.setup(this.container);
  },
  methods: {
    async setup(container) {
      if (isFunction$2(container)) {
        container = await container();
      }
      removeElement(this.$el);
      container.appendChild(this.$el);
    },
    setToast(props2) {
      if (!isUndefined$1(props2.id)) {
        this.toasts[props2.id] = props2;
      }
    },
    addToast(params) {
      params.content = normalizeToastComponent(params.content);
      const props2 = Object.assign({}, this.defaults, params.type && this.defaults.toastDefaults && this.defaults.toastDefaults[params.type], params);
      const toast = this.defaults.filterBeforeCreate(props2, this.toastArray);
      toast && this.setToast(toast);
    },
    dismissToast(id) {
      const toast = this.toasts[id];
      if (!isUndefined$1(toast) && !isUndefined$1(toast.onClose)) {
        toast.onClose();
      }
      delete this.toasts[id];
    },
    clearToasts() {
      Object.keys(this.toasts).forEach((id) => {
        this.dismissToast(id);
      });
    },
    getPositionToasts(position) {
      const toasts = this.filteredToasts.filter((toast) => toast.position === position).slice(0, this.defaults.maxToasts);
      return this.defaults.newestOnTop ? toasts.reverse() : toasts;
    },
    updateDefaults(update5) {
      if (!isUndefined$1(update5.container)) {
        this.setup(update5.container);
      }
      this.defaults = Object.assign({}, this.defaults, update5);
    },
    updateToast({
      id,
      options,
      create
    }) {
      if (this.toasts[id]) {
        if (options.timeout && options.timeout === this.toasts[id].timeout) {
          options.timeout++;
        }
        this.setToast(Object.assign({}, this.toasts[id], options));
      } else if (create) {
        this.addToast(Object.assign({}, { id }, options));
      }
    },
    getClasses(position) {
      const classes = [`${VT_NAMESPACE}__container`, position];
      return classes.concat(this.defaults.containerClassName);
    }
  }
});
function render10(_ctx, _cache) {
  const _component_Toast = resolveComponent("Toast");
  const _component_VtTransition = resolveComponent("VtTransition");
  return openBlock(), createElementBlock("div", null, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.positions, (pos) => {
      return openBlock(), createElementBlock("div", { key: pos }, [
        createVNode(_component_VtTransition, {
          transition: _ctx.defaults.transition,
          class: normalizeClass(_ctx.getClasses(pos))
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getPositionToasts(pos), (toast) => {
              return openBlock(), createBlock(_component_Toast, mergeProps({
                key: toast.id
              }, toast), null, 16);
            }), 128))
          ]),
          _: 2
        }, 1032, ["transition", "class"])
      ]);
    }), 128))
  ]);
}
VtToastContainer_default.render = render10;
var VtToastContainer_default2 = VtToastContainer_default;
var buildInterface = (globalOptions = {}, mountContainer = true) => {
  const events2 = globalOptions.eventBus = globalOptions.eventBus || new EventBus();
  if (mountContainer) {
    nextTick(() => {
      const app = createApp(VtToastContainer_default2, __spreadValues$1({}, globalOptions));
      const component = app.mount(document.createElement("div"));
      const onMounted2 = globalOptions.onMounted;
      if (!isUndefined$1(onMounted2)) {
        onMounted2(component, app);
      }
      if (globalOptions.shareAppContext) {
        const baseApp = globalOptions.shareAppContext;
        if (baseApp === true) {
          console.warn(`[${VT_NAMESPACE}] App to share context with was not provided.`);
        } else {
          app._context.components = baseApp._context.components;
          app._context.directives = baseApp._context.directives;
          app._context.mixins = baseApp._context.mixins;
          app._context.provides = baseApp._context.provides;
          app.config.globalProperties = baseApp.config.globalProperties;
        }
      }
    });
  }
  const toast = (content3, options) => {
    const props2 = Object.assign({}, { id: getId(), type: TYPE.DEFAULT }, options, {
      content: content3
    });
    events2.emit(EVENTS.ADD, props2);
    return props2.id;
  };
  toast.clear = () => events2.emit(EVENTS.CLEAR, void 0);
  toast.updateDefaults = (update5) => {
    events2.emit(EVENTS.UPDATE_DEFAULTS, update5);
  };
  toast.dismiss = (id) => {
    events2.emit(EVENTS.DISMISS, id);
  };
  function updateToast(id, { content: content3, options }, create = false) {
    const opt = Object.assign({}, options, { content: content3 });
    events2.emit(EVENTS.UPDATE, {
      id,
      options: opt,
      create
    });
  }
  toast.update = updateToast;
  toast.success = (content3, options) => toast(content3, Object.assign({}, options, { type: TYPE.SUCCESS }));
  toast.info = (content3, options) => toast(content3, Object.assign({}, options, { type: TYPE.INFO }));
  toast.error = (content3, options) => toast(content3, Object.assign({}, options, { type: TYPE.ERROR }));
  toast.warning = (content3, options) => toast(content3, Object.assign({}, options, { type: TYPE.WARNING }));
  return toast;
};
var createMockToastInterface = () => {
  const toast = () => console.warn(`[${VT_NAMESPACE}] This plugin does not support SSR!`);
  return new Proxy(toast, {
    get() {
      return toast;
    }
  });
};
function createToastInterface(optionsOrEventBus) {
  if (!isBrowser()) {
    return createMockToastInterface();
  }
  if (isEventBusInterface(optionsOrEventBus)) {
    return buildInterface({ eventBus: optionsOrEventBus }, false);
  }
  return buildInterface(optionsOrEventBus, true);
}
var toastInjectionKey = Symbol("VueToastification");
var globalEventBus = new EventBus();
var VueToastificationPlugin = (App2, options) => {
  if ((options == null ? void 0 : options.shareAppContext) === true) {
    options.shareAppContext = App2;
  }
  const inter = createToastInterface(__spreadValues$1({
    eventBus: globalEventBus
  }, options));
  App2.provide(toastInjectionKey, inter);
};
var useToast = (eventBus) => {
  if (eventBus) {
    return createToastInterface(eventBus);
  }
  const toast = getCurrentInstance() ? inject(toastInjectionKey, void 0) : void 0;
  return toast ? toast : createToastInterface(globalEventBus);
};
var src_default = VueToastificationPlugin;
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
}
const isProxyAvailable = typeof Proxy === "function";
const HOOK_SETUP = "devtools-plugin:setup";
const HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";
let supported;
let perf;
function isPerformanceSupported() {
  var _a;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof global !== "undefined" && ((_a = global.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
    supported = true;
    perf = global.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}
class ApiProxy {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings2 = {};
    if (plugin.settings) {
      for (const id in plugin.settings) {
        const item = plugin.settings[id];
        defaultSettings2[id] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings2);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data9 = JSON.parse(raw);
      Object.assign(currentSettings, data9);
    } catch (e2) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value2) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value2));
        } catch (e2) {
        }
        currentSettings = value2;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value2) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value2);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
}
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy)
      setupFn(proxy.proxiedTarget);
  }
}
/**
  * vee-validate v4.6.9
  * (c) 2022 Abdelrahman Awad
  * @license MIT
  */
function isCallable(fn3) {
  return typeof fn3 === "function";
}
function isNullOrUndefined(value2) {
  return value2 === null || value2 === void 0;
}
const isObject$4 = (obj) => obj !== null && !!obj && typeof obj === "object" && !Array.isArray(obj);
function isIndex$1(value2) {
  return Number(value2) >= 0;
}
function toNumber(value2) {
  const n2 = parseFloat(value2);
  return isNaN(n2) ? value2 : n2;
}
const RULES = {};
function defineRule(id, validator2) {
  guardExtend(id, validator2);
  RULES[id] = validator2;
}
function resolveRule(id) {
  return RULES[id];
}
function guardExtend(id, validator2) {
  if (isCallable(validator2)) {
    return;
  }
  throw new Error(`Extension Error: The validator '${id}' must be a function.`);
}
const FormContextKey = Symbol("vee-validate-form");
const FieldContextKey = Symbol("vee-validate-field-instance");
const IS_ABSENT = Symbol("Default empty value");
function isLocator(value2) {
  return isCallable(value2) && !!value2.__locatorRef;
}
function isYupValidator(value2) {
  return !!value2 && isCallable(value2.validate);
}
function hasCheckedAttr(type) {
  return type === "checkbox" || type === "radio";
}
function isContainerValue(value2) {
  return isObject$4(value2) || Array.isArray(value2);
}
function isEmptyContainer(value2) {
  if (Array.isArray(value2)) {
    return value2.length === 0;
  }
  return isObject$4(value2) && Object.keys(value2).length === 0;
}
function isNotNestedPath(path) {
  return /^\[.+\]$/i.test(path);
}
function isNativeMultiSelect(el) {
  return isNativeSelect(el) && el.multiple;
}
function isNativeSelect(el) {
  return el.tagName === "SELECT";
}
function isNativeMultiSelectNode(tag, attrs) {
  const hasTruthyBindingValue = ![false, null, void 0, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);
  return tag === "select" && "multiple" in attrs && hasTruthyBindingValue;
}
function shouldHaveValueBinding(tag, attrs) {
  return !isNativeMultiSelectNode(tag, attrs) && attrs.type !== "file" && !hasCheckedAttr(attrs.type);
}
function isFormSubmitEvent(evt) {
  return isEvent(evt) && evt.target && "submit" in evt.target;
}
function isEvent(evt) {
  if (!evt) {
    return false;
  }
  if (typeof Event !== "undefined" && isCallable(Event) && evt instanceof Event) {
    return true;
  }
  if (evt && evt.srcElement) {
    return true;
  }
  return false;
}
function isPropPresent(obj, prop) {
  return prop in obj && obj[prop] !== IS_ABSENT;
}
function isEqual(a3, b2) {
  if (a3 === b2)
    return true;
  if (a3 && b2 && typeof a3 === "object" && typeof b2 === "object") {
    if (a3.constructor !== b2.constructor)
      return false;
    var length, i2, keys2;
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!isEqual(a3[i2], b2[i2]))
          return false;
      return true;
    }
    if (a3 instanceof Map && b2 instanceof Map) {
      if (a3.size !== b2.size)
        return false;
      for (i2 of a3.entries())
        if (!b2.has(i2[0]))
          return false;
      for (i2 of a3.entries())
        if (!isEqual(i2[1], b2.get(i2[0])))
          return false;
      return true;
    }
    if (a3 instanceof File && b2 instanceof File) {
      if (a3.size !== b2.size)
        return false;
      if (a3.name !== b2.name)
        return false;
      if (a3.lastModified !== b2.lastModified)
        return false;
      if (a3.type !== b2.type)
        return false;
      return true;
    }
    if (a3 instanceof Set && b2 instanceof Set) {
      if (a3.size !== b2.size)
        return false;
      for (i2 of a3.entries())
        if (!b2.has(i2[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a3) && ArrayBuffer.isView(b2)) {
      length = a3.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (a3[i2] !== b2[i2])
          return false;
      return true;
    }
    if (a3.constructor === RegExp)
      return a3.source === b2.source && a3.flags === b2.flags;
    if (a3.valueOf !== Object.prototype.valueOf)
      return a3.valueOf() === b2.valueOf();
    if (a3.toString !== Object.prototype.toString)
      return a3.toString() === b2.toString();
    keys2 = Object.keys(a3);
    length = keys2.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!isEqual(a3[key], b2[key]))
        return false;
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
var fastDeepEqual = function equal(a3, b2) {
  if (a3 === b2)
    return true;
  if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
    if (a3.constructor !== b2.constructor)
      return false;
    var length, i2, keys2;
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length != b2.length)
        return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a3[i2], b2[i2]))
          return false;
      return true;
    }
    if (a3.constructor === RegExp)
      return a3.source === b2.source && a3.flags === b2.flags;
    if (a3.valueOf !== Object.prototype.valueOf)
      return a3.valueOf() === b2.valueOf();
    if (a3.toString !== Object.prototype.toString)
      return a3.toString() === b2.toString();
    keys2 = Object.keys(a3);
    length = keys2.length;
    if (length !== Object.keys(b2).length)
      return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys2[i2]))
        return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys2[i2];
      if (!equal(a3[key], b2[key]))
        return false;
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
};
function cleanupNonNestedPath(path) {
  if (isNotNestedPath(path)) {
    return path.replace(/\[|\]/gi, "");
  }
  return path;
}
function getFromPath(object, path, fallback) {
  if (!object) {
    return fallback;
  }
  if (isNotNestedPath(path)) {
    return object[cleanupNonNestedPath(path)];
  }
  const resolvedValue = (path || "").split(/\.|\[(\d+)\]/).filter(Boolean).reduce((acc, propKey) => {
    if (isContainerValue(acc) && propKey in acc) {
      return acc[propKey];
    }
    return fallback;
  }, object);
  return resolvedValue;
}
function setInPath(object, path, value2) {
  if (isNotNestedPath(path)) {
    object[cleanupNonNestedPath(path)] = value2;
    return;
  }
  const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i2 = 0; i2 < keys2.length; i2++) {
    if (i2 === keys2.length - 1) {
      acc[keys2[i2]] = value2;
      return;
    }
    if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
      acc[keys2[i2]] = isIndex$1(keys2[i2 + 1]) ? [] : {};
    }
    acc = acc[keys2[i2]];
  }
}
function unset(object, key) {
  if (Array.isArray(object) && isIndex$1(key)) {
    object.splice(Number(key), 1);
    return;
  }
  if (isObject$4(object)) {
    delete object[key];
  }
}
function unsetPath(object, path) {
  if (isNotNestedPath(path)) {
    delete object[cleanupNonNestedPath(path)];
    return;
  }
  const keys2 = path.split(/\.|\[(\d+)\]/).filter(Boolean);
  let acc = object;
  for (let i2 = 0; i2 < keys2.length; i2++) {
    if (i2 === keys2.length - 1) {
      unset(acc, keys2[i2]);
      break;
    }
    if (!(keys2[i2] in acc) || isNullOrUndefined(acc[keys2[i2]])) {
      break;
    }
    acc = acc[keys2[i2]];
  }
  const pathValues = keys2.map((_2, idx) => {
    return getFromPath(object, keys2.slice(0, idx).join("."));
  });
  for (let i2 = pathValues.length - 1; i2 >= 0; i2--) {
    if (!isEmptyContainer(pathValues[i2])) {
      continue;
    }
    if (i2 === 0) {
      unset(object, keys2[0]);
      continue;
    }
    unset(pathValues[i2 - 1], keys2[i2 - 1]);
  }
}
function keysOf(record) {
  return Object.keys(record);
}
function injectWithSelf(symbol, def = void 0) {
  const vm = getCurrentInstance();
  return (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || inject(symbol, def);
}
function warn(message) {
  warn$1(`[vee-validate]: ${message}`);
}
function normalizeField(field) {
  if (Array.isArray(field)) {
    return field[0];
  }
  return field;
}
function resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {
  if (Array.isArray(currentValue)) {
    const newVal = [...currentValue];
    const idx = newVal.findIndex((v2) => fastDeepEqual(v2, checkedValue));
    idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);
    return newVal;
  }
  return fastDeepEqual(currentValue, checkedValue) ? uncheckedValue : checkedValue;
}
function throttle$1(func, limit) {
  let inThrottle;
  let lastResult;
  return function(...args) {
    const context = this;
    if (!inThrottle) {
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
      lastResult = func.apply(context, args);
    }
    return lastResult;
  };
}
function debounceAsync(inner, ms = 0) {
  let timer = null;
  let resolves = [];
  return function(...args) {
    if (timer) {
      window.clearTimeout(timer);
    }
    timer = window.setTimeout(() => {
      const result = inner(...args);
      resolves.forEach((r2) => r2(result));
      resolves = [];
    }, ms);
    return new Promise((resolve) => resolves.push(resolve));
  };
}
function applyModelModifiers(value2, modifiers) {
  if (!isObject$4(modifiers)) {
    return value2;
  }
  if (modifiers.number) {
    return toNumber(value2);
  }
  return value2;
}
function withLatest(fn3, onDone) {
  let latestRun;
  return async function runLatest(...args) {
    const pending = fn3(...args);
    latestRun = pending;
    const result = await pending;
    if (pending !== latestRun) {
      return result;
    }
    latestRun = void 0;
    onDone(result, args);
    return result;
  };
}
const normalizeChildren = (tag, context, slotProps) => {
  if (!context.slots.default) {
    return context.slots.default;
  }
  if (typeof tag === "string" || !tag) {
    return context.slots.default(slotProps());
  }
  return {
    default: () => {
      var _a, _b;
      return (_b = (_a = context.slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, slotProps());
    }
  };
};
function getBoundValue(el) {
  if (hasValueBinding(el)) {
    return el._value;
  }
  return void 0;
}
function hasValueBinding(el) {
  return "_value" in el;
}
function normalizeEventValue(value2) {
  if (!isEvent(value2)) {
    return value2;
  }
  const input2 = value2.target;
  if (hasCheckedAttr(input2.type) && hasValueBinding(input2)) {
    return getBoundValue(input2);
  }
  if (input2.type === "file" && input2.files) {
    const files = Array.from(input2.files);
    return input2.multiple ? files : files[0];
  }
  if (isNativeMultiSelect(input2)) {
    return Array.from(input2.options).filter((opt) => opt.selected && !opt.disabled).map(getBoundValue);
  }
  if (isNativeSelect(input2)) {
    const selectedOption = Array.from(input2.options).find((opt) => opt.selected);
    return selectedOption ? getBoundValue(selectedOption) : input2.value;
  }
  return input2.value;
}
function normalizeRules(rules) {
  const acc = {};
  Object.defineProperty(acc, "_$$isNormalized", {
    value: true,
    writable: false,
    enumerable: false,
    configurable: false
  });
  if (!rules) {
    return acc;
  }
  if (isObject$4(rules) && rules._$$isNormalized) {
    return rules;
  }
  if (isObject$4(rules)) {
    return Object.keys(rules).reduce((prev, curr) => {
      const params = normalizeParams(rules[curr]);
      if (rules[curr] !== false) {
        prev[curr] = buildParams(params);
      }
      return prev;
    }, acc);
  }
  if (typeof rules !== "string") {
    return acc;
  }
  return rules.split("|").reduce((prev, rule) => {
    const parsedRule = parseRule(rule);
    if (!parsedRule.name) {
      return prev;
    }
    prev[parsedRule.name] = buildParams(parsedRule.params);
    return prev;
  }, acc);
}
function normalizeParams(params) {
  if (params === true) {
    return [];
  }
  if (Array.isArray(params)) {
    return params;
  }
  if (isObject$4(params)) {
    return params;
  }
  return [params];
}
function buildParams(provided) {
  const mapValueToLocator = (value2) => {
    if (typeof value2 === "string" && value2[0] === "@") {
      return createLocator(value2.slice(1));
    }
    return value2;
  };
  if (Array.isArray(provided)) {
    return provided.map(mapValueToLocator);
  }
  if (provided instanceof RegExp) {
    return [provided];
  }
  return Object.keys(provided).reduce((prev, key) => {
    prev[key] = mapValueToLocator(provided[key]);
    return prev;
  }, {});
}
const parseRule = (rule) => {
  let params = [];
  const name2 = rule.split(":")[0];
  if (rule.includes(":")) {
    params = rule.split(":").slice(1).join(":").split(",");
  }
  return { name: name2, params };
};
function createLocator(value2) {
  const locator = (crossTable) => {
    const val = getFromPath(crossTable, value2) || crossTable[value2];
    return val;
  };
  locator.__locatorRef = value2;
  return locator;
}
function extractLocators(params) {
  if (Array.isArray(params)) {
    return params.filter(isLocator);
  }
  return keysOf(params).filter((key) => isLocator(params[key])).map((key) => params[key]);
}
const DEFAULT_CONFIG = {
  generateMessage: ({ field }) => `${field} is not valid.`,
  bails: true,
  validateOnBlur: true,
  validateOnChange: true,
  validateOnInput: false,
  validateOnModelUpdate: true
};
let currentConfig = Object.assign({}, DEFAULT_CONFIG);
const getConfig = () => currentConfig;
async function validate(value2, rules, options = {}) {
  const shouldBail = options === null || options === void 0 ? void 0 : options.bails;
  const field = {
    name: (options === null || options === void 0 ? void 0 : options.name) || "{field}",
    rules,
    bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,
    formData: (options === null || options === void 0 ? void 0 : options.values) || {}
  };
  const result = await _validate(field, value2);
  const errors = result.errors;
  return {
    errors,
    valid: !errors.length
  };
}
async function _validate(field, value2) {
  if (isYupValidator(field.rules)) {
    return validateFieldWithYup(value2, field.rules, { bails: field.bails });
  }
  if (isCallable(field.rules) || Array.isArray(field.rules)) {
    const ctx = {
      field: field.name,
      form: field.formData,
      value: value2
    };
    const pipeline = Array.isArray(field.rules) ? field.rules : [field.rules];
    const length2 = pipeline.length;
    const errors2 = [];
    for (let i2 = 0; i2 < length2; i2++) {
      const rule = pipeline[i2];
      const result = await rule(value2, ctx);
      const isValid = typeof result !== "string" && result;
      if (isValid) {
        continue;
      }
      const message = typeof result === "string" ? result : _generateFieldError(ctx);
      errors2.push(message);
      if (field.bails) {
        return {
          errors: errors2
        };
      }
    }
    return {
      errors: errors2
    };
  }
  const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });
  const errors = [];
  const rulesKeys = Object.keys(normalizedContext.rules);
  const length = rulesKeys.length;
  for (let i2 = 0; i2 < length; i2++) {
    const rule = rulesKeys[i2];
    const result = await _test(normalizedContext, value2, {
      name: rule,
      params: normalizedContext.rules[rule]
    });
    if (result.error) {
      errors.push(result.error);
      if (field.bails) {
        return {
          errors
        };
      }
    }
  }
  return {
    errors
  };
}
async function validateFieldWithYup(value2, validator2, opts2) {
  var _a;
  const errors = await validator2.validate(value2, {
    abortEarly: (_a = opts2.bails) !== null && _a !== void 0 ? _a : true
  }).then(() => []).catch((err) => {
    if (err.name === "ValidationError") {
      return err.errors;
    }
    throw err;
  });
  return {
    errors
  };
}
async function _test(field, value2, rule) {
  const validator2 = resolveRule(rule.name);
  if (!validator2) {
    throw new Error(`No such validator '${rule.name}' exists.`);
  }
  const params = fillTargetValues(rule.params, field.formData);
  const ctx = {
    field: field.name,
    value: value2,
    form: field.formData,
    rule: Object.assign(Object.assign({}, rule), { params })
  };
  const result = await validator2(value2, params, ctx);
  if (typeof result === "string") {
    return {
      error: result
    };
  }
  return {
    error: result ? void 0 : _generateFieldError(ctx)
  };
}
function _generateFieldError(fieldCtx) {
  const message = getConfig().generateMessage;
  if (!message) {
    return "Field is invalid";
  }
  return message(fieldCtx);
}
function fillTargetValues(params, crossTable) {
  const normalize = (value2) => {
    if (isLocator(value2)) {
      return value2(crossTable);
    }
    return value2;
  };
  if (Array.isArray(params)) {
    return params.map(normalize);
  }
  return Object.keys(params).reduce((acc, param) => {
    acc[param] = normalize(params[param]);
    return acc;
  }, {});
}
async function validateYupSchema(schema, values) {
  const errorObjects = await schema.validate(values, { abortEarly: false }).then(() => []).catch((err) => {
    if (err.name !== "ValidationError") {
      throw err;
    }
    return err.inner || [];
  });
  const results = {};
  const errors = {};
  for (const error of errorObjects) {
    const messages = error.errors;
    results[error.path] = { valid: !messages.length, errors: messages };
    if (messages.length) {
      errors[error.path] = messages[0];
    }
  }
  return {
    valid: !errorObjects.length,
    results,
    errors
  };
}
async function validateObjectSchema(schema, values, opts2) {
  const paths = keysOf(schema);
  const validations = paths.map(async (path) => {
    var _a, _b, _c;
    const fieldResult = await validate(getFromPath(values, path), schema[path], {
      name: ((_a = opts2 === null || opts2 === void 0 ? void 0 : opts2.names) === null || _a === void 0 ? void 0 : _a[path]) || path,
      values,
      bails: (_c = (_b = opts2 === null || opts2 === void 0 ? void 0 : opts2.bailsMap) === null || _b === void 0 ? void 0 : _b[path]) !== null && _c !== void 0 ? _c : true
    });
    return Object.assign(Object.assign({}, fieldResult), { path });
  });
  let isAllValid = true;
  const validationResults = await Promise.all(validations);
  const results = {};
  const errors = {};
  for (const result of validationResults) {
    results[result.path] = {
      valid: result.valid,
      errors: result.errors
    };
    if (!result.valid) {
      isAllValid = false;
      errors[result.path] = result.errors[0];
    }
  }
  return {
    valid: isAllValid,
    results,
    errors
  };
}
function set(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x2) {
  if (typeof x2 !== "object")
    return x2;
  var i2 = 0, k2, list, tmp, str = Object.prototype.toString.call(x2);
  if (str === "[object Object]") {
    tmp = Object.create(x2.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x2.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x2.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x2.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = new Date(+x2);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x2.source, x2.flags);
  } else if (str === "[object DataView]") {
    tmp = new x2.constructor(klona(x2.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x2.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x2.constructor(x2);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x2); i2 < list.length; i2++) {
      set(tmp, list[i2], Object.getOwnPropertyDescriptor(x2, list[i2]));
    }
    for (i2 = 0, list = Object.getOwnPropertyNames(x2); i2 < list.length; i2++) {
      if (Object.hasOwnProperty.call(tmp, k2 = list[i2]) && tmp[k2] === x2[k2])
        continue;
      set(tmp, k2, Object.getOwnPropertyDescriptor(x2, k2));
    }
  }
  return tmp || x2;
}
let ID_COUNTER = 0;
function useFieldState(path, init) {
  const { value: value2, initialValue, setInitialValue } = _useFieldValue(path, init.modelValue, !init.standalone);
  const { errorMessage, errors, setErrors } = _useFieldErrors(path, !init.standalone);
  const meta = _useFieldMeta(value2, initialValue, errors);
  const id = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;
  function setState(state2) {
    var _a;
    if ("value" in state2) {
      value2.value = state2.value;
    }
    if ("errors" in state2) {
      setErrors(state2.errors);
    }
    if ("touched" in state2) {
      meta.touched = (_a = state2.touched) !== null && _a !== void 0 ? _a : meta.touched;
    }
    if ("initialValue" in state2) {
      setInitialValue(state2.initialValue);
    }
  }
  return {
    id,
    path,
    value: value2,
    initialValue,
    meta,
    errors,
    errorMessage,
    setState
  };
}
function _useFieldValue(path, modelValue3, shouldInjectForm = true) {
  const form = shouldInjectForm === true ? injectWithSelf(FormContextKey, void 0) : void 0;
  const modelRef = ref(unref(modelValue3));
  function resolveInitialValue2() {
    if (!form) {
      return unref(modelRef);
    }
    return getFromPath(form.meta.value.initialValues, unref(path), unref(modelRef));
  }
  function setInitialValue(value3) {
    if (!form) {
      modelRef.value = value3;
      return;
    }
    form.stageInitialValue(unref(path), value3, true);
  }
  const initialValue = computed(resolveInitialValue2);
  if (!form) {
    const value3 = ref(resolveInitialValue2());
    return {
      value: value3,
      initialValue,
      setInitialValue
    };
  }
  const currentValue = modelValue3 ? unref(modelValue3) : getFromPath(form.values, unref(path), unref(initialValue));
  form.stageInitialValue(unref(path), currentValue, true);
  const value2 = computed({
    get() {
      return getFromPath(form.values, unref(path));
    },
    set(newVal) {
      form.setFieldValue(unref(path), newVal);
    }
  });
  return {
    value: value2,
    initialValue,
    setInitialValue
  };
}
function _useFieldMeta(currentValue, initialValue, errors) {
  const meta = reactive({
    touched: false,
    pending: false,
    valid: true,
    validated: !!unref(errors).length,
    initialValue: computed(() => unref(initialValue)),
    dirty: computed(() => {
      return !isEqual(unref(currentValue), unref(initialValue));
    })
  });
  watch(errors, (value2) => {
    meta.valid = !value2.length;
  }, {
    immediate: true,
    flush: "sync"
  });
  return meta;
}
function _useFieldErrors(path, shouldInjectForm) {
  const form = shouldInjectForm ? injectWithSelf(FormContextKey, void 0) : void 0;
  function normalizeErrors(messages) {
    if (!messages) {
      return [];
    }
    return Array.isArray(messages) ? messages : [messages];
  }
  if (!form) {
    const errors2 = ref([]);
    return {
      errors: errors2,
      errorMessage: computed(() => errors2.value[0]),
      setErrors: (messages) => {
        errors2.value = normalizeErrors(messages);
      }
    };
  }
  const errors = computed(() => form.errorBag.value[unref(path)] || []);
  return {
    errors,
    errorMessage: computed(() => errors.value[0]),
    setErrors: (messages) => {
      form.setFieldErrorBag(unref(path), normalizeErrors(messages));
    }
  };
}
function installDevtoolsPlugin(app) {
  {
    setupDevtoolsPlugin({
      id: "vee-validate-devtools-plugin",
      label: "VeeValidate Plugin",
      packageName: "vee-validate",
      homepage: "https://vee-validate.logaretm.com/v4",
      app,
      logo: "https://vee-validate.logaretm.com/v4/logo.png"
    }, setupApiHooks);
  }
}
const DEVTOOLS_FORMS = {};
const DEVTOOLS_FIELDS = {};
let API;
const refreshInspector = throttle$1(() => {
  setTimeout(async () => {
    await nextTick();
    API === null || API === void 0 ? void 0 : API.sendInspectorState(INSPECTOR_ID$1);
    API === null || API === void 0 ? void 0 : API.sendInspectorTree(INSPECTOR_ID$1);
  }, 100);
}, 100);
function registerFormWithDevTools(form) {
  const vm = getCurrentInstance();
  if (!API) {
    const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;
    if (!app) {
      return;
    }
    installDevtoolsPlugin(app);
  }
  DEVTOOLS_FORMS[form.formId] = Object.assign({}, form);
  DEVTOOLS_FORMS[form.formId]._vm = vm;
  onUnmounted(() => {
    delete DEVTOOLS_FORMS[form.formId];
    refreshInspector();
  });
  refreshInspector();
}
function registerSingleFieldWithDevtools(field) {
  const vm = getCurrentInstance();
  if (!API) {
    const app = vm === null || vm === void 0 ? void 0 : vm.appContext.app;
    if (!app) {
      return;
    }
    installDevtoolsPlugin(app);
  }
  DEVTOOLS_FIELDS[field.id] = Object.assign({}, field);
  DEVTOOLS_FIELDS[field.id]._vm = vm;
  onUnmounted(() => {
    delete DEVTOOLS_FIELDS[field.id];
    refreshInspector();
  });
  refreshInspector();
}
const INSPECTOR_ID$1 = "vee-validate-inspector";
const COLORS = {
  error: 12405579,
  success: 448379,
  unknown: 5522283,
  white: 16777215,
  black: 0,
  blue: 218007,
  purple: 12157168,
  orange: 16099682,
  gray: 12304330
};
let SELECTED_NODE = null;
function setupApiHooks(api2) {
  API = api2;
  api2.addInspector({
    id: INSPECTOR_ID$1,
    icon: "rule",
    label: "vee-validate",
    noSelectionText: "Select a vee-validate node to inspect",
    actions: [
      {
        icon: "done_outline",
        tooltip: "Validate selected item",
        action: async () => {
          if (!SELECTED_NODE) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          const result = await SELECTED_NODE.validate();
          console.log(result);
        }
      },
      {
        icon: "delete_sweep",
        tooltip: "Clear validation state of the selected item",
        action: () => {
          if (!SELECTED_NODE) {
            console.error("There is not a valid selected vee-validate node or component");
            return;
          }
          if ("id" in SELECTED_NODE) {
            SELECTED_NODE.resetField();
            return;
          }
          SELECTED_NODE.resetForm();
        }
      }
    ]
  });
  api2.on.getInspectorTree((payload) => {
    if (payload.inspectorId !== INSPECTOR_ID$1) {
      return;
    }
    const forms = Object.values(DEVTOOLS_FORMS);
    const fields = Object.values(DEVTOOLS_FIELDS);
    payload.rootNodes = [
      ...forms.map(mapFormForDevtoolsInspector),
      ...fields.map((field) => mapFieldForDevtoolsInspector(field))
    ];
  });
  api2.on.getInspectorState((payload, ctx) => {
    if (payload.inspectorId !== INSPECTOR_ID$1 || ctx.currentTab !== `custom-inspector:${INSPECTOR_ID$1}`) {
      return;
    }
    const { form, field, type } = decodeNodeId(payload.nodeId);
    if (form && type === "form") {
      payload.state = buildFormState(form);
      SELECTED_NODE = form;
      return;
    }
    if (field && type === "field") {
      payload.state = buildFieldState(field);
      SELECTED_NODE = field;
      return;
    }
    SELECTED_NODE = null;
  });
}
function mapFormForDevtoolsInspector(form) {
  const { textColor, bgColor } = getTagTheme(form);
  const formTreeNodes = {};
  Object.values(form.fieldsByPath.value).forEach((field) => {
    const fieldInstance = Array.isArray(field) ? field[0] : field;
    if (!fieldInstance) {
      return;
    }
    setInPath(formTreeNodes, unref(fieldInstance.name), mapFieldForDevtoolsInspector(fieldInstance, form));
  });
  function buildFormTree(tree, path = []) {
    const key = [...path].pop();
    if ("id" in tree) {
      return Object.assign(Object.assign({}, tree), { label: key || tree.label });
    }
    if (isObject$4(tree)) {
      return {
        id: `${path.join(".")}`,
        label: key || "",
        children: Object.keys(tree).map((key2) => buildFormTree(tree[key2], [...path, key2]))
      };
    }
    if (Array.isArray(tree)) {
      return {
        id: `${path.join(".")}`,
        label: `${key}[]`,
        children: tree.map((c2, idx) => buildFormTree(c2, [...path, String(idx)]))
      };
    }
    return { id: "", label: "", children: [] };
  }
  const { children } = buildFormTree(formTreeNodes);
  return {
    id: encodeNodeId(form),
    label: "Form",
    children,
    tags: [
      {
        label: "Form",
        textColor,
        backgroundColor: bgColor
      },
      {
        label: `${Object.keys(form.fieldsByPath.value).length} fields`,
        textColor: COLORS.white,
        backgroundColor: COLORS.unknown
      }
    ]
  };
}
function mapFieldForDevtoolsInspector(field, form) {
  const fieldInstance = normalizeField(field);
  const { textColor, bgColor } = getTagTheme(fieldInstance);
  const isGroup = Array.isArray(field) && field.length > 1;
  return {
    id: encodeNodeId(form, fieldInstance, !isGroup),
    label: unref(fieldInstance.name),
    children: Array.isArray(field) ? field.map((fieldItem) => mapFieldForDevtoolsInspector(fieldItem, form)) : void 0,
    tags: [
      isGroup ? void 0 : {
        label: "Field",
        textColor,
        backgroundColor: bgColor
      },
      !form ? {
        label: "Standalone",
        textColor: COLORS.black,
        backgroundColor: COLORS.gray
      } : void 0,
      !isGroup && fieldInstance.type === "checkbox" ? {
        label: "Checkbox",
        textColor: COLORS.white,
        backgroundColor: COLORS.blue
      } : void 0,
      !isGroup && fieldInstance.type === "radio" ? {
        label: "Radio",
        textColor: COLORS.white,
        backgroundColor: COLORS.purple
      } : void 0,
      isGroup ? {
        label: "Group",
        textColor: COLORS.black,
        backgroundColor: COLORS.orange
      } : void 0
    ].filter(Boolean)
  };
}
function encodeNodeId(form, field, encodeIndex = true) {
  const fieldPath = form ? unref(field === null || field === void 0 ? void 0 : field.name) : field === null || field === void 0 ? void 0 : field.id;
  const fieldGroup = fieldPath ? form === null || form === void 0 ? void 0 : form.fieldsByPath.value[fieldPath] : void 0;
  let idx;
  if (encodeIndex && field && Array.isArray(fieldGroup)) {
    idx = fieldGroup.indexOf(field);
  }
  const idObject = { f: form === null || form === void 0 ? void 0 : form.formId, ff: fieldPath, idx, type: field ? "field" : "form" };
  return btoa(JSON.stringify(idObject));
}
function decodeNodeId(nodeId) {
  try {
    const idObject = JSON.parse(atob(nodeId));
    const form = DEVTOOLS_FORMS[idObject.f];
    if (!form && idObject.ff) {
      const field = DEVTOOLS_FIELDS[idObject.ff];
      if (!field) {
        return {};
      }
      return {
        type: idObject.type,
        field
      };
    }
    if (!form) {
      return {};
    }
    const fieldGroup = form.fieldsByPath.value[idObject.ff];
    return {
      type: idObject.type,
      form,
      field: Array.isArray(fieldGroup) ? fieldGroup[idObject.idx || 0] : fieldGroup
    };
  } catch (err) {
  }
  return {};
}
function buildFieldState(field) {
  const { errors, meta, value: value2 } = field;
  return {
    "Field state": [
      { key: "errors", value: errors.value },
      {
        key: "initialValue",
        value: meta.initialValue
      },
      {
        key: "currentValue",
        value: value2.value
      },
      {
        key: "touched",
        value: meta.touched
      },
      {
        key: "dirty",
        value: meta.dirty
      },
      {
        key: "valid",
        value: meta.valid
      }
    ]
  };
}
function buildFormState(form) {
  const { errorBag, meta, values, isSubmitting, submitCount } = form;
  return {
    "Form state": [
      {
        key: "submitCount",
        value: submitCount.value
      },
      {
        key: "isSubmitting",
        value: isSubmitting.value
      },
      {
        key: "touched",
        value: meta.value.touched
      },
      {
        key: "dirty",
        value: meta.value.dirty
      },
      {
        key: "valid",
        value: meta.value.valid
      },
      {
        key: "initialValues",
        value: meta.value.initialValues
      },
      {
        key: "currentValues",
        value: values
      },
      {
        key: "errors",
        value: keysOf(errorBag.value).reduce((acc, key) => {
          var _a;
          const message = (_a = errorBag.value[key]) === null || _a === void 0 ? void 0 : _a[0];
          if (message) {
            acc[key] = message;
          }
          return acc;
        }, {})
      }
    ]
  };
}
function getTagTheme(fieldOrForm) {
  const isValid = "id" in fieldOrForm ? fieldOrForm.meta.valid : fieldOrForm.meta.value.valid;
  return {
    bgColor: isValid ? COLORS.success : COLORS.error,
    textColor: isValid ? COLORS.black : COLORS.white
  };
}
function useField(name2, rules, opts2) {
  if (hasCheckedAttr(opts2 === null || opts2 === void 0 ? void 0 : opts2.type)) {
    return useCheckboxField(name2, rules, opts2);
  }
  return _useField(name2, rules, opts2);
}
function _useField(name2, rules, opts2) {
  const { initialValue: modelValue3, validateOnMount, bails, type, checkedValue, label: label2, validateOnValueUpdate, uncheckedValue, standalone, keepValueOnUnmount, modelPropName, syncVModel } = normalizeOptions(unref(name2), opts2);
  const form = !standalone ? injectWithSelf(FormContextKey) : void 0;
  let markedForRemoval = false;
  const { id, value: value2, initialValue, meta, setState, errors, errorMessage } = useFieldState(name2, {
    modelValue: modelValue3,
    standalone
  });
  if (syncVModel) {
    useVModel({ value: value2, prop: modelPropName, handleChange });
  }
  const handleBlur = () => {
    meta.touched = true;
  };
  const normalizedRules = computed(() => {
    let rulesValue = unref(rules);
    const schema = unref(form === null || form === void 0 ? void 0 : form.schema);
    if (schema && !isYupValidator(schema)) {
      rulesValue = extractRuleFromSchema(schema, unref(name2)) || rulesValue;
    }
    if (isYupValidator(rulesValue) || isCallable(rulesValue) || Array.isArray(rulesValue)) {
      return rulesValue;
    }
    return normalizeRules(rulesValue);
  });
  async function validateCurrentValue(mode) {
    var _a, _b;
    if (form === null || form === void 0 ? void 0 : form.validateSchema) {
      return (_a = (await form.validateSchema(mode)).results[unref(name2)]) !== null && _a !== void 0 ? _a : { valid: true, errors: [] };
    }
    return validate(value2.value, normalizedRules.value, {
      name: unref(label2) || unref(name2),
      values: (_b = form === null || form === void 0 ? void 0 : form.values) !== null && _b !== void 0 ? _b : {},
      bails
    });
  }
  const validateWithStateMutation = withLatest(async () => {
    meta.pending = true;
    meta.validated = true;
    return validateCurrentValue("validated-only");
  }, (result) => {
    if (markedForRemoval) {
      result.valid = true;
      result.errors = [];
    }
    setState({ errors: result.errors });
    meta.pending = false;
    return result;
  });
  const validateValidStateOnly = withLatest(async () => {
    return validateCurrentValue("silent");
  }, (result) => {
    if (markedForRemoval) {
      result.valid = true;
    }
    meta.valid = result.valid;
    return result;
  });
  function validate$1(opts3) {
    if ((opts3 === null || opts3 === void 0 ? void 0 : opts3.mode) === "silent") {
      return validateValidStateOnly();
    }
    return validateWithStateMutation();
  }
  function handleChange(e2, shouldValidate = true) {
    const newValue = normalizeEventValue(e2);
    value2.value = newValue;
    if (!validateOnValueUpdate && shouldValidate) {
      validateWithStateMutation();
    }
  }
  onMounted(() => {
    if (validateOnMount) {
      return validateWithStateMutation();
    }
    if (!form || !form.validateSchema) {
      validateValidStateOnly();
    }
  });
  function setTouched(isTouched) {
    meta.touched = isTouched;
  }
  let unwatchValue;
  let lastWatchedValue = klona(value2.value);
  function watchValue() {
    unwatchValue = watch(value2, (val, oldVal) => {
      if (isEqual(val, oldVal) && isEqual(val, lastWatchedValue)) {
        return;
      }
      const validateFn = validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly;
      validateFn();
      lastWatchedValue = klona(val);
    }, {
      deep: true
    });
  }
  watchValue();
  function resetField(state2) {
    var _a;
    unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();
    const newValue = state2 && "value" in state2 ? state2.value : initialValue.value;
    setState({
      value: klona(newValue),
      initialValue: klona(newValue),
      touched: (_a = state2 === null || state2 === void 0 ? void 0 : state2.touched) !== null && _a !== void 0 ? _a : false,
      errors: (state2 === null || state2 === void 0 ? void 0 : state2.errors) || []
    });
    meta.pending = false;
    meta.validated = false;
    validateValidStateOnly();
    nextTick(() => {
      watchValue();
    });
  }
  function setValue(newValue) {
    value2.value = newValue;
  }
  function setErrors(errors2) {
    setState({ errors: Array.isArray(errors2) ? errors2 : [errors2] });
  }
  const field = {
    id,
    name: name2,
    label: label2,
    value: value2,
    meta,
    errors,
    errorMessage,
    type,
    checkedValue,
    uncheckedValue,
    bails,
    keepValueOnUnmount,
    resetField,
    handleReset: () => resetField(),
    validate: validate$1,
    handleChange,
    handleBlur,
    setState,
    setTouched,
    setErrors,
    setValue
  };
  provide(FieldContextKey, field);
  if (isRef(rules) && typeof unref(rules) !== "function") {
    watch(rules, (value3, oldValue) => {
      if (isEqual(value3, oldValue)) {
        return;
      }
      meta.validated ? validateWithStateMutation() : validateValidStateOnly();
    }, {
      deep: true
    });
  }
  {
    field._vm = getCurrentInstance();
    watch(() => Object.assign(Object.assign({ errors: errors.value }, meta), { value: value2.value }), refreshInspector, {
      deep: true
    });
    if (!form) {
      registerSingleFieldWithDevtools(field);
    }
  }
  if (!form) {
    return field;
  }
  form.register(field);
  onBeforeUnmount(() => {
    markedForRemoval = true;
    form.unregister(field);
  });
  const dependencies = computed(() => {
    const rulesVal = normalizedRules.value;
    if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal) || Array.isArray(rulesVal)) {
      return {};
    }
    return Object.keys(rulesVal).reduce((acc, rule) => {
      const deps = extractLocators(rulesVal[rule]).map((dep) => dep.__locatorRef).reduce((depAcc, depName) => {
        const depValue = getFromPath(form.values, depName) || form.values[depName];
        if (depValue !== void 0) {
          depAcc[depName] = depValue;
        }
        return depAcc;
      }, {});
      Object.assign(acc, deps);
      return acc;
    }, {});
  });
  watch(dependencies, (deps, oldDeps) => {
    if (!Object.keys(deps).length) {
      return;
    }
    const shouldValidate = !isEqual(deps, oldDeps);
    if (shouldValidate) {
      meta.validated ? validateWithStateMutation() : validateValidStateOnly();
    }
  });
  return field;
}
function normalizeOptions(name2, opts2) {
  const defaults2 = () => ({
    initialValue: void 0,
    validateOnMount: false,
    bails: true,
    rules: "",
    label: name2,
    validateOnValueUpdate: true,
    standalone: false,
    keepValueOnUnmount: void 0,
    modelPropName: "modelValue",
    syncVModel: true
  });
  if (!opts2) {
    return defaults2();
  }
  const checkedValue = "valueProp" in opts2 ? opts2.valueProp : opts2.checkedValue;
  return Object.assign(Object.assign(Object.assign({}, defaults2()), opts2 || {}), { checkedValue });
}
function extractRuleFromSchema(schema, fieldName) {
  if (!schema) {
    return void 0;
  }
  return schema[fieldName];
}
function useCheckboxField(name2, rules, opts2) {
  const form = !(opts2 === null || opts2 === void 0 ? void 0 : opts2.standalone) ? injectWithSelf(FormContextKey) : void 0;
  const checkedValue = opts2 === null || opts2 === void 0 ? void 0 : opts2.checkedValue;
  const uncheckedValue = opts2 === null || opts2 === void 0 ? void 0 : opts2.uncheckedValue;
  function patchCheckboxApi(field) {
    const handleChange = field.handleChange;
    const checked = computed(() => {
      const currentValue = unref(field.value);
      const checkedVal = unref(checkedValue);
      return Array.isArray(currentValue) ? currentValue.findIndex((v2) => isEqual(v2, checkedVal)) >= 0 : isEqual(checkedVal, currentValue);
    });
    function handleCheckboxChange(e2, shouldValidate = true) {
      var _a;
      if (checked.value === ((_a = e2 === null || e2 === void 0 ? void 0 : e2.target) === null || _a === void 0 ? void 0 : _a.checked)) {
        if (shouldValidate) {
          field.validate();
        }
        return;
      }
      let newValue = normalizeEventValue(e2);
      if (!form) {
        newValue = resolveNextCheckboxValue(unref(field.value), unref(checkedValue), unref(uncheckedValue));
      }
      handleChange(newValue, shouldValidate);
    }
    return Object.assign(Object.assign({}, field), {
      checked,
      checkedValue,
      uncheckedValue,
      handleChange: handleCheckboxChange
    });
  }
  return patchCheckboxApi(_useField(name2, rules, opts2));
}
function useVModel({ prop, value: value2, handleChange }) {
  const vm = getCurrentInstance();
  if (!vm) {
    {
      console.warn("Failed to setup model events because `useField` was not called in setup.");
    }
    return;
  }
  const propName = prop || "modelValue";
  const emitName = `update:${propName}`;
  if (!(propName in vm.props)) {
    return;
  }
  watch(value2, (newValue) => {
    if (isEqual(newValue, getCurrentModelValue(vm, propName))) {
      return;
    }
    vm.emit(emitName, newValue);
  });
  watch(() => getCurrentModelValue(vm, propName), (propValue) => {
    if (propValue === IS_ABSENT && value2.value === void 0) {
      return;
    }
    const newValue = propValue === IS_ABSENT ? void 0 : propValue;
    if (isEqual(newValue, applyModelModifiers(value2.value, vm.props.modelModifiers))) {
      return;
    }
    handleChange(newValue);
  });
}
function getCurrentModelValue(vm, propName) {
  return vm.props[propName];
}
const FieldImpl = defineComponent({
  name: "Field",
  inheritAttrs: false,
  props: {
    as: {
      type: [String, Object],
      default: void 0
    },
    name: {
      type: String,
      required: true
    },
    rules: {
      type: [Object, String, Function],
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: false
    },
    validateOnBlur: {
      type: Boolean,
      default: void 0
    },
    validateOnChange: {
      type: Boolean,
      default: void 0
    },
    validateOnInput: {
      type: Boolean,
      default: void 0
    },
    validateOnModelUpdate: {
      type: Boolean,
      default: void 0
    },
    bails: {
      type: Boolean,
      default: () => getConfig().bails
    },
    label: {
      type: String,
      default: void 0
    },
    uncheckedValue: {
      type: null,
      default: void 0
    },
    modelValue: {
      type: null,
      default: IS_ABSENT
    },
    modelModifiers: {
      type: null,
      default: () => ({})
    },
    "onUpdate:modelValue": {
      type: null,
      default: void 0
    },
    standalone: {
      type: Boolean,
      default: false
    },
    keepValue: {
      type: Boolean,
      default: void 0
    }
  },
  setup(props2, ctx) {
    const rules = toRef(props2, "rules");
    const name2 = toRef(props2, "name");
    const label2 = toRef(props2, "label");
    const uncheckedValue = toRef(props2, "uncheckedValue");
    const keepValue = toRef(props2, "keepValue");
    const { errors, value: value2, errorMessage, validate: validateField, handleChange, handleBlur, setTouched, resetField, handleReset, meta, checked, setErrors } = useField(name2, rules, {
      validateOnMount: props2.validateOnMount,
      bails: props2.bails,
      standalone: props2.standalone,
      type: ctx.attrs.type,
      initialValue: resolveInitialValue(props2, ctx),
      checkedValue: ctx.attrs.value,
      uncheckedValue,
      label: label2,
      validateOnValueUpdate: false,
      keepValueOnUnmount: keepValue
    });
    const onChangeHandler = function handleChangeWithModel(e2, shouldValidate = true) {
      handleChange(e2, shouldValidate);
      ctx.emit("update:modelValue", value2.value);
    };
    const handleInput = (e2) => {
      if (!hasCheckedAttr(ctx.attrs.type)) {
        value2.value = normalizeEventValue(e2);
      }
    };
    const onInputHandler = function handleInputWithModel(e2) {
      handleInput(e2);
      ctx.emit("update:modelValue", value2.value);
    };
    const fieldProps = computed(() => {
      const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = resolveValidationTriggers(props2);
      const baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : void 0].filter(Boolean);
      const baseOnInput = [(e2) => onChangeHandler(e2, validateOnInput), ctx.attrs.onInput].filter(Boolean);
      const baseOnChange = [(e2) => onChangeHandler(e2, validateOnChange), ctx.attrs.onChange].filter(Boolean);
      const attrs = {
        name: props2.name,
        onBlur: baseOnBlur,
        onInput: baseOnInput,
        onChange: baseOnChange
      };
      attrs["onUpdate:modelValue"] = (e2) => onChangeHandler(e2, validateOnModelUpdate);
      if (hasCheckedAttr(ctx.attrs.type) && checked) {
        attrs.checked = checked.value;
      }
      const tag = resolveTag(props2, ctx);
      if (shouldHaveValueBinding(tag, ctx.attrs)) {
        attrs.value = value2.value;
      }
      return attrs;
    });
    function slotProps() {
      return {
        field: fieldProps.value,
        value: value2.value,
        meta,
        errors: errors.value,
        errorMessage: errorMessage.value,
        validate: validateField,
        resetField,
        handleChange: onChangeHandler,
        handleInput: onInputHandler,
        handleReset,
        handleBlur,
        setTouched,
        setErrors
      };
    }
    ctx.expose({
      setErrors,
      setTouched,
      reset: resetField,
      validate: validateField,
      handleChange
    });
    return () => {
      const tag = resolveDynamicComponent(resolveTag(props2, ctx));
      const children = normalizeChildren(tag, ctx, slotProps);
      if (tag) {
        return h$5(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);
      }
      return children;
    };
  }
});
function resolveTag(props2, ctx) {
  let tag = props2.as || "";
  if (!props2.as && !ctx.slots.default) {
    tag = "input";
  }
  return tag;
}
function resolveValidationTriggers(props2) {
  var _a, _b, _c, _d;
  const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();
  return {
    validateOnInput: (_a = props2.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,
    validateOnChange: (_b = props2.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,
    validateOnBlur: (_c = props2.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,
    validateOnModelUpdate: (_d = props2.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate
  };
}
function resolveInitialValue(props2, ctx) {
  if (!hasCheckedAttr(ctx.attrs.type)) {
    return isPropPresent(props2, "modelValue") ? props2.modelValue : ctx.attrs.value;
  }
  return isPropPresent(props2, "modelValue") ? props2.modelValue : void 0;
}
const Field = FieldImpl;
let FORM_COUNTER = 0;
function useForm(opts2) {
  var _a;
  const formId = FORM_COUNTER++;
  let RESET_LOCK = false;
  const fieldsByPath = ref({});
  const isSubmitting = ref(false);
  const submitCount = ref(0);
  const fieldArrays = [];
  const formValues = reactive(klona(unref(opts2 === null || opts2 === void 0 ? void 0 : opts2.initialValues) || {}));
  const { errorBag, setErrorBag, setFieldErrorBag } = useErrorBag(opts2 === null || opts2 === void 0 ? void 0 : opts2.initialErrors);
  const errors = computed(() => {
    return keysOf(errorBag.value).reduce((acc, key) => {
      const bag = errorBag.value[key];
      if (bag && bag.length) {
        acc[key] = bag[0];
      }
      return acc;
    }, {});
  });
  function getFirstFieldAtPath(path) {
    const fieldOrGroup = fieldsByPath.value[path];
    return Array.isArray(fieldOrGroup) ? fieldOrGroup[0] : fieldOrGroup;
  }
  function fieldExists(path) {
    return !!fieldsByPath.value[path];
  }
  const fieldNames = computed(() => {
    return keysOf(fieldsByPath.value).reduce((names, path) => {
      const field = getFirstFieldAtPath(path);
      if (field) {
        names[path] = unref(field.label || field.name) || "";
      }
      return names;
    }, {});
  });
  const fieldBailsMap = computed(() => {
    return keysOf(fieldsByPath.value).reduce((map2, path) => {
      var _a2;
      const field = getFirstFieldAtPath(path);
      if (field) {
        map2[path] = (_a2 = field.bails) !== null && _a2 !== void 0 ? _a2 : true;
      }
      return map2;
    }, {});
  });
  const initialErrors = Object.assign({}, (opts2 === null || opts2 === void 0 ? void 0 : opts2.initialErrors) || {});
  const keepValuesOnUnmount = (_a = opts2 === null || opts2 === void 0 ? void 0 : opts2.keepValuesOnUnmount) !== null && _a !== void 0 ? _a : false;
  const { initialValues, originalInitialValues, setInitialValues } = useFormInitialValues(fieldsByPath, formValues, opts2 === null || opts2 === void 0 ? void 0 : opts2.initialValues);
  const meta = useFormMeta(fieldsByPath, formValues, originalInitialValues, errors);
  const schema = opts2 === null || opts2 === void 0 ? void 0 : opts2.validationSchema;
  const debouncedSilentValidation = debounceAsync(_validateSchema, 5);
  const debouncedValidation = debounceAsync(_validateSchema, 5);
  const validateSchema = withLatest(async (mode) => {
    return await mode === "silent" ? debouncedSilentValidation() : debouncedValidation();
  }, (formResult, [mode]) => {
    const fieldsById = formCtx.fieldsByPath.value || {};
    const currentErrorsPaths = keysOf(formCtx.errorBag.value);
    const paths = [
      .../* @__PURE__ */ new Set([...keysOf(formResult.results), ...keysOf(fieldsById), ...currentErrorsPaths])
    ];
    return paths.reduce((validation, path) => {
      const field = fieldsById[path];
      const messages = (formResult.results[path] || { errors: [] }).errors;
      const fieldResult = {
        errors: messages,
        valid: !messages.length
      };
      validation.results[path] = fieldResult;
      if (!fieldResult.valid) {
        validation.errors[path] = fieldResult.errors[0];
      }
      if (!field) {
        setFieldError(path, messages);
        return validation;
      }
      applyFieldMutation(field, (f2) => f2.meta.valid = fieldResult.valid);
      if (mode === "silent") {
        return validation;
      }
      const wasValidated = Array.isArray(field) ? field.some((f2) => f2.meta.validated) : field.meta.validated;
      if (mode === "validated-only" && !wasValidated) {
        return validation;
      }
      applyFieldMutation(field, (f2) => f2.setState({ errors: fieldResult.errors }));
      return validation;
    }, { valid: formResult.valid, results: {}, errors: {} });
  });
  const formCtx = {
    formId,
    fieldsByPath,
    values: formValues,
    errorBag,
    errors,
    schema,
    submitCount,
    meta,
    isSubmitting,
    fieldArrays,
    keepValuesOnUnmount,
    validateSchema: unref(schema) ? validateSchema : void 0,
    validate: validate2,
    register: registerField,
    unregister: unregisterField,
    setFieldErrorBag,
    validateField,
    setFieldValue,
    setValues,
    setErrors,
    setFieldError,
    setFieldTouched,
    setTouched,
    resetForm,
    handleSubmit,
    stageInitialValue,
    unsetInitialValue,
    setFieldInitialValue,
    useFieldModel
  };
  function isFieldGroup(fieldOrGroup) {
    return Array.isArray(fieldOrGroup);
  }
  function applyFieldMutation(fieldOrGroup, mutation) {
    if (Array.isArray(fieldOrGroup)) {
      return fieldOrGroup.forEach(mutation);
    }
    return mutation(fieldOrGroup);
  }
  function mutateAllFields(mutation) {
    Object.values(fieldsByPath.value).forEach((field) => {
      if (!field) {
        return;
      }
      applyFieldMutation(field, mutation);
    });
  }
  function setFieldError(field, message) {
    setFieldErrorBag(field, message);
  }
  function setErrors(fields) {
    setErrorBag(fields);
  }
  function setFieldValue(field, value2, { force } = { force: false }) {
    var _a2;
    const fieldInstance = fieldsByPath.value[field];
    const clonedValue = klona(value2);
    if (!fieldInstance) {
      setInPath(formValues, field, clonedValue);
      return;
    }
    if (isFieldGroup(fieldInstance) && ((_a2 = fieldInstance[0]) === null || _a2 === void 0 ? void 0 : _a2.type) === "checkbox" && !Array.isArray(value2)) {
      const newValue2 = klona(resolveNextCheckboxValue(getFromPath(formValues, field) || [], value2, void 0));
      setInPath(formValues, field, newValue2);
      return;
    }
    let newValue = value2;
    if (!isFieldGroup(fieldInstance) && fieldInstance.type === "checkbox" && !force && !RESET_LOCK) {
      newValue = klona(resolveNextCheckboxValue(getFromPath(formValues, field), value2, unref(fieldInstance.uncheckedValue)));
    }
    setInPath(formValues, field, newValue);
  }
  function setValues(fields) {
    keysOf(formValues).forEach((key) => {
      delete formValues[key];
    });
    keysOf(fields).forEach((path) => {
      setFieldValue(path, fields[path]);
    });
    fieldArrays.forEach((f2) => f2 && f2.reset());
  }
  function createModel(path) {
    const { value: value2 } = _useFieldValue(path);
    watch(value2, () => {
      if (!fieldExists(unref(path))) {
        validate2({ mode: "validated-only" });
      }
    }, {
      deep: true
    });
    return value2;
  }
  function useFieldModel(path) {
    if (!Array.isArray(path)) {
      return createModel(path);
    }
    return path.map(createModel);
  }
  function setFieldTouched(field, isTouched) {
    const fieldInstance = fieldsByPath.value[field];
    if (fieldInstance) {
      applyFieldMutation(fieldInstance, (f2) => f2.setTouched(isTouched));
    }
  }
  function setTouched(fields) {
    keysOf(fields).forEach((field) => {
      setFieldTouched(field, !!fields[field]);
    });
  }
  function resetForm(state2) {
    RESET_LOCK = true;
    mutateAllFields((f2) => f2.resetField());
    if (state2 === null || state2 === void 0 ? void 0 : state2.values) {
      setInitialValues(state2.values);
      setValues(state2 === null || state2 === void 0 ? void 0 : state2.values);
    } else {
      setInitialValues(originalInitialValues.value);
      setValues(originalInitialValues.value);
    }
    if (state2 === null || state2 === void 0 ? void 0 : state2.touched) {
      setTouched(state2.touched);
    }
    setErrors((state2 === null || state2 === void 0 ? void 0 : state2.errors) || {});
    submitCount.value = (state2 === null || state2 === void 0 ? void 0 : state2.submitCount) || 0;
    nextTick(() => {
      RESET_LOCK = false;
    });
  }
  function insertFieldAtPath(field, path) {
    const rawField = markRaw(field);
    const fieldPath = path;
    if (!fieldsByPath.value[fieldPath]) {
      fieldsByPath.value[fieldPath] = rawField;
      return;
    }
    const fieldAtPath = fieldsByPath.value[fieldPath];
    if (fieldAtPath && !Array.isArray(fieldAtPath)) {
      fieldsByPath.value[fieldPath] = [fieldAtPath];
    }
    fieldsByPath.value[fieldPath] = [...fieldsByPath.value[fieldPath], rawField];
  }
  function removeFieldFromPath(field, path) {
    const fieldPath = path;
    const fieldAtPath = fieldsByPath.value[fieldPath];
    if (!fieldAtPath) {
      return;
    }
    if (!isFieldGroup(fieldAtPath) && field.id === fieldAtPath.id) {
      delete fieldsByPath.value[fieldPath];
      return;
    }
    if (isFieldGroup(fieldAtPath)) {
      const idx = fieldAtPath.findIndex((f2) => f2.id === field.id);
      if (idx === -1) {
        return;
      }
      fieldAtPath.splice(idx, 1);
      if (!fieldAtPath.length) {
        delete fieldsByPath.value[fieldPath];
      }
    }
  }
  function registerField(field) {
    const fieldPath = unref(field.name);
    insertFieldAtPath(field, fieldPath);
    if (isRef(field.name)) {
      watch(field.name, async (newPath, oldPath) => {
        await nextTick();
        removeFieldFromPath(field, oldPath);
        insertFieldAtPath(field, newPath);
        if (errors.value[oldPath] || errors.value[newPath]) {
          setFieldError(oldPath, void 0);
          validateField(newPath);
        }
        await nextTick();
        if (!fieldExists(oldPath)) {
          unsetPath(formValues, oldPath);
        }
      });
    }
    const initialErrorMessage = unref(field.errorMessage);
    if (initialErrorMessage && (initialErrors === null || initialErrors === void 0 ? void 0 : initialErrors[fieldPath]) !== initialErrorMessage) {
      validateField(fieldPath);
    }
    delete initialErrors[fieldPath];
  }
  function unregisterField(field) {
    const fieldName = unref(field.name);
    const fieldInstance = fieldsByPath.value[fieldName];
    const isGroup = !!fieldInstance && isFieldGroup(fieldInstance);
    removeFieldFromPath(field, fieldName);
    nextTick(() => {
      var _a2;
      const shouldKeepValue = (_a2 = unref(field.keepValueOnUnmount)) !== null && _a2 !== void 0 ? _a2 : unref(keepValuesOnUnmount);
      const currentGroupValue = getFromPath(formValues, fieldName);
      const isSameGroup = isGroup && (fieldInstance === fieldsByPath.value[fieldName] || !fieldsByPath.value[fieldName]);
      if (isSameGroup && Array.isArray(currentGroupValue) && !shouldKeepValue) {
        const valueIdx = currentGroupValue.findIndex((i2) => isEqual(i2, unref(field.checkedValue)));
        if (valueIdx > -1) {
          const newVal = [...currentGroupValue];
          newVal.splice(valueIdx, 1);
          setFieldValue(fieldName, newVal, { force: true });
        }
      }
      if (!fieldExists(fieldName)) {
        setFieldError(fieldName, void 0);
        if (shouldKeepValue) {
          return;
        }
        if (isGroup && !isEmptyContainer(getFromPath(formValues, fieldName))) {
          return;
        }
        unsetPath(formValues, fieldName);
      }
    });
  }
  async function validate2(opts3) {
    mutateAllFields((f2) => f2.meta.validated = true);
    if (formCtx.validateSchema) {
      return formCtx.validateSchema((opts3 === null || opts3 === void 0 ? void 0 : opts3.mode) || "force");
    }
    const validations = await Promise.all(Object.values(fieldsByPath.value).map((field) => {
      const fieldInstance = Array.isArray(field) ? field[0] : field;
      if (!fieldInstance) {
        return Promise.resolve({ key: "", valid: true, errors: [] });
      }
      return fieldInstance.validate(opts3).then((result) => {
        return {
          key: unref(fieldInstance.name),
          valid: result.valid,
          errors: result.errors
        };
      });
    }));
    const results = {};
    const errors2 = {};
    for (const validation of validations) {
      results[validation.key] = {
        valid: validation.valid,
        errors: validation.errors
      };
      if (validation.errors.length) {
        errors2[validation.key] = validation.errors[0];
      }
    }
    return {
      valid: validations.every((r2) => r2.valid),
      results,
      errors: errors2
    };
  }
  async function validateField(field) {
    const fieldInstance = fieldsByPath.value[field];
    if (!fieldInstance) {
      warn$1(`field with name ${field} was not found`);
      return Promise.resolve({ errors: [], valid: true });
    }
    if (Array.isArray(fieldInstance)) {
      return fieldInstance.map((f2) => f2.validate())[0];
    }
    return fieldInstance.validate();
  }
  function handleSubmit(fn3, onValidationError) {
    return function submissionHandler(e2) {
      if (e2 instanceof Event) {
        e2.preventDefault();
        e2.stopPropagation();
      }
      setTouched(keysOf(fieldsByPath.value).reduce((acc, field) => {
        acc[field] = true;
        return acc;
      }, {}));
      isSubmitting.value = true;
      submitCount.value++;
      return validate2().then((result) => {
        if (result.valid && typeof fn3 === "function") {
          return fn3(klona(formValues), {
            evt: e2,
            setErrors,
            setFieldError,
            setTouched,
            setFieldTouched,
            setValues,
            setFieldValue,
            resetForm
          });
        }
        if (!result.valid && typeof onValidationError === "function") {
          onValidationError({
            values: klona(formValues),
            evt: e2,
            errors: result.errors,
            results: result.results
          });
        }
      }).then((returnVal) => {
        isSubmitting.value = false;
        return returnVal;
      }, (err) => {
        isSubmitting.value = false;
        throw err;
      });
    };
  }
  function setFieldInitialValue(path, value2) {
    setInPath(initialValues.value, path, klona(value2));
  }
  function unsetInitialValue(path) {
    unsetPath(initialValues.value, path);
  }
  function stageInitialValue(path, value2, updateOriginal = false) {
    setInPath(formValues, path, value2);
    setFieldInitialValue(path, value2);
    if (updateOriginal && !(opts2 === null || opts2 === void 0 ? void 0 : opts2.initialValues)) {
      setInPath(originalInitialValues.value, path, klona(value2));
    }
  }
  async function _validateSchema() {
    const schemaValue = unref(schema);
    if (!schemaValue) {
      return { valid: true, results: {}, errors: {} };
    }
    const formResult = isYupValidator(schemaValue) ? await validateYupSchema(schemaValue, formValues) : await validateObjectSchema(schemaValue, formValues, {
      names: fieldNames.value,
      bailsMap: fieldBailsMap.value
    });
    return formResult;
  }
  const submitForm = handleSubmit((_2, { evt }) => {
    if (isFormSubmitEvent(evt)) {
      evt.target.submit();
    }
  });
  onMounted(() => {
    if (opts2 === null || opts2 === void 0 ? void 0 : opts2.initialErrors) {
      setErrors(opts2.initialErrors);
    }
    if (opts2 === null || opts2 === void 0 ? void 0 : opts2.initialTouched) {
      setTouched(opts2.initialTouched);
    }
    if (opts2 === null || opts2 === void 0 ? void 0 : opts2.validateOnMount) {
      validate2();
      return;
    }
    if (formCtx.validateSchema) {
      formCtx.validateSchema("silent");
    }
  });
  if (isRef(schema)) {
    watch(schema, () => {
      var _a2;
      (_a2 = formCtx.validateSchema) === null || _a2 === void 0 ? void 0 : _a2.call(formCtx, "validated-only");
    });
  }
  provide(FormContextKey, formCtx);
  {
    registerFormWithDevTools(formCtx);
    watch(() => Object.assign(Object.assign({ errors: errorBag.value }, meta.value), { values: formValues, isSubmitting: isSubmitting.value, submitCount: submitCount.value }), refreshInspector, {
      deep: true
    });
  }
  return {
    errors,
    meta,
    values: formValues,
    isSubmitting,
    submitCount,
    validate: validate2,
    validateField,
    handleReset: () => resetForm(),
    resetForm,
    handleSubmit,
    submitForm,
    setFieldError,
    setErrors,
    setFieldValue,
    setValues,
    setFieldTouched,
    setTouched,
    useFieldModel
  };
}
function useFormMeta(fieldsByPath, currentValues, initialValues, errors) {
  const MERGE_STRATEGIES = {
    touched: "some",
    pending: "some",
    valid: "every"
  };
  const isDirty = computed(() => {
    return !isEqual(currentValues, unref(initialValues));
  });
  function calculateFlags() {
    const fields = Object.values(fieldsByPath.value).flat(1).filter(Boolean);
    return keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {
      const mergeMethod = MERGE_STRATEGIES[flag];
      acc[flag] = fields[mergeMethod]((field) => field.meta[flag]);
      return acc;
    }, {});
  }
  const flags = reactive(calculateFlags());
  watchEffect(() => {
    const value2 = calculateFlags();
    flags.touched = value2.touched;
    flags.valid = value2.valid;
    flags.pending = value2.pending;
  });
  return computed(() => {
    return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { valid: flags.valid && !keysOf(errors.value).length, dirty: isDirty.value });
  });
}
function useFormInitialValues(fields, formValues, providedValues) {
  const initialValues = ref(klona(unref(providedValues)) || {});
  const originalInitialValues = ref(klona(unref(providedValues)) || {});
  function setInitialValues(values, updateFields = false) {
    initialValues.value = klona(values);
    originalInitialValues.value = klona(values);
    if (!updateFields) {
      return;
    }
    keysOf(fields.value).forEach((fieldPath) => {
      const field = fields.value[fieldPath];
      const wasTouched = Array.isArray(field) ? field.some((f2) => f2.meta.touched) : field === null || field === void 0 ? void 0 : field.meta.touched;
      if (!field || wasTouched) {
        return;
      }
      const newValue = getFromPath(initialValues.value, fieldPath);
      setInPath(formValues, fieldPath, klona(newValue));
    });
  }
  if (isRef(providedValues)) {
    watch(providedValues, (value2) => {
      setInitialValues(value2, true);
    }, {
      deep: true
    });
  }
  return {
    initialValues,
    originalInitialValues,
    setInitialValues
  };
}
function useErrorBag(initialErrors) {
  const errorBag = ref({});
  function normalizeErrorItem(message) {
    return Array.isArray(message) ? message : message ? [message] : [];
  }
  function setFieldErrorBag(field, message) {
    if (!message) {
      delete errorBag.value[field];
      return;
    }
    errorBag.value[field] = normalizeErrorItem(message);
  }
  function setErrorBag(fields) {
    errorBag.value = keysOf(fields).reduce((acc, key) => {
      const message = fields[key];
      if (message) {
        acc[key] = normalizeErrorItem(message);
      }
      return acc;
    }, {});
  }
  if (initialErrors) {
    setErrorBag(initialErrors);
  }
  return {
    errorBag,
    setErrorBag,
    setFieldErrorBag
  };
}
const FormImpl = defineComponent({
  name: "Form",
  inheritAttrs: false,
  props: {
    as: {
      type: String,
      default: "form"
    },
    validationSchema: {
      type: Object,
      default: void 0
    },
    initialValues: {
      type: Object,
      default: void 0
    },
    initialErrors: {
      type: Object,
      default: void 0
    },
    initialTouched: {
      type: Object,
      default: void 0
    },
    validateOnMount: {
      type: Boolean,
      default: false
    },
    onSubmit: {
      type: Function,
      default: void 0
    },
    onInvalidSubmit: {
      type: Function,
      default: void 0
    },
    keepValues: {
      type: Boolean,
      default: false
    }
  },
  setup(props2, ctx) {
    const initialValues = toRef(props2, "initialValues");
    const validationSchema = toRef(props2, "validationSchema");
    const keepValues = toRef(props2, "keepValues");
    const { errors, values, meta, isSubmitting, submitCount, validate: validate2, validateField, handleReset, resetForm, handleSubmit, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched } = useForm({
      validationSchema: validationSchema.value ? validationSchema : void 0,
      initialValues,
      initialErrors: props2.initialErrors,
      initialTouched: props2.initialTouched,
      validateOnMount: props2.validateOnMount,
      keepValuesOnUnmount: keepValues
    });
    const submitForm = handleSubmit((_2, { evt }) => {
      if (isFormSubmitEvent(evt)) {
        evt.target.submit();
      }
    }, props2.onInvalidSubmit);
    const onSubmit = props2.onSubmit ? handleSubmit(props2.onSubmit, props2.onInvalidSubmit) : submitForm;
    function handleFormReset(e2) {
      if (isEvent(e2)) {
        e2.preventDefault();
      }
      handleReset();
      if (typeof ctx.attrs.onReset === "function") {
        ctx.attrs.onReset();
      }
    }
    function handleScopedSlotSubmit(evt, onSubmit2) {
      const onSuccess = typeof evt === "function" && !onSubmit2 ? evt : onSubmit2;
      return handleSubmit(onSuccess, props2.onInvalidSubmit)(evt);
    }
    function slotProps() {
      return {
        meta: meta.value,
        errors: errors.value,
        values,
        isSubmitting: isSubmitting.value,
        submitCount: submitCount.value,
        validate: validate2,
        validateField,
        handleSubmit: handleScopedSlotSubmit,
        handleReset,
        submitForm,
        setErrors,
        setFieldError,
        setFieldValue,
        setValues,
        setFieldTouched,
        setTouched,
        resetForm
      };
    }
    ctx.expose({
      setFieldError,
      setErrors,
      setFieldValue,
      setValues,
      setFieldTouched,
      setTouched,
      resetForm,
      validate: validate2,
      validateField
    });
    return function renderForm() {
      const tag = props2.as === "form" ? props2.as : resolveDynamicComponent(props2.as);
      const children = normalizeChildren(tag, ctx, slotProps);
      if (!props2.as) {
        return children;
      }
      const formAttrs = props2.as === "form" ? {
        novalidate: true
      } : {};
      return h$5(tag, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);
    };
  }
});
const Form = FormImpl;
function useFieldArray(arrayPath) {
  const form = injectWithSelf(FormContextKey, void 0);
  const fields = ref([]);
  const noOp = () => {
  };
  const noOpApi = {
    fields,
    remove: noOp,
    push: noOp,
    swap: noOp,
    insert: noOp,
    update: noOp,
    replace: noOp,
    prepend: noOp,
    move: noOp
  };
  if (!form) {
    warn("FieldArray requires being a child of `<Form/>` or `useForm` being called before it. Array fields may not work correctly");
    return noOpApi;
  }
  if (!unref(arrayPath)) {
    warn("FieldArray requires a field path to be provided, did you forget to pass the `name` prop?");
    return noOpApi;
  }
  const alreadyExists = form.fieldArrays.find((a3) => unref(a3.path) === unref(arrayPath));
  if (alreadyExists) {
    return alreadyExists;
  }
  let entryCounter = 0;
  function initFields() {
    const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []) || [];
    fields.value = currentValues.map(createEntry);
    updateEntryFlags();
  }
  initFields();
  function updateEntryFlags() {
    const fieldsLength = fields.value.length;
    for (let i2 = 0; i2 < fieldsLength; i2++) {
      const entry = fields.value[i2];
      entry.isFirst = i2 === 0;
      entry.isLast = i2 === fieldsLength - 1;
    }
  }
  function createEntry(value2) {
    const key = entryCounter++;
    const entry = {
      key,
      value: computed({
        get() {
          const currentValues = getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(arrayPath), []) || [];
          const idx = fields.value.findIndex((e2) => e2.key === key);
          return idx === -1 ? value2 : currentValues[idx];
        },
        set(value3) {
          const idx = fields.value.findIndex((e2) => e2.key === key);
          if (idx === -1) {
            warn(`Attempting to update a non-existent array item`);
            return;
          }
          update5(idx, value3);
        }
      }),
      isFirst: false,
      isLast: false
    };
    return entry;
  }
  function remove2(idx) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!pathValue || !Array.isArray(pathValue)) {
      return;
    }
    const newValue = [...pathValue];
    newValue.splice(idx, 1);
    form === null || form === void 0 ? void 0 : form.unsetInitialValue(pathName + `[${idx}]`);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value.splice(idx, 1);
    updateEntryFlags();
  }
  function push2(value2) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;
    if (!Array.isArray(normalizedPathValue)) {
      return;
    }
    const newValue = [...normalizedPathValue];
    newValue.push(value2);
    form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value2);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value.push(createEntry(value2));
    updateEntryFlags();
  }
  function swap(indexA, indexB) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!Array.isArray(pathValue) || !(indexA in pathValue) || !(indexB in pathValue)) {
      return;
    }
    const newValue = [...pathValue];
    const newFields = [...fields.value];
    const temp = newValue[indexA];
    newValue[indexA] = newValue[indexB];
    newValue[indexB] = temp;
    const tempEntry = newFields[indexA];
    newFields[indexA] = newFields[indexB];
    newFields[indexB] = tempEntry;
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value = newFields;
    updateEntryFlags();
  }
  function insert(idx, value2) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!Array.isArray(pathValue) || pathValue.length < idx) {
      return;
    }
    const newValue = [...pathValue];
    const newFields = [...fields.value];
    newValue.splice(idx, 0, value2);
    newFields.splice(idx, 0, createEntry(value2));
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value = newFields;
    updateEntryFlags();
  }
  function replace2(arr) {
    const pathName = unref(arrayPath);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, arr);
    initFields();
  }
  function update5(idx, value2) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    if (!Array.isArray(pathValue) || pathValue.length - 1 < idx) {
      return;
    }
    form === null || form === void 0 ? void 0 : form.setFieldValue(`${pathName}[${idx}]`, value2);
  }
  function prepend(value2) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    const normalizedPathValue = isNullOrUndefined(pathValue) ? [] : pathValue;
    if (!Array.isArray(normalizedPathValue)) {
      return;
    }
    const newValue = [value2, ...normalizedPathValue];
    form === null || form === void 0 ? void 0 : form.stageInitialValue(pathName + `[${newValue.length - 1}]`, value2);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value.unshift(createEntry(value2));
    updateEntryFlags();
  }
  function move3(oldIdx, newIdx) {
    const pathName = unref(arrayPath);
    const pathValue = getFromPath(form === null || form === void 0 ? void 0 : form.values, pathName);
    const newValue = isNullOrUndefined(pathValue) ? [] : [...pathValue];
    if (!Array.isArray(pathValue) || !(oldIdx in pathValue) || !(newIdx in pathValue)) {
      return;
    }
    const newFields = [...fields.value];
    const movedItem = newFields[oldIdx];
    newFields.splice(oldIdx, 1);
    newFields.splice(newIdx, 0, movedItem);
    const movedValue = newValue[oldIdx];
    newValue.splice(oldIdx, 1);
    newValue.splice(newIdx, 0, movedValue);
    form === null || form === void 0 ? void 0 : form.setFieldValue(pathName, newValue);
    fields.value = newFields;
    updateEntryFlags();
  }
  const fieldArrayCtx = {
    fields,
    remove: remove2,
    push: push2,
    swap,
    insert,
    update: update5,
    replace: replace2,
    prepend,
    move: move3
  };
  form.fieldArrays.push(Object.assign({ path: arrayPath, reset: initFields }, fieldArrayCtx));
  onBeforeUnmount(() => {
    const idx = form.fieldArrays.findIndex((i2) => unref(i2.path) === unref(arrayPath));
    if (idx >= 0) {
      form.fieldArrays.splice(idx, 1);
    }
  });
  return fieldArrayCtx;
}
defineComponent({
  name: "FieldArray",
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      required: true
    }
  },
  setup(props2, ctx) {
    const { push: push2, remove: remove2, swap, insert, replace: replace2, update: update5, prepend, move: move3, fields } = useFieldArray(toRef(props2, "name"));
    function slotProps() {
      return {
        fields: fields.value,
        push: push2,
        remove: remove2,
        swap,
        insert,
        update: update5,
        replace: replace2,
        prepend,
        move: move3
      };
    }
    ctx.expose({
      push: push2,
      remove: remove2,
      swap,
      insert,
      update: update5,
      replace: replace2,
      prepend,
      move: move3
    });
    return () => {
      const children = normalizeChildren(void 0, ctx, slotProps);
      return children;
    };
  }
});
defineComponent({
  name: "ErrorMessage",
  props: {
    as: {
      type: String,
      default: void 0
    },
    name: {
      type: String,
      required: true
    }
  },
  setup(props2, ctx) {
    const form = inject(FormContextKey, void 0);
    const message = computed(() => {
      return form === null || form === void 0 ? void 0 : form.errors.value[props2.name];
    });
    function slotProps() {
      return {
        message: message.value
      };
    }
    return () => {
      if (!message.value) {
        return void 0;
      }
      const tag = props2.as ? resolveDynamicComponent(props2.as) : props2.as;
      const children = normalizeChildren(tag, ctx, slotProps);
      const attrs = Object.assign({ role: "alert" }, ctx.attrs);
      if (!tag && (Array.isArray(children) || !children) && (children === null || children === void 0 ? void 0 : children.length)) {
        return children;
      }
      if ((Array.isArray(children) || !children) && !(children === null || children === void 0 ? void 0 : children.length)) {
        return h$5(tag || "span", attrs, message.value);
      }
      return h$5(tag, attrs, children);
    };
  }
});
/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */
var storeKey = "store";
function find$1(list, f2) {
  return list.filter(f2)[0];
}
function deepCopy(obj, cache) {
  if (cache === void 0)
    cache = [];
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  var hit = find$1(cache, function(c2) {
    return c2.original === obj;
  });
  if (hit) {
    return hit.copy;
  }
  var copy = Array.isArray(obj) ? [] : {};
  cache.push({
    original: obj,
    copy
  });
  Object.keys(obj).forEach(function(key) {
    copy[key] = deepCopy(obj[key], cache);
  });
  return copy;
}
function forEachValue(obj, fn3) {
  Object.keys(obj).forEach(function(key) {
    return fn3(obj[key], key);
  });
}
function isObject$3(obj) {
  return obj !== null && typeof obj === "object";
}
function isPromise(val) {
  return val && typeof val.then === "function";
}
function assert(condition, msg) {
  if (!condition) {
    throw new Error("[vuex] " + msg);
  }
}
function partial(fn3, arg) {
  return function() {
    return fn3(arg);
  };
}
function genericSubscribe(fn3, subs, options) {
  if (subs.indexOf(fn3) < 0) {
    options && options.prepend ? subs.unshift(fn3) : subs.push(fn3);
  }
  return function() {
    var i2 = subs.indexOf(fn3);
    if (i2 > -1) {
      subs.splice(i2, 1);
    }
  };
}
function resetStore(store2, hot) {
  store2._actions = /* @__PURE__ */ Object.create(null);
  store2._mutations = /* @__PURE__ */ Object.create(null);
  store2._wrappedGetters = /* @__PURE__ */ Object.create(null);
  store2._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  var state2 = store2.state;
  installModule(store2, state2, [], store2._modules.root, true);
  resetStoreState(store2, state2, hot);
}
function resetStoreState(store2, state2, hot) {
  var oldState = store2._state;
  store2.getters = {};
  store2._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  var wrappedGetters = store2._wrappedGetters;
  var computedObj = {};
  forEachValue(wrappedGetters, function(fn3, key) {
    computedObj[key] = partial(fn3, store2);
    Object.defineProperty(store2.getters, key, {
      get: function() {
        return computedObj[key]();
      },
      enumerable: true
    });
  });
  store2._state = reactive({
    data: state2
  });
  if (store2.strict) {
    enableStrictMode(store2);
  }
  if (oldState) {
    if (hot) {
      store2._withCommit(function() {
        oldState.data = null;
      });
    }
  }
}
function installModule(store2, rootState, path, module2, hot) {
  var isRoot = !path.length;
  var namespace = store2._modules.getNamespace(path);
  if (module2.namespaced) {
    if (store2._modulesNamespaceMap[namespace] && true) {
      console.error("[vuex] duplicate namespace " + namespace + " for the namespaced module " + path.join("/"));
    }
    store2._modulesNamespaceMap[namespace] = module2;
  }
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store2._withCommit(function() {
      {
        if (moduleName in parentState) {
          console.warn(
            '[vuex] state field "' + moduleName + '" was overridden by a module with the same name at "' + path.join(".") + '"'
          );
        }
      }
      parentState[moduleName] = module2.state;
    });
  }
  var local = module2.context = makeLocalContext(store2, namespace, path);
  module2.forEachMutation(function(mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store2, namespacedType, mutation, local);
  });
  module2.forEachAction(function(action, key) {
    var type = action.root ? key : namespace + key;
    var handler2 = action.handler || action;
    registerAction(store2, type, handler2, local);
  });
  module2.forEachGetter(function(getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store2, namespacedType, getter, local);
  });
  module2.forEachChild(function(child, key) {
    installModule(store2, rootState, path.concat(key), child, hot);
  });
}
function makeLocalContext(store2, namespace, path) {
  var noNamespace = namespace === "";
  var local = {
    dispatch: noNamespace ? store2.dispatch : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store2._actions[type]) {
          console.error("[vuex] unknown local action type: " + args.type + ", global type: " + type);
          return;
        }
      }
      return store2.dispatch(type, payload);
    },
    commit: noNamespace ? store2.commit : function(_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;
      if (!options || !options.root) {
        type = namespace + type;
        if (!store2._mutations[type]) {
          console.error("[vuex] unknown local mutation type: " + args.type + ", global type: " + type);
          return;
        }
      }
      store2.commit(type, payload, options);
    }
  };
  Object.defineProperties(local, {
    getters: {
      get: noNamespace ? function() {
        return store2.getters;
      } : function() {
        return makeLocalGetters(store2, namespace);
      }
    },
    state: {
      get: function() {
        return getNestedState(store2.state, path);
      }
    }
  });
  return local;
}
function makeLocalGetters(store2, namespace) {
  if (!store2._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store2.getters).forEach(function(type) {
      if (type.slice(0, splitPos) !== namespace) {
        return;
      }
      var localType = type.slice(splitPos);
      Object.defineProperty(gettersProxy, localType, {
        get: function() {
          return store2.getters[type];
        },
        enumerable: true
      });
    });
    store2._makeLocalGettersCache[namespace] = gettersProxy;
  }
  return store2._makeLocalGettersCache[namespace];
}
function registerMutation(store2, type, handler2, local) {
  var entry = store2._mutations[type] || (store2._mutations[type] = []);
  entry.push(function wrappedMutationHandler(payload) {
    handler2.call(store2, local.state, payload);
  });
}
function registerAction(store2, type, handler2, local) {
  var entry = store2._actions[type] || (store2._actions[type] = []);
  entry.push(function wrappedActionHandler(payload) {
    var res = handler2.call(store2, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store2.getters,
      rootState: store2.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store2._devtoolHook) {
      return res.catch(function(err) {
        store2._devtoolHook.emit("vuex:error", err);
        throw err;
      });
    } else {
      return res;
    }
  });
}
function registerGetter(store2, type, rawGetter, local) {
  if (store2._wrappedGetters[type]) {
    {
      console.error("[vuex] duplicate getter key: " + type);
    }
    return;
  }
  store2._wrappedGetters[type] = function wrappedGetter(store3) {
    return rawGetter(
      local.state,
      local.getters,
      store3.state,
      store3.getters
    );
  };
}
function enableStrictMode(store2) {
  watch(function() {
    return store2._state.data;
  }, function() {
    {
      assert(store2._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, flush: "sync" });
}
function getNestedState(state2, path) {
  return path.reduce(function(state3, key) {
    return state3[key];
  }, state2);
}
function unifyObjectStyle(type, payload, options) {
  if (isObject$3(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }
  {
    assert(typeof type === "string", "expects string as the type, but found " + typeof type + ".");
  }
  return { type, payload, options };
}
var LABEL_VUEX_BINDINGS = "vuex bindings";
var MUTATIONS_LAYER_ID = "vuex:mutations";
var ACTIONS_LAYER_ID = "vuex:actions";
var INSPECTOR_ID = "vuex";
var actionId = 0;
function addDevtools(app, store2) {
  setupDevtoolsPlugin(
    {
      id: "org.vuejs.vuex",
      app,
      label: "Vuex",
      homepage: "https://next.vuex.vuejs.org/",
      logo: "https://vuejs.org/images/icons/favicon-96x96.png",
      packageName: "vuex",
      componentStateTypes: [LABEL_VUEX_BINDINGS]
    },
    function(api2) {
      api2.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: "Vuex Mutations",
        color: COLOR_LIME_500
      });
      api2.addTimelineLayer({
        id: ACTIONS_LAYER_ID,
        label: "Vuex Actions",
        color: COLOR_LIME_500
      });
      api2.addInspector({
        id: INSPECTOR_ID,
        label: "Vuex",
        icon: "storage",
        treeFilterPlaceholder: "Filter stores..."
      });
      api2.on.getInspectorTree(function(payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          if (payload.filter) {
            var nodes = [];
            flattenStoreForInspectorTree(nodes, store2._modules.root, payload.filter, "");
            payload.rootNodes = nodes;
          } else {
            payload.rootNodes = [
              formatStoreForInspectorTree(store2._modules.root, "")
            ];
          }
        }
      });
      api2.on.getInspectorState(function(payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          makeLocalGetters(store2, modulePath);
          payload.state = formatStoreForInspectorState(
            getStoreModule(store2._modules, modulePath),
            modulePath === "root" ? store2.getters : store2._makeLocalGettersCache,
            modulePath
          );
        }
      });
      api2.on.editInspectorState(function(payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          var path = payload.path;
          if (modulePath !== "root") {
            path = modulePath.split("/").filter(Boolean).concat(path);
          }
          store2._withCommit(function() {
            payload.set(store2._state.data, path, payload.state.value);
          });
        }
      });
      store2.subscribe(function(mutation, state2) {
        var data9 = {};
        if (mutation.payload) {
          data9.payload = mutation.payload;
        }
        data9.state = state2;
        api2.notifyComponentUpdate();
        api2.sendInspectorTree(INSPECTOR_ID);
        api2.sendInspectorState(INSPECTOR_ID);
        api2.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: mutation.type,
            data: data9
          }
        });
      });
      store2.subscribeAction({
        before: function(action, state2) {
          var data9 = {};
          if (action.payload) {
            data9.payload = action.payload;
          }
          action._id = actionId++;
          action._time = Date.now();
          data9.state = state2;
          api2.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: action._time,
              title: action.type,
              groupId: action._id,
              subtitle: "start",
              data: data9
            }
          });
        },
        after: function(action, state2) {
          var data9 = {};
          var duration = Date.now() - action._time;
          data9.duration = {
            _custom: {
              type: "duration",
              display: duration + "ms",
              tooltip: "Action duration",
              value: duration
            }
          };
          if (action.payload) {
            data9.payload = action.payload;
          }
          data9.state = state2;
          api2.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: action.type,
              groupId: action._id,
              subtitle: "end",
              data: data9
            }
          });
        }
      });
    }
  );
}
var COLOR_LIME_500 = 8702998;
var COLOR_DARK = 6710886;
var COLOR_WHITE = 16777215;
var TAG_NAMESPACED = {
  label: "namespaced",
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};
function extractNameFromPath(path) {
  return path && path !== "root" ? path.split("/").slice(-2, -1)[0] : "Root";
}
function formatStoreForInspectorTree(module2, path) {
  return {
    id: path || "root",
    label: extractNameFromPath(path),
    tags: module2.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module2._children).map(
      function(moduleName) {
        return formatStoreForInspectorTree(
          module2._children[moduleName],
          path + moduleName + "/"
        );
      }
    )
  };
}
function flattenStoreForInspectorTree(result, module2, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || "root",
      label: path.endsWith("/") ? path.slice(0, path.length - 1) : path || "Root",
      tags: module2.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module2._children).forEach(function(moduleName) {
    flattenStoreForInspectorTree(result, module2._children[moduleName], filter, path + moduleName + "/");
  });
}
function formatStoreForInspectorState(module2, getters, path) {
  getters = path === "root" ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module2.state).map(function(key) {
      return {
        key,
        editable: true,
        value: module2.state[key]
      };
    })
  };
  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function(key) {
      return {
        key: key.endsWith("/") ? extractNameFromPath(key) : key,
        editable: false,
        value: canThrow(function() {
          return tree[key];
        })
      };
    });
  }
  return storeState;
}
function transformPathsToObjectTree(getters) {
  var result = {};
  Object.keys(getters).forEach(function(key) {
    var path = key.split("/");
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function(p2) {
        if (!target[p2]) {
          target[p2] = {
            _custom: {
              value: {},
              display: p2,
              tooltip: "Module",
              abstract: true
            }
          };
        }
        target = target[p2]._custom.value;
      });
      target[leafKey] = canThrow(function() {
        return getters[key];
      });
    } else {
      result[key] = canThrow(function() {
        return getters[key];
      });
    }
  });
  return result;
}
function getStoreModule(moduleMap, path) {
  var names = path.split("/").filter(function(n2) {
    return n2;
  });
  return names.reduce(
    function(module2, moduleName, i2) {
      var child = module2[moduleName];
      if (!child) {
        throw new Error('Missing module "' + moduleName + '" for path "' + path + '".');
      }
      return i2 === names.length - 1 ? child : child._children;
    },
    path === "root" ? moduleMap : moduleMap.root._children
  );
}
function canThrow(cb) {
  try {
    return cb();
  } catch (e2) {
    return e2;
  }
}
var Module = function Module2(rawModule, runtime) {
  this.runtime = runtime;
  this._children = /* @__PURE__ */ Object.create(null);
  this._rawModule = rawModule;
  var rawState = rawModule.state;
  this.state = (typeof rawState === "function" ? rawState() : rawState) || {};
};
var prototypeAccessors$1 = { namespaced: { configurable: true } };
prototypeAccessors$1.namespaced.get = function() {
  return !!this._rawModule.namespaced;
};
Module.prototype.addChild = function addChild(key, module2) {
  this._children[key] = module2;
};
Module.prototype.removeChild = function removeChild(key) {
  delete this._children[key];
};
Module.prototype.getChild = function getChild(key) {
  return this._children[key];
};
Module.prototype.hasChild = function hasChild(key) {
  return key in this._children;
};
Module.prototype.update = function update3(rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};
Module.prototype.forEachChild = function forEachChild(fn3) {
  forEachValue(this._children, fn3);
};
Module.prototype.forEachGetter = function forEachGetter(fn3) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn3);
  }
};
Module.prototype.forEachAction = function forEachAction(fn3) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn3);
  }
};
Module.prototype.forEachMutation = function forEachMutation(fn3) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn3);
  }
};
Object.defineProperties(Module.prototype, prototypeAccessors$1);
var ModuleCollection = function ModuleCollection2(rawRootModule) {
  this.register([], rawRootModule, false);
};
ModuleCollection.prototype.get = function get2(path) {
  return path.reduce(function(module2, key) {
    return module2.getChild(key);
  }, this.root);
};
ModuleCollection.prototype.getNamespace = function getNamespace(path) {
  var module2 = this.root;
  return path.reduce(function(namespace, key) {
    module2 = module2.getChild(key);
    return namespace + (module2.namespaced ? key + "/" : "");
  }, "");
};
ModuleCollection.prototype.update = function update$1(rawRootModule) {
  update4([], this.root, rawRootModule);
};
ModuleCollection.prototype.register = function register(path, rawModule, runtime) {
  var this$1$1 = this;
  if (runtime === void 0)
    runtime = true;
  {
    assertRawModule(path, rawModule);
  }
  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent2 = this.get(path.slice(0, -1));
    parent2.addChild(path[path.length - 1], newModule);
  }
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function(rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};
ModuleCollection.prototype.unregister = function unregister(path) {
  var parent2 = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent2.getChild(key);
  if (!child) {
    {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is not registered"
      );
    }
    return;
  }
  if (!child.runtime) {
    return;
  }
  parent2.removeChild(key);
};
ModuleCollection.prototype.isRegistered = function isRegistered(path) {
  var parent2 = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  if (parent2) {
    return parent2.hasChild(key);
  }
  return false;
};
function update4(path, targetModule, newModule) {
  {
    assertRawModule(path, newModule);
  }
  targetModule.update(newModule);
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, manual reload is needed"
          );
        }
        return;
      }
      update4(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}
var functionAssert = {
  assert: function(value2) {
    return typeof value2 === "function";
  },
  expected: "function"
};
var objectAssert = {
  assert: function(value2) {
    return typeof value2 === "function" || typeof value2 === "object" && typeof value2.handler === "function";
  },
  expected: 'function or object with "handler" function'
};
var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};
function assertRawModule(path, rawModule) {
  Object.keys(assertTypes).forEach(function(key) {
    if (!rawModule[key]) {
      return;
    }
    var assertOptions2 = assertTypes[key];
    forEachValue(rawModule[key], function(value2, type) {
      assert(
        assertOptions2.assert(value2),
        makeAssertionMessage(path, key, type, value2, assertOptions2.expected)
      );
    });
  });
}
function makeAssertionMessage(path, key, type, value2, expected) {
  var buf = key + " should be " + expected + ' but "' + key + "." + type + '"';
  if (path.length > 0) {
    buf += ' in module "' + path.join(".") + '"';
  }
  buf += " is " + JSON.stringify(value2) + ".";
  return buf;
}
function createStore(options) {
  return new Store(options);
}
var Store = function Store2(options) {
  var this$1$1 = this;
  if (options === void 0)
    options = {};
  {
    assert(typeof Promise !== "undefined", "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store2, "store must be called with the new operator.");
  }
  var plugins2 = options.plugins;
  if (plugins2 === void 0)
    plugins2 = [];
  var strict = options.strict;
  if (strict === void 0)
    strict = false;
  var devtools = options.devtools;
  this._committing = false;
  this._actions = /* @__PURE__ */ Object.create(null);
  this._actionSubscribers = [];
  this._mutations = /* @__PURE__ */ Object.create(null);
  this._wrappedGetters = /* @__PURE__ */ Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = /* @__PURE__ */ Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = /* @__PURE__ */ Object.create(null);
  this._devtools = devtools;
  var store2 = this;
  var ref2 = this;
  var dispatch2 = ref2.dispatch;
  var commit2 = ref2.commit;
  this.dispatch = function boundDispatch(type, payload) {
    return dispatch2.call(store2, type, payload);
  };
  this.commit = function boundCommit(type, payload, options2) {
    return commit2.call(store2, type, payload, options2);
  };
  this.strict = strict;
  var state2 = this._modules.root.state;
  installModule(this, state2, [], this._modules.root);
  resetStoreState(this, state2);
  plugins2.forEach(function(plugin) {
    return plugin(this$1$1);
  });
};
var prototypeAccessors = { state: { configurable: true } };
Store.prototype.install = function install(app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;
  var useDevtools = this._devtools !== void 0 ? this._devtools : true;
  if (useDevtools) {
    addDevtools(app, this);
  }
};
prototypeAccessors.state.get = function() {
  return this._state.data;
};
prototypeAccessors.state.set = function(v2) {
  {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};
Store.prototype.commit = function commit(_type, _payload, _options) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload, _options);
  var type = ref2.type;
  var payload = ref2.payload;
  var options = ref2.options;
  var mutation = { type, payload };
  var entry = this._mutations[type];
  if (!entry) {
    {
      console.error("[vuex] unknown mutation type: " + type);
    }
    return;
  }
  this._withCommit(function() {
    entry.forEach(function commitIterator(handler2) {
      handler2(payload);
    });
  });
  this._subscribers.slice().forEach(function(sub) {
    return sub(mutation, this$1$1.state);
  });
  if (options && options.silent) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. Use the filter functionality in the vue-devtools"
    );
  }
};
Store.prototype.dispatch = function dispatch(_type, _payload) {
  var this$1$1 = this;
  var ref2 = unifyObjectStyle(_type, _payload);
  var type = ref2.type;
  var payload = ref2.payload;
  var action = { type, payload };
  var entry = this._actions[type];
  if (!entry) {
    {
      console.error("[vuex] unknown action type: " + type);
    }
    return;
  }
  try {
    this._actionSubscribers.slice().filter(function(sub) {
      return sub.before;
    }).forEach(function(sub) {
      return sub.before(action, this$1$1.state);
    });
  } catch (e2) {
    {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e2);
    }
  }
  var result = entry.length > 1 ? Promise.all(entry.map(function(handler2) {
    return handler2(payload);
  })) : entry[0](payload);
  return new Promise(function(resolve, reject) {
    result.then(function(res) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.after;
        }).forEach(function(sub) {
          return sub.after(action, this$1$1.state);
        });
      } catch (e2) {
        {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e2);
        }
      }
      resolve(res);
    }, function(error) {
      try {
        this$1$1._actionSubscribers.filter(function(sub) {
          return sub.error;
        }).forEach(function(sub) {
          return sub.error(action, this$1$1.state, error);
        });
      } catch (e2) {
        {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e2);
        }
      }
      reject(error);
    });
  });
};
Store.prototype.subscribe = function subscribe(fn3, options) {
  return genericSubscribe(fn3, this._subscribers, options);
};
Store.prototype.subscribeAction = function subscribeAction(fn3, options) {
  var subs = typeof fn3 === "function" ? { before: fn3 } : fn3;
  return genericSubscribe(subs, this._actionSubscribers, options);
};
Store.prototype.watch = function watch$1(getter, cb, options) {
  var this$1$1 = this;
  {
    assert(typeof getter === "function", "store.watch only accepts a function.");
  }
  return watch(function() {
    return getter(this$1$1.state, this$1$1.getters);
  }, cb, Object.assign({}, options));
};
Store.prototype.replaceState = function replaceState(state2) {
  var this$1$1 = this;
  this._withCommit(function() {
    this$1$1._state.data = state2;
  });
};
Store.prototype.registerModule = function registerModule(path, rawModule, options) {
  if (options === void 0)
    options = {};
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, "cannot register the root module by using registerModule.");
  }
  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  resetStoreState(this, this.state);
};
Store.prototype.unregisterModule = function unregisterModule(path) {
  var this$1$1 = this;
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  this._modules.unregister(path);
  this._withCommit(function() {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};
Store.prototype.hasModule = function hasModule(path) {
  if (typeof path === "string") {
    path = [path];
  }
  {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }
  return this._modules.isRegistered(path);
};
Store.prototype.hotUpdate = function hotUpdate(newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};
Store.prototype._withCommit = function _withCommit(fn3) {
  var committing = this._committing;
  this._committing = true;
  fn3();
  this._committing = committing;
};
Object.defineProperties(Store.prototype, prototypeAccessors);
function createLogger(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var collapsed = ref2.collapsed;
  if (collapsed === void 0)
    collapsed = true;
  var filter = ref2.filter;
  if (filter === void 0)
    filter = function(mutation, stateBefore, stateAfter) {
      return true;
    };
  var transformer = ref2.transformer;
  if (transformer === void 0)
    transformer = function(state2) {
      return state2;
    };
  var mutationTransformer = ref2.mutationTransformer;
  if (mutationTransformer === void 0)
    mutationTransformer = function(mut) {
      return mut;
    };
  var actionFilter = ref2.actionFilter;
  if (actionFilter === void 0)
    actionFilter = function(action, state2) {
      return true;
    };
  var actionTransformer = ref2.actionTransformer;
  if (actionTransformer === void 0)
    actionTransformer = function(act) {
      return act;
    };
  var logMutations = ref2.logMutations;
  if (logMutations === void 0)
    logMutations = true;
  var logActions = ref2.logActions;
  if (logActions === void 0)
    logActions = true;
  var logger2 = ref2.logger;
  if (logger2 === void 0)
    logger2 = console;
  return function(store2) {
    var prevState = deepCopy(store2.state);
    if (typeof logger2 === "undefined") {
      return;
    }
    if (logMutations) {
      store2.subscribe(function(mutation, state2) {
        var nextState = deepCopy(state2);
        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + mutation.type + formattedTime;
          startMessage(logger2, message, collapsed);
          logger2.log("%c prev state", "color: #9E9E9E; font-weight: bold", transformer(prevState));
          logger2.log("%c mutation", "color: #03A9F4; font-weight: bold", formattedMutation);
          logger2.log("%c next state", "color: #4CAF50; font-weight: bold", transformer(nextState));
          endMessage(logger2);
        }
        prevState = nextState;
      });
    }
    if (logActions) {
      store2.subscribeAction(function(action, state2) {
        if (actionFilter(action, state2)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + action.type + formattedTime;
          startMessage(logger2, message, collapsed);
          logger2.log("%c action", "color: #03A9F4; font-weight: bold", formattedAction);
          endMessage(logger2);
        }
      });
    }
  };
}
function startMessage(logger2, message, collapsed) {
  var startMessage2 = collapsed ? logger2.groupCollapsed : logger2.group;
  try {
    startMessage2.call(logger2, message);
  } catch (e2) {
    logger2.log(message);
  }
}
function endMessage(logger2) {
  try {
    logger2.groupEnd();
  } catch (e2) {
    logger2.log("\u2014\u2014 log end \u2014\u2014");
  }
}
function getFormattedTime() {
  var time = new Date();
  return " @ " + pad(time.getHours(), 2) + ":" + pad(time.getMinutes(), 2) + ":" + pad(time.getSeconds(), 2) + "." + pad(time.getMilliseconds(), 3);
}
function repeat(str, times) {
  return new Array(times + 1).join(str);
}
function pad(num, maxLength) {
  return repeat("0", maxLength - num.toString().length) + num;
}
const logger = createLogger({
  collapsed: false,
  filter(mutation, stateBefore, stateAfter) {
    return mutation.type !== "aBlocklistedMutation";
  },
  actionFilter(action, state2) {
    return action.type !== "aBlocklistedAction";
  },
  transformer(state2) {
    return state2;
  },
  mutationTransformer(mutation) {
    return mutation.type;
  },
  actionTransformer(action) {
    return action.type;
  },
  logActions: true,
  logMutations: true,
  logger: console
});
const debug = true;
const store = createStore({
  modules: {},
  strict: debug,
  plugins: [logger],
  state: {
    user: null,
    rules: [],
    accessToken: null,
    trackerId: null,
    kanbanId: null,
    swimlaneField: null,
    titleField: null,
    descriptionField: null,
    xaxisField: null,
    yaxisField: null,
    boards: {
      byId: {
        1: { id: 1, title: "Agile Board", rows: [1, 2, 3], imageUrl: null }
      },
      allIds: [1]
    },
    rows: {
      byId: {
        1: { id: 1, title: "UX", cells: [1, 2, 3, 4] },
        2: { id: 2, title: "Google Code-in Tasks", cells: [5, 6, 7, 8] },
        3: { id: 3, title: "Design", cells: [9, 10, 11, 12] }
      },
      allIds: [1, 2, 3]
    },
    cols: {
      byId: {
        1: { id: 1, title: "To Do", wip: 15 },
        2: { id: 2, title: "In progress", wip: 10 },
        3: { id: 3, title: "Test", wip: 100 },
        4: { id: 4, title: "Done", wip: 100 }
      },
      allIds: [1, 2, 3, 4]
    },
    cells: {
      byId: {
        1: { id: 1, title: "To do", cards: [] },
        2: { id: 2, title: "In progress", cards: [] },
        3: { id: 3, title: "Done", cards: [] },
        4: { id: 4, title: "To do", cards: [] },
        5: { id: 5, title: "In progress", cards: [] },
        6: { id: 6, title: "Done", cards: [] }
      },
      allIds: [1, 2, 3, 4, 5, 6]
    },
    cards: {
      byId: {
        1: { id: 1, column: 1, row: 1, sortOrder: 1, title: "Make start button", description: "Some card description" },
        2: { id: 2, column: 1, row: 1, sortOrder: 3, title: "Create time tracking", description: "Some card description" },
        3: { id: 3, column: 1, row: 1, sortOrder: 2, title: "Rich text formatting", description: "Some card description" },
        4: { id: 4, column: 1, row: 2, sortOrder: 3, title: "Add feature to Maps application", description: "Some card description" },
        5: { id: 5, column: 1, row: 2, sortOrder: 1, title: "Create a new activity for Sugarizer", description: "Some card description" },
        6: {
          id: 6,
          column: 1,
          row: 2,
          sortOrder: 2,
          title: "Agora-web Display election detail during voting",
          description: "Some card description"
        }
      },
      allIds: [1, 2, 3, 4, 5, 6]
    }
  },
  getters: {
    getUser(state2) {
      return state2.user;
    },
    getRules(state2) {
      return state2.rules;
    },
    getAccessToken(state2) {
      return state2.accessToken;
    },
    getTrackerId(state2) {
      return state2.trackerId;
    },
    getSwimlaneField(state2) {
      return state2.swimlaneField;
    },
    getTitleField(state2) {
      return state2.titleField;
    },
    getDescriptionField(state2) {
      return state2.descriptionField;
    },
    getXaxisField(state2) {
      return state2.xaxisField;
    },
    getYaxisField(state2) {
      return state2.yaxisField;
    },
    getCardsByCol(state2) {
      return (colIndex) => state2.rows.allIds.map((rowId) => state2.rows.byId[rowId].cells[colIndex]).map((cellId) => state2.cells.byId[cellId].cards).flat(1).map((cardId) => state2.cards.byId[cardId]);
    },
    getAllBoards(state2) {
      return state2.boards.allIds.map((id) => state2.boards.byId[id]);
    },
    getBoard(state2) {
      return (id) => state2.boards.byId[id];
    },
    getAllRows(state2) {
      return state2.rows.allIds.map((id) => state2.rows.byId[id]);
    },
    getRows(state2) {
      return (ids) => ids.map((id) => state2.rows.byId[id]);
    },
    getCols(state2) {
      return state2.cols.allIds.map((id) => state2.cols.byId[id]);
    },
    getColColor(state2) {
      return (id) => state2.cols.byId[id].color;
    },
    getCells(state2) {
      return (ids) => ids.map((id) => state2.cells.byId[id]);
    },
    getCell(state2) {
      return (id) => state2.cells.byId[id];
    },
    getCards(state2) {
      return (ids) => ids.map((id) => state2.cards.byId[id]);
    },
    getCard(state2) {
      return (id) => state2.cards.byId[id];
    }
  },
  actions: {
    initBoard({ commit: commit2 }, data9) {
      commit2("setBoard", data9);
    },
    setUser({ commit: commit2 }, data9) {
      commit2("setUser", data9);
    },
    addRules({ commit: commit2 }, data9) {
      commit2("addRules", data9);
    },
    addBoard({ commit: commit2 }, added) {
      commit2("addBoard", added);
    },
    addRow({ commit: commit2 }, added) {
      commit2("addRow", added);
    },
    moveRowBack({ commit: commit2 }, moved2) {
      commit2("moveRowBack", moved2);
    },
    moveRowForth({ commit: commit2 }, moved2) {
      commit2("moveRowForth", moved2);
    },
    moveColumn({ commit: commit2 }, moved2) {
      commit2("moveColumn", moved2);
    },
    addCell({ commit: commit2 }, added) {
      commit2("addCell", added);
    },
    addNewColumn({ commit: commit2 }, data9) {
      commit2("addNewColumn", data9);
    },
    removeCell({ commit: commit2 }, removed) {
      commit2("removeCell", removed);
    },
    moveCard({ commit: commit2 }, moved2) {
      commit2("moveCard", moved2);
    },
    addCard({ commit: commit2 }, added) {
      commit2("addCard", added);
    },
    addNewCard({ commit: commit2 }, data9) {
      commit2("addNewCard", data9);
    },
    removeCard({ commit: commit2 }, removed) {
      commit2("removeCard", removed);
    },
    editBoardField({ commit: commit2 }, { id, field, data: data9 }) {
      commit2("editBoardField", { id, field, data: data9 });
    },
    editRowField({ commit: commit2 }, { id, field, data: data9 }) {
      commit2("editRowField", { id, field, data: data9 });
    },
    editColumnField({ commit: commit2 }, { id, field, data: data9 }) {
      commit2("editColumnField", { id, field, data: data9 });
    },
    editCardField({ commit: commit2 }, { id, field, data: data9 }) {
      commit2("editCardField", { id, field, data: data9 });
    }
  },
  mutations: {
    setUser(state2, data9) {
      state2.user = data9;
    },
    setBoard(state2, data9) {
      let { boards, rows, cols, cells, cards } = makeKanbanData(data9);
      state2.boards = boards;
      state2.rows = rows;
      state2.cols = cols;
      state2.cells = cells;
      state2.cards = cards;
      state2.accessToken = data9.accessToken;
      state2.trackerId = data9.trackerId;
      state2.kanbanId = data9.kanbanId;
      state2.swimlaneField = data9.swimlaneField;
      state2.titleField = data9.titleField;
      state2.descriptionField = data9.descriptionField;
      state2.xaxisField = data9.xaxisField;
      state2.yaxisField = data9.yaxisField;
      state2.rules = data9.CASLAbilityRules;
    },
    addRules(state2, data9) {
      state2.rules = state2.rules.concat(data9);
    },
    addBoard(state2, data9) {
      let newId = makeId(state2.boards.allIds);
      let newRowId = makeId(state2.rows.allIds);
      state2.boards.allIds.push(newId);
      state2.boards.byId[newId] = { id: newId, title: data9.title, rows: [newRowId] };
      state2.rows.allIds.push(newRowId);
      state2.rows.byId[newRowId] = { id: newRowId, title: "New swimlane", cells: [] };
    },
    addRow(state2, data9) {
      let newRowId = makeId(state2.rows.allIds);
      state2.rows.allIds.push(newRowId);
      state2.rows.byId[newRowId] = { id: newRowId, title: data9.title, cells: [] };
      state2.cols.allIds.forEach((id) => {
        let newId = makeId(state2.cells.allIds);
        state2.cells.allIds.push(newId);
        state2.cells.byId[newId] = { id: newId, title: "New col", cards: [], limit: 50 };
        state2.rows.byId[newRowId].cells.push(newId);
      });
    },
    moveRowBack(state2, data9) {
      arrayMove(state2.boards.byId[data9.boardId].rows, data9.oldIndex, data9.oldIndex - 1);
    },
    moveRowForth(state2, data9) {
      arrayMove(state2.boards.byId[data9.boardId].rows, data9.oldIndex, data9.oldIndex + 1);
    },
    moveColumn(state2, data9) {
      state2.rows.allIds.forEach((rowId) => {
        arrayMove(state2.rows.byId[rowId].cells, data9.oldIndex, data9.newIndex);
      });
      arrayMove(state2.cols.allIds, data9.oldIndex, data9.newIndex);
    },
    addCell(state2, data9) {
      state2.rows.byId[data9.rowId].cells.splice(data9.newIndex, 0, data9.element.id);
    },
    addNewColumn(state2, data9) {
      state2.rows.allIds.forEach((rowId) => {
        let newId = makeId(state2.cells.allIds);
        state2.cells.allIds.push(newId);
        state2.cells.byId[newId] = { id: newId, title: data9.title, cards: [] };
        state2.rows.byId[rowId].cells.push(newId);
      });
      let newColId = makeId(state2.cols.allIds);
      state2.cols.byId[newColId] = { id: newColId, title: data9.title };
      state2.cols.allIds.push(newColId);
    },
    removeCell(state2, data9) {
      state2.rows.byId[data9.rowId].cells.splice(data9.oldIndex, 1);
    },
    moveCard(state2, data9) {
      arrayMove(state2.cells.byId[data9.cellId].cards, data9.oldIndex, data9.newIndex);
      setSortOrder(state2, data9);
    },
    addCard(state2, data9) {
      state2.cells.byId[data9.cellId].cards.splice(data9.newIndex, 0, data9.element.id);
      setSortOrder(state2, data9);
    },
    addNewCard(state2, data9) {
      state2.cards.allIds.push(data9.id);
      state2.cards.byId[data9.id] = { id: data9.id, title: data9.title, sortOrder: data9.sortOrder, row: data9.row, column: data9.column };
      state2.cells.byId[data9.cellId].cards.push(data9.id);
    },
    removeCard(state2, data9) {
      state2.cells.byId[data9.cellId].cards.splice(data9.oldIndex, 1);
    },
    editBoardField(state2, { id, field, data: data9 }) {
      state2.boards.byId[id][field] = data9;
    },
    editRowField(state2, { id, field, data: data9 }) {
      state2.rows.byId[id][field] = data9;
    },
    editColumnField(state2, { id, field, data: data9 }) {
      state2.cols.byId[id][field] = data9;
    },
    editCardField(state2, { id, field, data: data9 }) {
      state2.cards.byId[id][field] = data9;
    }
  }
});
function makeKanbanData(data9) {
  let boardsById = {};
  let boardsAllIds = [data9.trackerId];
  boardsById[data9.trackerId] = {
    id: data9.trackerId,
    title: `Board ${data9.trackerId}`,
    imageUrl: null,
    rows: []
  };
  if (!data9.rows || data9.rows.length === 0)
    data9.rows = [{ id: 0 }];
  let rowsById = data9.rows;
  let rowsAllIds = Object.keys(data9.rows);
  boardsById[data9.trackerId].rows = rowsAllIds;
  let colsById = data9.columns;
  let colsAllIds = Object.keys(data9.columns);
  for (const columnId in data9.columns) {
    colsById[columnId].color = "#f3f4fa";
  }
  let cellsById = {};
  let cellsAllIds = [];
  let cellId = 1;
  let rowCells = [];
  rowsAllIds.forEach((rowId) => {
    const row = rowsById[rowId];
    Object.values(colsById).forEach((col) => {
      let cardsIds = data9.cards.filter((card) => {
        if (row.id === 0)
          return card.column == col.value;
        return card.row == row.value && card.column == col.value;
      }).sort((a3, b2) => parseFloat(a3.sortOrder) - parseFloat(b2.sortOrder)).map((card) => card.id);
      cellsById[cellId] = { id: cellId, cards: cardsIds };
      cellsAllIds.push(cellId);
      rowCells.push(cellId);
      cellId++;
    });
    rowsById[rowId].cells = rowCells;
    rowCells = [];
  });
  let cardsById = {};
  let cardsAllIds = data9.cards.map((card) => card.id);
  data9.cards.map((card) => {
    card.sortOrder = parseFloat(card.sortOrder);
    return card;
  }).sort((a3, b2) => a3.id - b2.id).forEach((card) => {
    cardsById[card.id] = card;
  });
  return {
    boards: {
      byId: boardsById,
      allIds: boardsAllIds
    },
    rows: {
      byId: rowsById,
      allIds: rowsAllIds
    },
    cols: {
      byId: colsById,
      allIds: colsAllIds
    },
    cells: {
      byId: cellsById,
      allIds: cellsAllIds
    },
    cards: {
      byId: cardsById,
      allIds: cardsAllIds
    }
  };
}
function arrayMove(arr, fromIndex, toIndex) {
  let element = arr[fromIndex];
  arr.splice(fromIndex, 1);
  arr.splice(toIndex, 0, element);
}
function makeId(ids) {
  return ids.length ? Math.max(...ids) + 1 : 1;
}
function setSortOrder(state2, data9) {
  let sortOrder = 1;
  let cardIds = state2.cells.byId[data9.cellId].cards;
  let prevId = cardIds[data9.newIndex - 1];
  let nextId = cardIds[data9.newIndex + 1];
  let sum = [state2.cards.byId[prevId], state2.cards.byId[nextId]].filter((el) => el).map((el) => el.sortOrder).reduce((prev, curr) => prev + curr, 0);
  if (sum > 0 && nextId) {
    sortOrder = sum / 2;
  } else if (sum >= 1) {
    sortOrder = sum + 1;
  }
  state2.cards.byId[data9.element.id].sortOrder = sortOrder;
}
const KanbanRow_vue_vue_type_style_index_0_scoped_9a2cc3a4_lang = "";
const _export_sfc$1 = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$j = { class: "kanban-row" };
const _hoisted_2$i = {
  key: 0,
  class: "pl-3"
};
const __default__$b = {
  name: "KanbanRow"
};
const _sfc_main$n = /* @__PURE__ */ Object.assign(__default__$b, {
  props: {
    title: {
      type: String,
      default: ""
    },
    transparentTitleBg: {
      type: Boolean,
      default: false
    },
    boardId: {
      type: Number
    },
    rowId: {
      type: Number
    },
    rowValue: [String, Number],
    index: {
      type: Number
    }
  },
  setup(__props) {
    const props2 = __props;
    const showEditField = ref(false);
    const toast = useToast();
    const handleTitleChange = (event) => {
      showEditField.value = false;
      if (event.target.value.length < 1) {
        toast.error(`This field must be at least 1 character`);
        return;
      }
      store.dispatch("editRowField", {
        id: props2.rowId,
        field: "title",
        data: event.target.value
      });
    };
    return (_ctx, _cache) => {
      const _directive_focus = resolveDirective("focus");
      return openBlock(), createElementBlock("div", _hoisted_1$j, [
        createElementVNode("div", {
          class: normalizeClass(["kanban-row-title", { "bg-color-transparent": __props.transparentTitleBg }])
        }, [
          !showEditField.value ? (openBlock(), createElementBlock("span", _hoisted_2$i, toDisplayString(__props.title), 1)) : createCommentVNode("v-if", true),
          showEditField.value ? (openBlock(), createBlock(unref(Form), { key: 1 }, {
            default: withCtx(() => [
              withDirectives(createVNode(unref(Field), {
                value: __props.title,
                onBlur: handleTitleChange,
                name: "rowTitle",
                type: "text",
                rules: { minLength: 1 }
              }, null, 8, ["value"]), [
                [_directive_focus]
              ])
            ]),
            _: 1
          })) : createCommentVNode("v-if", true),
          createCommentVNode("v-if", true)
        ], 2),
        createElementVNode("div", null, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]);
    };
  }
});
const KanbanRow = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__scopeId", "data-v-9a2cc3a4"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/KanbanRow.vue"]]);
const KanbanCard_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$i = { class: "kanban-card-body" };
const _hoisted_2$h = { class: "kanban-card-menu" };
const _hoisted_3$c = { class: "kanban-card-title" };
const _hoisted_4$a = { class: "kanban-card-text" };
const __default__$a = {
  name: "KanbanCard"
};
const _sfc_main$m = /* @__PURE__ */ Object.assign(__default__$a, {
  setup(__props) {
    const isHovered = ref(false);
    const handleMouseEnter = (event) => {
      isHovered.value = true;
    };
    const handleMouseLeave = (event) => {
      isHovered.value = false;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "kanban-card",
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }, [
        createElementVNode("div", _hoisted_1$i, [
          renderSlot(_ctx.$slots, "default"),
          createVNode(Transition, {
            name: "slide-fade",
            persisted: ""
          }, {
            default: withCtx(() => [
              withDirectives(createElementVNode("div", _hoisted_2$h, [
                renderSlot(_ctx.$slots, "menu")
              ], 512), [
                [vShow, isHovered.value]
              ])
            ]),
            _: 3
          }),
          createElementVNode("div", _hoisted_3$c, [
            renderSlot(_ctx.$slots, "title")
          ]),
          createElementVNode("div", _hoisted_4$a, [
            renderSlot(_ctx.$slots, "text")
          ])
        ])
      ], 32);
    };
  }
});
const KanbanCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/KanbanCard.vue"]]);
const FormAddColumn_vue_vue_type_style_index_0_scoped_bc7c1907_lang = "";
const ButtonAddColumn_vue_vue_type_style_index_0_scoped_ecbfa224_lang = "";
const __default__$9 = {
  name: "ButtonAddColumn"
};
const _sfc_main$l = /* @__PURE__ */ Object.assign(__default__$9, {
  props: {
    rowId: {
      type: Number
    }
  },
  setup(__props) {
    ref(false);
    return (_ctx, _cache) => {
      return createCommentVNode("v-if", true);
    };
  }
});
const ButtonAddColumn = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__scopeId", "data-v-ecbfa224"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/Buttons/ButtonAddColumn.vue"]]);
var e$3, t$4, n$3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : (e$3 = [], t$4 = [], { has: function(t13) {
  return e$3.indexOf(t13) > -1;
}, get: function(n2) {
  return t$4[e$3.indexOf(n2)];
}, set: function(n2, o2) {
  -1 === e$3.indexOf(n2) && (e$3.push(n2), t$4.push(o2));
}, delete: function(n2) {
  var o2 = e$3.indexOf(n2);
  o2 > -1 && (e$3.splice(o2, 1), t$4.splice(o2, 1));
} }), o$4 = function(e2) {
  return new Event(e2, { bubbles: true });
};
try {
  new Event("test");
} catch (e2) {
  o$4 = function(e3) {
    var t13 = document.createEvent("Event");
    return t13.initEvent(e3, true, false), t13;
  };
}
function r$3(e2) {
  var t13 = n$3.get(e2);
  t13 && t13.destroy();
}
function i$4(e2) {
  var t13 = n$3.get(e2);
  t13 && t13.update();
}
var l$5 = null;
"undefined" == typeof window || "function" != typeof window.getComputedStyle ? ((l$5 = function(e2) {
  return e2;
}).destroy = function(e2) {
  return e2;
}, l$5.update = function(e2) {
  return e2;
}) : ((l$5 = function(e2, t13) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], function(e3) {
    return function(e4) {
      if (e4 && e4.nodeName && "TEXTAREA" === e4.nodeName && !n$3.has(e4)) {
        var t14, r2 = null, i2 = null, l2 = null, d3 = function() {
          e4.clientWidth !== i2 && c2();
        }, a3 = function(t15) {
          window.removeEventListener("resize", d3, false), e4.removeEventListener("input", c2, false), e4.removeEventListener("keyup", c2, false), e4.removeEventListener("autosize:destroy", a3, false), e4.removeEventListener("autosize:update", c2, false), Object.keys(t15).forEach(function(n2) {
            e4.style[n2] = t15[n2];
          }), n$3.delete(e4);
        }.bind(e4, { height: e4.style.height, resize: e4.style.resize, overflowY: e4.style.overflowY, overflowX: e4.style.overflowX, wordWrap: e4.style.wordWrap });
        e4.addEventListener("autosize:destroy", a3, false), "onpropertychange" in e4 && "oninput" in e4 && e4.addEventListener("keyup", c2, false), window.addEventListener("resize", d3, false), e4.addEventListener("input", c2, false), e4.addEventListener("autosize:update", c2, false), e4.style.overflowX = "hidden", e4.style.wordWrap = "break-word", n$3.set(e4, { destroy: a3, update: c2 }), "vertical" === (t14 = window.getComputedStyle(e4, null)).resize ? e4.style.resize = "none" : "both" === t14.resize && (e4.style.resize = "horizontal"), r2 = "content-box" === t14.boxSizing ? -(parseFloat(t14.paddingTop) + parseFloat(t14.paddingBottom)) : parseFloat(t14.borderTopWidth) + parseFloat(t14.borderBottomWidth), isNaN(r2) && (r2 = 0), c2();
      }
      function u2(t15) {
        var n2 = e4.style.width;
        e4.style.width = "0px", e4.style.width = n2, e4.style.overflowY = t15;
      }
      function s3() {
        if (0 !== e4.scrollHeight) {
          var t15 = function(e5) {
            for (var t16 = []; e5 && e5.parentNode && e5.parentNode instanceof Element; )
              e5.parentNode.scrollTop && t16.push({ node: e5.parentNode, scrollTop: e5.parentNode.scrollTop }), e5 = e5.parentNode;
            return t16;
          }(e4), n2 = document.documentElement && document.documentElement.scrollTop;
          e4.style.height = "", e4.style.height = e4.scrollHeight + r2 + "px", i2 = e4.clientWidth, t15.forEach(function(e5) {
            e5.node.scrollTop = e5.scrollTop;
          }), n2 && (document.documentElement.scrollTop = n2);
        }
      }
      function c2() {
        s3();
        var t15 = Math.round(parseFloat(e4.style.height)), n2 = window.getComputedStyle(e4, null), r3 = "content-box" === n2.boxSizing ? Math.round(parseFloat(n2.height)) : e4.offsetHeight;
        if (r3 < t15 ? "hidden" === n2.overflowY && (u2("scroll"), s3(), r3 = "content-box" === n2.boxSizing ? Math.round(parseFloat(window.getComputedStyle(e4, null).height)) : e4.offsetHeight) : "hidden" !== n2.overflowY && (u2("hidden"), s3(), r3 = "content-box" === n2.boxSizing ? Math.round(parseFloat(window.getComputedStyle(e4, null).height)) : e4.offsetHeight), l2 !== r3) {
          l2 = r3;
          var i3 = o$4("autosize:resized");
          try {
            e4.dispatchEvent(i3);
          } catch (e5) {
          }
        }
      }
    }(e3);
  }), e2;
}).destroy = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], r$3), e2;
}, l$5.update = function(e2) {
  return e2 && Array.prototype.forEach.call(e2.length ? e2 : [e2], i$4), e2;
});
var d$5 = l$5;
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a3 = function() {
      return f2.apply(this, arguments);
    };
    a3.prototype = f2.prototype;
  } else
    a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d3 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a3, k2, d3.get ? d3 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a3;
}
var axios$3 = { exports: {} };
var axios$2 = { exports: {} };
var bind$4 = function bind3(fn3, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    return fn3.apply(thisArg, args);
  };
};
var bind$3 = bind$4;
var toString = Object.prototype.toString;
var kindOf = function(cache) {
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
}(/* @__PURE__ */ Object.create(null));
function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}
function isArray$6(val) {
  return Array.isArray(val);
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer$3(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
function isString$2(val) {
  return typeof val === "string";
}
function isNumber$1(val) {
  return typeof val === "number";
}
function isObject$2(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject$2(val) {
  if (kindOf(val) !== "object") {
    return false;
  }
  var prototype2 = Object.getPrototypeOf(val);
  return prototype2 === null || prototype2 === Object.prototype;
}
var isDate$1 = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
function isFunction$1(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject$2(val) && isFunction$1(val.pipe);
}
function isFormData(thing) {
  var pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction$1(thing.toString) && thing.toString() === pattern);
}
var isURLSearchParams = kindOfTest("URLSearchParams");
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn3) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$6(obj)) {
    for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn3.call(null, obj[i2], i2, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn3.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge$3() {
  var result = {};
  function assignValue2(val, key) {
    if (isPlainObject$2(result[key]) && isPlainObject$2(val)) {
      result[key] = merge$3(result[key], val);
    } else if (isPlainObject$2(val)) {
      result[key] = merge$3({}, val);
    } else if (isArray$6(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    forEach(arguments[i2], assignValue2);
  }
  return result;
}
function extend$1(a3, b2, thisArg) {
  forEach(b2, function assignValue2(val, key) {
    if (thisArg && typeof val === "function") {
      a3[key] = bind$3(val, thisArg);
    } else {
      a3[key] = val;
    }
  });
  return a3;
}
function stripBOM(content3) {
  if (content3.charCodeAt(0) === 65279) {
    content3 = content3.slice(1);
  }
  return content3;
}
function inherits(constructor, superConstructor, props2, descriptors2) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  props2 && Object.assign(constructor.prototype, props2);
}
function toFlatObject(sourceObj, destObj, filter) {
  var props2;
  var i2;
  var prop;
  var merged = {};
  destObj = destObj || {};
  do {
    props2 = Object.getOwnPropertyNames(sourceObj);
    i2 = props2.length;
    while (i2-- > 0) {
      prop = props2[i2];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
}
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}
function toArray(thing) {
  if (!thing)
    return null;
  var i2 = thing.length;
  if (isUndefined(i2))
    return null;
  var arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
}
var isTypedArray$2 = function(TypedArray2) {
  return function(thing) {
    return TypedArray2 && thing instanceof TypedArray2;
  };
}(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
var utils$e = {
  isArray: isArray$6,
  isArrayBuffer,
  isBuffer: isBuffer$3,
  isFormData,
  isArrayBufferView,
  isString: isString$2,
  isNumber: isNumber$1,
  isObject: isObject$2,
  isPlainObject: isPlainObject$2,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge: merge$3,
  extend: extend$1,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  isTypedArray: isTypedArray$2,
  isFileList
};
var utils$d = utils$e;
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$d.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$d.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$d.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$d.forEach(val, function parseValue(v2) {
        if (utils$d.isDate(v2)) {
          v2 = v2.toISOString();
        } else if (utils$d.isObject(v2)) {
          v2 = JSON.stringify(v2);
        }
        parts.push(encode$1(key) + "=" + encode$1(v2));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$c = utils$e;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn3) {
  utils$c.forEach(this.handlers, function forEachHandler(h3) {
    if (h3 !== null) {
      fn3(h3);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$b = utils$e;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$b.forEach(headers, function processHeader(value2, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value2;
      delete headers[name2];
    }
  });
};
var utils$a = utils$e;
function AxiosError$2(message, code, config, request2, response) {
  Error.call(this);
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request2 && (this.request = request2);
  response && (this.response = response);
}
utils$a.inherits(AxiosError$2, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError$2.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED"
].forEach(function(code) {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$2, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError$2.from = function(error, code, config, request2, response, customProps) {
  var axiosError = Object.create(prototype);
  utils$a.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });
  AxiosError$2.call(axiosError, error.message, code, config, request2, response);
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_1 = AxiosError$2;
var transitional = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
var utils$9 = utils$e;
function toFormData$1(obj, formData) {
  formData = formData || new FormData();
  var stack = [];
  function convertValue(value2) {
    if (value2 === null)
      return "";
    if (utils$9.isDate(value2)) {
      return value2.toISOString();
    }
    if (utils$9.isArrayBuffer(value2) || utils$9.isTypedArray(value2)) {
      return typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function build(data9, parentKey) {
    if (utils$9.isPlainObject(data9) || utils$9.isArray(data9)) {
      if (stack.indexOf(data9) !== -1) {
        throw Error("Circular reference detected in " + parentKey);
      }
      stack.push(data9);
      utils$9.forEach(data9, function each(value2, key) {
        if (utils$9.isUndefined(value2))
          return;
        var fullKey = parentKey ? parentKey + "." + key : key;
        var arr;
        if (value2 && !parentKey && typeof value2 === "object") {
          if (utils$9.endsWith(key, "{}")) {
            value2 = JSON.stringify(value2);
          } else if (utils$9.endsWith(key, "[]") && (arr = utils$9.toArray(value2))) {
            arr.forEach(function(el) {
              !utils$9.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }
        build(value2, fullKey);
      });
      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data9));
    }
  }
  build(obj);
  return formData;
}
var toFormData_1 = toFormData$1;
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var AxiosError2 = AxiosError_1;
  settle = function settle2(resolve, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError2(
        "Request failed with status code " + response.status,
        [AxiosError2.ERR_BAD_REQUEST, AxiosError2.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  };
  return settle;
}
var cookies;
var hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var utils2 = utils$e;
  cookies = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    return {
      write: function write2(name2, value2, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name2 + "=" + encodeURIComponent(value2));
        if (utils2.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils2.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils2.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read2(name2) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove: function remove2(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    };
  }() : function nonStandardBrowserEnv() {
    return {
      write: function write2() {
      },
      read: function read2() {
        return null;
      },
      remove: function remove2() {
      }
    };
  }();
  return cookies;
}
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var parseHeaders;
var hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var utils2 = utils$e;
  var ignoreDuplicateOf = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  parseHeaders = function parseHeaders2(headers) {
    var parsed = {};
    var key;
    var val;
    var i2;
    if (!headers) {
      return parsed;
    }
    utils2.forEach(headers.split("\n"), function parser(line) {
      i2 = line.indexOf(":");
      key = utils2.trim(line.substr(0, i2)).toLowerCase();
      val = utils2.trim(line.substr(i2 + 1));
      if (key) {
        if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
          return;
        }
        if (key === "set-cookie") {
          parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      }
    });
    return parsed;
  };
  return parseHeaders;
}
var isURLSameOrigin;
var hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var utils2 = utils$e;
  isURLSameOrigin = utils2.isStandardBrowserEnv() ? function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement("a");
    var originURL;
    function resolveURL(url) {
      var href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      var parsed = utils2.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() : function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }();
  return isURLSameOrigin;
}
var CanceledError_1;
var hasRequiredCanceledError;
function requireCanceledError() {
  if (hasRequiredCanceledError)
    return CanceledError_1;
  hasRequiredCanceledError = 1;
  var AxiosError2 = AxiosError_1;
  var utils2 = utils$e;
  function CanceledError2(message) {
    AxiosError2.call(this, message == null ? "canceled" : message, AxiosError2.ERR_CANCELED);
    this.name = "CanceledError";
  }
  utils2.inherits(CanceledError2, AxiosError2, {
    __CANCEL__: true
  });
  CanceledError_1 = CanceledError2;
  return CanceledError_1;
}
var parseProtocol;
var hasRequiredParseProtocol;
function requireParseProtocol() {
  if (hasRequiredParseProtocol)
    return parseProtocol;
  hasRequiredParseProtocol = 1;
  parseProtocol = function parseProtocol2(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  };
  return parseProtocol;
}
var xhr;
var hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var utils2 = utils$e;
  var settle2 = requireSettle();
  var cookies2 = requireCookies();
  var buildURL3 = buildURL$1;
  var buildFullPath3 = buildFullPath$1;
  var parseHeaders2 = requireParseHeaders();
  var isURLSameOrigin2 = requireIsURLSameOrigin();
  var transitionalDefaults2 = transitional;
  var AxiosError2 = AxiosError_1;
  var CanceledError2 = requireCanceledError();
  var parseProtocol2 = requireParseProtocol();
  xhr = function xhrAdapter(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var requestData = config.data;
      var requestHeaders = config.headers;
      var responseType = config.responseType;
      var onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils2.isFormData(requestData) && utils2.isStandardBrowserEnv()) {
        delete requestHeaders["Content-Type"];
      }
      var request2 = new XMLHttpRequest();
      if (config.auth) {
        var username = config.auth.username || "";
        var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
      }
      var fullPath = buildFullPath3(config.baseURL, config.url);
      request2.open(config.method.toUpperCase(), buildURL3(fullPath, config.params, config.paramsSerializer), true);
      request2.timeout = config.timeout;
      function onloadend() {
        if (!request2) {
          return;
        }
        var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
        var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
        var response = {
          data: responseData,
          status: request2.status,
          statusText: request2.statusText,
          headers: responseHeaders,
          config,
          request: request2
        };
        settle2(function _resolve(value2) {
          resolve(value2);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request2 = null;
      }
      if ("onloadend" in request2) {
        request2.onloadend = onloadend;
      } else {
        request2.onreadystatechange = function handleLoad() {
          if (!request2 || request2.readyState !== 4) {
            return;
          }
          if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request2.onabort = function handleAbort() {
        if (!request2) {
          return;
        }
        reject(new AxiosError2("Request aborted", AxiosError2.ECONNABORTED, config, request2));
        request2 = null;
      };
      request2.onerror = function handleError() {
        reject(new AxiosError2("Network Error", AxiosError2.ERR_NETWORK, config, request2, request2));
        request2 = null;
      };
      request2.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        var transitional3 = config.transitional || transitionalDefaults2;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError2(
          timeoutErrorMessage,
          transitional3.clarifyTimeoutError ? AxiosError2.ETIMEDOUT : AxiosError2.ECONNABORTED,
          config,
          request2
        ));
        request2 = null;
      };
      if (utils2.isStandardBrowserEnv()) {
        var xsrfValue = (config.withCredentials || isURLSameOrigin2(fullPath)) && config.xsrfCookieName ? cookies2.read(config.xsrfCookieName) : void 0;
        if (xsrfValue) {
          requestHeaders[config.xsrfHeaderName] = xsrfValue;
        }
      }
      if ("setRequestHeader" in request2) {
        utils2.forEach(requestHeaders, function setRequestHeader(val, key) {
          if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
            delete requestHeaders[key];
          } else {
            request2.setRequestHeader(key, val);
          }
        });
      }
      if (!utils2.isUndefined(config.withCredentials)) {
        request2.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request2.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request2.addEventListener("progress", config.onDownloadProgress);
      }
      if (typeof config.onUploadProgress === "function" && request2.upload) {
        request2.upload.addEventListener("progress", config.onUploadProgress);
      }
      if (config.cancelToken || config.signal) {
        onCanceled = function(cancel) {
          if (!request2) {
            return;
          }
          reject(!cancel || cancel && cancel.type ? new CanceledError2() : cancel);
          request2.abort();
          request2 = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      if (!requestData) {
        requestData = null;
      }
      var protocol = parseProtocol2(fullPath);
      if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
        reject(new AxiosError2("Unsupported protocol " + protocol + ":", AxiosError2.ERR_BAD_REQUEST, config));
        return;
      }
      request2.send(requestData);
    });
  };
  return xhr;
}
var _null;
var hasRequired_null;
function require_null() {
  if (hasRequired_null)
    return _null;
  hasRequired_null = 1;
  _null = null;
  return _null;
}
var utils$8 = utils$e;
var normalizeHeaderName2 = normalizeHeaderName$1;
var AxiosError$1 = AxiosError_1;
var transitionalDefaults = transitional;
var toFormData = toFormData_1;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value2) {
  if (!utils$8.isUndefined(headers) && utils$8.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value2;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = requireXhr();
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = requireXhr();
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$8.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$8.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$6 = {
  transitional: transitionalDefaults,
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data9, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$8.isFormData(data9) || utils$8.isArrayBuffer(data9) || utils$8.isBuffer(data9) || utils$8.isStream(data9) || utils$8.isFile(data9) || utils$8.isBlob(data9)) {
      return data9;
    }
    if (utils$8.isArrayBufferView(data9)) {
      return data9.buffer;
    }
    if (utils$8.isURLSearchParams(data9)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data9.toString();
    }
    var isObjectPayload = utils$8.isObject(data9);
    var contentType = headers && headers["Content-Type"];
    var isFileList2;
    if ((isFileList2 = utils$8.isFileList(data9)) || isObjectPayload && contentType === "multipart/form-data") {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList2 ? { "files[]": data9 } : data9, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data9);
    }
    return data9;
  }],
  transformResponse: [function transformResponse(data9) {
    var transitional3 = this.transitional || defaults$6.transitional;
    var silentJSONParsing = transitional3 && transitional3.silentJSONParsing;
    var forcedJSONParsing = transitional3 && transitional3.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$8.isString(data9) && data9.length) {
      try {
        return JSON.parse(data9);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError$1.from(e2, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data9;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: require_null()
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$8.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$6.headers[method] = {};
});
utils$8.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$6.headers[method] = utils$8.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$6;
var utils$7 = utils$e;
var defaults$5 = defaults_1;
var transformData$1 = function transformData(data9, headers, fns) {
  var context = this || defaults$5;
  utils$7.forEach(fns, function transform(fn3) {
    data9 = fn3.call(context, data9, headers);
  });
  return data9;
};
var isCancel$1;
var hasRequiredIsCancel;
function requireIsCancel() {
  if (hasRequiredIsCancel)
    return isCancel$1;
  hasRequiredIsCancel = 1;
  isCancel$1 = function isCancel2(value2) {
    return !!(value2 && value2.__CANCEL__);
  };
  return isCancel$1;
}
var utils$6 = utils$e;
var transformData2 = transformData$1;
var isCancel = requireIsCancel();
var defaults$4 = defaults_1;
var CanceledError = requireCanceledError();
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}
var dispatchRequest$1 = function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = config.headers || {};
  config.data = transformData2.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );
  config.headers = utils$6.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );
  utils$6.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );
  var adapter = config.adapter || defaults$4.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData2.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$5 = utils$e;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config = {};
  function getMergedValue(target, source) {
    if (utils$5.isPlainObject(target) && utils$5.isPlainObject(source)) {
      return utils$5.merge(target, source);
    } else if (utils$5.isPlainObject(source)) {
      return utils$5.merge({}, source);
    } else if (utils$5.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function valueFromConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    }
  }
  function defaultToConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      return getMergedValue(void 0, config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(void 0, config1[prop]);
    }
  }
  var mergeMap = {
    "url": valueFromConfig2,
    "method": valueFromConfig2,
    "data": valueFromConfig2,
    "baseURL": defaultToConfig2,
    "transformRequest": defaultToConfig2,
    "transformResponse": defaultToConfig2,
    "paramsSerializer": defaultToConfig2,
    "timeout": defaultToConfig2,
    "timeoutMessage": defaultToConfig2,
    "withCredentials": defaultToConfig2,
    "adapter": defaultToConfig2,
    "responseType": defaultToConfig2,
    "xsrfCookieName": defaultToConfig2,
    "xsrfHeaderName": defaultToConfig2,
    "onUploadProgress": defaultToConfig2,
    "onDownloadProgress": defaultToConfig2,
    "decompress": defaultToConfig2,
    "maxContentLength": defaultToConfig2,
    "maxBodyLength": defaultToConfig2,
    "beforeRedirect": defaultToConfig2,
    "transport": defaultToConfig2,
    "httpAgent": defaultToConfig2,
    "httpsAgent": defaultToConfig2,
    "cancelToken": defaultToConfig2,
    "socketPath": defaultToConfig2,
    "responseEncoding": defaultToConfig2,
    "validateStatus": mergeDirectKeys
  };
  utils$5.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge3 = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge3(prop);
    utils$5.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
};
var data8;
var hasRequiredData;
function requireData() {
  if (hasRequiredData)
    return data8;
  hasRequiredData = 1;
  data8 = {
    "version": "0.27.2"
  };
  return data8;
}
var VERSION = requireData().version;
var AxiosError = AxiosError_1;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators$1.transitional = function transitional2(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value2, opt, opts2) {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts2) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys2 = Object.keys(options);
  var i2 = keys2.length;
  while (i2-- > 0) {
    var opt = keys2[i2];
    var validator2 = schema[opt];
    if (validator2) {
      var value2 = options[opt];
      var result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
var validator$1 = {
  assertOptions,
  validators: validators$1
};
var utils$4 = utils$e;
var buildURL2 = buildURL$1;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var buildFullPath2 = buildFullPath$1;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(configOrUrl, config) {
  if (typeof configOrUrl === "string") {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }
  config = mergeConfig$1(this.defaults, config);
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = "get";
  }
  var transitional3 = config.transitional;
  if (transitional3 !== void 0) {
    validator.assertOptions(transitional3, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config) {
  config = mergeConfig$1(this.defaults, config);
  var fullPath = buildFullPath2(config.baseURL, config.url);
  return buildURL2(fullPath, config.params, config.paramsSerializer);
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data9, config) {
      return this.request(mergeConfig$1(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data9
      }));
    };
  }
  Axios$1.prototype[method] = generateHTTPMethod();
  Axios$1.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_1 = Axios$1;
var CancelToken_1;
var hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var CanceledError2 = requireCanceledError();
  function CancelToken(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    var resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    var token2 = this;
    this.promise.then(function(cancel) {
      if (!token2._listeners)
        return;
      var i2;
      var l2 = token2._listeners.length;
      for (i2 = 0; i2 < l2; i2++) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = function(onfulfilled) {
      var _resolve;
      var promise = new Promise(function(resolve) {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError2(message);
      resolvePromise(token2.reason);
    });
  }
  CancelToken.prototype.throwIfRequested = function throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  };
  CancelToken.prototype.subscribe = function subscribe2(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  };
  CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    var index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  };
  CancelToken.source = function source() {
    var cancel;
    var token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  };
  CancelToken_1 = CancelToken;
  return CancelToken_1;
}
var spread;
var hasRequiredSpread;
function requireSpread() {
  if (hasRequiredSpread)
    return spread;
  hasRequiredSpread = 1;
  spread = function spread2(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  };
  return spread;
}
var isAxiosError;
var hasRequiredIsAxiosError;
function requireIsAxiosError() {
  if (hasRequiredIsAxiosError)
    return isAxiosError;
  hasRequiredIsAxiosError = 1;
  var utils2 = utils$e;
  isAxiosError = function isAxiosError2(payload) {
    return utils2.isObject(payload) && payload.isAxiosError === true;
  };
  return isAxiosError;
}
var utils$3 = utils$e;
var bind$2 = bind$4;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$3 = defaults_1;
function createInstance(defaultConfig2) {
  var context = new Axios(defaultConfig2);
  var instance = bind$2(Axios.prototype.request, context);
  utils$3.extend(instance, Axios.prototype, context);
  utils$3.extend(instance, context);
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig2(defaultConfig2, instanceConfig));
  };
  return instance;
}
var axios$1 = createInstance(defaults$3);
axios$1.Axios = Axios;
axios$1.CanceledError = requireCanceledError();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.VERSION = requireData().version;
axios$1.toFormData = toFormData_1;
axios$1.AxiosError = AxiosError_1;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
(function(module2) {
  module2.exports = axios$2.exports;
})(axios$3);
const axios = /* @__PURE__ */ getDefaultExportFromCjs(axios$3.exports);
var shams = function hasSymbols() {
  if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
    return false;
  }
  if (typeof Symbol.iterator === "symbol") {
    return true;
  }
  var obj = {};
  var sym = Symbol("test");
  var symObj = Object(sym);
  if (typeof sym === "string") {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
    return false;
  }
  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  }
  if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === "function") {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};
var origSymbol = typeof Symbol !== "undefined" && Symbol;
var hasSymbolSham = shams;
var hasSymbols$1 = function hasNativeSymbols() {
  if (typeof origSymbol !== "function") {
    return false;
  }
  if (typeof Symbol !== "function") {
    return false;
  }
  if (typeof origSymbol("foo") !== "symbol") {
    return false;
  }
  if (typeof Symbol("bar") !== "symbol") {
    return false;
  }
  return hasSymbolSham();
};
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
var slice = Array.prototype.slice;
var toStr$1 = Object.prototype.toString;
var funcType = "[object Function]";
var implementation$1 = function bind4(that) {
  var target = this;
  if (typeof target !== "function" || toStr$1.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slice.call(arguments, 1);
  var bound;
  var binder = function() {
    if (this instanceof bound) {
      var result = target.apply(
        this,
        args.concat(slice.call(arguments))
      );
      if (Object(result) === result) {
        return result;
      }
      return this;
    } else {
      return target.apply(
        that,
        args.concat(slice.call(arguments))
      );
    }
  };
  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];
  for (var i2 = 0; i2 < boundLength; i2++) {
    boundArgs.push("$" + i2);
  }
  bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
  if (target.prototype) {
    var Empty = function Empty2() {
    };
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};
var implementation = implementation$1;
var functionBind = Function.prototype.bind || implementation;
var bind$1 = functionBind;
var src = bind$1.call(Function.call, Object.prototype.hasOwnProperty);
var undefined$1;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError$1 = TypeError;
var getEvalledConstructor = function(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
  } catch (e2) {
  }
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, "");
  } catch (e2) {
    $gOPD = null;
  }
}
var throwTypeError = function() {
  throw new $TypeError$1();
};
var ThrowTypeError = $gOPD ? function() {
  try {
    arguments.callee;
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      return $gOPD(arguments, "callee").get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols2 = hasSymbols$1();
var getProto = Object.getPrototypeOf || function(x2) {
  return x2.__proto__;
};
var needsEval = {};
var TypedArray = typeof Uint8Array === "undefined" ? undefined$1 : getProto(Uint8Array);
var INTRINSICS = {
  "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols2 ? getProto([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols2 ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
  "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols2 ? getProto(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$1,
  "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
};
var doEval = function doEval2(name2) {
  var value2;
  if (name2 === "%AsyncFunction%") {
    value2 = getEvalledConstructor("async function () {}");
  } else if (name2 === "%GeneratorFunction%") {
    value2 = getEvalledConstructor("function* () {}");
  } else if (name2 === "%AsyncGeneratorFunction%") {
    value2 = getEvalledConstructor("async function* () {}");
  } else if (name2 === "%AsyncGenerator%") {
    var fn3 = doEval2("%AsyncGeneratorFunction%");
    if (fn3) {
      value2 = fn3.prototype;
    }
  } else if (name2 === "%AsyncIteratorPrototype%") {
    var gen = doEval2("%AsyncGenerator%");
    if (gen) {
      value2 = getProto(gen.prototype);
    }
  }
  INTRINSICS[name2] = value2;
  return value2;
};
var LEGACY_ALIASES = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
};
var bind5 = functionBind;
var hasOwn$1 = src;
var $concat$1 = bind5.call(Function.call, Array.prototype.concat);
var $spliceApply = bind5.call(Function.apply, Array.prototype.splice);
var $replace$1 = bind5.call(Function.call, String.prototype.replace);
var $strSlice = bind5.call(Function.call, String.prototype.slice);
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = function stringToPath2(string) {
  var first = $strSlice(string, 0, 1);
  var last2 = $strSlice(string, -1);
  if (first === "%" && last2 !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
  } else if (last2 === "%" && first !== "%") {
    throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
  }
  var result = [];
  $replace$1(string, rePropName, function(match, number, quote2, subString) {
    result[result.length] = quote2 ? $replace$1(subString, reEscapeChar, "$1") : number || match;
  });
  return result;
};
var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
  var intrinsicName = name2;
  var alias;
  if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = "%" + alias[0] + "%";
  }
  if (hasOwn$1(INTRINSICS, intrinsicName)) {
    var value2 = INTRINSICS[intrinsicName];
    if (value2 === needsEval) {
      value2 = doEval(intrinsicName);
    }
    if (typeof value2 === "undefined" && !allowMissing) {
      throw new $TypeError$1("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
    }
    return {
      alias,
      name: intrinsicName,
      value: value2
    };
  }
  throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
};
var getIntrinsic = function GetIntrinsic(name2, allowMissing) {
  if (typeof name2 !== "string" || name2.length === 0) {
    throw new $TypeError$1("intrinsic name must be a non-empty string");
  }
  if (arguments.length > 1 && typeof allowMissing !== "boolean") {
    throw new $TypeError$1('"allowMissing" argument must be a boolean');
  }
  var parts = stringToPath(name2);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
  var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value2 = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat$1([0, 1], alias));
  }
  for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
    var part = parts[i2];
    var first = $strSlice(part, 0, 1);
    var last2 = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first !== last2) {
      throw new $SyntaxError("property names with quotes must have matching quotes");
    }
    if (part === "constructor" || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += "." + part;
    intrinsicRealName = "%" + intrinsicBaseName + "%";
    if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
      value2 = INTRINSICS[intrinsicRealName];
    } else if (value2 != null) {
      if (!(part in value2)) {
        if (!allowMissing) {
          throw new $TypeError$1("base intrinsic for " + name2 + " exists, but the property is not available.");
        }
        return void 0;
      }
      if ($gOPD && i2 + 1 >= parts.length) {
        var desc = $gOPD(value2, part);
        isOwn = !!desc;
        if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
          value2 = desc.get;
        } else {
          value2 = value2[part];
        }
      } else {
        isOwn = hasOwn$1(value2, part);
        value2 = value2[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value2;
      }
    }
  }
  return value2;
};
var callBind$1 = { exports: {} };
(function(module2) {
  var bind6 = functionBind;
  var GetIntrinsic3 = getIntrinsic;
  var $apply = GetIntrinsic3("%Function.prototype.apply%");
  var $call = GetIntrinsic3("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic3("%Reflect.apply%", true) || bind6.call($call, $apply);
  var $gOPD2 = GetIntrinsic3("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic3("%Object.defineProperty%", true);
  var $max = GetIntrinsic3("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e2) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind2(originalFunction) {
    var func = $reflectApply(bind6, $call, arguments);
    if ($gOPD2 && $defineProperty) {
      var desc = $gOPD2(func, "length");
      if (desc.configurable) {
        $defineProperty(
          func,
          "length",
          { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
        );
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind6, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", { value: applyBind });
  } else {
    module2.exports.apply = applyBind;
  }
})(callBind$1);
var GetIntrinsic$1 = getIntrinsic;
var callBind = callBind$1.exports;
var $indexOf = callBind(GetIntrinsic$1("String.prototype.indexOf"));
var callBound$1 = function callBoundIntrinsic(name2, allowMissing) {
  var intrinsic = GetIntrinsic$1(name2, !!allowMissing);
  if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};
const __viteBrowserExternal = new Proxy({}, {
  get(_2, key) {
    throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${key}" in client code.`);
  }
});
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasMap = typeof Map === "function" && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === "function" && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString$1 = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
  return O2.__proto__;
} : null);
function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
    return str;
  }
  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof num === "number") {
    var int = num < 0 ? -$floor(-num) : $floor(num);
    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return $replace.call(str, sepRegex, "$&_");
}
var inspectCustom = require$$0.custom;
var inspectSymbol = inspectCustom && isSymbol(inspectCustom) ? inspectCustom : null;
var objectInspect = function inspect_(obj, options, depth, seen) {
  var opts2 = options || {};
  if (has$3(opts2, "quoteStyle") && (opts2.quoteStyle !== "single" && opts2.quoteStyle !== "double")) {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }
  if (has$3(opts2, "maxStringLength") && (typeof opts2.maxStringLength === "number" ? opts2.maxStringLength < 0 && opts2.maxStringLength !== Infinity : opts2.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }
  var customInspect = has$3(opts2, "customInspect") ? opts2.customInspect : true;
  if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  }
  if (has$3(opts2, "indent") && opts2.indent !== null && opts2.indent !== "	" && !(parseInt(opts2.indent, 10) === opts2.indent && opts2.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }
  if (has$3(opts2, "numericSeparator") && typeof opts2.numericSeparator !== "boolean") {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }
  var numericSeparator = opts2.numericSeparator;
  if (typeof obj === "undefined") {
    return "undefined";
  }
  if (obj === null) {
    return "null";
  }
  if (typeof obj === "boolean") {
    return obj ? "true" : "false";
  }
  if (typeof obj === "string") {
    return inspectString(obj, opts2);
  }
  if (typeof obj === "number") {
    if (obj === 0) {
      return Infinity / obj > 0 ? "0" : "-0";
    }
    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }
  if (typeof obj === "bigint") {
    var bigIntStr = String(obj) + "n";
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }
  var maxDepth = typeof opts2.depth === "undefined" ? 5 : opts2.depth;
  if (typeof depth === "undefined") {
    depth = 0;
  }
  if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
    return isArray$5(obj) ? "[Array]" : "[Object]";
  }
  var indent = getIndent(opts2, depth);
  if (typeof seen === "undefined") {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return "[Circular]";
  }
  function inspect2(value2, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }
    if (noIndent) {
      var newOpts = {
        depth: opts2.depth
      };
      if (has$3(opts2, "quoteStyle")) {
        newOpts.quoteStyle = opts2.quoteStyle;
      }
      return inspect_(value2, newOpts, depth + 1, seen);
    }
    return inspect_(value2, opts2, depth + 1, seen);
  }
  if (typeof obj === "function") {
    var name2 = nameOf(obj);
    var keys2 = arrObjKeys(obj, inspect2);
    return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
  }
  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
    return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
  }
  if (isElement(obj)) {
    var s3 = "<" + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];
    for (var i2 = 0; i2 < attrs.length; i2++) {
      s3 += " " + attrs[i2].name + "=" + wrapQuotes(quote(attrs[i2].value), "double", opts2);
    }
    s3 += ">";
    if (obj.childNodes && obj.childNodes.length) {
      s3 += "...";
    }
    s3 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
    return s3;
  }
  if (isArray$5(obj)) {
    if (obj.length === 0) {
      return "[]";
    }
    var xs = arrObjKeys(obj, inspect2);
    if (indent && !singleLineValues(xs)) {
      return "[" + indentedJoin(xs, indent) + "]";
    }
    return "[ " + $join.call(xs, ", ") + " ]";
  }
  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect2);
    if ("cause" in obj && !isEnumerable.call(obj, "cause")) {
      return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect2(obj.cause), parts), ", ") + " }";
    }
    if (parts.length === 0) {
      return "[" + String(obj) + "]";
    }
    return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
  }
  if (typeof obj === "object" && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === "function") {
      return obj[inspectSymbol]();
    } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
      return obj.inspect();
    }
  }
  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function(value2, key) {
      mapParts.push(inspect2(key, obj, true) + " => " + inspect2(value2, obj));
    });
    return collectionOf("Map", mapSize.call(obj), mapParts, indent);
  }
  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function(value2) {
      setParts.push(inspect2(value2, obj));
    });
    return collectionOf("Set", setSize.call(obj), setParts, indent);
  }
  if (isWeakMap(obj)) {
    return weakCollectionOf("WeakMap");
  }
  if (isWeakSet(obj)) {
    return weakCollectionOf("WeakSet");
  }
  if (isWeakRef(obj)) {
    return weakCollectionOf("WeakRef");
  }
  if (isNumber(obj)) {
    return markBoxed(inspect2(Number(obj)));
  }
  if (isBigInt(obj)) {
    return markBoxed(inspect2(bigIntValueOf.call(obj)));
  }
  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }
  if (isString$1(obj)) {
    return markBoxed(inspect2(String(obj)));
  }
  if (!isDate2(obj) && !isRegExp$1(obj)) {
    var ys = arrObjKeys(obj, inspect2);
    var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? "" : "null prototype";
    var stringTag2 = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
    var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
    var tag = constructorTag + (stringTag2 || protoTag ? "[" + $join.call($concat.call([], stringTag2 || [], protoTag || []), ": ") + "] " : "");
    if (ys.length === 0) {
      return tag + "{}";
    }
    if (indent) {
      return tag + "{" + indentedJoin(ys, indent) + "}";
    }
    return tag + "{ " + $join.call(ys, ", ") + " }";
  }
  return String(obj);
};
function wrapQuotes(s3, defaultStyle, opts2) {
  var quoteChar = (opts2.quoteStyle || defaultStyle) === "double" ? '"' : "'";
  return quoteChar + s3 + quoteChar;
}
function quote(s3) {
  return $replace.call(String(s3), /"/g, "&quot;");
}
function isArray$5(obj) {
  return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isDate2(obj) {
  return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isRegExp$1(obj) {
  return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isError(obj) {
  return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isString$1(obj) {
  return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isNumber(obj) {
  return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isBoolean(obj) {
  return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
}
function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === "object" && obj instanceof Symbol;
  }
  if (typeof obj === "symbol") {
    return true;
  }
  if (!obj || typeof obj !== "object" || !symToString) {
    return false;
  }
  try {
    symToString.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
function isBigInt(obj) {
  if (!obj || typeof obj !== "object" || !bigIntValueOf) {
    return false;
  }
  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e2) {
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty || function(key) {
  return key in this;
};
function has$3(obj, key) {
  return hasOwn.call(obj, key);
}
function toStr(obj) {
  return objectToString$1.call(obj);
}
function nameOf(f2) {
  if (f2.name) {
    return f2.name;
  }
  var m3 = $match.call(functionToString.call(f2), /^function\s*([\w$]+)/);
  if (m3) {
    return m3[1];
  }
  return null;
}
function indexOf(xs, x2) {
  if (xs.indexOf) {
    return xs.indexOf(x2);
  }
  for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
    if (xs[i2] === x2) {
      return i2;
    }
  }
  return -1;
}
function isMap(x2) {
  if (!mapSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    mapSize.call(x2);
    try {
      setSize.call(x2);
    } catch (s3) {
      return true;
    }
    return x2 instanceof Map;
  } catch (e2) {
  }
  return false;
}
function isWeakMap(x2) {
  if (!weakMapHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakMapHas.call(x2, weakMapHas);
    try {
      weakSetHas.call(x2, weakSetHas);
    } catch (s3) {
      return true;
    }
    return x2 instanceof WeakMap;
  } catch (e2) {
  }
  return false;
}
function isWeakRef(x2) {
  if (!weakRefDeref || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakRefDeref.call(x2);
    return true;
  } catch (e2) {
  }
  return false;
}
function isSet(x2) {
  if (!setSize || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    setSize.call(x2);
    try {
      mapSize.call(x2);
    } catch (m3) {
      return true;
    }
    return x2 instanceof Set;
  } catch (e2) {
  }
  return false;
}
function isWeakSet(x2) {
  if (!weakSetHas || !x2 || typeof x2 !== "object") {
    return false;
  }
  try {
    weakSetHas.call(x2, weakSetHas);
    try {
      weakMapHas.call(x2, weakMapHas);
    } catch (s3) {
      return true;
    }
    return x2 instanceof WeakSet;
  } catch (e2) {
  }
  return false;
}
function isElement(x2) {
  if (!x2 || typeof x2 !== "object") {
    return false;
  }
  if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
    return true;
  }
  return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
}
function inspectString(str, opts2) {
  if (str.length > opts2.maxStringLength) {
    var remaining = str.length - opts2.maxStringLength;
    var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
    return inspectString($slice.call(str, 0, opts2.maxStringLength), opts2) + trailer;
  }
  var s3 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s3, "single", opts2);
}
function lowbyte(c2) {
  var n2 = c2.charCodeAt(0);
  var x2 = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[n2];
  if (x2) {
    return "\\" + x2;
  }
  return "\\x" + (n2 < 16 ? "0" : "") + $toUpperCase.call(n2.toString(16));
}
function markBoxed(str) {
  return "Object(" + str + ")";
}
function weakCollectionOf(type) {
  return type + " { ? }";
}
function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
  return type + " (" + size + ") {" + joinedEntries + "}";
}
function singleLineValues(xs) {
  for (var i2 = 0; i2 < xs.length; i2++) {
    if (indexOf(xs[i2], "\n") >= 0) {
      return false;
    }
  }
  return true;
}
function getIndent(opts2, depth) {
  var baseIndent;
  if (opts2.indent === "	") {
    baseIndent = "	";
  } else if (typeof opts2.indent === "number" && opts2.indent > 0) {
    baseIndent = $join.call(Array(opts2.indent + 1), " ");
  } else {
    return null;
  }
  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}
function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return "";
  }
  var lineJoiner = "\n" + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
}
function arrObjKeys(obj, inspect2) {
  var isArr = isArray$5(obj);
  var xs = [];
  if (isArr) {
    xs.length = obj.length;
    for (var i2 = 0; i2 < obj.length; i2++) {
      xs[i2] = has$3(obj, i2) ? inspect2(obj[i2], obj) : "";
    }
  }
  var syms = typeof gOPS === "function" ? gOPS(obj) : [];
  var symMap;
  if (hasShammedSymbols) {
    symMap = {};
    for (var k2 = 0; k2 < syms.length; k2++) {
      symMap["$" + syms[k2]] = syms[k2];
    }
  }
  for (var key in obj) {
    if (!has$3(obj, key)) {
      continue;
    }
    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    }
    if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
      continue;
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect2(key, obj) + ": " + inspect2(obj[key], obj));
    } else {
      xs.push(key + ": " + inspect2(obj[key], obj));
    }
  }
  if (typeof gOPS === "function") {
    for (var j2 = 0; j2 < syms.length; j2++) {
      if (isEnumerable.call(obj, syms[j2])) {
        xs.push("[" + inspect2(syms[j2]) + "]: " + inspect2(obj[syms[j2]], obj));
      }
    }
  }
  return xs;
}
var GetIntrinsic2 = getIntrinsic;
var callBound = callBound$1;
var inspect = objectInspect;
var $TypeError = GetIntrinsic2("%TypeError%");
var $WeakMap = GetIntrinsic2("%WeakMap%", true);
var $Map = GetIntrinsic2("%Map%", true);
var $weakMapGet = callBound("WeakMap.prototype.get", true);
var $weakMapSet = callBound("WeakMap.prototype.set", true);
var $weakMapHas = callBound("WeakMap.prototype.has", true);
var $mapGet = callBound("Map.prototype.get", true);
var $mapSet = callBound("Map.prototype.set", true);
var $mapHas = callBound("Map.prototype.has", true);
var listGetNode = function(list, key) {
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr;
      return curr;
    }
  }
};
var listGet = function(objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};
var listSet = function(objects, key, value2) {
  var node = listGetNode(objects, key);
  if (node) {
    node.value = value2;
  } else {
    objects.next = {
      key,
      next: objects.next,
      value: value2
    };
  }
};
var listHas = function(objects, key) {
  return !!listGetNode(objects, key);
};
var sideChannel = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function(key) {
      if (!channel.has(key)) {
        throw new $TypeError("Side channel does not contain " + inspect(key));
      }
    },
    get: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          return listGet($o, key);
        }
      }
    },
    has: function(key) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          return listHas($o, key);
        }
      }
      return false;
    },
    set: function(key, value2) {
      if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
        if (!$wm) {
          $wm = new $WeakMap();
        }
        $weakMapSet($wm, key, value2);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }
        $mapSet($m, key, value2);
      } else {
        if (!$o) {
          $o = { key: {}, next: null };
        }
        listSet($o, key, value2);
      }
    }
  };
  return channel;
};
var replace = String.prototype.replace;
var percentTwenties = /%20/g;
var Format = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
};
var formats$3 = {
  "default": Format.RFC3986,
  formatters: {
    RFC1738: function(value2) {
      return replace.call(value2, percentTwenties, "+");
    },
    RFC3986: function(value2) {
      return String(value2);
    }
  },
  RFC1738: Format.RFC1738,
  RFC3986: Format.RFC3986
};
var formats$2 = formats$3;
var has$2 = Object.prototype.hasOwnProperty;
var isArray$4 = Array.isArray;
var hexTable = function() {
  var array = [];
  for (var i2 = 0; i2 < 256; ++i2) {
    array.push("%" + ((i2 < 16 ? "0" : "") + i2.toString(16)).toUpperCase());
  }
  return array;
}();
var compactQueue = function compactQueue2(queue) {
  while (queue.length > 1) {
    var item = queue.pop();
    var obj = item.obj[item.prop];
    if (isArray$4(obj)) {
      var compacted = [];
      for (var j2 = 0; j2 < obj.length; ++j2) {
        if (typeof obj[j2] !== "undefined") {
          compacted.push(obj[j2]);
        }
      }
      item.obj[item.prop] = compacted;
    }
  }
};
var arrayToObject = function arrayToObject2(source, options) {
  var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var i2 = 0; i2 < source.length; ++i2) {
    if (typeof source[i2] !== "undefined") {
      obj[i2] = source[i2];
    }
  }
  return obj;
};
var merge$2 = function merge(target, source, options) {
  if (!source) {
    return target;
  }
  if (typeof source !== "object") {
    if (isArray$4(target)) {
      target.push(source);
    } else if (target && typeof target === "object") {
      if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
        target[source] = true;
      }
    } else {
      return [target, source];
    }
    return target;
  }
  if (!target || typeof target !== "object") {
    return [target].concat(source);
  }
  var mergeTarget = target;
  if (isArray$4(target) && !isArray$4(source)) {
    mergeTarget = arrayToObject(target, options);
  }
  if (isArray$4(target) && isArray$4(source)) {
    source.forEach(function(item, i2) {
      if (has$2.call(target, i2)) {
        var targetItem = target[i2];
        if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
          target[i2] = merge(targetItem, item, options);
        } else {
          target.push(item);
        }
      } else {
        target[i2] = item;
      }
    });
    return target;
  }
  return Object.keys(source).reduce(function(acc, key) {
    var value2 = source[key];
    if (has$2.call(acc, key)) {
      acc[key] = merge(acc[key], value2, options);
    } else {
      acc[key] = value2;
    }
    return acc;
  }, mergeTarget);
};
var assign = function assignSingleSource(target, source) {
  return Object.keys(source).reduce(function(acc, key) {
    acc[key] = source[key];
    return acc;
  }, target);
};
var decode = function(str, decoder, charset) {
  var strWithoutPlus = str.replace(/\+/g, " ");
  if (charset === "iso-8859-1") {
    return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
  }
  try {
    return decodeURIComponent(strWithoutPlus);
  } catch (e2) {
    return strWithoutPlus;
  }
};
var encode = function encode2(str, defaultEncoder, charset, kind, format3) {
  if (str.length === 0) {
    return str;
  }
  var string = str;
  if (typeof str === "symbol") {
    string = Symbol.prototype.toString.call(str);
  } else if (typeof str !== "string") {
    string = String(str);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  var out = "";
  for (var i2 = 0; i2 < string.length; ++i2) {
    var c2 = string.charCodeAt(i2);
    if (c2 === 45 || c2 === 46 || c2 === 95 || c2 === 126 || c2 >= 48 && c2 <= 57 || c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || format3 === formats$2.RFC1738 && (c2 === 40 || c2 === 41)) {
      out += string.charAt(i2);
      continue;
    }
    if (c2 < 128) {
      out = out + hexTable[c2];
      continue;
    }
    if (c2 < 2048) {
      out = out + (hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63]);
      continue;
    }
    if (c2 < 55296 || c2 >= 57344) {
      out = out + (hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63]);
      continue;
    }
    i2 += 1;
    c2 = 65536 + ((c2 & 1023) << 10 | string.charCodeAt(i2) & 1023);
    out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
  }
  return out;
};
var compact = function compact2(value2) {
  var queue = [{ obj: { o: value2 }, prop: "o" }];
  var refs = [];
  for (var i2 = 0; i2 < queue.length; ++i2) {
    var item = queue[i2];
    var obj = item.obj[item.prop];
    var keys2 = Object.keys(obj);
    for (var j2 = 0; j2 < keys2.length; ++j2) {
      var key = keys2[j2];
      var val = obj[key];
      if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
        queue.push({ obj, prop: key });
        refs.push(val);
      }
    }
  }
  compactQueue(queue);
  return value2;
};
var isRegExp = function isRegExp2(obj) {
  return Object.prototype.toString.call(obj) === "[object RegExp]";
};
var isBuffer$2 = function isBuffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};
var combine = function combine2(a3, b2) {
  return [].concat(a3, b2);
};
var maybeMap = function maybeMap2(val, fn3) {
  if (isArray$4(val)) {
    var mapped = [];
    for (var i2 = 0; i2 < val.length; i2 += 1) {
      mapped.push(fn3(val[i2]));
    }
    return mapped;
  }
  return fn3(val);
};
var utils$2 = {
  arrayToObject,
  assign,
  combine,
  compact,
  decode,
  encode,
  isBuffer: isBuffer$2,
  isRegExp,
  maybeMap,
  merge: merge$2
};
var getSideChannel2 = sideChannel;
var utils$1 = utils$2;
var formats$1 = formats$3;
var has$1 = Object.prototype.hasOwnProperty;
var arrayPrefixGenerators = {
  brackets: function brackets(prefix) {
    return prefix + "[]";
  },
  comma: "comma",
  indices: function indices(prefix, key) {
    return prefix + "[" + key + "]";
  },
  repeat: function repeat2(prefix) {
    return prefix;
  }
};
var isArray$3 = Array.isArray;
var split = String.prototype.split;
var push = Array.prototype.push;
var pushToArray = function(arr, valueOrArray) {
  push.apply(arr, isArray$3(valueOrArray) ? valueOrArray : [valueOrArray]);
};
var toISO = Date.prototype.toISOString;
var defaultFormat = formats$1["default"];
var defaults$2 = {
  addQueryPrefix: false,
  allowDots: false,
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encoder: utils$1.encode,
  encodeValuesOnly: false,
  format: defaultFormat,
  formatter: formats$1.formatters[defaultFormat],
  indices: false,
  serializeDate: function serializeDate(date2) {
    return toISO.call(date2);
  },
  skipNulls: false,
  strictNullHandling: false
};
var isNonNullishPrimitive = function isNonNullishPrimitive2(v2) {
  return typeof v2 === "string" || typeof v2 === "number" || typeof v2 === "boolean" || typeof v2 === "symbol" || typeof v2 === "bigint";
};
var sentinel = {};
var stringify$2 = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter, sort2, allowDots, serializeDate2, format3, formatter, encodeValuesOnly, charset, sideChannel2) {
  var obj = object;
  var tmpSc = sideChannel2;
  var step = 0;
  var findFlag = false;
  while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
    var pos = tmpSc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        findFlag = true;
      }
    }
    if (typeof tmpSc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate2(obj);
  } else if (generateArrayPrefix === "comma" && isArray$3(obj)) {
    obj = utils$1.maybeMap(obj, function(value3) {
      if (value3 instanceof Date) {
        return serializeDate2(value3);
      }
      return value3;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? encoder(prefix, defaults$2.encoder, charset, "key", format3) : prefix;
    }
    obj = "";
  }
  if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
    if (encoder) {
      var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$2.encoder, charset, "key", format3);
      if (generateArrayPrefix === "comma" && encodeValuesOnly) {
        var valuesArray = split.call(String(obj), ",");
        var valuesJoined = "";
        for (var i2 = 0; i2 < valuesArray.length; ++i2) {
          valuesJoined += (i2 === 0 ? "" : ",") + formatter(encoder(valuesArray[i2], defaults$2.encoder, charset, "value", format3));
        }
        return [formatter(keyValue) + (commaRoundTrip && isArray$3(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
      }
      return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults$2.encoder, charset, "value", format3))];
    }
    return [formatter(prefix) + "=" + formatter(String(obj))];
  }
  var values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  var objKeys;
  if (generateArrayPrefix === "comma" && isArray$3(obj)) {
    objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray$3(filter)) {
    objKeys = filter;
  } else {
    var keys2 = Object.keys(obj);
    objKeys = sort2 ? keys2.sort(sort2) : keys2;
  }
  var adjustedPrefix = commaRoundTrip && isArray$3(obj) && obj.length === 1 ? prefix + "[]" : prefix;
  for (var j2 = 0; j2 < objKeys.length; ++j2) {
    var key = objKeys[j2];
    var value2 = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
    if (skipNulls && value2 === null) {
      continue;
    }
    var keyPrefix = isArray$3(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
    sideChannel2.set(object, step);
    var valueSideChannel = getSideChannel2();
    valueSideChannel.set(sentinel, sideChannel2);
    pushToArray(values, stringify(
      value2,
      keyPrefix,
      generateArrayPrefix,
      commaRoundTrip,
      strictNullHandling,
      skipNulls,
      encoder,
      filter,
      sort2,
      allowDots,
      serializeDate2,
      format3,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
};
var normalizeStringifyOptions = function normalizeStringifyOptions2(opts2) {
  if (!opts2) {
    return defaults$2;
  }
  if (opts2.encoder !== null && typeof opts2.encoder !== "undefined" && typeof opts2.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  var charset = opts2.charset || defaults$2.charset;
  if (typeof opts2.charset !== "undefined" && opts2.charset !== "utf-8" && opts2.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var format3 = formats$1["default"];
  if (typeof opts2.format !== "undefined") {
    if (!has$1.call(formats$1.formatters, opts2.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format3 = opts2.format;
  }
  var formatter = formats$1.formatters[format3];
  var filter = defaults$2.filter;
  if (typeof opts2.filter === "function" || isArray$3(opts2.filter)) {
    filter = opts2.filter;
  }
  return {
    addQueryPrefix: typeof opts2.addQueryPrefix === "boolean" ? opts2.addQueryPrefix : defaults$2.addQueryPrefix,
    allowDots: typeof opts2.allowDots === "undefined" ? defaults$2.allowDots : !!opts2.allowDots,
    charset,
    charsetSentinel: typeof opts2.charsetSentinel === "boolean" ? opts2.charsetSentinel : defaults$2.charsetSentinel,
    delimiter: typeof opts2.delimiter === "undefined" ? defaults$2.delimiter : opts2.delimiter,
    encode: typeof opts2.encode === "boolean" ? opts2.encode : defaults$2.encode,
    encoder: typeof opts2.encoder === "function" ? opts2.encoder : defaults$2.encoder,
    encodeValuesOnly: typeof opts2.encodeValuesOnly === "boolean" ? opts2.encodeValuesOnly : defaults$2.encodeValuesOnly,
    filter,
    format: format3,
    formatter,
    serializeDate: typeof opts2.serializeDate === "function" ? opts2.serializeDate : defaults$2.serializeDate,
    skipNulls: typeof opts2.skipNulls === "boolean" ? opts2.skipNulls : defaults$2.skipNulls,
    sort: typeof opts2.sort === "function" ? opts2.sort : null,
    strictNullHandling: typeof opts2.strictNullHandling === "boolean" ? opts2.strictNullHandling : defaults$2.strictNullHandling
  };
};
var stringify_1 = function(object, opts2) {
  var obj = object;
  var options = normalizeStringifyOptions(opts2);
  var objKeys;
  var filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray$3(options.filter)) {
    filter = options.filter;
    objKeys = filter;
  }
  var keys2 = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  var arrayFormat;
  if (opts2 && opts2.arrayFormat in arrayPrefixGenerators) {
    arrayFormat = opts2.arrayFormat;
  } else if (opts2 && "indices" in opts2) {
    arrayFormat = opts2.indices ? "indices" : "repeat";
  } else {
    arrayFormat = "indices";
  }
  var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
  if (opts2 && "commaRoundTrip" in opts2 && typeof opts2.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  var commaRoundTrip = generateArrayPrefix === "comma" && opts2 && opts2.commaRoundTrip;
  if (!objKeys) {
    objKeys = Object.keys(obj);
  }
  if (options.sort) {
    objKeys.sort(options.sort);
  }
  var sideChannel2 = getSideChannel2();
  for (var i2 = 0; i2 < objKeys.length; ++i2) {
    var key = objKeys[i2];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    pushToArray(keys2, stringify$2(
      obj[key],
      key,
      generateArrayPrefix,
      commaRoundTrip,
      options.strictNullHandling,
      options.skipNulls,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel2
    ));
  }
  var joined = keys2.join(options.delimiter);
  var prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
};
var utils = utils$2;
var has = Object.prototype.hasOwnProperty;
var isArray$2 = Array.isArray;
var defaults$1 = {
  allowDots: false,
  allowPrototypes: false,
  allowSparse: false,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: false,
  comma: false,
  decoder: utils.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: false,
  interpretNumericEntities: false,
  parameterLimit: 1e3,
  parseArrays: true,
  plainObjects: false,
  strictNullHandling: false
};
var interpretNumericEntities = function(str) {
  return str.replace(/&#(\d+);/g, function($0, numberStr) {
    return String.fromCharCode(parseInt(numberStr, 10));
  });
};
var parseArrayValue = function(val, options) {
  if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
    return val.split(",");
  }
  return val;
};
var isoSentinel = "utf8=%26%2310003%3B";
var charsetSentinel = "utf8=%E2%9C%93";
var parseValues = function parseQueryStringValues(str, options) {
  var obj = {};
  var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
  var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
  var parts = cleanStr.split(options.delimiter, limit);
  var skipIndex = -1;
  var i2;
  var charset = options.charset;
  if (options.charsetSentinel) {
    for (i2 = 0; i2 < parts.length; ++i2) {
      if (parts[i2].indexOf("utf8=") === 0) {
        if (parts[i2] === charsetSentinel) {
          charset = "utf-8";
        } else if (parts[i2] === isoSentinel) {
          charset = "iso-8859-1";
        }
        skipIndex = i2;
        i2 = parts.length;
      }
    }
  }
  for (i2 = 0; i2 < parts.length; ++i2) {
    if (i2 === skipIndex) {
      continue;
    }
    var part = parts[i2];
    var bracketEqualsPos = part.indexOf("]=");
    var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
    var key, val;
    if (pos === -1) {
      key = options.decoder(part, defaults$1.decoder, charset, "key");
      val = options.strictNullHandling ? null : "";
    } else {
      key = options.decoder(part.slice(0, pos), defaults$1.decoder, charset, "key");
      val = utils.maybeMap(
        parseArrayValue(part.slice(pos + 1), options),
        function(encodedVal) {
          return options.decoder(encodedVal, defaults$1.decoder, charset, "value");
        }
      );
    }
    if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
      val = interpretNumericEntities(val);
    }
    if (part.indexOf("[]=") > -1) {
      val = isArray$2(val) ? [val] : val;
    }
    if (has.call(obj, key)) {
      obj[key] = utils.combine(obj[key], val);
    } else {
      obj[key] = val;
    }
  }
  return obj;
};
var parseObject = function(chain, val, options, valuesParsed) {
  var leaf = valuesParsed ? val : parseArrayValue(val, options);
  for (var i2 = chain.length - 1; i2 >= 0; --i2) {
    var obj;
    var root2 = chain[i2];
    if (root2 === "[]" && options.parseArrays) {
      obj = [].concat(leaf);
    } else {
      obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
      var index2 = parseInt(cleanRoot, 10);
      if (!options.parseArrays && cleanRoot === "") {
        obj = { 0: leaf };
      } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
        obj = [];
        obj[index2] = leaf;
      } else if (cleanRoot !== "__proto__") {
        obj[cleanRoot] = leaf;
      }
    }
    leaf = obj;
  }
  return leaf;
};
var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
  if (!givenKey) {
    return;
  }
  var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
  var brackets2 = /(\[[^[\]]*])/;
  var child = /(\[[^[\]]*])/g;
  var segment = options.depth > 0 && brackets2.exec(key);
  var parent2 = segment ? key.slice(0, segment.index) : key;
  var keys2 = [];
  if (parent2) {
    if (!options.plainObjects && has.call(Object.prototype, parent2)) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(parent2);
  }
  var i2 = 0;
  while (options.depth > 0 && (segment = child.exec(key)) !== null && i2 < options.depth) {
    i2 += 1;
    if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
      if (!options.allowPrototypes) {
        return;
      }
    }
    keys2.push(segment[1]);
  }
  if (segment) {
    keys2.push("[" + key.slice(segment.index) + "]");
  }
  return parseObject(keys2, val, options, valuesParsed);
};
var normalizeParseOptions = function normalizeParseOptions2(opts2) {
  if (!opts2) {
    return defaults$1;
  }
  if (opts2.decoder !== null && opts2.decoder !== void 0 && typeof opts2.decoder !== "function") {
    throw new TypeError("Decoder has to be a function.");
  }
  if (typeof opts2.charset !== "undefined" && opts2.charset !== "utf-8" && opts2.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  var charset = typeof opts2.charset === "undefined" ? defaults$1.charset : opts2.charset;
  return {
    allowDots: typeof opts2.allowDots === "undefined" ? defaults$1.allowDots : !!opts2.allowDots,
    allowPrototypes: typeof opts2.allowPrototypes === "boolean" ? opts2.allowPrototypes : defaults$1.allowPrototypes,
    allowSparse: typeof opts2.allowSparse === "boolean" ? opts2.allowSparse : defaults$1.allowSparse,
    arrayLimit: typeof opts2.arrayLimit === "number" ? opts2.arrayLimit : defaults$1.arrayLimit,
    charset,
    charsetSentinel: typeof opts2.charsetSentinel === "boolean" ? opts2.charsetSentinel : defaults$1.charsetSentinel,
    comma: typeof opts2.comma === "boolean" ? opts2.comma : defaults$1.comma,
    decoder: typeof opts2.decoder === "function" ? opts2.decoder : defaults$1.decoder,
    delimiter: typeof opts2.delimiter === "string" || utils.isRegExp(opts2.delimiter) ? opts2.delimiter : defaults$1.delimiter,
    depth: typeof opts2.depth === "number" || opts2.depth === false ? +opts2.depth : defaults$1.depth,
    ignoreQueryPrefix: opts2.ignoreQueryPrefix === true,
    interpretNumericEntities: typeof opts2.interpretNumericEntities === "boolean" ? opts2.interpretNumericEntities : defaults$1.interpretNumericEntities,
    parameterLimit: typeof opts2.parameterLimit === "number" ? opts2.parameterLimit : defaults$1.parameterLimit,
    parseArrays: opts2.parseArrays !== false,
    plainObjects: typeof opts2.plainObjects === "boolean" ? opts2.plainObjects : defaults$1.plainObjects,
    strictNullHandling: typeof opts2.strictNullHandling === "boolean" ? opts2.strictNullHandling : defaults$1.strictNullHandling
  };
};
var parse$2 = function(str, opts2) {
  var options = normalizeParseOptions(opts2);
  if (str === "" || str === null || typeof str === "undefined") {
    return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  }
  var tempObj = typeof str === "string" ? parseValues(str, options) : str;
  var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  var keys2 = Object.keys(tempObj);
  for (var i2 = 0; i2 < keys2.length; ++i2) {
    var key = keys2[i2];
    var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
    obj = utils.merge(obj, newObj, options);
  }
  if (options.allowSparse === true) {
    return obj;
  }
  return utils.compact(obj);
};
var stringify$1 = stringify_1;
var parse$1 = parse$2;
var formats = formats$3;
var lib = {
  formats,
  parse: parse$1,
  stringify: stringify$1
};
const baseUrl = location.protocol + "//" + location.host + location.pathname.replace(/\/[^\/]*$/, "") + "/api";
console.log("LOCATION:", location);
const api = axios.create({
  baseURL: baseUrl
});
const kanban = {
  createBoard: function({ trackerId, itemId }, payload) {
    return api.post(`/trackers/${trackerId}/`, lib.stringify(payload), {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  createItem: function({ trackerId }, payload) {
    return api.post(`/trackers/${trackerId}/items`, lib.stringify(payload, { encode: false }), {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  getItem: function({ trackerId, itemId }, payload) {
    return api.get(`/trackers/${trackerId}/items/${itemId}`, lib.stringify(payload), {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  setItem: function({ trackerId, itemId }, payload) {
    return api.post(`/trackers/${trackerId}/items/${itemId}`, lib.stringify(payload, { encode: false }), {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  deleteItem: function({ trackerId, itemId }) {
    return api.delete(`/trackers/${trackerId}/items/${itemId}`, {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  getField: function({ trackerId, fieldId }, payload) {
    return api.get(`/trackers/${trackerId}/fields/${fieldId}`, lib.stringify(payload), {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  setField: function({ trackerId, fieldId }, payload) {
    return api.post(`/trackers/${trackerId}/fields/${fieldId}`, lib.stringify(payload), {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  deleteField: function({ trackerId, fieldId }) {
    return api.delete(`/trackers/${trackerId}/fields/${fieldId}`, {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  },
  getUsers: function() {
    return api.get(`/users`, {
      headers: {
        Authorization: `Bearer ${store.getters.getAccessToken}`
      }
    });
  }
};
const FormAddCard_vue_vue_type_style_index_0_scoped_d6985196_lang = "";
const _withScopeId$b = (n2) => (pushScopeId("data-v-d6985196"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$h = { class: "add-cart-container" };
const _hoisted_2$g = /* @__PURE__ */ createTextVNode(" Add card ");
const _hoisted_3$b = {
  key: 0,
  class: "fas fa-spinner fa-spin"
};
const _hoisted_4$9 = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
const __default__$8 = {
  name: "FormAddCard"
};
const _sfc_main$k = /* @__PURE__ */ Object.assign(__default__$8, {
  props: {
    cellId: {
      type: Number
    },
    rowValue: [String, Number],
    columnValue: [String, Number]
  },
  emits: ["close"],
  setup(__props, { emit: emit2 }) {
    const props2 = __props;
    const toast = useToast();
    const trackerId = ref(store.getters.getTrackerId);
    const title3 = ref("");
    const textarea = ref(null);
    const loading = ref(false);
    watchEffect(() => {
      d$5(textarea.value);
    });
    const handleAddCard = () => {
      loading.value = true;
      let sortOrder = 1;
      let cardIds = store.getters.getCell(props2.cellId).cards;
      let lastCard = store.getters.getCard(cardIds[cardIds.length - 1]);
      if (lastCard)
        sortOrder = parseFloat(lastCard.sortOrder) + 1;
      kanban.createItem(
        { trackerId: trackerId.value },
        {
          fields: {
            [store.getters.getTitleField]: title3.value,
            [store.getters.getSwimlaneField]: props2.rowValue,
            [store.getters.getXaxisField]: props2.columnValue,
            [store.getters.getYaxisField]: sortOrder
          }
        }
      ).then((res) => {
        loading.value = false;
        emit2("close");
        store.dispatch("addNewCard", {
          id: res.data.itemId,
          title: title3.value,
          cellId: props2.cellId,
          row: props2.rowValue,
          column: props2.columnValue,
          sortOrder
        });
        store.dispatch("addRules", [
          {
            action: "update",
            subject: "Tracker_Item",
            fields: [
              store.getters.getTitleField,
              store.getters.getDescriptionField,
              store.getters.getXaxisField,
              store.getters.getYaxisField,
              store.getters.getSwimlaneField
            ],
            conditions: {
              itemId: res.data.itemId
            }
          },
          {
            action: "delete",
            subject: "Tracker_Item",
            conditions: {
              itemId: res.data.itemId
            }
          }
        ]);
        console.log(res.data);
        toast.success(`${res.status} ${res.statusText}! Item created.`);
      }).catch((err) => {
        loading.value = false;
        const { code, errortitle, message } = err.response.data;
        const msg = `Code: ${code} - ${message}`;
        toast.error(msg);
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$h, [
        createVNode(KanbanCard, null, {
          default: withCtx(() => [
            withDirectives(createElementVNode("textarea", {
              ref_key: "textarea",
              ref: textarea,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => title3.value = $event),
              class: "form-control",
              rows: "3",
              placeholder: "Enter a title for this card..."
            }, toDisplayString(title3.value), 513), [
              [vModelText, title3.value]
            ])
          ]),
          _: 1
        }),
        createVNode(unref(Button), {
          sm: "",
          onClick: handleAddCard
        }, {
          default: withCtx(() => [
            _hoisted_2$g,
            loading.value ? (openBlock(), createElementBlock("i", _hoisted_3$b)) : createCommentVNode("v-if", true)
          ]),
          _: 1
        }),
        createVNode(unref(Button), {
          class: "ml-2",
          variant: "default",
          sm: "",
          onClick: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("close"))
        }, {
          default: withCtx(() => [
            _hoisted_4$9
          ]),
          _: 1
        })
      ]);
    };
  }
});
const FormAddCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__scopeId", "data-v-d6985196"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/Forms/FormAddCard.vue"]]);
function t$3(t13, r2) {
  for (var n2 = 0; n2 < r2.length; n2++) {
    var i2 = r2[n2];
    i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(t13, i2.key, i2);
  }
}
function r$2() {
  return (r$2 = Object.assign || function(t13) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var n2 = arguments[r2];
      for (var i2 in n2)
        Object.prototype.hasOwnProperty.call(n2, i2) && (t13[i2] = n2[i2]);
    }
    return t13;
  }).apply(this, arguments);
}
function n$2(t13, r2) {
  t13.prototype = Object.create(r2.prototype), t13.prototype.constructor = t13, t13.__proto__ = r2;
}
var i$3 = function() {
  function r2(t13, r3) {
    this.operator = t13, this.value = r3, Object.defineProperty(this, "t", { writable: true });
  }
  var n2, i2;
  return r2.prototype.addNote = function(t13) {
    this.t = this.t || [], this.t.push(t13);
  }, n2 = r2, (i2 = [{ key: "notes", get: function() {
    return this.t;
  } }]) && t$3(n2.prototype, i2), r2;
}(), e$2 = function(t13) {
  function r2() {
    return t13.apply(this, arguments) || this;
  }
  return n$2(r2, t13), r2;
}(i$3), o$3 = function(t13) {
  function r2(r3, n2) {
    if (!Array.isArray(n2))
      throw new Error('"' + r3 + '" operator expects to receive an array of conditions');
    return t13.call(this, r3, n2) || this;
  }
  return n$2(r2, t13), r2;
}(e$2), u$4 = "__itself__", f$4 = function(t13) {
  function r2(r3, n2, i2) {
    var e2;
    return (e2 = t13.call(this, r3, i2) || this).field = n2, e2;
  }
  return n$2(r2, t13), r2;
}(i$3), a$4 = new e$2("__null__", null), c$5 = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
function s$4(t13, r2) {
  return r2 instanceof o$3 && r2.operator === t13;
}
function h$4(t13, r2) {
  return 1 === r2.length ? r2[0] : new o$3(t13, function t14(r3, n2, i2) {
    for (var e2 = i2 || [], o2 = 0, u2 = n2.length; o2 < u2; o2++) {
      var f2 = n2[o2];
      s$4(r3, f2) ? t14(r3, f2.value, e2) : e2.push(f2);
    }
    return e2;
  }(t13, r2));
}
var v$3 = function(t13) {
  return t13;
}, d$4 = function() {
  return /* @__PURE__ */ Object.create(null);
}, l$4 = Object.defineProperty(d$4(), "__@type@__", { value: "ignore value" });
function p$5(t13, r2, n2) {
  if (void 0 === n2 && (n2 = false), !t13 || t13 && t13.constructor !== Object)
    return false;
  for (var i2 in t13) {
    if (c$5(t13, i2) && c$5(r2, i2) && (!n2 || t13[i2] !== l$4))
      return true;
  }
  return false;
}
function w$4(t13) {
  var r2 = [];
  for (var n2 in t13)
    c$5(t13, n2) && t13[n2] !== l$4 && r2.push(n2);
  return r2;
}
function b$4(t13, r2) {
  r2 !== a$4 && t13.push(r2);
}
var y$4 = function(t13) {
  return h$4("and", t13);
}, j$5 = { compound: function(t13, r2, n2) {
  var i2 = (Array.isArray(r2) ? r2 : [r2]).map(function(t14) {
    return n2.parse(t14);
  });
  return new o$3(t13.name, i2);
}, field: function(t13, r2, n2) {
  return new f$4(t13.name, n2.field, r2);
}, document: function(t13, r2) {
  return new e$2(t13.name, r2);
} }, _$6 = function() {
  function t13(t14, n3) {
    var i2 = this;
    void 0 === n3 && (n3 = d$4()), this.i = void 0, this.o = void 0, this.u = void 0, this.s = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.s = { operatorToConditionName: n3.operatorToConditionName || v$3, defaultOperatorName: n3.defaultOperatorName || "eq", mergeFinalConditions: n3.mergeFinalConditions || y$4 }, this.i = Object.keys(t14).reduce(function(n4, e2) {
      return n4[e2] = r$2({ name: i2.s.operatorToConditionName(e2) }, t14[e2]), n4;
    }, {}), this.o = r$2({}, n3.fieldContext, { field: "", query: {}, parse: this.parse, hasOperators: function(t15) {
      return p$5(t15, i2.i, n3.useIgnoreValue);
    } }), this.u = r$2({}, n3.documentContext, { parse: this.parse, query: {} }), this.h = n3.useIgnoreValue ? w$4 : Object.keys;
  }
  var n2 = t13.prototype;
  return n2.setParse = function(t14) {
    this.parse = t14, this.o.parse = t14, this.u.parse = t14;
  }, n2.parseField = function(t14, r2, n3, i2) {
    var e2 = this.i[r2];
    if (!e2)
      throw new Error('Unsupported operator "' + r2 + '"');
    if ("field" !== e2.type)
      throw new Error("Unexpected " + e2.type + ' operator "' + r2 + '" at field level');
    return this.o.field = t14, this.o.query = i2, this.parseInstruction(e2, n3, this.o);
  }, n2.parseInstruction = function(t14, r2, n3) {
    return "function" == typeof t14.validate && t14.validate(t14, r2), (t14.parse || j$5[t14.type])(t14, r2, n3);
  }, n2.parseFieldOperators = function(t14, r2) {
    for (var n3 = [], i2 = this.h(r2), e2 = 0, o2 = i2.length; e2 < o2; e2++) {
      var u2 = i2[e2];
      if (!this.i[u2])
        throw new Error('Field query for "' + t14 + '" may contain only operators or a plain object as a value');
      b$4(n3, this.parseField(t14, u2, r2[u2], r2));
    }
    return n3;
  }, n2.parse = function(t14) {
    var r2 = [], n3 = this.h(t14);
    this.u.query = t14;
    for (var i2 = 0, e2 = n3.length; i2 < e2; i2++) {
      var o2 = n3[i2], u2 = t14[o2], f2 = this.i[o2];
      if (f2) {
        if ("document" !== f2.type && "compound" !== f2.type)
          throw new Error('Cannot use parsing instruction for operator "' + o2 + '" in "document" context as it is supposed to be used in  "' + f2.type + '" context');
        b$4(r2, this.parseInstruction(f2, u2, this.u));
      } else
        this.o.hasOperators(u2) ? r2.push.apply(r2, this.parseFieldOperators(o2, u2)) : b$4(r2, this.parseField(o2, this.s.defaultOperatorName, u2, t14));
    }
    return this.s.mergeFinalConditions(r2);
  }, t13;
}();
function m$5(t13, r2) {
  var n2 = t13[r2];
  if ("function" != typeof n2)
    throw new Error('Unable to interpret "' + r2 + '" condition. Did you forget to register interpreter for it?');
  return n2;
}
function g$4(t13) {
  return t13.operator;
}
function E$4(t13, n2) {
  var i2, e2 = n2, o2 = e2 && e2.getInterpreterName || g$4;
  switch (e2 ? e2.numberOfArguments : 0) {
    case 1:
      i2 = function(r2) {
        var n3 = o2(r2, e2);
        return m$5(t13, n3)(r2, u2);
      };
      break;
    case 3:
      i2 = function(r2, n3, i3) {
        var f2 = o2(r2, e2);
        return m$5(t13, f2)(r2, n3, i3, u2);
      };
      break;
    default:
      i2 = function(r2, n3) {
        var i3 = o2(r2, e2);
        return m$5(t13, i3)(r2, n3, u2);
      };
  }
  var u2 = r$2({}, e2, { interpret: i2 });
  return u2.interpret;
}
function x$4(t13, r2) {
  return function(n2) {
    for (var i2 = arguments.length, e2 = new Array(i2 > 1 ? i2 - 1 : 0), o2 = 1; o2 < i2; o2++)
      e2[o2 - 1] = arguments[o2];
    var u2 = t13.apply(void 0, [n2].concat(e2)), f2 = r2.bind(null, u2);
    return f2.ast = u2, f2;
  };
}
_$6.prototype.parseInstruction;
function f$3(e2, t13) {
  if (!Array.isArray(t13))
    throw new Error('"' + e2.name + '" expects value to be an array');
}
function u$3(e2, t13) {
  if (f$3(e2, t13), !t13.length)
    throw new Error('"' + e2.name + '" expects to have at least one element in array');
}
var c$4 = function(e2) {
  return function(t13, r2) {
    if (typeof r2 !== e2)
      throw new Error('"' + t13.name + '" expects value to be a "' + e2 + '"');
  };
}, p$4 = { type: "compound", validate: u$3, parse: function(t13, r2, n2) {
  var o2 = n2.parse, a3 = r2.map(function(e2) {
    return o2(e2);
  });
  return h$4(t13.name, a3);
} }, s$3 = p$4, l$3 = { type: "compound", validate: u$3 }, d$3 = { type: "field", validate: function(e2, t13) {
  if (!(t13 && (t13 instanceof RegExp || t13.constructor === Object)))
    throw new Error('"' + e2.name + '" expects to receive either regular expression or object of field operators');
}, parse: function(e2, n2, o2) {
  var a3 = n2 instanceof RegExp ? new f$4("regex", o2.field, n2) : o2.parse(n2, o2);
  return new o$3(e2.name, [a3]);
} }, v$2 = { type: "field", validate: function(e2, t13) {
  if (!t13 || t13.constructor !== Object)
    throw new Error('"' + e2.name + '" expects to receive an object with nested query or field level operators');
}, parse: function(e2, r2, o2) {
  var a3 = o2.parse, i2 = o2.field, f2 = (0, o2.hasOperators)(r2) ? a3(r2, { field: u$4 }) : a3(r2);
  return new f$4(e2.name, i2, f2);
} }, w$3 = { type: "field", validate: c$4("number") }, y$3 = { type: "field", validate: f$3 }, $$3 = y$3, x$3 = y$3, h$3 = { type: "field", validate: function(e2, t13) {
  if (!Array.isArray(t13) || 2 !== t13.length)
    throw new Error('"' + e2.name + '" expects an array with 2 numeric elements');
} }, m$4 = { type: "field", validate: c$4("boolean") }, g$3 = { type: "field", validate: function(e2, t13) {
  if (!("string" == typeof t13 || "number" == typeof t13 || t13 instanceof Date))
    throw new Error('"' + e2.name + '" expects value to be comparable (i.e., string, number or date)');
} }, b$3 = g$3, E$3 = b$3, j$4 = b$3, O$3 = { type: "field" }, R$4 = O$3, _$5 = { type: "field", validate: function(e2, t13) {
  if (!(t13 instanceof RegExp) && "string" != typeof t13)
    throw new Error('"' + e2.name + '" expects value to be a regular expression or a string that represents regular expression');
}, parse: function(e2, r2, n2) {
  var o2 = "string" == typeof r2 ? new RegExp(r2, n2.query.$options || "") : r2;
  return new f$4(e2.name, n2.field, o2);
} }, q$5 = { type: "field", parse: function() {
  return a$4;
} }, A$4 = { type: "document", validate: c$4("function") }, N$4 = Object.freeze({ __proto__: null, $and: p$4, $or: s$3, $nor: l$3, $not: d$3, $elemMatch: v$2, $size: w$3, $in: y$3, $nin: $$3, $all: x$3, $mod: h$3, $exists: m$4, $gte: g$3, $gt: b$3, $lt: E$3, $lte: j$4, $eq: O$3, $ne: R$4, $regex: _$5, $options: q$5, $where: A$4 });
var P$4 = function(e2) {
  var t13, r2;
  function n2(t14) {
    return e2.call(this, t14, { defaultOperatorName: "$eq", operatorToConditionName: function(e3) {
      return e3.slice(1);
    } }) || this;
  }
  return r2 = e2, (t13 = n2).prototype = Object.create(r2.prototype), t13.prototype.constructor = t13, t13.__proto__ = r2, n2.prototype.parse = function(t14, r3) {
    return r3 && r3.field ? y$4(this.parseFieldOperators(r3.field, t14)) : e2.prototype.parse.call(this, t14);
  }, n2;
}(_$6), z$4 = N$4;
function t$2(r2, n2, t13) {
  for (var u2 = 0, e2 = r2.length; u2 < e2; u2++)
    if (0 === t13(r2[u2], n2))
      return true;
  return false;
}
function u$2(r2, n2) {
  return Array.isArray(r2) && Number.isNaN(Number(n2));
}
function e$1(r2, n2, t13) {
  if (!u$2(r2, n2))
    return t13(r2, n2);
  for (var e2 = [], o2 = 0; o2 < r2.length; o2++) {
    var i2 = t13(r2[o2], n2);
    void 0 !== i2 && (e2 = e2.concat(i2));
  }
  return e2;
}
function o$2(r2) {
  return function(n2, t13, u2) {
    var e2 = u2.get(t13, n2.field);
    return Array.isArray(e2) ? e2.some(function(t14) {
      return r2(n2, t14, u2);
    }) : r2(n2, e2, u2);
  };
}
function i$2() {
  return (i$2 = Object.assign || function(r2) {
    for (var n2 = 1; n2 < arguments.length; n2++) {
      var t13 = arguments[n2];
      for (var u2 in t13)
        Object.prototype.hasOwnProperty.call(t13, u2) && (r2[u2] = t13[u2]);
    }
    return r2;
  }).apply(this, arguments);
}
var f$2 = function(r2, n2) {
  return r2[n2];
};
function c$3(r2, n2, t13) {
  var u2 = n2.lastIndexOf(".");
  return -1 === u2 ? [r2, n2] : [t13(r2, n2.slice(0, u2)), n2.slice(u2 + 1)];
}
function a$3(n2, t13, u2) {
  if (void 0 === u2 && (u2 = f$2), t13 === u$4)
    return n2;
  if (!n2)
    throw new Error('Unable to get field "' + t13 + '" out of ' + String(n2) + ".");
  return function(r2, n3, t14) {
    if (-1 === n3.indexOf("."))
      return e$1(r2, n3, t14);
    for (var u3 = n3.split("."), o2 = r2, i2 = 0, f2 = u3.length; i2 < f2; i2++)
      if (!(o2 = e$1(o2, u3[i2], t14)) || "object" != typeof o2)
        return o2;
    return o2;
  }(n2, t13, u2);
}
function y$2(r2, n2) {
  return r2 === n2 ? 0 : r2 > n2 ? 1 : -1;
}
function l$2(r2, t13) {
  return void 0 === t13 && (t13 = {}), E$4(r2, i$2({ get: a$3, compare: y$2 }, t13));
}
var b$2 = function(r2, n2, t13) {
  var u2 = t13.interpret;
  return r2.value.some(function(r3) {
    return u2(r3, n2);
  });
}, m$3 = function(r2, n2, t13) {
  return !b$2(r2, n2, t13);
}, d$2 = function(r2, n2, t13) {
  var u2 = t13.interpret;
  return r2.value.every(function(r3) {
    return u2(r3, n2);
  });
}, g$2 = function(r2, n2, t13) {
  return !(0, t13.interpret)(r2.value[0], n2);
}, p$3 = function(r2, n2, u2) {
  var e2 = u2.compare, o2 = (0, u2.get)(n2, r2.field);
  return Array.isArray(o2) && !Array.isArray(r2.value) ? t$2(o2, r2.value, e2) : 0 === e2(o2, r2.value);
}, A$3 = function(r2, n2, t13) {
  return !p$3(r2, n2, t13);
}, s$2 = o$2(function(r2, n2, t13) {
  var u2 = t13.compare(n2, r2.value);
  return 0 === u2 || -1 === u2;
}), h$2 = o$2(function(r2, n2, t13) {
  return -1 === t13.compare(n2, r2.value);
}), j$3 = o$2(function(r2, n2, t13) {
  return 1 === t13.compare(n2, r2.value);
}), w$2 = o$2(function(r2, n2, t13) {
  var u2 = t13.compare(n2, r2.value);
  return 0 === u2 || 1 === u2;
}), _$4 = function(n2, t13, e2) {
  var o2 = e2.get;
  if (n2.field === u$4)
    return void 0 !== t13;
  var i2 = c$3(t13, n2.field, o2), f2 = i2[0], a3 = i2[1], v2 = function(r2) {
    return !!r2 && r2.hasOwnProperty(a3) === n2.value;
  };
  return u$2(f2, a3) ? f2.some(v2) : v2(f2);
}, x$2 = o$2(function(r2, n2) {
  return "number" == typeof n2 && n2 % r2.value[0] === r2.value[1];
}), O$2 = function(n2, t13, e2) {
  var o2 = e2.get, i2 = c$3(t13, n2.field, o2), f2 = i2[0], a3 = i2[1], v2 = function(r2) {
    var t14 = o2(r2, a3);
    return Array.isArray(t14) && t14.length === n2.value;
  };
  return n2.field !== u$4 && u$2(f2, a3) ? f2.some(v2) : v2(f2);
}, N$3 = o$2(function(r2, n2) {
  return "string" == typeof n2 && r2.value.test(n2);
}), q$4 = o$2(function(r2, n2, u2) {
  var e2 = u2.compare;
  return t$2(r2.value, n2, e2);
}), z$3 = function(r2, n2, t13) {
  return !q$4(r2, n2, t13);
}, E$2 = function(r2, n2, u2) {
  var e2 = u2.compare, o2 = (0, u2.get)(n2, r2.field);
  return Array.isArray(o2) && r2.value.every(function(r3) {
    return t$2(o2, r3, e2);
  });
}, M$2 = function(r2, n2, t13) {
  var u2 = t13.interpret, e2 = (0, t13.get)(n2, r2.field);
  return Array.isArray(e2) && e2.some(function(n3) {
    return u2(r2.value, n3);
  });
}, S$3 = function(r2, n2) {
  return r2.value.call(n2);
}, U$3 = i$2({}, Object.freeze({ __proto__: null, or: b$2, nor: m$3, and: d$2, not: g$2, eq: p$3, ne: A$3, lte: s$2, lt: h$2, gt: j$3, gte: w$2, exists: _$4, mod: x$2, size: O$2, regex: N$3, within: q$4, nin: z$3, all: E$2, elemMatch: M$2, where: S$3 }), { in: q$4 });
l$2(U$3);
function c$2() {
  return (c$2 = Object.assign || function(r2) {
    for (var t13 = 1; t13 < arguments.length; t13++) {
      var o2 = arguments[t13];
      for (var n2 in o2)
        Object.prototype.hasOwnProperty.call(o2, n2) && (r2[n2] = o2[n2]);
    }
    return r2;
  }).apply(this, arguments);
}
function a$2(r2) {
  return r2 instanceof Date ? r2.getTime() : r2 && "function" == typeof r2.toJSON ? r2.toJSON() : r2;
}
var m$2 = function(r2, t13) {
  return y$2(a$2(r2), a$2(t13));
};
function p$2(n2, e2, i2) {
  var u2 = new P$4(n2), a3 = l$2(e2, c$2({ compare: m$2 }, i2));
  if (i2 && i2.forPrimitives) {
    var p2 = { field: u$4 }, s3 = u2.parse;
    u2.setParse(function(r2) {
      return s3(r2, p2);
    });
  }
  return x$4(u2.parse, a3);
}
p$2(z$4, U$3);
p$2(["$and", "$or"].reduce(function(r2, t13) {
  return r2[t13] = c$2({}, r2[t13], { type: "field" }), r2;
}, c$2({}, z$4, { $nor: c$2({}, z$4.$nor, { type: "field", parse: j$5.compound }) })), U$3, { forPrimitives: true });
function _$3(t13, r2) {
  for (var i2 = 0; i2 < r2.length; i2++) {
    var n2 = r2[i2];
    n2.enumerable = n2.enumerable || false;
    n2.configurable = true;
    if ("value" in n2)
      n2.writable = true;
    Object.defineProperty(t13, n2.key, n2);
  }
}
function C$2(t13, r2, i2) {
  if (r2)
    _$3(t13.prototype, r2);
  if (i2)
    _$3(t13, i2);
  return t13;
}
function P$3() {
  P$3 = Object.assign || function(t13) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var i2 = arguments[r2];
      for (var n2 in i2)
        if (Object.prototype.hasOwnProperty.call(i2, n2))
          t13[n2] = i2[n2];
    }
    return t13;
  };
  return P$3.apply(this, arguments);
}
function R$3(t13, r2) {
  t13.prototype = Object.create(r2.prototype);
  t13.prototype.constructor = t13;
  k$3(t13, r2);
}
function k$3(t13, r2) {
  k$3 = Object.setPrototypeOf || function t14(r3, i2) {
    r3.__proto__ = i2;
    return r3;
  };
  return k$3(t13, r2);
}
function B$3(t13) {
  if (void 0 === t13)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t13;
}
function T$2(t13) {
  return Array.isArray(t13) ? t13 : [t13];
}
var q$3 = Object.hasOwn || Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);
var z$2 = "__caslSubjectType__";
function S$2(t13, r2) {
  if (r2) {
    if (!q$3(r2, z$2))
      Object.defineProperty(r2, z$2, { value: t13 });
    else if (t13 !== r2[z$2])
      throw new Error("Trying to cast object to subject type " + t13 + " but previously it was casted to " + r2[z$2]);
  }
  return r2;
}
var Y$3 = function t(r2) {
  var i2 = typeof r2;
  return "string" === i2 || "function" === i2;
};
var D$3 = function t2(r2) {
  return r2.modelName || r2.name;
};
var L$3 = function t3(r2) {
  return "string" === typeof r2 ? r2 : D$3(r2);
};
function G$2(t13) {
  if (q$3(t13, z$2))
    return t13[z$2];
  return D$3(t13.constructor);
}
function Q$2(t13, r2, i2) {
  for (var n2 = i2; n2 < r2.length; n2++)
    t13.push(r2[n2]);
}
function U$2(t13, r2) {
  if (!t13 || !t13.length)
    return r2 || [];
  if (!r2 || !r2.length)
    return t13 || [];
  var i2 = 0;
  var n2 = 0;
  var e2 = [];
  while (i2 < t13.length && n2 < r2.length)
    if (t13[i2].priority < r2[n2].priority) {
      e2.push(t13[i2]);
      i2++;
    } else {
      e2.push(r2[n2]);
      n2++;
    }
  Q$2(e2, t13, i2);
  Q$2(e2, r2, n2);
  return e2;
}
function V$3(t13, r2, i2) {
  var n2 = t13.get(r2);
  if (!n2) {
    n2 = i2();
    t13.set(r2, n2);
  }
  return n2;
}
var W$2 = function t4(r2) {
  return r2;
};
function X$2(t13, r2) {
  if (Array.isArray(t13.fields) && !t13.fields.length)
    throw new Error("`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa");
  if (t13.fields && !r2.fieldMatcher)
    throw new Error('You need to pass "fieldMatcher" option in order to restrict access by fields');
  if (t13.conditions && !r2.conditionsMatcher)
    throw new Error('You need to pass "conditionsMatcher" option in order to restrict access by conditions');
}
var Z$2 = function() {
  function t13(t14, r3, i2) {
    if (void 0 === i2)
      i2 = 0;
    X$2(t14, r3);
    this.action = r3.resolveAction(t14.action);
    this.subject = t14.subject;
    this.inverted = !!t14.inverted;
    this.conditions = t14.conditions;
    this.reason = t14.reason;
    this.fields = t14.fields ? T$2(t14.fields) : void 0;
    this.priority = i2;
    this.t = r3;
  }
  var r2 = t13.prototype;
  r2.i = function t14() {
    if (this.conditions && !this.u)
      this.u = this.t.conditionsMatcher(this.conditions);
    return this.u;
  };
  r2.matchesConditions = function t14(r3) {
    if (!this.conditions)
      return true;
    if (!r3 || Y$3(r3))
      return !this.inverted;
    var i2 = this.i();
    return i2(r3);
  };
  r2.matchesField = function t14(r3) {
    if (!this.fields)
      return true;
    if (!r3)
      return !this.inverted;
    if (this.fields && !this.o)
      this.o = this.t.fieldMatcher(this.fields);
    return this.o(r3);
  };
  C$2(t13, [{ key: "ast", get: function t14() {
    var r3 = this.i();
    return r3 ? r3.ast : void 0;
  } }]);
  return t13;
}();
function tt$1(t13, r2) {
  var i2 = { value: t13, prev: r2, next: null };
  if (r2)
    r2.next = i2;
  return i2;
}
function rt$1(t13) {
  if (t13.next)
    t13.next.prev = t13.prev;
  if (t13.prev)
    t13.prev.next = t13.next;
  t13.next = t13.prev = null;
}
var it$1 = function t5(r2) {
  return { value: r2.value, prev: r2.prev, next: r2.next };
};
var nt$1 = function t6() {
  return { rules: [], merged: false };
};
var et$1 = function t7() {
  return /* @__PURE__ */ new Map();
};
var ut$1 = function t8(r2, i2) {
  if (!r2.h && i2.fields)
    r2.h = true;
};
var ot$1 = function() {
  function t13(t14, r3) {
    if (void 0 === t14)
      t14 = [];
    if (void 0 === r3)
      r3 = {};
    this.h = false;
    this.v = /* @__PURE__ */ new Map();
    this.l = { conditionsMatcher: r3.conditionsMatcher, fieldMatcher: r3.fieldMatcher, resolveAction: r3.resolveAction || W$2 };
    this.p = r3.anyAction || "manage";
    this.g = r3.anySubjectType || "all";
    this.A = r3.detectSubjectType || G$2;
    this.j = t14;
    this.$ = this.M(t14);
  }
  var r2 = t13.prototype;
  r2.detectSubjectType = function t14(r3) {
    if (Y$3(r3))
      return r3;
    if (!r3)
      return this.g;
    return this.A(r3);
  };
  r2.update = function t14(r3) {
    var i2 = { rules: r3, ability: this, target: this };
    this.m("update", i2);
    this.j = r3;
    this.$ = this.M(r3);
    this.m("updated", i2);
    return this;
  };
  r2.M = function t14(r3) {
    var i2 = /* @__PURE__ */ new Map();
    for (var n2 = r3.length - 1; n2 >= 0; n2--) {
      var e2 = r3.length - n2 - 1;
      var u2 = new Z$2(r3[n2], this.l, e2);
      var o2 = T$2(u2.action);
      var s3 = T$2(u2.subject || this.g);
      ut$1(this, u2);
      for (var a3 = 0; a3 < s3.length; a3++) {
        var f2 = V$3(i2, s3[a3], et$1);
        for (var c2 = 0; c2 < o2.length; c2++)
          V$3(f2, o2[c2], nt$1).rules.push(u2);
      }
    }
    return i2;
  };
  r2.possibleRulesFor = function t14(r3, i2) {
    if (void 0 === i2)
      i2 = this.g;
    if (!Y$3(i2))
      throw new Error('"possibleRulesFor" accepts only subject types (i.e., string or class) as the 2nd parameter');
    var n2 = V$3(this.$, i2, et$1);
    var e2 = V$3(n2, r3, nt$1);
    if (e2.merged)
      return e2.rules;
    var u2 = r3 !== this.p && n2.has(this.p) ? n2.get(this.p).rules : void 0;
    var o2 = U$2(e2.rules, u2);
    if (i2 !== this.g)
      o2 = U$2(o2, this.possibleRulesFor(r3, this.g));
    e2.rules = o2;
    e2.merged = true;
    return o2;
  };
  r2.rulesFor = function t14(r3, i2, n2) {
    var e2 = this.possibleRulesFor(r3, i2);
    if (n2 && "string" !== typeof n2)
      throw new Error("The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details");
    if (!this.h)
      return e2;
    return e2.filter(function(t15) {
      return t15.matchesField(n2);
    });
  };
  r2.on = function t14(r3, i2) {
    var n2 = this;
    var e2 = this.v.get(r3) || null;
    var u2 = tt$1(i2, e2);
    this.v.set(r3, u2);
    return function() {
      var t15 = n2.v.get(r3);
      if (!u2.next && !u2.prev && t15 === u2)
        n2.v.delete(r3);
      else if (u2 === t15)
        n2.v.set(r3, u2.prev);
      rt$1(u2);
    };
  };
  r2.m = function t14(r3, i2) {
    var n2 = this.v.get(r3) || null;
    while (null !== n2) {
      var e2 = n2.prev ? it$1(n2.prev) : null;
      n2.value(i2);
      n2 = e2;
    }
  };
  C$2(t13, [{ key: "rules", get: function t14() {
    return this.j;
  } }]);
  return t13;
}();
var st$1 = function(t13) {
  R$3(PureAbility, t13);
  function PureAbility() {
    return t13.apply(this, arguments) || this;
  }
  var r2 = PureAbility.prototype;
  r2.can = function t14(r3, i2, n2) {
    var e2 = this.relevantRuleFor(r3, i2, n2);
    return !!e2 && !e2.inverted;
  };
  r2.relevantRuleFor = function t14(r3, i2, n2) {
    var e2 = this.detectSubjectType(i2);
    var u2 = this.rulesFor(r3, e2, n2);
    for (var o2 = 0, s3 = u2.length; o2 < s3; o2++)
      if (u2[o2].matchesConditions(i2))
        return u2[o2];
    return null;
  };
  r2.cannot = function t14(r3, i2, n2) {
    return !this.can(r3, i2, n2);
  };
  return PureAbility;
}(ot$1);
var at$1 = { $eq: O$3, $ne: R$4, $lt: E$3, $lte: j$4, $gt: b$3, $gte: g$3, $in: y$3, $nin: $$3, $all: x$3, $size: w$3, $regex: _$5, $options: q$5, $elemMatch: v$2, $exists: m$4 };
var ft$1 = { eq: p$3, ne: A$3, lt: h$2, lte: s$2, gt: j$3, gte: w$2, in: q$4, nin: z$3, all: E$2, size: O$2, regex: N$3, elemMatch: M$2, exists: _$4, and: d$2 };
var ht$1 = p$2(at$1, ft$1);
var vt$1 = /[-/\\^$+?.()|[\]{}]/g;
var lt$1 = /\.?\*+\.?/g;
var dt$1 = /\*+/;
var bt$1 = /\./g;
function yt$1(t13, r2, i2) {
  var n2 = "*" === i2[0] || "." === t13[0] && "." === t13[t13.length - 1] ? "+" : "*";
  var e2 = -1 === t13.indexOf("**") ? "[^.]" : ".";
  var u2 = t13.replace(bt$1, "\\$&").replace(dt$1, e2 + n2);
  return r2 + t13.length === i2.length ? "(?:" + u2 + ")?" : u2;
}
function pt$1(t13, r2, i2) {
  if ("." === t13 && ("*" === i2[r2 - 1] || "*" === i2[r2 + 1]))
    return t13;
  return "\\" + t13;
}
function wt$1(t13) {
  var r2 = t13.map(function(t14) {
    return t14.replace(vt$1, pt$1).replace(lt$1, yt$1);
  });
  var i2 = r2.length > 1 ? "(?:" + r2.join("|") + ")" : r2[0];
  return new RegExp("^" + i2 + "$");
}
var gt$1 = function t9(r2) {
  var i2;
  return function(t13) {
    if ("undefined" === typeof i2)
      i2 = r2.every(function(t14) {
        return -1 === t14.indexOf("*");
      }) ? null : wt$1(r2);
    return null === i2 ? -1 !== r2.indexOf(t13) : i2.test(t13);
  };
};
var At$1 = function(t13) {
  R$3(Ability, t13);
  function Ability(r2, i2) {
    if (void 0 === r2)
      r2 = [];
    if (void 0 === i2)
      i2 = {};
    return t13.call(this, r2, P$3({ conditionsMatcher: ht$1, fieldMatcher: gt$1 }, i2)) || this;
  }
  return Ability;
}(st$1);
var $t$1 = function t10(r2) {
  return 'Cannot execute "' + r2.action + '" on "' + r2.subjectType + '"';
};
var Mt$1 = function t11(r2) {
  this.message = r2;
};
Mt$1.prototype = Object.create(Error.prototype);
var mt$1 = function(t13) {
  R$3(ForbiddenError, t13);
  ForbiddenError.setDefaultMessage = function t14(r3) {
    this._ = "string" === typeof r3 ? function() {
      return r3;
    } : r3;
  };
  ForbiddenError.from = function t14(r3) {
    return new this(r3);
  };
  function ForbiddenError(r3) {
    var i2;
    i2 = t13.call(this, "") || this;
    i2.ability = r3;
    if ("function" === typeof Error.captureStackTrace) {
      i2.name = "ForbiddenError";
      Error.captureStackTrace(B$3(i2), i2.constructor);
    }
    return i2;
  }
  var r2 = ForbiddenError.prototype;
  r2.setMessage = function t14(r3) {
    this.message = r3;
    return this;
  };
  r2.throwUnlessCan = function t14() {
    var r3;
    var i2 = (r3 = this.ability).relevantRuleFor.apply(r3, arguments);
    if (i2 && !i2.inverted)
      return;
    this.action = arguments.length <= 0 ? void 0 : arguments[0];
    this.subject = arguments.length <= 1 ? void 0 : arguments[1];
    this.subjectType = L$3(this.ability.detectSubjectType(arguments.length <= 1 ? void 0 : arguments[1]));
    this.field = arguments.length <= 2 ? void 0 : arguments[2];
    var n2 = i2 ? i2.reason : "";
    this.message = this.message || n2 || this.constructor._(this);
    throw this;
  };
  return ForbiddenError;
}(Mt$1);
mt$1._ = $t$1;
Object.freeze({ __proto__: null });
const defineAbilityFor = (rules) => {
  return new At$1(rules);
};
const ButtonAddCard_vue_vue_type_style_index_0_scoped_9acdb58f_lang = "";
const _withScopeId$a = (n2) => (pushScopeId("data-v-9acdb58f"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$g = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-plus" }, null, -1));
const _hoisted_2$f = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createElementVNode("span", { class: "ml-2" }, "Add a card", -1));
const __default__$7 = {
  name: "ButtonAddCard"
};
const _sfc_main$j = /* @__PURE__ */ Object.assign(__default__$7, {
  props: {
    cellId: {
      type: Number
    },
    rowValue: [String, Number],
    columnValue: [String, Number]
  },
  setup(__props) {
    const showForm = ref(false);
    const canCreateCard = computed(() => {
      const ability = defineAbilityFor(store.getters.getRules);
      return ability.can("create", "Tracker_Item");
    });
    const handleOpen = () => {
      showForm.value = true;
    };
    const handleClose = () => {
      showForm.value = false;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        !showForm.value && unref(canCreateCard) ? (openBlock(), createBlock(unref(Button), {
          key: 0,
          class: "w-100",
          variant: "default",
          sm: "",
          onClick: handleOpen
        }, {
          default: withCtx(() => [
            _hoisted_1$g,
            _hoisted_2$f
          ]),
          _: 1
        })) : createCommentVNode("v-if", true),
        showForm.value ? (openBlock(), createBlock(FormAddCard, {
          key: 1,
          cellId: __props.cellId,
          rowValue: __props.rowValue,
          columnValue: __props.columnValue,
          onClose: handleClose
        }, null, 8, ["cellId", "rowValue", "columnValue"])) : createCommentVNode("v-if", true)
      ], 64);
    };
  }
});
const ButtonAddCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__scopeId", "data-v-9acdb58f"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/Buttons/ButtonAddCard.vue"]]);
const KanbanColumn_vue_vue_type_style_index_0_scoped_5fec18df_lang = "";
const _hoisted_1$f = { class: "kanban-column-header" };
const _hoisted_2$e = {
  key: 0,
  class: "mr-2"
};
const _hoisted_7$3 = { class: "kanban-column-body d-flex flex-column flex-grow-1" };
const _hoisted_8$4 = { class: "flex-grow-1" };
const _hoisted_9$3 = { key: 0 };
const __default__$6 = {
  name: "KanbanColumn"
};
const _sfc_main$i = /* @__PURE__ */ Object.assign(__default__$6, {
  props: {
    title: {
      type: String,
      default: ""
    },
    limit: {
      type: Number
    },
    total: {
      type: Number
    },
    colId: {
      type: Number
    },
    rowValue: [Number, String],
    columnValue: [Number, String],
    cellId: {
      type: Number
    },
    rowIndex: {
      type: Number
    },
    colIndex: {
      type: Number
    }
  },
  setup(__props) {
    const props2 = __props;
    const showEditField = ref(false);
    const toast = useToast();
    const isLimitExceeded = computed(() => {
      if (props2.limit) {
        return props2.total > props2.limit;
      } else {
        return false;
      }
    });
    const handleTitleBlur = (event) => {
      showEditField.value = false;
      if (event.target.value.length < 1) {
        toast.error(`This field must be at least 1 character`);
        return;
      }
      store.dispatch("editColumnField", {
        id: props2.colId,
        field: "title",
        data: event.target.value
      });
    };
    return (_ctx, _cache) => {
      resolveComponent("ColorPicker");
      const _directive_focus = resolveDirective("focus");
      const _directive_autosize = resolveDirective("autosize");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["kanban-column", { "border border-danger": unref(isLimitExceeded) }])
      }, [
        createCommentVNode(` <div class="kanban-column-header mb-2" :style="{'background-color': store.getters.getColColor(props.colId)}"> `),
        createElementVNode("div", _hoisted_1$f, [
          createElementVNode("h6", {
            class: normalizeClass(["d-flex justify-content-center align-items-center mb-0", { "drag-handle-cell": false }])
          }, [
            !showEditField.value ? (openBlock(), createElementBlock("span", _hoisted_2$e, toDisplayString(__props.title), 1)) : createCommentVNode("v-if", true),
            showEditField.value ? withDirectives((openBlock(), createBlock(unref(Field), {
              key: 1,
              class: "flex-grow-1 mr-1",
              as: "textarea",
              rows: "1",
              value: __props.title,
              onBlur: handleTitleBlur,
              name: "rowTitle",
              type: "text",
              rules: { minLength: 1 }
            }, null, 8, ["value"])), [
              [_directive_focus],
              [_directive_autosize]
            ]) : createCommentVNode("v-if", true)
          ]),
          createElementVNode("span", {
            class: normalizeClass(["rounded p-1", { "bg-danger text-light": unref(isLimitExceeded) }])
          }, toDisplayString(__props.total) + toDisplayString(__props.limit ? `/${__props.limit}` : ""), 3),
          createCommentVNode("v-if", true)
        ]),
        createElementVNode("div", _hoisted_7$3, [
          createElementVNode("div", _hoisted_8$4, [
            renderSlot(_ctx.$slots, "default", {}, void 0, true)
          ]),
          __props.colIndex === 0 ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
            createVNode(ButtonAddCard, {
              cellId: __props.cellId,
              rowValue: __props.rowValue,
              columnValue: __props.columnValue
            }, null, 8, ["cellId", "rowValue", "columnValue"])
          ])) : createCommentVNode("v-if", true)
        ])
      ], 2);
    };
  }
});
const KanbanColumn = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__scopeId", "data-v-5fec18df"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/KanbanColumn.vue"]]);
const FormEditField_vue_vue_type_style_index_0_scoped_ac0038a0_lang = "";
const _hoisted_1$e = {
  key: 1,
  class: "editable-container"
};
const __default__$5 = {
  name: "FormEditField"
};
const _sfc_main$h = /* @__PURE__ */ Object.assign(__default__$5, {
  props: {
    id: [Number, String],
    title: {
      type: String
    }
  },
  setup(__props) {
    const props2 = __props;
    const trackerId = ref(store.getters.getTrackerId);
    const showEditField = ref(false);
    const toast = useToast();
    const titleField = ref(props2.title);
    const handleSaveTitle = (event) => {
      showEditField.value = false;
      if (titleField.value.length < 1) {
        toast.error(`This field must be at least 1 character`);
        return;
      }
      kanban.setItem(
        { trackerId: trackerId.value, itemId: props2.id },
        {
          fields: {
            [store.getters.getTitleField]: titleField.value
          }
        }
      ).then((res) => {
      }).catch((err) => {
        if (!err.response)
          toast.error("Error: title not saved");
        const { code, errortitle, message } = err.response.data;
        const msg = `Code: ${code} - ${message}`;
        toast.error(msg);
      });
      store.dispatch("editCardField", {
        id: props2.id,
        field: "title",
        data: titleField.value
      });
    };
    const handleEditClick = (event) => {
      const ability = defineAbilityFor(store.getters.getRules);
      const canUpdate = ability.can("update", S$2("Tracker_Item", { itemId: props2.id }), store.getters.getTitleField);
      if (canUpdate)
        showEditField.value = true;
    };
    return (_ctx, _cache) => {
      const _directive_focus = resolveDirective("focus");
      const _directive_autosize = resolveDirective("autosize");
      return openBlock(), createElementBlock("div", null, [
        !showEditField.value ? (openBlock(), createElementBlock("div", {
          key: 0,
          onClick: handleEditClick
        }, toDisplayString(titleField.value), 1)) : createCommentVNode("v-if", true),
        showEditField.value ? (openBlock(), createElementBlock("div", _hoisted_1$e, [
          withDirectives(createVNode(unref(Field), {
            class: "form-control",
            as: "textarea",
            rows: "1",
            modelValue: titleField.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => titleField.value = $event),
            name: "cardTitle",
            type: "text",
            rules: { minLength: 1 },
            onBlur: handleSaveTitle
          }, null, 8, ["modelValue"]), [
            [_directive_focus],
            [_directive_autosize]
          ])
        ])) : createCommentVNode("v-if", true)
      ]);
    };
  }
});
const FormEditField = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__scopeId", "data-v-ac0038a0"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/Forms/FormEditField.vue"]]);
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value2) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value2,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value2;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.14.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on$1(el, event, fn3) {
  el.addEventListener(event, fn3, !IE11OrLess && captureMode);
}
function off(el, event, fn3) {
  el.removeEventListener(event, fn3, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name2, state2) {
  if (el && name2) {
    if (el.classList) {
      el.classList[state2 ? "add" : "remove"](name2);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
      el.className = (className + (state2 ? " " + name2 : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style2 = el && el.style;
  if (style2) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style2) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style2[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i2 = 0, n2 = list.length;
    if (iterator) {
      for (; i2 < n2; i2++) {
        iterator(list[i2], i2);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY;
      left2 /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom2 = top2 + height;
      right2 = left2 + width;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent2 = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent2) {
    var parentSideVal = getRect(parent2)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent2;
    if (parent2 === getWindowScrollingElement())
      break;
    parent2 = getParentAutoScrollElement(parent2, false);
  }
  return false;
}
function getChild2(el, childNum, options, includeDragEl) {
  var currentChild = 0, i2 = 0, children = el.children;
  while (i2 < children.length) {
    if (children[i2].style.display !== "none" && children[i2] !== Sortable.ghost && (includeDragEl || children[i2] !== Sortable.dragged) && closest(children[i2], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i2];
      }
      currentChild++;
    }
    i2++;
  }
  return null;
}
function lastChild(el, selector) {
  var last2 = el.lastElementChild;
  while (last2 && (last2 === Sortable.ghost || css(last2, "display") === "none" || selector && !matches(last2, selector))) {
    last2 = last2.previousElementSibling;
  }
  return last2 || null;
}
function index$1(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i2 in arr) {
    if (!arr.hasOwnProperty(i2))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i2][key])
        return Number(i2);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src2) {
  if (dst && src2) {
    for (var key in src2) {
      if (src2.hasOwnProperty(key)) {
        dst[key] = src2[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x2, y2) {
  el.scrollLeft += x2;
  el.scrollTop += y2;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state2) {
      animationStates.push(state2);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state2) {
        var time = 0, target = state2.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state2.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name2, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name2, value2) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
        modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value2);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name2, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name2, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data9 = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name2) {
      _dispatchEvent({
        sortable,
        name: name2,
        originalEvent
      });
    }
  }, data9));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild2(el, 0, options), child2 = getChild2(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x2, y2) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x2 >= rect.left - threshold && x2 <= rect.right + threshold, insideVertically = y2 >= rect.top - threshold && y2 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value2, pull) {
    return function(to2, from, dragEl2, evt) {
      var sameGroup = to2.options.group.name && from.options.group.name && to2.options.group.name === from.options.group.name;
      if (value2 == null && (pull || sameGroup)) {
        return true;
      } else if (value2 == null || value2 === false) {
        return false;
      } else if (pull && value2 === "clone") {
        return value2;
      } else if (typeof value2 === "function") {
        return toFn(value2(to2, from, dragEl2, evt), pull)(to2, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to2 : from).options.group.name;
        return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i2 in evt) {
        if (evt.hasOwnProperty(i2)) {
          event[i2] = evt[i2];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction2() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name2 in defaults2) {
    !(name2 in options) && (options[name2] = defaults2[name2]);
  }
  _prepareGroup(options);
  for (var fn3 in this) {
    if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
      this[fn3] = this[fn3].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on$1(el, "pointerdown", this._onTapStart);
  } else {
    on$1(el, "mousedown", this._onTapStart);
    on$1(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on$1(el, "dragover", this);
    on$1(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch2 = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch2 || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$1(target);
    oldDraggableIndex = index$1(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch2, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch2, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch2 || evt).clientX,
        clientY: (touch2 || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch2 || evt).clientX;
      this._lastY = (touch2 || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch2);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on$1(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mouseup", _this._onDrop);
      on$1(ownerDocument, "touchend", _this._onDrop);
      on$1(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch2) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on$1(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchend", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on$1(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on$1(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on$1(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
    var touch2 = e2.touches ? e2.touches[0] : e2;
    if (Math.max(Math.abs(touch2.clientX - this._lastX), Math.abs(touch2.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch2) {
    touch2 = touch2 || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch2) {
      if (this.options.supportPointer) {
        on$1(document, "pointermove", this._onTouchMove);
      } else if (touch2) {
        on$1(document, "touchmove", this._onTouchMove);
      } else {
        on$1(document, "mousemove", this._onTouchMove);
      }
    } else {
      on$1(dragEl, "dragend", this);
      on$1(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on$1(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent2 = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent2)
          break;
        parent2 = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent2) {
        do {
          if (parent2[expando]) {
            var inserted = void 0;
            inserted = parent2[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent2
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent2;
        } while (parent2 = parent2.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch2 = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch2.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch2.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch2.clientX - this._lastX), Math.abs(touch2.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch2;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on$1(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on$1(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name2, extra) {
      pluginEvent2(name2, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$1(dragEl);
      newDraggableIndex = index$1(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild2(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction2 = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction2 = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction2 !== 0) {
          var dragIndex = index$1(dragEl);
          do {
            dragIndex -= direction2;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction2 === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction2;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction2 === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$1(dragEl);
    newDraggableIndex = index$1(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order2 = [], el, children = this.el.children, i2 = 0, n2 = children.length, options = this.options;
    for (; i2 < n2; i2++) {
      el = children[i2];
      if (closest(el, options.draggable, this.el, false)) {
        order2.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i2) {
      var el = rootEl2.children[i2];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store2 = this.options.store;
    store2 && store2.set && store2.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name2, value2) {
    var options = this.options;
    if (value2 === void 0) {
      return options[name2];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name2, value2);
      if (typeof modifiedValue !== "undefined") {
        options[name2] = modifiedValue;
      } else {
        options[name2] = value2;
      }
      if (name2 === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy2() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild2(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$1(dragEl) < index$1(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i2 = str.length, sum = 0;
  while (i2--) {
    sum += str.charCodeAt(i2);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn3) {
  return setTimeout(fn3, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on$1(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on: on$1,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index: index$1,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild2
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn3 in this) {
      if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
        this[fn3] = this[fn3].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on$1(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on$1(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on$1(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on$1(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x2, y2);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x2 !== lastAutoScrollX || y2 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x2, y2), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x2;
          lastAutoScrollY = y2;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x2 = (evt.touches ? evt.touches[0] : evt).clientX, y2 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x2) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x2) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y2) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y2) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i2 = 0; i2 <= layersOut; i2++) {
        if (!autoScrolls[i2]) {
          autoScrolls[i2] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch2 = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch2.clientX, touch2.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild2(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}
function insertNodeAt(fatherNode, node, position) {
  const refNode = position === 0 ? fatherNode.children[0] : fatherNode.children[position - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}
function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }
  return global.console;
}
const console$1 = getConsole();
function cached(fn3) {
  const cache = /* @__PURE__ */ Object.create(null);
  return function cachedFn(str) {
    const hit = cache[str];
    return hit || (cache[str] = fn3(str));
  };
}
const regex = /-(\w)/g;
const camelize = cached((str) => str.replace(regex, (_2, c2) => c2.toUpperCase()));
const manageAndEmit$1 = ["Start", "Add", "Remove", "Update", "End"];
const emit$1 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
const manage$1 = ["Move"];
const eventHandlerNames = [manage$1, manageAndEmit$1, emit$1].flatMap((events2) => events2).map((evt) => `on${evt}`);
const events = {
  manage: manage$1,
  manageAndEmit: manageAndEmit$1,
  emit: emit$1
};
function isReadOnly(eventName) {
  return eventHandlerNames.indexOf(eventName) !== -1;
}
const tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function isHtmlTag(name2) {
  return tags.includes(name2);
}
function isTransition(name2) {
  return ["transition-group", "TransitionGroup"].includes(name2);
}
function isHtmlAttribute(value2) {
  return ["id", "class", "role", "style"].includes(value2) || value2.startsWith("data-") || value2.startsWith("aria-") || value2.startsWith("on");
}
function project(entries) {
  return entries.reduce((res, [key, value2]) => {
    res[key] = value2;
    return res;
  }, {});
}
function getComponentAttributes({ $attrs, componentData = {} }) {
  const attributes = project(
    Object.entries($attrs).filter(([key, _2]) => isHtmlAttribute(key))
  );
  return {
    ...attributes,
    ...componentData
  };
}
function createSortableOption({ $attrs, callBackBuilder }) {
  const options = project(getValidSortableEntries($attrs));
  Object.entries(callBackBuilder).forEach(([eventType, eventBuilder]) => {
    events[eventType].forEach((event) => {
      options[`on${event}`] = eventBuilder(event);
    });
  });
  const draggable = `[data-draggable]${options.draggable || ""}`;
  return {
    ...options,
    draggable
  };
}
function getValidSortableEntries(value2) {
  return Object.entries(value2).filter(([key, _2]) => !isHtmlAttribute(key)).map(([key, value3]) => [camelize(key), value3]).filter(([key, _2]) => !isReadOnly(key));
}
const getHtmlElementFromNode = ({ el }) => el;
const addContext = (domElement, context) => domElement.__draggable_context = context;
const getContext = (domElement) => domElement.__draggable_context;
class ComponentStructure {
  constructor({
    nodes: { header, default: defaultNodes, footer },
    root: root2,
    realList
  }) {
    this.defaultNodes = defaultNodes;
    this.children = [...header, ...defaultNodes, ...footer];
    this.externalComponent = root2.externalComponent;
    this.rootTransition = root2.transition;
    this.tag = root2.tag;
    this.realList = realList;
  }
  get _isRootComponent() {
    return this.externalComponent || this.rootTransition;
  }
  render(h3, attributes) {
    const { tag, children, _isRootComponent } = this;
    const option2 = !_isRootComponent ? children : { default: () => children };
    return h3(tag, attributes, option2);
  }
  updated() {
    const { defaultNodes, realList } = this;
    defaultNodes.forEach((node, index2) => {
      addContext(getHtmlElementFromNode(node), {
        element: realList[index2],
        index: index2
      });
    });
  }
  getUnderlyingVm(domElement) {
    return getContext(domElement);
  }
  getVmIndexFromDomIndex(domIndex, element) {
    const { defaultNodes } = this;
    const { length } = defaultNodes;
    const domChildren = element.children;
    const domElement = domChildren.item(domIndex);
    if (domElement === null) {
      return length;
    }
    const context = getContext(domElement);
    if (context) {
      return context.index;
    }
    if (length === 0) {
      return 0;
    }
    const firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
    const indexFirstDomListElement = [...domChildren].findIndex(
      (element2) => element2 === firstDomListElement
    );
    return domIndex < indexFirstDomListElement ? 0 : length;
  }
}
function getSlot(slots, key) {
  const slotValue = slots[key];
  return slotValue ? slotValue() : [];
}
function computeNodes({ $slots, realList, getKey }) {
  const normalizedList = realList || [];
  const [header, footer] = ["header", "footer"].map(
    (name2) => getSlot($slots, name2)
  );
  const { item } = $slots;
  if (!item) {
    throw new Error("draggable element must have an item slot");
  }
  const defaultNodes = normalizedList.flatMap(
    (element, index2) => item({ element, index: index2 }).map((node) => {
      node.key = getKey(element);
      node.props = { ...node.props || {}, "data-draggable": true };
      return node;
    })
  );
  if (defaultNodes.length !== normalizedList.length) {
    throw new Error("Item slot must have only one child");
  }
  return {
    header,
    footer,
    default: defaultNodes
  };
}
function getRootInformation(tag) {
  const transition = isTransition(tag);
  const externalComponent = !isHtmlTag(tag) && !transition;
  return {
    transition,
    externalComponent,
    tag: externalComponent ? resolveComponent(tag) : transition ? TransitionGroup : tag
  };
}
function computeComponentStructure({ $slots, tag, realList, getKey }) {
  const nodes = computeNodes({ $slots, realList, getKey });
  const root2 = getRootInformation(tag);
  return new ComponentStructure({ nodes, root: root2, realList });
}
function emit(evtName, evtData) {
  nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function manage(evtName) {
  return (evtData, originalElement) => {
    if (this.realList !== null) {
      return this[`onDrag${evtName}`](evtData, originalElement);
    }
  };
}
function manageAndEmit(evtName) {
  const delegateCallBack = manage.call(this, evtName);
  return (evtData, originalElement) => {
    delegateCallBack.call(this, evtData, originalElement);
    emit.call(this, evtName, evtData);
  };
}
let draggingElement = null;
const props = {
  list: {
    type: Array,
    required: false,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  },
  itemKey: {
    type: [String, Function],
    required: true
  },
  clone: {
    type: Function,
    default: (original) => {
      return original;
    }
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
const emits = [
  "update:modelValue",
  "change",
  ...[...events.manageAndEmit, ...events.emit].map((evt) => evt.toLowerCase())
];
const draggableComponent = defineComponent({
  name: "draggable",
  inheritAttrs: false,
  props,
  emits,
  data() {
    return {
      error: false
    };
  },
  render() {
    try {
      this.error = false;
      const { $slots, $attrs, tag, componentData, realList, getKey } = this;
      const componentStructure = computeComponentStructure({
        $slots,
        tag,
        realList,
        getKey
      });
      this.componentStructure = componentStructure;
      const attributes = getComponentAttributes({ $attrs, componentData });
      return componentStructure.render(h$5, attributes);
    } catch (err) {
      this.error = true;
      return h$5("pre", { style: { color: "red" } }, err.stack);
    }
  },
  created() {
    if (this.list !== null && this.modelValue !== null) {
      console$1.error(
        "modelValue and list props are mutually exclusive! Please set one or another."
      );
    }
  },
  mounted() {
    if (this.error) {
      return;
    }
    const { $attrs, $el, componentStructure } = this;
    componentStructure.updated();
    const sortableOptions = createSortableOption({
      $attrs,
      callBackBuilder: {
        manageAndEmit: (event) => manageAndEmit.call(this, event),
        emit: (event) => emit.bind(this, event),
        manage: (event) => manage.call(this, event)
      }
    });
    const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
    this._sortable = new Sortable(targetDomElement, sortableOptions);
    this.targetDomElement = targetDomElement;
    targetDomElement.__draggable_component__ = this;
  },
  updated() {
    this.componentStructure.updated();
  },
  beforeUnmount() {
    if (this._sortable !== void 0)
      this._sortable.destroy();
  },
  computed: {
    realList() {
      const { list } = this;
      return list ? list : this.modelValue;
    },
    getKey() {
      const { itemKey } = this;
      if (typeof itemKey === "function") {
        return itemKey;
      }
      return (element) => element[itemKey];
    }
  },
  watch: {
    $attrs: {
      handler(newOptionValue) {
        const { _sortable } = this;
        if (!_sortable)
          return;
        getValidSortableEntries(newOptionValue).forEach(([key, value2]) => {
          _sortable.option(key, value2);
        });
      },
      deep: true
    }
  },
  methods: {
    getUnderlyingVm(domElement) {
      return this.componentStructure.getUnderlyingVm(domElement) || null;
    },
    getUnderlyingPotencialDraggableComponent(htmElement) {
      return htmElement.__draggable_component__;
    },
    emitChanges(evt) {
      nextTick(() => this.$emit("change", evt));
    },
    alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }
      const newList = [...this.modelValue];
      onList(newList);
      this.$emit("update:modelValue", newList);
    },
    spliceList() {
      const spliceList = (list) => list.splice(...arguments);
      this.alterList(spliceList);
    },
    updatePosition(oldIndex2, newIndex2) {
      const updatePosition = (list) => list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
      this.alterList(updatePosition);
    },
    getRelatedContextFromMoveEvent({ to: to2, related }) {
      const component = this.getUnderlyingPotencialDraggableComponent(to2);
      if (!component) {
        return { component };
      }
      const list = component.realList;
      const context = { list, component };
      if (to2 !== related && list) {
        const destination = component.getUnderlyingVm(related) || {};
        return { ...destination, ...context };
      }
      return context;
    },
    getVmIndexFromDomIndex(domIndex) {
      return this.componentStructure.getVmIndexFromDomIndex(
        domIndex,
        this.targetDomElement
      );
    },
    onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd(evt) {
      const element = evt.item._underlying_vm_;
      if (element === void 0) {
        return;
      }
      removeNode(evt.item);
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.spliceList(newIndex2, 0, element);
      const added = { element, newIndex: newIndex2 };
      this.emitChanges({ added });
    },
    onDragRemove(evt) {
      insertNodeAt(this.$el, evt.item, evt.oldIndex);
      if (evt.pullMode === "clone") {
        removeNode(evt.clone);
        return;
      }
      const { index: oldIndex2, element } = this.context;
      this.spliceList(oldIndex2, 1);
      const removed = { element, oldIndex: oldIndex2 };
      this.emitChanges({ removed });
    },
    onDragUpdate(evt) {
      removeNode(evt.item);
      insertNodeAt(evt.from, evt.item, evt.oldIndex);
      const oldIndex2 = this.context.index;
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.updatePosition(oldIndex2, newIndex2);
      const moved2 = { element: this.context.element, oldIndex: oldIndex2, newIndex: newIndex2 };
      this.emitChanges({ moved: moved2 });
    },
    computeFutureIndex(relatedContext, evt) {
      if (!relatedContext.element) {
        return 0;
      }
      const domChildren = [...evt.to.children].filter(
        (el) => el.style["display"] !== "none"
      );
      const currentDomIndex = domChildren.indexOf(evt.related);
      const currentIndex = relatedContext.component.getVmIndexFromDomIndex(
        currentDomIndex
      );
      const draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    },
    onDragMove(evt, originalEvent) {
      const { move: move3, realList } = this;
      if (!move3 || !realList) {
        return true;
      }
      const relatedContext = this.getRelatedContextFromMoveEvent(evt);
      const futureIndex = this.computeFutureIndex(relatedContext, evt);
      const draggedContext = {
        ...this.context,
        futureIndex
      };
      const sendEvent = {
        ...evt,
        relatedContext,
        draggedContext
      };
      return move3(sendEvent, originalEvent);
    },
    onDragEnd() {
      draggingElement = null;
    }
  }
});
const KanbanCards_vue_vue_type_style_index_0_scoped_99d91ba3_lang = "";
const _withScopeId$9 = (n2) => (pushScopeId("data-v-99d91ba3"), n2 = n2(), popScopeId(), n2);
const _hoisted_3$a = { class: "card-menu" };
const _hoisted_4$8 = ["href"];
const _hoisted_5$7 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-link" }, null, -1));
const _hoisted_6$4 = [
  _hoisted_5$7
];
const _hoisted_7$2 = ["href"];
const _hoisted_8$3 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-edit" }, null, -1));
const _hoisted_9$2 = [
  _hoisted_8$3
];
const _hoisted_10$2 = {
  key: 0,
  class: "mt-1"
};
const __default__$4 = {
  name: "KanbanCards"
};
const _sfc_main$g = /* @__PURE__ */ Object.assign(__default__$4, {
  props: {
    cardIds: {
      type: Array,
      default() {
        return [];
      }
    },
    rowId: {
      type: Number
    },
    rowValue: [Number, String],
    columnValue: [Number, String],
    cellId: {
      type: Number
    }
  },
  emits: ["editCard"],
  setup(__props, { emit: emit2 }) {
    const props2 = __props;
    const toast = useToast();
    const dragging = ref(false);
    const getCards = computed(() => store.getters.getCards(props2.cardIds));
    const getTrackerItemEditLink = computed(() => (id) => `tiki-tracker-update_item?trackerId=${store.getters.getTrackerId}&itemId=${id}`);
    const getTrackerItemLink = computed(() => (id) => `tiki-view_tracker_item.php?itemId=${id}`);
    const startDragging = () => dragging.value = true;
    const endDragging = () => setTimeout(() => dragging.value = false, 0);
    const checkMove = (event) => {
      const ability = defineAbilityFor(store.getters.getRules);
      const canUpdate = ability.can("update", S$2("Tracker_Item", { itemId: event.draggedContext.element.id }), store.getters.getColumnField);
      return canUpdate;
    };
    const handleChange = (event) => {
      if (event.moved) {
        store.dispatch("moveCard", {
          oldIndex: event.moved.oldIndex,
          newIndex: event.moved.newIndex,
          element: event.moved.element,
          rowId: props2.rowId,
          cellId: props2.cellId
        });
        let sortOrder = store.getters.getCard(event.moved.element.id).sortOrder;
        setItem(event.moved.element.id, sortOrder);
      } else if (event.added) {
        store.dispatch("addCard", {
          newIndex: event.added.newIndex,
          element: event.added.element,
          rowId: props2.rowId,
          cellId: props2.cellId
        });
        let sortOrder = store.getters.getCard(event.added.element.id).sortOrder;
        setItem(event.added.element.id, sortOrder);
      } else if (event.removed) {
        store.dispatch("removeCard", {
          oldIndex: event.removed.oldIndex,
          element: event.removed.element,
          rowId: props2.rowId,
          cellId: props2.cellId
        });
      }
    };
    const setItem = (itemId, newIndex2) => {
      kanban.setItem(
        { trackerId: store.getters.getTrackerId, itemId },
        {
          fields: {
            [store.getters.getSwimlaneField]: props2.rowValue,
            [store.getters.getXaxisField]: props2.columnValue,
            [store.getters.getYaxisField]: newIndex2
          }
        }
      ).then((res) => {
      }).catch((err) => {
        if (!err.response)
          return;
        const { code, errortitle, message } = err.response.data;
        const msg = `Code: ${code} - ${message}`;
        toast.error(msg);
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(draggableComponent), {
        list: unref(getCards),
        group: "cards",
        "item-key": "id",
        class: "container-cards",
        chosenClass: "chosen-card",
        ghostClass: "ghost-card",
        dragClass: "dragging-card",
        filter: "textarea",
        preventOnFilter: false,
        onChange: handleChange,
        onStart: startDragging,
        onEnd: endDragging,
        move: checkMove,
        fallbackTolerance: 3,
        forceFallback: true,
        animation: 150
      }, {
        item: withCtx(({ element }) => [
          createVNode(KanbanCard, null, {
            menu: withCtx(() => [
              createElementVNode("div", _hoisted_3$a, [
                createElementVNode("a", {
                  class: "p-1 mr-3",
                  href: unref(getTrackerItemLink)(element.id),
                  target: "_blank"
                }, _hoisted_6$4, 8, _hoisted_4$8),
                createElementVNode("a", {
                  class: "p-1 mr-1",
                  href: unref(getTrackerItemEditLink)(element.id),
                  target: "_blank"
                }, _hoisted_9$2, 8, _hoisted_7$2),
                createCommentVNode(' <Button class="d-inline-block" variant="default" sm @click="handleEditCard(element)"> ')
              ])
            ]),
            title: withCtx(() => [
              createVNode(FormEditField, {
                title: element.title,
                id: element.id
              }, null, 8, ["title", "id"])
            ]),
            text: withCtx(() => [
              element.description ? (openBlock(), createElementBlock("div", _hoisted_10$2, toDisplayString(element.description.substring(0, 115)), 1)) : createCommentVNode("v-if", true)
            ]),
            default: withCtx(() => [
              createCommentVNode("v-if", true),
              createCommentVNode("v-if", true)
            ]),
            _: 2
          }, 1024)
        ]),
        _: 1
      }, 8, ["list"]);
    };
  }
});
const KanbanCards = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__scopeId", "data-v-99d91ba3"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/KanbanCards.vue"]]);
const FormEditCard_vue_vue_type_style_index_0_scoped_e30ad356_lang = "";
const _withScopeId$8 = (n2) => (pushScopeId("data-v-e30ad356"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$d = { class: "mb-3" };
const _hoisted_2$d = {
  key: 1,
  class: "editable-container"
};
const _hoisted_3$9 = { class: "editable-controls" };
const _hoisted_4$7 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-check" }, null, -1));
const _hoisted_5$6 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
const _hoisted_6$3 = {
  key: 0,
  class: "mb-2"
};
const _hoisted_7$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("span", { class: "mr-2" }, [
  /* @__PURE__ */ createElementVNode("i", { class: "fas fa-link" })
], -1));
const _hoisted_8$2 = ["href"];
const _hoisted_9$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("h6", { class: "d-inline-block mr-2" }, [
  /* @__PURE__ */ createElementVNode("i", { class: "fas fa-align-left mr-2" }),
  /* @__PURE__ */ createTextVNode(" Description")
], -1));
const _hoisted_10$1 = { key: 2 };
const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-check" }, null, -1));
const _hoisted_12$1 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
const __default__$3 = {
  name: "FormEditCard"
};
const _sfc_main$f = /* @__PURE__ */ Object.assign(__default__$3, {
  props: {
    id: [Number, String],
    title: {
      type: String
    },
    desc: {
      type: String,
      default: ""
    },
    reference: {
      type: String,
      default: ""
    }
  },
  setup(__props) {
    const props2 = __props;
    const trackerId = ref(store.getters.getTrackerId);
    const showEditField = ref(false);
    const toast = useToast();
    const editDesc = ref(false);
    const titleField = ref(props2.title);
    const description = ref("");
    ref(null);
    watchEffect(() => {
      description.value = props2.desc;
    });
    const handleEditClick = (event) => {
      const ability = defineAbilityFor(store.getters.getRules);
      const canUpdate = ability.can("update", S$2("Tracker_Item", { itemId: props2.id }), store.getters.getTitleField);
      if (canUpdate)
        showEditField.value = true;
    };
    const handleSaveTitle = (event) => {
      showEditField.value = false;
      if (titleField.value.length < 1) {
        toast.error(`This field must be at least 1 character`);
        return;
      }
      kanban.setItem(
        { trackerId: trackerId.value, itemId: props2.id },
        {
          fields: {
            [store.getters.getTitleField]: titleField.value
          }
        }
      ).then((res) => {
        toast.success(`Success! Title saved.`);
      }).catch((err) => {
        if (!err.response)
          toast.error("Error: title not saved");
        const { code, errortitle, message } = err.response.data;
        const msg = `Code: ${code} - ${message}`;
        toast.error(msg);
      });
      store.dispatch("editCardField", {
        id: props2.id,
        field: "title",
        data: titleField.value
      });
    };
    const handleDescriptionInput = (event) => {
      description.value = event.target.value;
    };
    const handleEditDesc = () => {
      const ability = defineAbilityFor(store.getters.getRules);
      const canUpdate = ability.can("update", S$2("Tracker_Item", { itemId: props2.id }), store.getters.getDescriptionField);
      if (canUpdate)
        editDesc.value = true;
    };
    const handleSaveDesc = () => {
      kanban.setItem(
        { trackerId: trackerId.value, itemId: props2.id },
        {
          fields: {
            [store.getters.getDescriptionField]: description.value
          }
        }
      ).then((res) => {
        toast.success(`Success! Description saved.`);
      }).catch((err) => {
        if (!err.response)
          toast.error("Error: description not saved");
        const { code, errortitle, message } = err.response.data;
        const msg = `Code: ${code} - ${message}`;
        toast.error(msg);
      });
      store.dispatch("editCardField", {
        id: props2.id,
        field: "description",
        data: description.value
      });
      editDesc.value = false;
    };
    const handleCancel = () => {
      description.value = props2.desc;
      editDesc.value = false;
    };
    const handleCancelEditTitle = () => {
      titleField.value = props2.title;
      showEditField.value = false;
    };
    return (_ctx, _cache) => {
      const _directive_focus = resolveDirective("focus");
      const _directive_autosize = resolveDirective("autosize");
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", _hoisted_1$d, [
          !showEditField.value ? (openBlock(), createElementBlock("h4", {
            key: 0,
            onClick: handleEditClick
          }, toDisplayString(titleField.value), 1)) : createCommentVNode("v-if", true),
          showEditField.value ? (openBlock(), createElementBlock("div", _hoisted_2$d, [
            withDirectives(createVNode(unref(Field), {
              class: "form-control mb-1",
              as: "textarea",
              rows: "1",
              modelValue: titleField.value,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => titleField.value = $event),
              name: "cardTitle",
              type: "text",
              rules: { minLength: 1 }
            }, null, 8, ["modelValue"]), [
              [_directive_focus],
              [_directive_autosize]
            ]),
            createElementVNode("div", _hoisted_3$9, [
              createVNode(unref(Button), {
                class: "d-inline-block",
                variant: "default",
                sm: "",
                onClick: handleSaveTitle
              }, {
                default: withCtx(() => [
                  _hoisted_4$7
                ]),
                _: 1
              }),
              createVNode(unref(Button), {
                class: "d-inline-block ml-2",
                variant: "default",
                sm: "",
                onClick: handleCancelEditTitle
              }, {
                default: withCtx(() => [
                  _hoisted_5$6
                ]),
                _: 1
              })
            ])
          ])) : createCommentVNode("v-if", true)
        ]),
        __props.reference ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
          createElementVNode("small", null, [
            _hoisted_7$1,
            createElementVNode("a", {
              href: __props.reference,
              target: "_blank"
            }, "item-" + toDisplayString(__props.id), 9, _hoisted_8$2)
          ])
        ])) : createCommentVNode("v-if", true),
        _hoisted_9$1,
        !editDesc.value ? (openBlock(), createElementBlock("p", {
          key: 1,
          onClick: handleEditDesc
        }, [
          description.value.length === 0 ? (openBlock(), createElementBlock("div", {
            key: 0,
            onClick: handleEditDesc
          }, "Click to add description...")) : createCommentVNode("v-if", true),
          createTextVNode(" " + toDisplayString(description.value), 1)
        ])) : createCommentVNode("v-if", true),
        editDesc.value ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
          withDirectives((openBlock(), createElementBlock("textarea", {
            onInput: handleDescriptionInput,
            class: "form-control mb-2",
            name: "",
            id: ""
          }, [
            createTextVNode(toDisplayString(description.value), 1)
          ], 32)), [
            [_directive_autosize],
            [_directive_focus]
          ]),
          createElementVNode("div", null, [
            createVNode(unref(Button), {
              class: "d-inline-block",
              variant: "default",
              sm: "",
              onClick: handleSaveDesc
            }, {
              default: withCtx(() => [
                _hoisted_11$1
              ]),
              _: 1
            }),
            createVNode(unref(Button), {
              class: "d-inline-block ml-2",
              variant: "default",
              sm: "",
              onClick: handleCancel
            }, {
              default: withCtx(() => [
                _hoisted_12$1
              ]),
              _: 1
            })
          ])
        ])) : createCommentVNode("v-if", true)
      ], 64);
    };
  }
});
const FormEditCard = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__scopeId", "data-v-e30ad356"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/Forms/FormEditCard.vue"]]);
function C$1(e2) {
  return (C$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  })(e2);
}
function k$2(e2, t13, n2, o2, r2, i2, a3) {
  try {
    var l2 = e2[i2](a3), u2 = l2.value;
  } catch (e3) {
    return void n2(e3);
  }
  l2.done ? t13(u2) : Promise.resolve(u2).then(o2, r2);
}
function A$2(e2, t13) {
  for (var n2 = 0; n2 < t13.length; n2++) {
    var o2 = t13[n2];
    o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, o2.key, o2);
  }
}
function L$2(e2, t13, n2) {
  return t13 in e2 ? Object.defineProperty(e2, t13, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t13] = n2, e2;
}
function B$2(e2, t13) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    t13 && (o2 = o2.filter(function(t14) {
      return Object.getOwnPropertyDescriptor(e2, t14).enumerable;
    })), n2.push.apply(n2, o2);
  }
  return n2;
}
function _$2(e2) {
  for (var t13 = 1; t13 < arguments.length; t13++) {
    var n2 = null != arguments[t13] ? arguments[t13] : {};
    t13 % 2 ? B$2(Object(n2), true).forEach(function(t14) {
      L$2(e2, t14, n2[t14]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : B$2(Object(n2)).forEach(function(t14) {
      Object.defineProperty(e2, t14, Object.getOwnPropertyDescriptor(n2, t14));
    });
  }
  return e2;
}
function j$2(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return P$2(e3);
  }(e2) || function(e3) {
    if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
      return Array.from(e3);
  }(e2) || function(e3, t13) {
    if (!e3)
      return;
    if ("string" == typeof e3)
      return P$2(e3, t13);
    var n2 = Object.prototype.toString.call(e3).slice(8, -1);
    "Object" === n2 && e3.constructor && (n2 = e3.constructor.name);
    if ("Map" === n2 || "Set" === n2)
      return Array.from(e3);
    if ("Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return P$2(e3, t13);
  }(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function P$2(e2, t13) {
  (null == t13 || t13 > e2.length) && (t13 = e2.length);
  for (var n2 = 0, o2 = new Array(t13); n2 < t13; n2++)
    o2[n2] = e2[n2];
  return o2;
}
var I$2 = function(e2) {
  return function(e3, t13) {
    return j$2(e3.querySelectorAll(t13) || []);
  }(e2, 'button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=""]:not([disabled]), [contentEditable="true"]:not([disabled]), [contentEditable="TRUE"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex="-1"])');
}, V$2 = function(e2) {
  return e2 == document.activeElement;
}, D$2 = function() {
  function e2() {
    !function(e3, t14) {
      if (!(e3 instanceof t14))
        throw new TypeError("Cannot call a class as a function");
    }(this, e2), this.root = null, this.elements = [], this.onKeyDown = this.onKeyDown.bind(this), this.enable = this.enable.bind(this), this.disable = this.disable.bind(this), this.firstElement = this.firstElement.bind(this), this.lastElement = this.lastElement.bind(this);
  }
  var t13, n2;
  return t13 = e2, (n2 = [{ key: "lastElement", value: function() {
    return this.elements[this.elements.length - 1] || null;
  } }, { key: "firstElement", value: function() {
    return this.elements[0] || null;
  } }, { key: "onKeyDown", value: function(e3) {
    if (function(e4) {
      return "Tab" === e4.key || 9 === e4.keyCode;
    }(e3)) {
      if (!e3.shiftKey)
        return !document.activeElement || V$2(this.lastElement()) ? (this.firstElement().focus(), void e3.preventDefault()) : void 0;
      V$2(this.firstElement()) && (this.lastElement().focus(), e3.preventDefault());
    }
  } }, { key: "enabled", value: function() {
    return !!this.root;
  } }, { key: "enable", value: function(e3) {
    e3 && (this.root = e3, this.elements = I$2(this.root), this.root.addEventListener("keydown", this.onKeyDown));
  } }, { key: "disable", value: function() {
    this.root.removeEventListener("keydown", this.onKeyDown), this.root = null;
  } }]) && A$2(t13.prototype, n2), e2;
}(), N$2 = function(e2) {
  var t13 = e2.targetTouches ? e2.targetTouches[0] : e2;
  return { x: t13.clientX, y: t13.clientY };
}, R$2 = function(e2, t13, n2) {
  return "number" != typeof e2 && (e2 = Math.min(t13, n2) || t13), "number" != typeof n2 && (n2 = Math.max(t13, e2)), Math.min(Math.max(t13, e2), n2);
}, $$2 = function(e2) {
  return e2 && Number(e2.replace(/px$/, "")) || 0;
}, H$1 = { down: { pc: "mousedown", m: "touchstart" }, move: { pc: "mousemove", m: "touchmove" }, up: { pc: "mouseup", m: "touchend" } }, K$1 = function(e2, t13, n2) {
  t13 && t13.addEventListener(H$1[e2].pc, n2), t13 && t13.addEventListener(H$1[e2].m, n2, { passive: false });
}, U$1 = function(e2, t13, n2) {
  t13 && t13.removeEventListener(H$1[e2].pc, n2), t13 && t13.removeEventListener(H$1[e2].m, n2);
}, F$2 = false;
if ("undefined" != typeof window) {
  var W$1 = { get passive() {
    F$2 = true;
  } };
  window.addEventListener("testPassive", null, W$1), window.removeEventListener("testPassive", null, W$1);
}
var Y$2, q$2, G$1 = "undefined" != typeof window && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || "MacIntel" === window.navigator.platform && window.navigator.maxTouchPoints > 1), X$1 = [], Z$1 = false, J$2 = 0, Q$1 = -1, ee$1 = function(e2, t13) {
  var n2 = false;
  return function(e3) {
    for (var t14 = []; e3; ) {
      if (t14.push(e3), e3.classList.contains("vfm"))
        return t14;
      e3 = e3.parentElement;
    }
    return t14;
  }(e2).forEach(function(e3) {
    (function(e4) {
      if (!e4 || e4.nodeType !== Node.ELEMENT_NODE)
        return false;
      var t14 = window.getComputedStyle(e4);
      return ["auto", "scroll"].includes(t14.overflowY) && e4.scrollHeight > e4.clientHeight;
    })(e3) && function(e4, t14) {
      return !(0 === e4.scrollTop && t14 < 0 || e4.scrollTop + e4.clientHeight + t14 >= e4.scrollHeight && t14 > 0);
    }(e3, t13) && (n2 = true);
  }), n2;
}, te$1 = function(e2) {
  return X$1.some(function() {
    return ee$1(e2, -J$2);
  });
}, ne$1 = function(e2) {
  var t13 = e2 || window.event;
  return !!te$1(t13.target) || (t13.touches.length > 1 || (t13.preventDefault && t13.preventDefault(), false));
}, oe$1 = function(e2, t13) {
  if (e2) {
    if (!X$1.some(function(t14) {
      return t14.targetElement === e2;
    })) {
      var n2 = { targetElement: e2, options: t13 || {} };
      X$1 = [].concat(j$2(X$1), [n2]), G$1 ? (e2.ontouchstart = function(e3) {
        1 === e3.targetTouches.length && (Q$1 = e3.targetTouches[0].clientY);
      }, e2.ontouchmove = function(t14) {
        1 === t14.targetTouches.length && function(e3, t15) {
          J$2 = e3.targetTouches[0].clientY - Q$1, !te$1(e3.target) && (t15 && 0 === t15.scrollTop && J$2 > 0 || function(e4) {
            return !!e4 && e4.scrollHeight - e4.scrollTop <= e4.clientHeight;
          }(t15) && J$2 < 0 ? ne$1(e3) : e3.stopPropagation());
        }(t14, e2);
      }, Z$1 || (document.addEventListener("touchmove", ne$1, F$2 ? { passive: false } : void 0), Z$1 = true)) : function(e3) {
        if (void 0 === q$2) {
          var t14 = !!e3 && true === e3.reserveScrollBarGap, n3 = window.innerWidth - document.documentElement.clientWidth;
          if (t14 && n3 > 0) {
            var o2 = parseInt(getComputedStyle(document.body).getPropertyValue("padding-right"), 10);
            q$2 = document.body.style.paddingRight, document.body.style.paddingRight = "".concat(o2 + n3, "px");
          }
        }
        void 0 === Y$2 && (Y$2 = document.body.style.overflow, document.body.style.overflow = "hidden");
      }(t13);
    }
  } else
    console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.");
}, re$1 = function(e2) {
  e2 ? (X$1 = X$1.filter(function(t13) {
    return t13.targetElement !== e2;
  }), G$1 ? (e2.ontouchstart = null, e2.ontouchmove = null, Z$1 && 0 === X$1.length && (document.removeEventListener("touchmove", ne$1, F$2 ? { passive: false } : void 0), Z$1 = false)) : X$1.length || (void 0 !== q$2 && (document.body.style.paddingRight = q$2, q$2 = void 0), void 0 !== Y$2 && (document.body.style.overflow = Y$2, Y$2 = void 0))) : console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices.");
}, ie$1 = function() {
}, ae$1 = "enter", le$1 = "entering", ue$1 = "leave", se$1 = "leavng", fe$1 = { t: "ns-resize", tr: "nesw-resize", r: "ew-resize", br: "nwse-resize", b: "ns-resize", bl: "nesw-resize", l: "ew-resize", tl: "nwse-resize" }, de$1 = { props: { name: { type: String, default: null }, modelValue: { type: Boolean, default: false }, ssr: { type: Boolean, default: true }, classes: { type: [String, Object, Array], default: "" }, overlayClass: { type: [String, Object, Array], default: "" }, contentClass: { type: [String, Object, Array], default: "" }, styles: { type: [Object, Array], default: function() {
  return {};
} }, overlayStyle: { type: [Object, Array], default: function() {
  return {};
} }, contentStyle: { type: [Object, Array], default: function() {
  return {};
} }, lockScroll: { type: Boolean, default: true }, hideOverlay: { type: Boolean, default: false }, clickToClose: { type: Boolean, default: true }, escToClose: { type: Boolean, default: false }, preventClick: { type: Boolean, default: false }, attach: { type: null, default: false, validator: function(e2) {
  var t13 = C$1(e2);
  return "boolean" === t13 || "string" === t13 || e2.nodeType === Node.ELEMENT_NODE;
} }, transition: { type: [String, Object], default: "vfm" }, overlayTransition: { type: [String, Object], default: "vfm" }, keepOverlay: { type: Boolean, default: false }, zIndexAuto: { type: Boolean, default: true }, zIndexBase: { type: [String, Number], default: 1e3 }, zIndex: { type: [Boolean, String, Number], default: false }, focusRetain: { type: Boolean, default: true }, focusTrap: { type: Boolean, default: false }, fitParent: { type: Boolean, default: true }, drag: { type: Boolean, default: false }, dragSelector: { type: String, default: "" }, keepChangedStyle: { type: Boolean, default: false }, resize: { type: Boolean, default: false }, resizeDirections: { type: Array, default: function() {
  return ["t", "tr", "r", "br", "b", "bl", "l", "tl"];
}, validator: function(e2) {
  return ["t", "tr", "r", "br", "b", "bl", "l", "tl"].filter(function(t13) {
    return -1 !== e2.indexOf(t13);
  }).length === e2.length;
} }, minWidth: { type: Number, default: 0 }, minHeight: { type: Number, default: 0 }, maxWidth: { type: Number, default: 1 / 0 }, maxHeight: { type: Number, default: 1 / 0 } }, emits: ["update:modelValue", "click-outside", "before-open", "opened", "before-close", "closed", "_before-open", "_opened", "_closed", "drag:start", "drag:move", "drag:end", "resize:start", "resize:move", "resize:end"], setup: function(l2, u2) {
  var s3 = u2.emit, f2 = Symbol("vfm"), d3 = ref(null), c2 = ref(null), v2 = ref(null), p2 = ref(null), m3 = ref(null), y2 = ref(null), h3 = ref(null), b2 = new D$2(), g2 = ref(false), w2 = reactive({ modal: false, overlay: false, resize: false }), x2 = ref(null), E2 = ref(null), S3 = ref(false), O2 = ref({}), z2 = ref({}), M3 = ref(null), T2 = ref(null), C2 = ie$1, k2 = ie$1, A3 = computed(function() {
    return "string" == typeof l2.overlayTransition ? { name: l2.overlayTransition } : _$2({}, l2.overlayTransition);
  }), B2 = computed(function() {
    return "string" == typeof l2.transition ? { name: l2.transition } : _$2({}, l2.transition);
  }), P2 = computed(function() {
    return (l2.hideOverlay || x2.value === ue$1) && E2.value === ue$1;
  }), I2 = computed(function() {
    return false === l2.zIndex ? !!l2.zIndexAuto && +l2.zIndexBase + 2 * (h3.value || 0) : l2.zIndex;
  }), V = computed(function() {
    return _$2({}, false !== I2.value && { zIndex: I2.value });
  }), H3 = computed(function() {
    var e2 = [z2.value];
    return Array.isArray(l2.contentStyle) ? e2.push.apply(e2, j$2(l2.contentStyle)) : e2.push(l2.contentStyle), e2;
  });
  function F2() {
    return { uid: f2, props: l2, emit: s3, vfmContainer: c2, vfmContent: v2, vfmResize: p2, vfmOverlayTransition: m3, vfmTransition: y2, getAttachElement: G2, modalStackIndex: h3, visibility: w2, handleLockScroll: q, $focusTrap: b2, toggle: Q, params: O2 };
  }
  function W3() {
    if (l2.modelValue) {
      if (s3("_before-open", X({ type: "_before-open" })), Z3("before-open", false))
        return void k2("show");
      var e2 = G2();
      if (e2 || false === l2.attach) {
        if (false !== l2.attach) {
          if (!d3.value)
            return g2.value = true, void nextTick(function() {
              W3();
            });
          e2.appendChild(d3.value);
        }
        var t13 = l2.api.openedModals.findIndex(function(e3) {
          return e3.uid === f2;
        });
        -1 !== t13 && l2.api.openedModals.splice(t13, 1), l2.api.openedModals.push(F2()), h3.value = l2.api.openedModals.length - 1, q(), l2.api.openedModals.filter(function(e3) {
          return e3.uid !== f2;
        }).forEach(function(t14, n2) {
          t14.getAttachElement() === e2 && (t14.modalStackIndex.value = n2, !t14.props.keepOverlay && (t14.visibility.overlay = false));
        }), g2.value = true, w2.overlay = true, w2.modal = true;
      } else
        false !== e2 && console.warn("Unable to locate target ".concat(l2.attach));
    }
  }
  function Y2() {
    var e2 = l2.api.openedModals.findIndex(function(e3) {
      return e3.uid === f2;
    });
    if (-1 !== e2 && l2.api.openedModals.splice(e2, 1), l2.api.openedModals.length > 0) {
      var t13 = l2.api.openedModals[l2.api.openedModals.length - 1];
      t13.props.focusTrap && t13.$focusTrap.firstElement().focus(), (t13.props.focusRetain || t13.props.focusTrap) && t13.vfmContainer.value.focus(), !t13.props.hideOverlay && (t13.visibility.overlay = true);
    }
    l2.drag && ne2(), l2.resize && ce2(), M3.value = null, w2.overlay = false, w2.modal = false;
  }
  function q() {
    l2.modelValue && nextTick(function() {
      l2.lockScroll ? oe$1(c2.value, { reserveScrollBarGap: true }) : re$1(c2.value);
    });
  }
  function G2() {
    return false !== l2.attach && ("string" == typeof l2.attach ? !!window && window.document.querySelector(l2.attach) : l2.attach);
  }
  function X() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return _$2({ ref: F2() }, e2);
  }
  function Z3(e2, t13) {
    var n2 = false, o2 = X({ type: e2, stop: function() {
      n2 = true;
    } });
    return s3(e2, o2), !!n2 && (S3.value = true, nextTick(function() {
      s3("update:modelValue", t13);
    }), true);
  }
  function J2(e2, t13, n2) {
    M3.value = "".concat(t13, ":").concat(n2), s3(M3.value, e2);
  }
  function Q(e2, t13) {
    var n2 = arguments;
    return new Promise(function(o2, r2) {
      C2 = function(e3) {
        o2(e3), C2 = ie$1;
      }, k2 = function(e3) {
        r2(e3), k2 = ie$1;
      };
      var i2 = "boolean" == typeof e2 ? e2 : !l2.modelValue;
      i2 && 2 === n2.length && (O2.value = t13), s3("update:modelValue", i2);
    });
  }
  function ee2(e2) {
    e2.stopPropagation();
    var t13, n2 = "resize", o2 = "drag", r2 = e2.target.getAttribute("direction");
    if (r2)
      t13 = n2;
    else {
      if (!function(e3, t14, n3) {
        return "" === n3 || j$2(t14.querySelectorAll(n3)).includes(e3.target);
      }(e2, v2.value, l2.dragSelector))
        return;
      t13 = o2;
    }
    J2(e2, t13, "start");
    var i2, a3, u3, s4, f3 = N$2(e2), d4 = c2.value.getBoundingClientRect(), p3 = v2.value.getBoundingClientRect(), m4 = "absolute" === window.getComputedStyle(v2.value).position, y3 = $$2(z2.value.top), h4 = $$2(z2.value.left), b3 = function() {
      if (l2.fitParent) {
        var e3 = { absolute: function() {
          return { minTop: 0, minLeft: 0, maxTop: d4.height - p3.height, maxLeft: d4.width - p3.width };
        }, relative: function() {
          return { minTop: y3 + d4.top - p3.top, minLeft: h4 + d4.left - p3.left, maxTop: y3 + d4.bottom - p3.bottom, maxLeft: h4 + d4.right - p3.right };
        } };
        return m4 ? e3.absolute() : e3.relative();
      }
      return {};
    }(), g3 = t13 === n2 && (i2 = document.body, a3 = "cursor", u3 = fe$1[r2], s4 = i2.style[a3], i2.style[a3] = u3, function() {
      i2.style[a3] = s4;
    }), w3 = function(e3) {
      e3.stopPropagation(), J2(e3, t13, "move");
      var i3, a4, u4 = N$2(e3), s5 = { x: u4.x - f3.x, y: u4.y - f3.y };
      t13 === n2 && (s5 = function(e4, t14, n3, o3, r3) {
        var i4 = function(e5) {
          var n4, o4 = t14[e5.axis];
          o4 = l2.fitParent ? R$2(e5.min, o4, e5.max) : o4;
          var i5 = R$2(e5.minEdge, e5.getEdge(o4), e5.maxEdge);
          return o4 = e5.getOffsetAxis(i5, r3), L$2(n4 = {}, e5.edgeName, i5), L$2(n4, e5.axis, o4), n4;
        }, a5 = function(e5, t15, r4, i5) {
          var a6, u6 = o3[t15], s7 = n3[e5] - o3[e5], f4 = (a6 = t15).charAt(0).toUpperCase() + a6.slice(1);
          return { axis: r4, edgeName: t15, min: i5 ? s7 : -u6, max: i5 ? u6 : s7, minEdge: l2["min".concat(f4)], maxEdge: l2["max".concat(f4)], getEdge: function(e6) {
            return o3[t15] - e6 * (i5 ? 1 : -1);
          }, getOffsetAxis: function(e6, n4) {
            var r5 = o3[t15] - e6;
            return n4 ? i5 ? r5 : 0 : (i5 ? 1 : -1) * r5 / 2;
          } };
        }, u5 = { t: ["top", "height", "y", true], b: ["bottom", "height", "y", false], l: ["left", "width", "x", true], r: ["right", "width", "x", false] }, s6 = { x: 0, y: 0 };
        return e4.split("").forEach(function(e5) {
          var t15 = a5.apply(void 0, j$2(u5[e5]));
          s6 = _$2(_$2({}, s6), i4(t15));
        }), s6;
      }(r2, s5, d4, p3, m4)), m4 ? (i3 = p3.top - d4.top + s5.y, a4 = p3.left - d4.left + s5.x) : (i3 = y3 + s5.y, a4 = h4 + s5.x), t13 === o2 && l2.fitParent && (i3 = R$2(b3.minTop, i3, b3.maxTop), a4 = R$2(b3.minLeft, a4, b3.maxLeft));
      var c3 = _$2(_$2(_$2({ position: "relative", top: i3 + "px", left: a4 + "px", margin: "unset", touchAction: "none" }, m4 && { position: "absolute", transform: "unset", width: p3.width + "px", height: p3.height + "px" }), s5.width && { width: s5.width + "px" }), s5.height && { height: s5.height + "px" });
      z2.value = _$2(_$2({}, z2.value), c3);
    };
    K$1("move", document, w3), K$1("up", document, function e3(o3) {
      o3.stopPropagation(), t13 === n2 && g3 && g3(), setTimeout(function() {
        J2(o3, t13, "end");
      }), U$1("move", document, w3), U$1("up", document, e3);
    });
  }
  function te2() {
    K$1("down", v2.value, ee2), z2.value.touchAction = "none";
  }
  function ne2() {
    U$1("down", v2.value, ee2);
  }
  function de2() {
    w2.resize = true, nextTick(function() {
      K$1("down", p2.value, ee2);
    });
  }
  function ce2() {
    U$1("down", p2.value, ee2), w2.resize = false;
  }
  return watch(function() {
    return l2.modelValue;
  }, function(e2) {
    if (S3.value)
      S3.value = false;
    else if (W3(), !e2) {
      if (Z3("before-close", true))
        return void k2("hide");
      Y2();
    }
  }), watch(function() {
    return l2.lockScroll;
  }, q), watch(function() {
    return l2.hideOverlay;
  }, function(e2) {
    l2.modelValue && !e2 && (w2.overlay = true);
  }), watch(function() {
    return l2.attach;
  }, W3), watch(P2, function(e2) {
    e2 && (g2.value = false, c2.value.style.display = "none");
  }, { flush: "post" }), watch(function() {
    return l2.drag;
  }, function(e2) {
    g2.value && (e2 ? te2() : ne2());
  }), watch(function() {
    return l2.resize;
  }, function(e2) {
    g2.value && (e2 ? de2() : ce2());
  }), watch(function() {
    return l2.keepChangedStyle;
  }, function(e2) {
    e2 || (z2.value = {});
  }), l2.api.modals.push(F2()), onMounted(function() {
    W3();
  }), onBeforeUnmount(function() {
    var e2;
    Y2(), l2.lockScroll && c2.value && re$1(c2.value), null == d3 || null === (e2 = d3.value) || void 0 === e2 || e2.remove();
    var t13 = l2.api.modals.findIndex(function(e3) {
      return e3.uid === f2;
    });
    l2.api.modals.splice(t13, 1);
  }), { root: d3, vfmContainer: c2, vfmContent: v2, vfmResize: p2, vfmOverlayTransition: m3, vfmTransition: y2, computedOverlayTransition: A3, computedTransition: B2, visible: g2, visibility: w2, params: O2, calculateZIndex: I2, bindStyle: V, bindContentStyle: H3, beforeOverlayEnter: function() {
    x2.value = le$1;
  }, afterOverlayEnter: function() {
    x2.value = ae$1;
  }, beforeOverlayLeave: function() {
    x2.value = se$1;
  }, afterOverlayLeave: function() {
    x2.value = ue$1;
  }, beforeModalEnter: function() {
    E2.value = le$1;
  }, afterModalEnter: function() {
    E2.value = ae$1, (l2.focusRetain || l2.focusTrap) && c2.value.focus(), l2.focusTrap && b2.enable(c2.value), l2.drag && te2(), l2.resize && de2(), s3("_opened"), s3("opened", X({ type: "opened" })), C2("show");
  }, beforeModalLeave: function() {
    E2.value = se$1, b2.enabled() && b2.disable();
  }, afterModalLeave: function() {
    E2.value = ue$1, h3.value = null, l2.lockScroll && re$1(c2.value), l2.keepChangedStyle || (z2.value = {});
    var e2 = false, t13 = X({ type: "closed", stop: function() {
      e2 = true;
    } });
    s3("_closed"), s3("closed", t13), C2("hide"), e2 || (O2.value = {});
  }, onMousedown: function(e2) {
    T2.value = null == e2 ? void 0 : e2.target;
  }, onMouseupContainer: function() {
    T2.value === c2.value && "resize:move" !== M3.value && (s3("click-outside", X({ type: "click-outside" })), l2.clickToClose && s3("update:modelValue", false));
  }, onEsc: function() {
    g2.value && l2.escToClose && s3("update:modelValue", false);
  } };
} }, ce$1 = withScopeId("data-v-2836fdb5");
pushScopeId("data-v-2836fdb5");
var ve$1 = { key: 0, ref: "vfmResize", class: "vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none" };
popScopeId();
var pe$1 = ce$1(function(e2, t13, n2, o2, r2, i2) {
  return n2.ssr || o2.visible ? withDirectives((openBlock(), createBlock("div", { key: 0, ref: "root", style: o2.bindStyle, class: ["vfm vfm--inset", [false === n2.attach ? "vfm--fixed" : "vfm--absolute", { "vfm--prevent-none": n2.preventClick }]], onKeydown: t13[4] || (t13[4] = withKeys(function() {
    return o2.onEsc && o2.onEsc.apply(o2, arguments);
  }, ["esc"])) }, [createVNode(Transition, mergeProps(o2.computedOverlayTransition, { onBeforeEnter: o2.beforeOverlayEnter, onAfterEnter: o2.afterOverlayEnter, onBeforeLeave: o2.beforeOverlayLeave, onAfterLeave: o2.afterOverlayLeave }), { default: ce$1(function() {
    return [!n2.hideOverlay && o2.visibility.overlay ? (openBlock(), createBlock("div", { key: 0, class: ["vfm__overlay vfm--overlay vfm--absolute vfm--inset", n2.overlayClass], style: n2.overlayStyle }, null, 6)) : createCommentVNode("v-if", true)];
  }), _: 1 }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"]), createVNode(Transition, mergeProps(o2.computedTransition, { onBeforeEnter: o2.beforeModalEnter, onAfterEnter: o2.afterModalEnter, onBeforeLeave: o2.beforeModalLeave, onAfterLeave: o2.afterModalLeave }), { default: ce$1(function() {
    return [withDirectives(createVNode("div", { ref: "vfmContainer", class: ["vfm__container vfm--absolute vfm--inset vfm--outline-none", n2.classes], style: n2.styles, "aria-expanded": o2.visibility.modal.toString(), role: "dialog", "aria-modal": "true", tabindex: "-1", onMouseup: t13[2] || (t13[2] = withModifiers(function() {
      return o2.onMouseupContainer && o2.onMouseupContainer.apply(o2, arguments);
    }, ["self"])), onMousedown: t13[3] || (t13[3] = withModifiers(function() {
      return o2.onMousedown && o2.onMousedown.apply(o2, arguments);
    }, ["self"])) }, [createVNode("div", { ref: "vfmContent", class: ["vfm__content", [n2.contentClass, { "vfm--prevent-auto": n2.preventClick }]], style: o2.bindContentStyle, onMousedown: t13[1] || (t13[1] = function(e3) {
      return o2.onMousedown(null);
    }) }, [renderSlot(e2.$slots, "default", { params: o2.params, close: function() {
      return e2.$emit("update:modelValue", false);
    } }), o2.visibility.resize && o2.visibility.modal ? (openBlock(), createBlock("div", ve$1, [(openBlock(true), createBlock(Fragment, null, renderList(n2.resizeDirections, function(e3) {
      return openBlock(), createBlock("div", { key: e3, direction: e3, class: ["vfm--resize-".concat(e3), "vfm--absolute vfm--prevent-auto"] }, null, 10, ["direction"]);
    }), 128))], 512)) : createCommentVNode("v-if", true)], 38)], 46, ["aria-expanded"]), [[vShow, o2.visibility.modal]])];
  }), _: 3 }, 16, ["onBeforeEnter", "onAfterEnter", "onBeforeLeave", "onAfterLeave"])], 38)), [[vShow, !n2.ssr || o2.visible]]) : createCommentVNode("v-if", true);
});
!function(e2, t13) {
  void 0 === t13 && (t13 = {});
  var n2 = t13.insertAt;
  if (e2 && "undefined" != typeof document) {
    var o2 = document.head || document.getElementsByTagName("head")[0], r2 = document.createElement("style");
    r2.type = "text/css", "top" === n2 && o2.firstChild ? o2.insertBefore(r2, o2.firstChild) : o2.appendChild(r2), r2.styleSheet ? r2.styleSheet.cssText = e2 : r2.appendChild(document.createTextNode(e2));
  }
}("\n.vfm--fixed[data-v-2836fdb5] {\n  position: fixed;\n}\n.vfm--absolute[data-v-2836fdb5] {\n  position: absolute;\n}\n.vfm--inset[data-v-2836fdb5] {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay[data-v-2836fdb5] {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none[data-v-2836fdb5] {\n  pointer-events: none;\n}\n.vfm--prevent-auto[data-v-2836fdb5] {\n  pointer-events: auto;\n}\n.vfm--outline-none[data-v-2836fdb5]:focus {\n  outline: none;\n}\n.vfm-enter-active[data-v-2836fdb5],\n.vfm-leave-active[data-v-2836fdb5] {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from[data-v-2836fdb5],\n.vfm-leave-to[data-v-2836fdb5] {\n  opacity: 0;\n}\n.vfm--touch-none[data-v-2836fdb5] {\n  touch-action: none;\n}\n.vfm--select-none[data-v-2836fdb5] {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n}\n.vfm--resize-tr[data-v-2836fdb5],\n.vfm--resize-br[data-v-2836fdb5],\n.vfm--resize-bl[data-v-2836fdb5],\n.vfm--resize-tl[data-v-2836fdb5] {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n.vfm--resize-t[data-v-2836fdb5] {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr[data-v-2836fdb5] {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r[data-v-2836fdb5] {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br[data-v-2836fdb5] {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b[data-v-2836fdb5] {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl[data-v-2836fdb5] {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l[data-v-2836fdb5] {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl[data-v-2836fdb5] {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n"), de$1.render = pe$1, de$1.__scopeId = "data-v-2836fdb5", de$1.__file = "lib/VueFinalModal.vue";
var me$1 = { props: {}, methods: { slice: function(e2) {
  this.api.dynamicModals.splice(e2, 1);
}, beforeOpen: function(e2, t13, n2) {
  var o2, r2 = this;
  return (o2 = function* () {
    e2.ref.params.value = t13.params, yield r2.$nextTick(), yield r2.$nextTick(), t13.value || (r2.slice(n2), t13.reject("show"));
  }, function() {
    var e3 = this, t14 = arguments;
    return new Promise(function(n3, r3) {
      var i2 = o2.apply(e3, t14);
      function a3(e4) {
        k$2(i2, n3, r3, a3, l2, "next", e4);
      }
      function l2(e4) {
        k$2(i2, n3, r3, a3, l2, "throw", e4);
      }
      a3(void 0);
    });
  })();
}, isString: function(e2) {
  return "string" == typeof e2;
} } }, ye$1 = { class: "modals-container" };
function he$1(e2, t13) {
  var n2 = _$2(_$2({}, e2), {}, { props: _$2({}, e2.props) });
  return Object.assign(n2.props, { api: { type: Object, default: function() {
    return t13;
  } } }), n2;
}
me$1.render = function(e2, t13, n2, o2, r2, i2) {
  return openBlock(), createBlock("div", ye$1, [(openBlock(true), createBlock(Fragment, null, renderList(e2.api.dynamicModals, function(e3, t14) {
    return openBlock(), createBlock(resolveDynamicComponent(e3.component), mergeProps({ key: e3.id }, e3.bind, { modelValue: e3.value, "onUpdate:modelValue": function(t15) {
      return e3.value = t15;
    } }, toHandlers(e3.on), { on_closed: function(e4) {
      return i2.slice(t14);
    }, on_beforeOpen: function(t15) {
      return i2.beforeOpen(t15, e3);
    }, on_opened: e3.opened }), createSlots({ _: 2 }, [renderList(e3.slots, function(e4, t15) {
      return { name: t15, fn: withCtx(function() {
        return [createCommentVNode(" eslint-disable vue/no-v-html "), i2.isString(e4) ? (openBlock(), createBlock("div", { key: 0, innerHTML: e4 }, null, 8, ["innerHTML"])) : (openBlock(), createBlock(resolveDynamicComponent(e4.component), mergeProps({ key: 1 }, e4.bind, toHandlers(e4.on || {})), null, 16))];
      }) };
    })]), 1040, ["modelValue", "onUpdate:modelValue", "on_closed", "on_beforeOpen", "on_opened"]);
  }), 128))]);
}, me$1.__file = "lib/ModalsContainer.vue";
var ge$1 = function() {
  var e2, t13, n2 = (t13 = null, { show: function(e3) {
    for (var n3 = this, o2 = arguments.length, r2 = new Array(o2 > 1 ? o2 - 1 : 0), i2 = 1; i2 < o2; i2++)
      r2[i2 - 1] = arguments[i2];
    switch (C$1(e3)) {
      case "string":
        return this.toggle.apply(this, [e3, true].concat(r2));
      case "object":
        return Promise.allSettled([new Promise(function(o3, i3) {
          var a3 = { value: true, id: Symbol("dynamicModal"), component: t13, bind: {}, slots: {}, on: {}, params: r2[0], reject: i3, opened: function() {
            o3("show");
          } };
          n3.dynamicModals.push(shallowReactive(Object.assign(a3, e3)));
        })]);
    }
  }, hide: function() {
    for (var e3 = arguments.length, t14 = new Array(e3), n3 = 0; n3 < e3; n3++)
      t14[n3] = arguments[n3];
    return this.toggle(t14, false);
  }, hideAll: function() {
    return this.hide.apply(this, j$2(this.openedModals.map(function(e3) {
      return e3.props.name;
    })));
  }, toggle: function(e3) {
    for (var t14 = arguments.length, n3 = new Array(t14 > 1 ? t14 - 1 : 0), o2 = 1; o2 < t14; o2++)
      n3[o2 - 1] = arguments[o2];
    var r2 = Array.isArray(e3) ? this.get.apply(this, j$2(e3)) : this.get(e3);
    return Promise.allSettled(r2.map(function(e4) {
      return e4.toggle.apply(e4, n3);
    }));
  }, get: function() {
    for (var e3 = arguments.length, t14 = new Array(e3), n3 = 0; n3 < e3; n3++)
      t14[n3] = arguments[n3];
    return this.modals.filter(function(e4) {
      return t14.includes(e4.props.name);
    });
  }, dynamicModals: shallowReactive([]), openedModals: [], modals: [], _setDefaultModal: function(e3) {
    t13 = e3;
  } });
  return L$2(e2 = {}, "$vfm", n2), L$2(e2, "VueFinalModal", function(e3) {
    var t14 = he$1(de$1, e3);
    return e3._setDefaultModal(t14), t14;
  }(n2)), L$2(e2, "ModalsContainer", function(e3) {
    return he$1(me$1, e3);
  }(n2)), e2;
}, we$1 = ge$1();
we$1.$vfm;
var Ee$1 = we$1.VueFinalModal;
we$1.ModalsContainer;
const KanbanColumns_vue_vue_type_style_index_0_scoped_52824979_lang = "";
const _withScopeId$7 = (n2) => (pushScopeId("data-v-52824979"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$c = {
  key: 0,
  class: "d-flex"
};
const _hoisted_2$c = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-times" }, null, -1));
const _hoisted_3$8 = { class: "w-100" };
const __default__$2 = {
  name: "KanbanColumns"
};
const _sfc_main$e = /* @__PURE__ */ Object.assign(__default__$2, {
  props: {
    cellIds: {
      type: Array,
      default() {
        return [];
      }
    },
    rowId: {
      type: Number
    },
    rowValue: [Number, String],
    rowIndex: {
      type: Number
    }
  },
  setup(__props) {
    const props2 = __props;
    const dragging = ref(false);
    const showModal = ref(false);
    const card = ref(false);
    ref(false);
    const getCells = computed(() => store.getters.getCells(props2.cellIds));
    const getCols = computed(() => store.getters.getCols);
    const startDragging = () => dragging.value = true;
    const endDragging = () => dragging.value = false;
    const handleChange = (event) => {
      if (event.moved) {
        store.dispatch("moveColumn", {
          oldIndex: event.moved.oldIndex,
          newIndex: event.moved.newIndex,
          element: event.moved.element,
          rowId: props2.rowId
        });
      } else if (event.added) {
        store.dispatch("addCell", {
          newIndex: event.added.newIndex,
          element: event.added.element,
          rowId: props2.rowId
        });
      } else if (event.removed) {
        store.dispatch("removeCell", {
          oldIndex: event.removed.oldIndex,
          element: event.removed.element,
          rowId: props2.rowId
        });
      }
    };
    const handleEditCard = (element) => {
      card.value = element;
      showModal.value = true;
    };
    const handleClickOutside = () => {
      showModal.value = false;
    };
    const handleModalClosed = () => {
      showModal.value = false;
    };
    return (_ctx, _cache) => {
      const _component_PerfectScrollbar = resolveComponent("PerfectScrollbar");
      resolveComponent("DatePicker");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(draggableComponent), {
          list: unref(getCells),
          group: "cells",
          "item-key": "id",
          class: "container-cells",
          chosenClass: "chosen-cell",
          ghostClass: "ghost-cell",
          dragClass: "dragging-cell",
          handle: ".drag-handle-cell",
          onChange: handleChange,
          onStart: startDragging,
          onEnd: endDragging,
          forceFallback: true,
          animation: 200
        }, {
          item: withCtx(({ element, index: index2 }) => [
            createVNode(KanbanColumn, {
              rowIndex: __props.rowIndex,
              colIndex: index2,
              cellId: element.id,
              columnValue: unref(getCols)[index2].value,
              rowValue: __props.rowValue,
              colId: unref(getCols)[index2].id,
              title: unref(getCols)[index2].title,
              limit: unref(getCols)[index2].wip,
              total: unref(store).getters.getCardsByCol(index2).length
            }, {
              default: withCtx(() => [
                createVNode(_component_PerfectScrollbar, {
                  class: "d-flex h-100",
                  options: { suppressScrollX: true }
                }, {
                  default: withCtx(() => [
                    createVNode(KanbanCards, {
                      cellId: element.id,
                      rowId: __props.rowId,
                      columnValue: unref(getCols)[index2].value,
                      rowValue: __props.rowValue,
                      cardIds: element.cards,
                      onEditCard: handleEditCard
                    }, null, 8, ["cellId", "rowId", "columnValue", "rowValue", "cardIds"])
                  ]),
                  _: 2
                }, 1024)
              ]),
              _: 2
            }, 1032, ["rowIndex", "colIndex", "cellId", "columnValue", "rowValue", "colId", "title", "limit", "total"])
          ]),
          _: 1
        }, 8, ["list"]),
        createVNode(unref(Ee$1), {
          modelValue: showModal.value,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => showModal.value = $event),
          classes: "f-modal-container",
          "content-class": "f-modal-content",
          drag: false,
          resize: false,
          "fit-parent": false,
          onClickOutside: handleClickOutside,
          onClosed: handleModalClosed
        }, {
          default: withCtx(() => [
            showModal.value ? (openBlock(), createElementBlock("div", _hoisted_1$c, [
              createVNode(unref(Button), {
                class: "f-modal-close",
                variant: "default",
                onClick: _cache[0] || (_cache[0] = ($event) => showModal.value = false)
              }, {
                default: withCtx(() => [
                  _hoisted_2$c
                ]),
                _: 1
              }),
              createElementVNode("div", _hoisted_3$8, [
                createVNode(FormEditCard, {
                  id: card.value.id,
                  title: card.value.title,
                  desc: card.value.description,
                  reference: `tiki-view_tracker_item.php?itemId=${card.value.id}`
                }, null, 8, ["id", "title", "desc", "reference"])
              ]),
              createCommentVNode("v-if", true)
            ])) : createCommentVNode("v-if", true)
          ]),
          _: 1
        }, 8, ["modelValue"])
      ], 64);
    };
  }
});
const KanbanColumns = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__scopeId", "data-v-52824979"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/KanbanColumns.vue"]]);
const KanbanBoard_vue_vue_type_style_index_0_scoped_1f155bab_lang = "";
const _withScopeId$6 = (n2) => (pushScopeId("data-v-1f155bab"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$b = {
  key: 0,
  style: { "font-size": "1.25rem", "font-weight": "500" }
};
const _hoisted_2$b = {
  key: 1,
  class: "mx-2"
};
const _hoisted_3$7 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode("i", { class: "fas fa-spinner fa-spin" }, null, -1));
const _hoisted_4$6 = [
  _hoisted_3$7
];
const _hoisted_5$5 = {
  key: 2,
  class: "mx-2"
};
const _hoisted_8$1 = { class: "board-container" };
const __default__$1 = {
  name: "KanbanBoard"
};
const _sfc_main$d = /* @__PURE__ */ Object.assign(__default__$1, {
  props: {
    id: {
      type: Number
    },
    loading: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props2 = __props;
    const board = computed(() => store.getters.getBoard(props2.id));
    const getUserName = computed(() => {
      const user = store.getters.getUser;
      if (user && user.user)
        return user.user;
      return user ? user : "guest";
    });
    const showEditField = ref(false);
    const toast = useToast();
    const handleTitleBlur = (event) => {
      showEditField.value = false;
      if (event.target.value.length < 1) {
        toast.error(`This field must be at least 1 character`);
        return;
      }
      store.dispatch("editBoardField", {
        id: props2.id,
        field: "title",
        data: event.target.value
      });
    };
    return (_ctx, _cache) => {
      const _component_PerfectScrollbar = resolveComponent("PerfectScrollbar");
      const _directive_focus = resolveDirective("focus");
      const _directive_autosize = resolveDirective("autosize");
      return openBlock(), createElementBlock("div", {
        class: "kanban-container",
        style: normalizeStyle({ backgroundImage: unref(board).imageUrl ? `url(${unref(board).imageUrl})` : "none" })
      }, [
        createCommentVNode(` <nav class="navbar navbar-light rounded-lg bg-color-grey" :class="{'bg-color-transparent': board.imageUrl, 'bg-light': !board.imageUrl}"> `),
        createElementVNode("nav", {
          class: normalizeClass(["navbar navbar-light", { "bg-color-transparent": unref(board).imageUrl }])
        }, [
          createElementVNode("div", null, [
            !showEditField.value ? (openBlock(), createElementBlock("span", _hoisted_1$b, toDisplayString(unref(board).title), 1)) : createCommentVNode("v-if", true),
            __props.loading ? (openBlock(), createElementBlock("span", _hoisted_2$b, _hoisted_4$6)) : createCommentVNode("v-if", true),
            !__props.loading ? (openBlock(), createElementBlock("span", _hoisted_5$5, "(" + toDisplayString(unref(getUserName)) + ")", 1)) : createCommentVNode("v-if", true),
            showEditField.value ? withDirectives((openBlock(), createBlock(unref(Field), {
              key: 3,
              as: "textarea",
              rows: "1",
              value: unref(board).title,
              onBlur: handleTitleBlur,
              name: "rowTitle",
              type: "text",
              rules: { minLength: 1 }
            }, null, 8, ["value"])), [
              [_directive_focus],
              [_directive_autosize]
            ]) : createCommentVNode("v-if", true)
          ]),
          createCommentVNode("v-if", true)
        ], 2),
        createVNode(_component_PerfectScrollbar, { class: "d-flex" }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_8$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(store).getters.getRows(unref(board).rows), (row, index2) => {
                return openBlock(), createBlock(KanbanRow, {
                  key: row.title,
                  title: row.title,
                  transparentTitleBg: unref(board).imageUrl ? true : false,
                  boardId: __props.id,
                  rowId: row.id,
                  rowValue: row.value,
                  index: index2
                }, {
                  default: withCtx(() => [
                    createVNode(KanbanColumns, {
                      rowId: row.id,
                      rowIndex: index2,
                      rowValue: row.value,
                      cellIds: row.cells
                    }, null, 8, ["rowId", "rowIndex", "rowValue", "cellIds"]),
                    index2 === 0 ? (openBlock(), createBlock(ButtonAddColumn, {
                      key: 0,
                      rowId: row.id
                    }, null, 8, ["rowId"])) : createCommentVNode("v-if", true)
                  ]),
                  _: 2
                }, 1032, ["title", "transparentTitleBg", "boardId", "rowId", "rowValue", "index"]);
              }), 128))
            ])
          ]),
          _: 1
        })
      ], 4);
    };
  }
});
const KanbanBoard = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__scopeId", "data-v-1f155bab"], ["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/components/KanbanBoard.vue"]]);
const __default__ = {
  name: "App"
};
const _sfc_main$c = /* @__PURE__ */ Object.assign(__default__, {
  props: {
    customProps: {
      type: Object
    }
  },
  setup(__props) {
    const props2 = __props;
    const boardId = ref(props2.customProps.kanbanData.trackerId);
    const loading = ref(false);
    onBeforeMount(() => {
      console.log(props2.customProps.kanbanData);
      loading.value = false;
      const cardsAllIds = props2.customProps.kanbanData.cards.map((card) => card.id);
      props2.customProps.kanbanData.cards = [...new Set(cardsAllIds)].map((id) => {
        return props2.customProps.kanbanData.cards.find((card) => card.id === id);
      });
      store.dispatch("initBoard", props2.customProps.kanbanData);
      store.dispatch("setUser", props2.customProps.kanbanData.user);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createCommentVNode(' <Sidebar>\n        <template v-slot:sidebar-content>\n            <Sidemenu @boardId="setBoardId"/>\n        </template>\n        <KanbanBoard :id="boardId" />\n    </Sidebar> '),
        createVNode(KanbanBoard, {
          id: boardId.value,
          loading: loading.value
        }, null, 8, ["id", "loading"])
      ], 2112);
    };
  }
});
const App = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "/home/benoitg/development/tiki/lib/vue-mf/kanban/src/App.vue"]]);
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function isObject$1(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainObject$1(o2) {
  var ctor, prot;
  if (isObject$1(o2) === false)
    return false;
  ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject$1(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function t$1() {
  return t$1 = Object.assign || function(e2) {
    for (var t13 = 1; t13 < arguments.length; t13++) {
      var r2 = arguments[t13];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, t$1.apply(this, arguments);
}
function r$1(e2, t13) {
  if (null == e2)
    return {};
  var r2, n2, i2 = {}, o2 = Object.keys(e2);
  for (n2 = 0; n2 < o2.length; n2++)
    t13.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e2[r2]);
  return i2;
}
const n$1 = { silent: false, logLevel: "warn" }, i$1 = ["validator"], o$1 = Object.prototype, a$1 = o$1.toString, s$1 = o$1.hasOwnProperty, u$1 = /^\s*function (\w+)/;
function l$1(e2) {
  var t13;
  const r2 = null !== (t13 = null == e2 ? void 0 : e2.type) && void 0 !== t13 ? t13 : e2;
  if (r2) {
    const e3 = r2.toString().match(u$1);
    return e3 ? e3[1] : "";
  }
  return "";
}
const c$1 = isPlainObject$1, f$1 = (e2) => e2;
let d$1 = f$1;
{
  const e2 = "undefined" != typeof console;
  d$1 = e2 ? function(e3, t13 = n$1.logLevel) {
    false === n$1.silent && console[t13](`[VueTypes warn]: ${e3}`);
  } : f$1;
}
const p$1 = (e2, t13) => s$1.call(e2, t13), y$1 = Number.isInteger || function(e2) {
  return "number" == typeof e2 && isFinite(e2) && Math.floor(e2) === e2;
}, v$1 = Array.isArray || function(e2) {
  return "[object Array]" === a$1.call(e2);
}, h$1 = (e2) => "[object Function]" === a$1.call(e2), b$1 = (e2) => c$1(e2) && p$1(e2, "_vueTypes_name"), g$1 = (e2) => c$1(e2) && (p$1(e2, "type") || ["_vueTypes_name", "validator", "default", "required"].some((t13) => p$1(e2, t13)));
function O$1(e2, t13) {
  return Object.defineProperty(e2.bind(t13), "__original", { value: e2 });
}
function m$1(e2, t13, r2 = false) {
  let n2, i2 = true, o2 = "";
  n2 = c$1(e2) ? e2 : { type: e2 };
  const a3 = b$1(n2) ? n2._vueTypes_name + " - " : "";
  if (g$1(n2) && null !== n2.type) {
    if (void 0 === n2.type || true === n2.type)
      return i2;
    if (!n2.required && void 0 === t13)
      return i2;
    v$1(n2.type) ? (i2 = n2.type.some((e3) => true === m$1(e3, t13, true)), o2 = n2.type.map((e3) => l$1(e3)).join(" or ")) : (o2 = l$1(n2), i2 = "Array" === o2 ? v$1(t13) : "Object" === o2 ? c$1(t13) : "String" === o2 || "Number" === o2 || "Boolean" === o2 || "Function" === o2 ? function(e3) {
      if (null == e3)
        return "";
      const t14 = e3.constructor.toString().match(u$1);
      return t14 ? t14[1] : "";
    }(t13) === o2 : t13 instanceof n2.type);
  }
  if (!i2) {
    const e3 = `${a3}value "${t13}" should be of type "${o2}"`;
    return false === r2 ? (d$1(e3), false) : e3;
  }
  if (p$1(n2, "validator") && h$1(n2.validator)) {
    const e3 = d$1, o3 = [];
    if (d$1 = (e4) => {
      o3.push(e4);
    }, i2 = n2.validator(t13), d$1 = e3, !i2) {
      const e4 = (o3.length > 1 ? "* " : "") + o3.join("\n* ");
      return o3.length = 0, false === r2 ? (d$1(e4), i2) : e4;
    }
  }
  return i2;
}
function j$1(e2, t13) {
  const r2 = Object.defineProperties(t13, { _vueTypes_name: { value: e2, writable: true }, isRequired: { get() {
    return this.required = true, this;
  } }, def: { value(e3) {
    return void 0 === e3 ? (p$1(this, "default") && delete this.default, this) : h$1(e3) || true === m$1(this, e3, true) ? (this.default = v$1(e3) ? () => [...e3] : c$1(e3) ? () => Object.assign({}, e3) : e3, this) : (d$1(`${this._vueTypes_name} - invalid default value: "${e3}"`), this);
  } } }), { validator: n2 } = r2;
  return h$1(n2) && (r2.validator = O$1(n2, r2)), r2;
}
function _$1(e2, t13) {
  const r2 = j$1(e2, t13);
  return Object.defineProperty(r2, "validate", { value(e3) {
    return h$1(this.validator) && d$1(`${this._vueTypes_name} - calling .validate() will overwrite the current custom validator function. Validator info:
${JSON.stringify(this)}`), this.validator = O$1(e3, this), this;
  } });
}
function T$1(e2, t13, n2) {
  const o2 = function(e3) {
    const t14 = {};
    return Object.getOwnPropertyNames(e3).forEach((r2) => {
      t14[r2] = Object.getOwnPropertyDescriptor(e3, r2);
    }), Object.defineProperties({}, t14);
  }(t13);
  if (o2._vueTypes_name = e2, !c$1(n2))
    return o2;
  const { validator: a3 } = n2, s3 = r$1(n2, i$1);
  if (h$1(a3)) {
    let { validator: e3 } = o2;
    e3 && (e3 = null !== (l2 = (u2 = e3).__original) && void 0 !== l2 ? l2 : u2), o2.validator = O$1(e3 ? function(t14) {
      return e3.call(this, t14) && a3.call(this, t14);
    } : a3, o2);
  }
  var u2, l2;
  return Object.assign(o2, s3);
}
function $$1(e2) {
  return e2.replace(/^(?!\s*$)/gm, "  ");
}
const w$1 = () => _$1("any", {}), P$1 = () => _$1("function", { type: Function }), x$1 = () => _$1("boolean", { type: Boolean }), E$1 = () => _$1("string", { type: String }), N$1 = () => _$1("number", { type: Number }), q$1 = () => _$1("array", { type: Array }), A$1 = () => _$1("object", { type: Object }), V$1 = () => j$1("integer", { type: Number, validator: (e2) => y$1(e2) }), S$1 = () => j$1("symbol", { validator: (e2) => "symbol" == typeof e2 });
function k$1(e2, t13 = "custom validation failed") {
  if ("function" != typeof e2)
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return j$1(e2.name || "<<anonymous function>>", { type: null, validator(r2) {
    const n2 = e2(r2);
    return n2 || d$1(`${this._vueTypes_name} - ${t13}`), n2;
  } });
}
function D$1(e2) {
  if (!v$1(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  const t13 = `oneOf - value should be one of "${e2.join('", "')}".`, r2 = e2.reduce((e3, t14) => {
    if (null != t14) {
      const r3 = t14.constructor;
      -1 === e3.indexOf(r3) && e3.push(r3);
    }
    return e3;
  }, []);
  return j$1("oneOf", { type: r2.length > 0 ? r2 : void 0, validator(r3) {
    const n2 = -1 !== e2.indexOf(r3);
    return n2 || d$1(t13), n2;
  } });
}
function L$1(e2) {
  if (!v$1(e2))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  let t13 = false, r2 = [];
  for (let n3 = 0; n3 < e2.length; n3 += 1) {
    const i2 = e2[n3];
    if (g$1(i2)) {
      if (b$1(i2) && "oneOf" === i2._vueTypes_name && i2.type) {
        r2 = r2.concat(i2.type);
        continue;
      }
      if (h$1(i2.validator) && (t13 = true), true === i2.type || !i2.type) {
        d$1('oneOfType - invalid usage of "true" or "null" as types.');
        continue;
      }
      r2 = r2.concat(i2.type);
    } else
      r2.push(i2);
  }
  r2 = r2.filter((e3, t14) => r2.indexOf(e3) === t14);
  const n2 = r2.length > 0 ? r2 : null;
  return j$1("oneOfType", t13 ? { type: n2, validator(t14) {
    const r3 = [], n3 = e2.some((e3) => {
      const n4 = m$1(b$1(e3) && "oneOf" === e3._vueTypes_name ? e3.type || null : e3, t14, true);
      return "string" == typeof n4 && r3.push(n4), true === n4;
    });
    return n3 || d$1(`oneOfType - provided value does not match any of the ${r3.length} passed-in validators:
${$$1(r3.join("\n"))}`), n3;
  } } : { type: n2 });
}
function F$1(e2) {
  return j$1("arrayOf", { type: Array, validator(t13) {
    let r2 = "";
    const n2 = t13.every((t14) => (r2 = m$1(e2, t14, true), true === r2));
    return n2 || d$1(`arrayOf - value validation error:
${$$1(r2)}`), n2;
  } });
}
function Y$1(e2) {
  return j$1("instanceOf", { type: e2 });
}
function B$1(e2) {
  return j$1("objectOf", { type: Object, validator(t13) {
    let r2 = "";
    const n2 = Object.keys(t13).every((n3) => (r2 = m$1(e2, t13[n3], true), true === r2));
    return n2 || d$1(`objectOf - value validation error:
${$$1(r2)}`), n2;
  } });
}
function I$1(e2) {
  const t13 = Object.keys(e2), r2 = t13.filter((t14) => {
    var r3;
    return !(null === (r3 = e2[t14]) || void 0 === r3 || !r3.required);
  }), n2 = j$1("shape", { type: Object, validator(n3) {
    if (!c$1(n3))
      return false;
    const i2 = Object.keys(n3);
    if (r2.length > 0 && r2.some((e3) => -1 === i2.indexOf(e3))) {
      const e3 = r2.filter((e4) => -1 === i2.indexOf(e4));
      return d$1(1 === e3.length ? `shape - required property "${e3[0]}" is not defined.` : `shape - required properties "${e3.join('", "')}" are not defined.`), false;
    }
    return i2.every((r3) => {
      if (-1 === t13.indexOf(r3))
        return true === this._vueTypes_isLoose || (d$1(`shape - shape definition does not include a "${r3}" property. Allowed keys: "${t13.join('", "')}".`), false);
      const i3 = m$1(e2[r3], n3[r3], true);
      return "string" == typeof i3 && d$1(`shape - "${r3}" property validation error:
 ${$$1(i3)}`), true === i3;
    });
  } });
  return Object.defineProperty(n2, "_vueTypes_isLoose", { writable: true, value: false }), Object.defineProperty(n2, "loose", { get() {
    return this._vueTypes_isLoose = true, this;
  } }), n2;
}
const J$1 = ["name", "validate", "getter"], M$1 = /* @__PURE__ */ (() => {
  var e2, t13;
  return t13 = e2 = class {
    static get any() {
      return w$1();
    }
    static get func() {
      return P$1().def(this.defaults.func);
    }
    static get bool() {
      return x$1().def(this.defaults.bool);
    }
    static get string() {
      return E$1().def(this.defaults.string);
    }
    static get number() {
      return N$1().def(this.defaults.number);
    }
    static get array() {
      return q$1().def(this.defaults.array);
    }
    static get object() {
      return A$1().def(this.defaults.object);
    }
    static get integer() {
      return V$1().def(this.defaults.integer);
    }
    static get symbol() {
      return S$1();
    }
    static extend(e3) {
      if (v$1(e3))
        return e3.forEach((e4) => this.extend(e4)), this;
      const { name: t14, validate: n2 = false, getter: i2 = false } = e3, o2 = r$1(e3, J$1);
      if (p$1(this, t14))
        throw new TypeError(`[VueTypes error]: Type "${t14}" already defined`);
      const { type: a3 } = o2;
      if (b$1(a3))
        return delete o2.type, Object.defineProperty(this, t14, i2 ? { get: () => T$1(t14, a3, o2) } : { value(...e4) {
          const r2 = T$1(t14, a3, o2);
          return r2.validator && (r2.validator = r2.validator.bind(r2, ...e4)), r2;
        } });
      let s3;
      return s3 = i2 ? { get() {
        const e4 = Object.assign({}, o2);
        return n2 ? _$1(t14, e4) : j$1(t14, e4);
      }, enumerable: true } : { value(...e4) {
        const r2 = Object.assign({}, o2);
        let i3;
        return i3 = n2 ? _$1(t14, r2) : j$1(t14, r2), r2.validator && (i3.validator = r2.validator.bind(i3, ...e4)), i3;
      }, enumerable: true }, Object.defineProperty(this, t14, s3);
    }
  }, e2.defaults = {}, e2.sensibleDefaults = void 0, e2.config = n$1, e2.custom = k$1, e2.oneOf = D$1, e2.instanceOf = Y$1, e2.oneOfType = L$1, e2.arrayOf = F$1, e2.objectOf = B$1, e2.shape = I$1, e2.utils = { validate: (e3, t14) => true === m$1(t14, e3, true), toType: (e3, t14, r2 = false) => r2 ? _$1(e3, t14) : j$1(e3, t14) }, t13;
})();
function R$1(e2 = { func: () => {
}, bool: true, string: "", number: 0, array: () => [], object: () => ({}), integer: 0 }) {
  var r2, n2;
  return n2 = r2 = class extends M$1 {
    static get sensibleDefaults() {
      return t$1({}, this.defaults);
    }
    static set sensibleDefaults(r3) {
      this.defaults = false !== r3 ? t$1({}, true !== r3 ? r3 : e2) : {};
    }
  }, r2.defaults = t$1({}, e2), n2;
}
class z$1 extends R$1() {
}
var tinycolor$1 = { exports: {} };
(function(module2) {
  (function(Math2) {
    var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math2.round, mathMin = Math2.min, mathMax = Math2.max, mathRandom = Math2.random;
    function tinycolor2(color, opts2) {
      color = color ? color : "";
      opts2 = opts2 || {};
      if (color instanceof tinycolor2) {
        return color;
      }
      if (!(this instanceof tinycolor2)) {
        return new tinycolor2(color, opts2);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts2.format || rgb.format;
      this._gradientType = opts2.gradientType;
      if (this._r < 1) {
        this._r = mathRound(this._r);
      }
      if (this._g < 1) {
        this._g = mathRound(this._g);
      }
      if (this._b < 1) {
        this._b = mathRound(this._b);
      }
      this._ok = rgb.ok;
      this._tc_id = tinyCounter++;
    }
    tinycolor2.prototype = {
      isDark: function() {
        return this.getBrightness() < 128;
      },
      isLight: function() {
        return !this.isDark();
      },
      isValid: function() {
        return this._ok;
      },
      getOriginalInput: function() {
        return this._originalInput;
      },
      getFormat: function() {
        return this._format;
      },
      getAlpha: function() {
        return this._a;
      },
      getBrightness: function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R2, G2, B2;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R2 = RsRGB / 12.92;
        } else {
          R2 = Math2.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G2 = GsRGB / 12.92;
        } else {
          G2 = Math2.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B2 = BsRGB / 12.92;
        } else {
          B2 = Math2.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
      },
      setAlpha: function(value2) {
        this._a = boundAlpha(value2);
        this._roundA = mathRound(100 * this._a) / 100;
        return this;
      },
      toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
      },
      toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h3 = mathRound(hsv.h * 360), s3 = mathRound(hsv.s * 100), v2 = mathRound(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h3 + ", " + s3 + "%, " + v2 + "%)" : "hsva(" + h3 + ", " + s3 + "%, " + v2 + "%, " + this._roundA + ")";
      },
      toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
      },
      toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h3 = mathRound(hsl.h * 360), s3 = mathRound(hsl.s * 100), l2 = mathRound(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h3 + ", " + s3 + "%, " + l2 + "%)" : "hsla(" + h3 + ", " + s3 + "%, " + l2 + "%, " + this._roundA + ")";
      },
      toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
      },
      toRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
      },
      toPercentageRgbString: function() {
        return this._a == 1 ? "rgb(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" : "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s3 = tinycolor2(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s3._r, s3._g, s3._b, s3._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function(format3) {
        var formatSet = !!format3;
        format3 = format3 || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format3 === "hex" || format3 === "hex6" || format3 === "hex3" || format3 === "hex4" || format3 === "hex8" || format3 === "name");
        if (needsAlphaFormat) {
          if (format3 === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format3 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format3 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format3 === "hex" || format3 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format3 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format3 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format3 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format3 === "name") {
          formattedString = this.toName();
        }
        if (format3 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format3 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function() {
        return tinycolor2(this.toString());
      },
      _applyModification: function(fn3, args) {
        var color = fn3.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function() {
        return this._applyModification(lighten, arguments);
      },
      brighten: function() {
        return this._applyModification(brighten, arguments);
      },
      darken: function() {
        return this._applyModification(darken, arguments);
      },
      desaturate: function() {
        return this._applyModification(desaturate, arguments);
      },
      saturate: function() {
        return this._applyModification(saturate, arguments);
      },
      greyscale: function() {
        return this._applyModification(greyscale, arguments);
      },
      spin: function() {
        return this._applyModification(spin, arguments);
      },
      _applyCombination: function(fn3, args) {
        return fn3.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function() {
        return this._applyCombination(analogous, arguments);
      },
      complement: function() {
        return this._applyCombination(complement, arguments);
      },
      monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
      },
      splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
      },
      triad: function() {
        return this._applyCombination(triad, arguments);
      },
      tetrad: function() {
        return this._applyCombination(tetrad, arguments);
      }
    };
    tinycolor2.fromRatio = function(color, opts2) {
      if (typeof color == "object") {
        var newColor = {};
        for (var i2 in color) {
          if (color.hasOwnProperty(i2)) {
            if (i2 === "a") {
              newColor[i2] = color[i2];
            } else {
              newColor[i2] = convertToPercentage(color[i2]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor2(color, opts2);
    };
    function inputToRGB(color) {
      var rgb = { r: 0, g: 0, b: 0 };
      var a3 = 1;
      var s3 = null;
      var v2 = null;
      var l2 = null;
      var ok = false;
      var format3 = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (typeof color == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format3 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s3 = convertToPercentage(color.s);
          v2 = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s3, v2);
          ok = true;
          format3 = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s3 = convertToPercentage(color.s);
          l2 = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s3, l2);
          ok = true;
          format3 = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a3 = color.a;
        }
      }
      a3 = boundAlpha(a3);
      return {
        ok,
        format: color.format || format3,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a3
      };
    }
    function rgbToRgb(r2, g2, b2) {
      return {
        r: bound01(r2, 255) * 255,
        g: bound01(g2, 255) * 255,
        b: bound01(b2, 255) * 255
      };
    }
    function rgbToHsl(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h3, s3, l2 = (max2 + min2) / 2;
      if (max2 == min2) {
        h3 = s3 = 0;
      } else {
        var d3 = max2 - min2;
        s3 = l2 > 0.5 ? d3 / (2 - max2 - min2) : d3 / (max2 + min2);
        switch (max2) {
          case r2:
            h3 = (g2 - b2) / d3 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h3 = (b2 - r2) / d3 + 2;
            break;
          case b2:
            h3 = (r2 - g2) / d3 + 4;
            break;
        }
        h3 /= 6;
      }
      return { h: h3, s: s3, l: l2 };
    }
    function hslToRgb(h3, s3, l2) {
      var r2, g2, b2;
      h3 = bound01(h3, 360);
      s3 = bound01(s3, 100);
      l2 = bound01(l2, 100);
      function hue2rgb(p3, q2, t13) {
        if (t13 < 0)
          t13 += 1;
        if (t13 > 1)
          t13 -= 1;
        if (t13 < 1 / 6)
          return p3 + (q2 - p3) * 6 * t13;
        if (t13 < 1 / 2)
          return q2;
        if (t13 < 2 / 3)
          return p3 + (q2 - p3) * (2 / 3 - t13) * 6;
        return p3;
      }
      if (s3 === 0) {
        r2 = g2 = b2 = l2;
      } else {
        var q = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3;
        var p2 = 2 * l2 - q;
        r2 = hue2rgb(p2, q, h3 + 1 / 3);
        g2 = hue2rgb(p2, q, h3);
        b2 = hue2rgb(p2, q, h3 - 1 / 3);
      }
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHsv(r2, g2, b2) {
      r2 = bound01(r2, 255);
      g2 = bound01(g2, 255);
      b2 = bound01(b2, 255);
      var max2 = mathMax(r2, g2, b2), min2 = mathMin(r2, g2, b2);
      var h3, s3, v2 = max2;
      var d3 = max2 - min2;
      s3 = max2 === 0 ? 0 : d3 / max2;
      if (max2 == min2) {
        h3 = 0;
      } else {
        switch (max2) {
          case r2:
            h3 = (g2 - b2) / d3 + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            h3 = (b2 - r2) / d3 + 2;
            break;
          case b2:
            h3 = (r2 - g2) / d3 + 4;
            break;
        }
        h3 /= 6;
      }
      return { h: h3, s: s3, v: v2 };
    }
    function hsvToRgb(h3, s3, v2) {
      h3 = bound01(h3, 360) * 6;
      s3 = bound01(s3, 100);
      v2 = bound01(v2, 100);
      var i2 = Math2.floor(h3), f2 = h3 - i2, p2 = v2 * (1 - s3), q = v2 * (1 - f2 * s3), t13 = v2 * (1 - (1 - f2) * s3), mod = i2 % 6, r2 = [v2, q, p2, p2, t13, v2][mod], g2 = [t13, v2, v2, q, p2, p2][mod], b2 = [p2, p2, t13, v2, v2, q][mod];
      return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
    }
    function rgbToHex(r2, g2, b2, allow3Char) {
      var hex = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r2, g2, b2, a3, allow4Char) {
      var hex = [
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16)),
        pad2(convertDecimalToHex(a3))
      ];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r2, g2, b2, a3) {
      var hex = [
        pad2(convertDecimalToHex(a3)),
        pad2(mathRound(r2).toString(16)),
        pad2(mathRound(g2).toString(16)),
        pad2(mathRound(b2).toString(16))
      ];
      return hex.join("");
    }
    tinycolor2.equals = function(color1, color2) {
      if (!color1 || !color2) {
        return false;
      }
      return tinycolor2(color1).toRgbString() == tinycolor2(color2).toRgbString();
    };
    tinycolor2.random = function() {
      return tinycolor2.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
      });
    };
    function desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor2(hsl);
    }
    function greyscale(color) {
      return tinycolor2(color).desaturate(100);
    }
    function lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor2(color).toRgb();
      rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
      rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
      rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
      return tinycolor2(rgb);
    }
    function darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor2(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor2(hsl);
    }
    function spin(color, amount) {
      var hsl = tinycolor2(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor2(hsl);
    }
    function complement(color) {
      var hsl = tinycolor2(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor2(hsl);
    }
    function triad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h3 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h3 + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h3 + 240) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function tetrad(color) {
      var hsl = tinycolor2(color).toHsl();
      var h3 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h3 + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h3 + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h3 + 270) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function splitcomplement(color) {
      var hsl = tinycolor2(color).toHsl();
      var h3 = hsl.h;
      return [
        tinycolor2(color),
        tinycolor2({ h: (h3 + 72) % 360, s: hsl.s, l: hsl.l }),
        tinycolor2({ h: (h3 + 216) % 360, s: hsl.s, l: hsl.l })
      ];
    }
    function analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor2(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor2(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor2(hsl));
      }
      return ret;
    }
    function monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor2(color).toHsv();
      var h3 = hsv.h, s3 = hsv.s, v2 = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor2({ h: h3, s: s3, v: v2 }));
        v2 = (v2 + modification) % 1;
      }
      return ret;
    }
    tinycolor2.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor2(color1).toRgb();
      var rgb2 = tinycolor2(color2).toRgb();
      var p2 = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
        g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
        b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
        a: (rgb2.a - rgb1.a) * p2 + rgb1.a
      };
      return tinycolor2(rgba);
    };
    tinycolor2.readability = function(color1, color2) {
      var c1 = tinycolor2(color1);
      var c2 = tinycolor2(color2);
      return (Math2.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math2.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor2.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor2.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor2.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level = args.level;
      size = args.size;
      for (var i2 = 0; i2 < colorList.length; i2++) {
        readability = tinycolor2.readability(baseColor, colorList[i2]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor2(colorList[i2]);
        }
      }
      if (tinycolor2.isReadable(baseColor, bestColor, { "level": level, "size": size }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor2.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor2.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor2.hexNames = flip2(names);
    function flip2(o2) {
      var flipped = {};
      for (var i2 in o2) {
        if (o2.hasOwnProperty(i2)) {
          flipped[o2[i2]] = i2;
        }
      }
      return flipped;
    }
    function boundAlpha(a3) {
      a3 = parseFloat(a3);
      if (isNaN(a3) || a3 < 0 || a3 > 1) {
        a3 = 1;
      }
      return a3;
    }
    function bound01(n2, max2) {
      if (isOnePointZero(n2)) {
        n2 = "100%";
      }
      var processPercent = isPercentage(n2);
      n2 = mathMin(max2, mathMax(0, parseFloat(n2)));
      if (processPercent) {
        n2 = parseInt(n2 * max2, 10) / 100;
      }
      if (Math2.abs(n2 - max2) < 1e-6) {
        return 1;
      }
      return n2 % max2 / parseFloat(max2);
    }
    function clamp01(val) {
      return mathMin(1, mathMax(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n2) {
      return typeof n2 == "string" && n2.indexOf(".") != -1 && parseFloat(n2) === 1;
    }
    function isPercentage(n2) {
      return typeof n2 === "string" && n2.indexOf("%") != -1;
    }
    function pad2(c2) {
      return c2.length == 1 ? "0" + c2 : "" + c2;
    }
    function convertToPercentage(n2) {
      if (n2 <= 1) {
        n2 = n2 * 100 + "%";
      }
      return n2;
    }
    function convertDecimalToHex(d3) {
      return Math2.round(parseFloat(d3) * 255).toString(16);
    }
    function convertHexToDecimal(h3) {
      return parseIntFromHex(h3) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return { r: 0, g: 0, b: 0, a: 0, format: "name" };
      }
      var match;
      if (match = matchers.rgb.exec(color)) {
        return { r: match[1], g: match[2], b: match[3] };
      }
      if (match = matchers.rgba.exec(color)) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
      }
      if (match = matchers.hsl.exec(color)) {
        return { h: match[1], s: match[2], l: match[3] };
      }
      if (match = matchers.hsla.exec(color)) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
      }
      if (match = matchers.hsv.exec(color)) {
        return { h: match[1], s: match[2], v: match[3] };
      }
      if (match = matchers.hsva.exec(color)) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
      }
      if (match = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          a: convertHexToDecimal(match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match[1]),
          g: parseIntFromHex(match[2]),
          b: parseIntFromHex(match[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          a: convertHexToDecimal(match[4] + "" + match[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match[1] + "" + match[1]),
          g: parseIntFromHex(match[2] + "" + match[2]),
          b: parseIntFromHex(match[3] + "" + match[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level, size;
      parms = parms || { "level": "AA", "size": "small" };
      level = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level !== "AA" && level !== "AAA") {
        level = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return { "level": level, "size": size };
    }
    if (module2.exports) {
      module2.exports = tinycolor2;
    } else {
      window.tinycolor = tinycolor2;
    }
  })(Math);
})(tinycolor$1);
const tinycolor = tinycolor$1.exports;
function tryOnScopeDispose(fn3) {
  if (getCurrentScope()) {
    onScopeDispose(fn3);
    return true;
  }
  return false;
}
const isClient = typeof window !== "undefined";
const isString = (val) => typeof val === "string";
const noop2 = () => {
};
function createFilterWrapper(filter, fn3) {
  function wrapper(...args) {
    filter(() => fn3.apply(this, args), { fn: fn3, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  const filter = (invoke) => {
    const duration = unref(ms);
    const maxDuration = unref(options.maxWait);
    if (timer)
      clearTimeout(timer);
    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        clearTimeout(maxTimer);
        maxTimer = null;
      }
      return invoke();
    }
    if (maxDuration && !maxTimer) {
      maxTimer = setTimeout(() => {
        if (timer)
          clearTimeout(timer);
        maxTimer = null;
        invoke();
      }, maxDuration);
    }
    timer = setTimeout(() => {
      if (maxTimer)
        clearTimeout(maxTimer);
      maxTimer = null;
      invoke();
    }, duration);
  };
  return filter;
}
function useDebounceFn(fn3, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn3);
}
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a = options, {
    eventFilter = bypassFilter
  } = _a, watchOptions = __objRest$5(_a, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function tryOnMounted(fn3, sync = true) {
  if (getCurrentInstance())
    onMounted(fn3);
  else if (sync)
    fn3();
  else
    nextTick(fn3);
}
function whenever(source, cb, options) {
  return watch(source, (v2, ov, onInvalidate) => {
    if (v2)
      cb(v2, ov, onInvalidate);
  }, options);
}
function unrefElement(elRef) {
  var _a;
  const plain = unref(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop2;
  let cleanup = noop2;
  const stopWatch = watch(() => unref(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop2;
    };
  }, { immediate: true, flush: "post" });
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return stop;
}
function onClickOutside(target, handler2, options = {}) {
  const { window: window2 = defaultWindow, event = "pointerdown" } = options;
  if (!window2)
    return;
  const listener = (event2) => {
    const el = unrefElement(target);
    if (!el)
      return;
    if (el === event2.target || event2.composedPath().includes(el))
      return;
    handler2(event2);
  };
  return useEventListener(window2, event, listener, { passive: true });
}
const StorageSerializers = {
  boolean: {
    read: (v2) => v2 === "true",
    write: (v2) => String(v2)
  },
  object: {
    read: (v2) => JSON.parse(v2),
    write: (v2) => JSON.stringify(v2)
  },
  number: {
    read: (v2) => Number.parseFloat(v2),
    write: (v2) => String(v2)
  },
  any: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  string: {
    read: (v2) => v2,
    write: (v2) => String(v2)
  },
  map: {
    read: (v2) => new Map(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  },
  set: {
    read: (v2) => new Set(JSON.parse(v2)),
    write: (v2) => JSON.stringify(Array.from(v2.entries()))
  }
};
function useStorage(key, initialValue, storage = ((_a) => (_a = defaultWindow) == null ? void 0 : _a.localStorage)(), options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e2) => {
      console.error(e2);
    }
  } = options;
  const rawInit = unref(initialValue);
  const type = rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
  const data9 = (shallow ? shallowRef : ref)(initialValue);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  function read2(event) {
    if (!storage || event && event.key !== key)
      return;
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        data9.value = rawInit;
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
      } else {
        data9.value = serializer.read(rawValue);
      }
    } catch (e2) {
      onError(e2);
    }
  }
  read2();
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", (e2) => setTimeout(() => read2(e2), 0));
  if (storage) {
    watchWithFilter(data9, () => {
      try {
        if (data9.value == null)
          storage.removeItem(key);
        else
          storage.setItem(key, serializer.write(data9.value));
      } catch (e2) {
        onError(e2);
      }
    }, {
      flush,
      deep,
      eventFilter
    });
  }
  return data9;
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window2 = defaultWindow } = options;
  return useStorage(key, initialValue, window2 == null ? void 0 : window2.localStorage, options);
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
var t12 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function e(t13) {
  var e2 = { exports: {} };
  return t13(e2, e2.exports), e2.exports;
}
var n = function(t13) {
  return t13 && t13.Math == Math && t13;
}, r = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof t12 && t12) || function() {
  return this;
}() || Function("return this")(), o = function(t13) {
  try {
    return !!t13();
  } catch (t14) {
    return true;
  }
}, i = !o(function() {
  return 7 != Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1];
}), u = {}.propertyIsEnumerable, a2 = Object.getOwnPropertyDescriptor, c = { f: a2 && !u.call({ 1: 2 }, 1) ? function(t13) {
  var e2 = a2(this, t13);
  return !!e2 && e2.enumerable;
} : u }, l = function(t13, e2) {
  return { enumerable: !(1 & t13), configurable: !(2 & t13), writable: !(4 & t13), value: e2 };
}, f = {}.toString, s2 = function(t13) {
  return f.call(t13).slice(8, -1);
}, d2 = "".split, v = o(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(t13) {
  return "String" == s2(t13) ? d2.call(t13, "") : Object(t13);
} : Object, p = function(t13) {
  if (null == t13)
    throw TypeError("Can't call method on " + t13);
  return t13;
}, g = function(t13) {
  return v(p(t13));
}, h2 = function(t13) {
  return "object" == typeof t13 ? null !== t13 : "function" == typeof t13;
}, y = function(t13, e2) {
  if (!h2(t13))
    return t13;
  var n2, r2;
  if (e2 && "function" == typeof (n2 = t13.toString) && !h2(r2 = n2.call(t13)))
    return r2;
  if ("function" == typeof (n2 = t13.valueOf) && !h2(r2 = n2.call(t13)))
    return r2;
  if (!e2 && "function" == typeof (n2 = t13.toString) && !h2(r2 = n2.call(t13)))
    return r2;
  throw TypeError("Can't convert object to primitive value");
}, m2 = {}.hasOwnProperty, S2 = function(t13, e2) {
  return m2.call(t13, e2);
}, x = r.document, b = h2(x) && h2(x.createElement), E = function(t13) {
  return b ? x.createElement(t13) : {};
}, w = !i && !o(function() {
  return 7 != Object.defineProperty(E("div"), "a", { get: function() {
    return 7;
  } }).a;
}), O = Object.getOwnPropertyDescriptor, T = { f: i ? O : function(t13, e2) {
  if (t13 = g(t13), e2 = y(e2, true), w)
    try {
      return O(t13, e2);
    } catch (t14) {
    }
  if (S2(t13, e2))
    return l(!c.f.call(t13, e2), t13[e2]);
} }, A2 = function(t13) {
  if (!h2(t13))
    throw TypeError(String(t13) + " is not an object");
  return t13;
}, k = Object.defineProperty, R = { f: i ? k : function(t13, e2, n2) {
  if (A2(t13), e2 = y(e2, true), A2(n2), w)
    try {
      return k(t13, e2, n2);
    } catch (t14) {
    }
  if ("get" in n2 || "set" in n2)
    throw TypeError("Accessors not supported");
  return "value" in n2 && (t13[e2] = n2.value), t13;
} }, I = i ? function(t13, e2, n2) {
  return R.f(t13, e2, l(1, n2));
} : function(t13, e2, n2) {
  return t13[e2] = n2, t13;
}, j = function(t13, e2) {
  try {
    I(r, t13, e2);
  } catch (n2) {
    r[t13] = e2;
  }
  return e2;
}, C = r["__core-js_shared__"] || j("__core-js_shared__", {}), L = Function.toString;
"function" != typeof C.inspectSource && (C.inspectSource = function(t13) {
  return L.call(t13);
});
var P, M2, _, D2 = C.inspectSource, U = r.WeakMap, N = "function" == typeof U && /native code/.test(D2(U)), F = e(function(t13) {
  (t13.exports = function(t14, e2) {
    return C[t14] || (C[t14] = void 0 !== e2 ? e2 : {});
  })("versions", []).push({ version: "3.8.3", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
}), W2 = 0, z = Math.random(), $ = function(t13) {
  return "Symbol(" + String(void 0 === t13 ? "" : t13) + ")_" + (++W2 + z).toString(36);
}, B = F("keys"), Y = function(t13) {
  return B[t13] || (B[t13] = $(t13));
}, G = {}, H2 = r.WeakMap;
if (N) {
  var X = C.state || (C.state = new H2()), V = X.get, K = X.has, q = X.set;
  P = function(t13, e2) {
    return e2.facade = t13, q.call(X, t13, e2), e2;
  }, M2 = function(t13) {
    return V.call(X, t13) || {};
  }, _ = function(t13) {
    return K.call(X, t13);
  };
} else {
  var Q = Y("state");
  G[Q] = true, P = function(t13, e2) {
    return e2.facade = t13, I(t13, Q, e2), e2;
  }, M2 = function(t13) {
    return S2(t13, Q) ? t13[Q] : {};
  }, _ = function(t13) {
    return S2(t13, Q);
  };
}
var J = { set: P, get: M2, has: _, enforce: function(t13) {
  return _(t13) ? M2(t13) : P(t13, {});
}, getterFor: function(t13) {
  return function(e2) {
    var n2;
    if (!h2(e2) || (n2 = M2(e2)).type !== t13)
      throw TypeError("Incompatible receiver, " + t13 + " required");
    return n2;
  };
} }, Z2 = e(function(t13) {
  var e2 = J.get, n2 = J.enforce, o2 = String(String).split("String");
  (t13.exports = function(t14, e3, i2, u2) {
    var a3, c2 = !!u2 && !!u2.unsafe, l2 = !!u2 && !!u2.enumerable, f2 = !!u2 && !!u2.noTargetGet;
    "function" == typeof i2 && ("string" != typeof e3 || S2(i2, "name") || I(i2, "name", e3), (a3 = n2(i2)).source || (a3.source = o2.join("string" == typeof e3 ? e3 : ""))), t14 !== r ? (c2 ? !f2 && t14[e3] && (l2 = true) : delete t14[e3], l2 ? t14[e3] = i2 : I(t14, e3, i2)) : l2 ? t14[e3] = i2 : j(e3, i2);
  })(Function.prototype, "toString", function() {
    return "function" == typeof this && e2(this).source || D2(this);
  });
}), tt = r, et = function(t13) {
  return "function" == typeof t13 ? t13 : void 0;
}, nt = function(t13, e2) {
  return arguments.length < 2 ? et(tt[t13]) || et(r[t13]) : tt[t13] && tt[t13][e2] || r[t13] && r[t13][e2];
}, rt = Math.ceil, ot = Math.floor, it = function(t13) {
  return isNaN(t13 = +t13) ? 0 : (t13 > 0 ? ot : rt)(t13);
}, ut = Math.min, at = function(t13) {
  return t13 > 0 ? ut(it(t13), 9007199254740991) : 0;
}, ct = Math.max, lt = Math.min, ft = function(t13, e2) {
  var n2 = it(t13);
  return n2 < 0 ? ct(n2 + e2, 0) : lt(n2, e2);
}, st = function(t13) {
  return function(e2, n2, r2) {
    var o2, i2 = g(e2), u2 = at(i2.length), a3 = ft(r2, u2);
    if (t13 && n2 != n2) {
      for (; u2 > a3; )
        if ((o2 = i2[a3++]) != o2)
          return true;
    } else
      for (; u2 > a3; a3++)
        if ((t13 || a3 in i2) && i2[a3] === n2)
          return t13 || a3 || 0;
    return !t13 && -1;
  };
}, dt = { includes: st(true), indexOf: st(false) }, vt = dt.indexOf, pt = function(t13, e2) {
  var n2, r2 = g(t13), o2 = 0, i2 = [];
  for (n2 in r2)
    !S2(G, n2) && S2(r2, n2) && i2.push(n2);
  for (; e2.length > o2; )
    S2(r2, n2 = e2[o2++]) && (~vt(i2, n2) || i2.push(n2));
  return i2;
}, gt = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], ht = gt.concat("length", "prototype"), yt = { f: Object.getOwnPropertyNames || function(t13) {
  return pt(t13, ht);
} }, mt = { f: Object.getOwnPropertySymbols }, St = nt("Reflect", "ownKeys") || function(t13) {
  var e2 = yt.f(A2(t13)), n2 = mt.f;
  return n2 ? e2.concat(n2(t13)) : e2;
}, xt = function(t13, e2) {
  for (var n2 = St(e2), r2 = R.f, o2 = T.f, i2 = 0; i2 < n2.length; i2++) {
    var u2 = n2[i2];
    S2(t13, u2) || r2(t13, u2, o2(e2, u2));
  }
}, bt = /#|\.prototype\./, Et = function(t13, e2) {
  var n2 = Ot[wt(t13)];
  return n2 == At || n2 != Tt && ("function" == typeof e2 ? o(e2) : !!e2);
}, wt = Et.normalize = function(t13) {
  return String(t13).replace(bt, ".").toLowerCase();
}, Ot = Et.data = {}, Tt = Et.NATIVE = "N", At = Et.POLYFILL = "P", kt = Et, Rt = T.f, It = function(t13, e2) {
  var n2, o2, i2, u2, a3, c2 = t13.target, l2 = t13.global, f2 = t13.stat;
  if (n2 = l2 ? r : f2 ? r[c2] || j(c2, {}) : (r[c2] || {}).prototype)
    for (o2 in e2) {
      if (u2 = e2[o2], i2 = t13.noTargetGet ? (a3 = Rt(n2, o2)) && a3.value : n2[o2], !kt(l2 ? o2 : c2 + (f2 ? "." : "#") + o2, t13.forced) && void 0 !== i2) {
        if (typeof u2 == typeof i2)
          continue;
        xt(u2, i2);
      }
      (t13.sham || i2 && i2.sham) && I(u2, "sham", true), Z2(n2, o2, u2, t13);
    }
}, jt = function(t13, e2) {
  var n2 = [][t13];
  return !!n2 && o(function() {
    n2.call(null, e2 || function() {
      throw 1;
    }, 1);
  });
}, Ct = Object.defineProperty, Lt = {}, Pt = function(t13) {
  throw t13;
}, Mt = function(t13, e2) {
  if (S2(Lt, t13))
    return Lt[t13];
  e2 || (e2 = {});
  var n2 = [][t13], r2 = !!S2(e2, "ACCESSORS") && e2.ACCESSORS, u2 = S2(e2, 0) ? e2[0] : Pt, a3 = S2(e2, 1) ? e2[1] : void 0;
  return Lt[t13] = !!n2 && !o(function() {
    if (r2 && !i)
      return true;
    var t14 = { length: -1 };
    r2 ? Ct(t14, 1, { enumerable: true, get: Pt }) : t14[1] = 1, n2.call(t14, u2, a3);
  });
}, _t = dt.indexOf, Dt = [].indexOf, Ut = !!Dt && 1 / [1].indexOf(1, -0) < 0, Nt = jt("indexOf"), Ft = Mt("indexOf", { ACCESSORS: true, 1: 0 });
function Wt(t13, e2) {
  if (!(t13 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
}
function zt(t13, e2) {
  for (var n2 = 0; n2 < e2.length; n2++) {
    var r2 = e2[n2];
    r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t13, r2.key, r2);
  }
}
function $t(t13, e2, n2) {
  return e2 && zt(t13.prototype, e2), n2 && zt(t13, n2), t13;
}
It({ target: "Array", proto: true, forced: Ut || !Nt || !Ft }, { indexOf: function(t13) {
  return Ut ? Dt.apply(this, arguments) || 0 : _t(this, t13, arguments.length > 1 ? arguments[1] : void 0);
} });
(function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "isInBrowser", value: function() {
    return "undefined" != typeof window;
  } }, { key: "isServer", value: function() {
    return "undefined" == typeof window;
  } }, { key: "getUA", value: function() {
    return t13.isInBrowser() ? window.navigator.userAgent.toLowerCase() : "";
  } }, { key: "isMobile", value: function() {
    return /Mobile|mini|Fennec|Android|iP(ad|od|hone)/.test(navigator.appVersion);
  } }, { key: "isOpera", value: function() {
    return -1 !== navigator.userAgent.indexOf("Opera");
  } }, { key: "isIE", value: function() {
    var e2 = t13.getUA();
    return "" !== e2 && e2.indexOf("msie") > 0;
  } }, { key: "isIE9", value: function() {
    var e2 = t13.getUA();
    return "" !== e2 && e2.indexOf("msie 9.0") > 0;
  } }, { key: "isEdge", value: function() {
    var e2 = t13.getUA();
    return "" !== e2 && e2.indexOf("edge/") > 0;
  } }, { key: "isChrome", value: function() {
    var e2 = t13.getUA();
    return "" !== e2 && /chrome\/\d+/.test(e2) && !t13.isEdge();
  } }, { key: "isPhantomJS", value: function() {
    var e2 = t13.getUA();
    return "" !== e2 && /phantomjs/.test(e2);
  } }, { key: "isFirefox", value: function() {
    var e2 = t13.getUA();
    return "" !== e2 && /firefox/.test(e2);
  } }]), t13;
})();
var Yt = [].join, Gt = v != Object, Ht = jt("join", ",");
It({ target: "Array", proto: true, forced: Gt || !Ht }, { join: function(t13) {
  return Yt.call(g(this), void 0 === t13 ? "," : t13);
} });
var Xt, Vt, Kt = function(t13) {
  return Object(p(t13));
}, qt = Array.isArray || function(t13) {
  return "Array" == s2(t13);
}, Qt = !!Object.getOwnPropertySymbols && !o(function() {
  return !String(Symbol());
}), Jt = Qt && !Symbol.sham && "symbol" == typeof Symbol.iterator, Zt = F("wks"), te = r.Symbol, ee = Jt ? te : te && te.withoutSetter || $, ne = function(t13) {
  return S2(Zt, t13) || (Qt && S2(te, t13) ? Zt[t13] = te[t13] : Zt[t13] = ee("Symbol." + t13)), Zt[t13];
}, re = ne("species"), oe = function(t13, e2) {
  var n2;
  return qt(t13) && ("function" != typeof (n2 = t13.constructor) || n2 !== Array && !qt(n2.prototype) ? h2(n2) && null === (n2 = n2[re]) && (n2 = void 0) : n2 = void 0), new (void 0 === n2 ? Array : n2)(0 === e2 ? 0 : e2);
}, ie = function(t13, e2, n2) {
  var r2 = y(e2);
  r2 in t13 ? R.f(t13, r2, l(0, n2)) : t13[r2] = n2;
}, ue = nt("navigator", "userAgent") || "", ae = r.process, ce = ae && ae.versions, le = ce && ce.v8;
le ? Vt = (Xt = le.split("."))[0] + Xt[1] : ue && (!(Xt = ue.match(/Edge\/(\d+)/)) || Xt[1] >= 74) && (Xt = ue.match(/Chrome\/(\d+)/)) && (Vt = Xt[1]);
var fe = Vt && +Vt, se = ne("species"), de = function(t13) {
  return fe >= 51 || !o(function() {
    var e2 = [];
    return (e2.constructor = {})[se] = function() {
      return { foo: 1 };
    }, 1 !== e2[t13](Boolean).foo;
  });
}, ve = de("splice"), pe = Mt("splice", { ACCESSORS: true, 0: 0, 1: 2 }), ge = Math.max, he = Math.min;
It({ target: "Array", proto: true, forced: !ve || !pe }, { splice: function(t13, e2) {
  var n2, r2, o2, i2, u2, a3, c2 = Kt(this), l2 = at(c2.length), f2 = ft(t13, l2), s3 = arguments.length;
  if (0 === s3 ? n2 = r2 = 0 : 1 === s3 ? (n2 = 0, r2 = l2 - f2) : (n2 = s3 - 2, r2 = he(ge(it(e2), 0), l2 - f2)), l2 + n2 - r2 > 9007199254740991)
    throw TypeError("Maximum allowed length exceeded");
  for (o2 = oe(c2, r2), i2 = 0; i2 < r2; i2++)
    (u2 = f2 + i2) in c2 && ie(o2, i2, c2[u2]);
  if (o2.length = r2, n2 < r2) {
    for (i2 = f2; i2 < l2 - r2; i2++)
      a3 = i2 + n2, (u2 = i2 + r2) in c2 ? c2[a3] = c2[u2] : delete c2[a3];
    for (i2 = l2; i2 > l2 - r2 + n2; i2--)
      delete c2[i2 - 1];
  } else if (n2 > r2)
    for (i2 = l2 - r2; i2 > f2; i2--)
      a3 = i2 + n2 - 1, (u2 = i2 + r2 - 1) in c2 ? c2[a3] = c2[u2] : delete c2[a3];
  for (i2 = 0; i2 < n2; i2++)
    c2[i2 + f2] = arguments[i2 + 2];
  return c2.length = l2 - r2 + n2, o2;
} });
var ye = {};
ye[ne("toStringTag")] = "z";
var me = "[object z]" === String(ye), Se = ne("toStringTag"), xe = "Arguments" == s2(function() {
  return arguments;
}()), be = me ? s2 : function(t13) {
  var e2, n2, r2;
  return void 0 === t13 ? "Undefined" : null === t13 ? "Null" : "string" == typeof (n2 = function(t14, e3) {
    try {
      return t14[e3];
    } catch (t15) {
    }
  }(e2 = Object(t13), Se)) ? n2 : xe ? s2(e2) : "Object" == (r2 = s2(e2)) && "function" == typeof e2.callee ? "Arguments" : r2;
}, Ee = me ? {}.toString : function() {
  return "[object " + be(this) + "]";
};
me || Z2(Object.prototype, "toString", Ee, { unsafe: true });
var we = function() {
  var t13 = A2(this), e2 = "";
  return t13.global && (e2 += "g"), t13.ignoreCase && (e2 += "i"), t13.multiline && (e2 += "m"), t13.dotAll && (e2 += "s"), t13.unicode && (e2 += "u"), t13.sticky && (e2 += "y"), e2;
};
function Oe(t13, e2) {
  return RegExp(t13, e2);
}
var Te, Ae, ke = { UNSUPPORTED_Y: o(function() {
  var t13 = Oe("a", "y");
  return t13.lastIndex = 2, null != t13.exec("abcd");
}), BROKEN_CARET: o(function() {
  var t13 = Oe("^r", "gy");
  return t13.lastIndex = 2, null != t13.exec("str");
}) }, Re = RegExp.prototype.exec, Ie = String.prototype.replace, je = Re, Ce = (Te = /a/, Ae = /b*/g, Re.call(Te, "a"), Re.call(Ae, "a"), 0 !== Te.lastIndex || 0 !== Ae.lastIndex), Le = ke.UNSUPPORTED_Y || ke.BROKEN_CARET, Pe = void 0 !== /()??/.exec("")[1];
(Ce || Pe || Le) && (je = function(t13) {
  var e2, n2, r2, o2, i2 = this, u2 = Le && i2.sticky, a3 = we.call(i2), c2 = i2.source, l2 = 0, f2 = t13;
  return u2 && (-1 === (a3 = a3.replace("y", "")).indexOf("g") && (a3 += "g"), f2 = String(t13).slice(i2.lastIndex), i2.lastIndex > 0 && (!i2.multiline || i2.multiline && "\n" !== t13[i2.lastIndex - 1]) && (c2 = "(?: " + c2 + ")", f2 = " " + f2, l2++), n2 = new RegExp("^(?:" + c2 + ")", a3)), Pe && (n2 = new RegExp("^" + c2 + "$(?!\\s)", a3)), Ce && (e2 = i2.lastIndex), r2 = Re.call(u2 ? n2 : i2, f2), u2 ? r2 ? (r2.input = r2.input.slice(l2), r2[0] = r2[0].slice(l2), r2.index = i2.lastIndex, i2.lastIndex += r2[0].length) : i2.lastIndex = 0 : Ce && r2 && (i2.lastIndex = i2.global ? r2.index + r2[0].length : e2), Pe && r2 && r2.length > 1 && Ie.call(r2[0], n2, function() {
    for (o2 = 1; o2 < arguments.length - 2; o2++)
      void 0 === arguments[o2] && (r2[o2] = void 0);
  }), r2;
});
var Me = je;
It({ target: "RegExp", proto: true, forced: /./.exec !== Me }, { exec: Me });
var _e = RegExp.prototype, De = _e.toString, Ue = o(function() {
  return "/a/b" != De.call({ source: "a", flags: "b" });
}), Ne = "toString" != De.name;
(Ue || Ne) && Z2(RegExp.prototype, "toString", function() {
  var t13 = A2(this), e2 = String(t13.source), n2 = t13.flags;
  return "/" + e2 + "/" + String(void 0 === n2 && t13 instanceof RegExp && !("flags" in _e) ? we.call(t13) : n2);
}, { unsafe: true });
var Fe = ne("species"), We = !o(function() {
  var t13 = /./;
  return t13.exec = function() {
    var t14 = [];
    return t14.groups = { a: "7" }, t14;
  }, "7" !== "".replace(t13, "$<a>");
}), ze = "$0" === "a".replace(/./, "$0"), $e = ne("replace"), Be = !!/./[$e] && "" === /./[$e]("a", "$0"), Ye = !o(function() {
  var t13 = /(?:)/, e2 = t13.exec;
  t13.exec = function() {
    return e2.apply(this, arguments);
  };
  var n2 = "ab".split(t13);
  return 2 !== n2.length || "a" !== n2[0] || "b" !== n2[1];
}), Ge = function(t13, e2, n2, r2) {
  var i2 = ne(t13), u2 = !o(function() {
    var e3 = {};
    return e3[i2] = function() {
      return 7;
    }, 7 != ""[t13](e3);
  }), a3 = u2 && !o(function() {
    var e3 = false, n3 = /a/;
    return "split" === t13 && ((n3 = {}).constructor = {}, n3.constructor[Fe] = function() {
      return n3;
    }, n3.flags = "", n3[i2] = /./[i2]), n3.exec = function() {
      return e3 = true, null;
    }, n3[i2](""), !e3;
  });
  if (!u2 || !a3 || "replace" === t13 && (!We || !ze || Be) || "split" === t13 && !Ye) {
    var c2 = /./[i2], l2 = n2(i2, ""[t13], function(t14, e3, n3, r3, o2) {
      return e3.exec === Me ? u2 && !o2 ? { done: true, value: c2.call(e3, n3, r3) } : { done: true, value: t14.call(n3, e3, r3) } : { done: false };
    }, { REPLACE_KEEPS_$0: ze, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: Be }), f2 = l2[0], s3 = l2[1];
    Z2(String.prototype, t13, f2), Z2(RegExp.prototype, i2, 2 == e2 ? function(t14, e3) {
      return s3.call(t14, this, e3);
    } : function(t14) {
      return s3.call(t14, this);
    });
  }
  r2 && I(RegExp.prototype[i2], "sham", true);
}, He = ne("match"), Xe = function(t13) {
  var e2;
  return h2(t13) && (void 0 !== (e2 = t13[He]) ? !!e2 : "RegExp" == s2(t13));
}, Ve = function(t13) {
  if ("function" != typeof t13)
    throw TypeError(String(t13) + " is not a function");
  return t13;
}, Ke = ne("species"), qe = function(t13) {
  return function(e2, n2) {
    var r2, o2, i2 = String(p(e2)), u2 = it(n2), a3 = i2.length;
    return u2 < 0 || u2 >= a3 ? t13 ? "" : void 0 : (r2 = i2.charCodeAt(u2)) < 55296 || r2 > 56319 || u2 + 1 === a3 || (o2 = i2.charCodeAt(u2 + 1)) < 56320 || o2 > 57343 ? t13 ? i2.charAt(u2) : r2 : t13 ? i2.slice(u2, u2 + 2) : o2 - 56320 + (r2 - 55296 << 10) + 65536;
  };
}, Qe = { codeAt: qe(false), charAt: qe(true) }, Je = Qe.charAt, Ze = function(t13, e2, n2) {
  return e2 + (n2 ? Je(t13, e2).length : 1);
}, tn = function(t13, e2) {
  var n2 = t13.exec;
  if ("function" == typeof n2) {
    var r2 = n2.call(t13, e2);
    if ("object" != typeof r2)
      throw TypeError("RegExp exec method returned something other than an Object or null");
    return r2;
  }
  if ("RegExp" !== s2(t13))
    throw TypeError("RegExp#exec called on incompatible receiver");
  return Me.call(t13, e2);
}, en = [].push, nn = Math.min, rn = !o(function() {
  return !RegExp(4294967295, "y");
});
Ge("split", 2, function(t13, e2, n2) {
  var r2;
  return r2 = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function(t14, n3) {
    var r3 = String(p(this)), o2 = void 0 === n3 ? 4294967295 : n3 >>> 0;
    if (0 === o2)
      return [];
    if (void 0 === t14)
      return [r3];
    if (!Xe(t14))
      return e2.call(r3, t14, o2);
    for (var i2, u2, a3, c2 = [], l2 = (t14.ignoreCase ? "i" : "") + (t14.multiline ? "m" : "") + (t14.unicode ? "u" : "") + (t14.sticky ? "y" : ""), f2 = 0, s3 = new RegExp(t14.source, l2 + "g"); (i2 = Me.call(s3, r3)) && !((u2 = s3.lastIndex) > f2 && (c2.push(r3.slice(f2, i2.index)), i2.length > 1 && i2.index < r3.length && en.apply(c2, i2.slice(1)), a3 = i2[0].length, f2 = u2, c2.length >= o2)); )
      s3.lastIndex === i2.index && s3.lastIndex++;
    return f2 === r3.length ? !a3 && s3.test("") || c2.push("") : c2.push(r3.slice(f2)), c2.length > o2 ? c2.slice(0, o2) : c2;
  } : "0".split(void 0, 0).length ? function(t14, n3) {
    return void 0 === t14 && 0 === n3 ? [] : e2.call(this, t14, n3);
  } : e2, [function(e3, n3) {
    var o2 = p(this), i2 = null == e3 ? void 0 : e3[t13];
    return void 0 !== i2 ? i2.call(e3, o2, n3) : r2.call(String(o2), e3, n3);
  }, function(t14, o2) {
    var i2 = n2(r2, t14, this, o2, r2 !== e2);
    if (i2.done)
      return i2.value;
    var u2 = A2(t14), a3 = String(this), c2 = function(t15, e3) {
      var n3, r3 = A2(t15).constructor;
      return void 0 === r3 || null == (n3 = A2(r3)[Ke]) ? e3 : Ve(n3);
    }(u2, RegExp), l2 = u2.unicode, f2 = (u2.ignoreCase ? "i" : "") + (u2.multiline ? "m" : "") + (u2.unicode ? "u" : "") + (rn ? "y" : "g"), s3 = new c2(rn ? u2 : "^(?:" + u2.source + ")", f2), d3 = void 0 === o2 ? 4294967295 : o2 >>> 0;
    if (0 === d3)
      return [];
    if (0 === a3.length)
      return null === tn(s3, a3) ? [a3] : [];
    for (var v2 = 0, p2 = 0, g2 = []; p2 < a3.length; ) {
      s3.lastIndex = rn ? p2 : 0;
      var h3, y2 = tn(s3, rn ? a3 : a3.slice(p2));
      if (null === y2 || (h3 = nn(at(s3.lastIndex + (rn ? 0 : p2)), a3.length)) === v2)
        p2 = Ze(a3, p2, l2);
      else {
        if (g2.push(a3.slice(v2, p2)), g2.length === d3)
          return g2;
        for (var m3 = 1; m3 <= y2.length - 1; m3++)
          if (g2.push(y2[m3]), g2.length === d3)
            return g2;
        p2 = v2 = h3;
      }
    }
    return g2.push(a3.slice(v2)), g2;
  }];
}, !rn);
var on = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF", un = "[" + on + "]", an = RegExp("^" + un + un + "*"), cn = RegExp(un + un + "*$"), ln = function(t13) {
  return function(e2) {
    var n2 = String(p(e2));
    return 1 & t13 && (n2 = n2.replace(an, "")), 2 & t13 && (n2 = n2.replace(cn, "")), n2;
  };
}, fn2 = { start: ln(1), end: ln(2), trim: ln(3) }, sn = fn2.trim;
It({ target: "String", proto: true, forced: function(t13) {
  return o(function() {
    return !!on[t13]() || "\u200B\x85\u180E" != "\u200B\x85\u180E"[t13]() || on[t13].name !== t13;
  });
}("trim") }, { trim: function() {
  return sn(this);
} });
var dn = de("slice"), vn = Mt("slice", { ACCESSORS: true, 0: 0, 1: 2 }), pn = ne("species"), gn = [].slice, hn = Math.max;
It({ target: "Array", proto: true, forced: !dn || !vn }, { slice: function(t13, e2) {
  var n2, r2, o2, i2 = g(this), u2 = at(i2.length), a3 = ft(t13, u2), c2 = ft(void 0 === e2 ? u2 : e2, u2);
  if (qt(i2) && ("function" != typeof (n2 = i2.constructor) || n2 !== Array && !qt(n2.prototype) ? h2(n2) && null === (n2 = n2[pn]) && (n2 = void 0) : n2 = void 0, n2 === Array || void 0 === n2))
    return gn.call(i2, a3, c2);
  for (r2 = new (void 0 === n2 ? Array : n2)(hn(c2 - a3, 0)), o2 = 0; a3 < c2; a3++, o2++)
    a3 in i2 && ie(r2, o2, i2[a3]);
  return r2.length = o2, r2;
} });
var yn = Object.keys || function(t13) {
  return pt(t13, gt);
}, mn = o(function() {
  yn(1);
});
It({ target: "Object", stat: true, forced: mn }, { keys: function(t13) {
  return yn(Kt(t13));
} });
var Sn, xn = function(t13) {
  if (Xe(t13))
    throw TypeError("The method doesn't accept regular expressions");
  return t13;
}, bn = ne("match"), En = T.f, wn = "".startsWith, On = Math.min, Tn = function(t13) {
  var e2 = /./;
  try {
    "/./"[t13](e2);
  } catch (n2) {
    try {
      return e2[bn] = false, "/./"[t13](e2);
    } catch (t14) {
    }
  }
  return false;
}("startsWith"), An = !(Tn || (Sn = En(String.prototype, "startsWith"), !Sn || Sn.writable));
function kn(t13) {
  return (kn = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t14) {
    return typeof t14;
  } : function(t14) {
    return t14 && "function" == typeof Symbol && t14.constructor === Symbol && t14 !== Symbol.prototype ? "symbol" : typeof t14;
  })(t13);
}
It({ target: "String", proto: true, forced: !An && !Tn }, { startsWith: function(t13) {
  var e2 = String(p(this));
  xn(t13);
  var n2 = at(On(arguments.length > 1 ? arguments[1] : void 0, e2.length)), r2 = String(t13);
  return wn ? wn.call(e2, r2, n2) : e2.slice(n2, n2 + r2.length) === r2;
} });
var jn = function(t13) {
  return "string" == typeof t13;
}, Mn = function(t13) {
  return null !== t13 && "object" === kn(t13);
}, Vn = function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "isWindow", value: function(t14) {
    return t14 === window;
  } }, { key: "addEventListener", value: function(t14, e2, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t14 && e2 && n2 && t14.addEventListener(e2, n2, r2);
  } }, { key: "removeEventListener", value: function(t14, e2, n2) {
    var r2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
    t14 && e2 && n2 && t14.removeEventListener(e2, n2, r2);
  } }, { key: "triggerDragEvent", value: function(e2, n2) {
    var r2 = false, o2 = function(t14) {
      var e3;
      null === (e3 = n2.drag) || void 0 === e3 || e3.call(n2, t14);
    }, i2 = function e3(i3) {
      var u2;
      t13.removeEventListener(document, "mousemove", o2), t13.removeEventListener(document, "mouseup", e3), document.onselectstart = null, document.ondragstart = null, r2 = false, null === (u2 = n2.end) || void 0 === u2 || u2.call(n2, i3);
    };
    t13.addEventListener(e2, "mousedown", function(e3) {
      var u2;
      r2 || (document.onselectstart = function() {
        return false;
      }, document.ondragstart = function() {
        return false;
      }, t13.addEventListener(document, "mousemove", o2), t13.addEventListener(document, "mouseup", i2), r2 = true, null === (u2 = n2.start) || void 0 === u2 || u2.call(n2, e3));
    });
  } }, { key: "getBoundingClientRect", value: function(t14) {
    return t14 && Mn(t14) && 1 === t14.nodeType ? t14.getBoundingClientRect() : null;
  } }, { key: "hasClass", value: function(t14, e2) {
    return !!(t14 && Mn(t14) && jn(e2) && 1 === t14.nodeType) && t14.classList.contains(e2.trim());
  } }, { key: "addClass", value: function(e2, n2) {
    if (e2 && Mn(e2) && jn(n2) && 1 === e2.nodeType && (n2 = n2.trim(), !t13.hasClass(e2, n2))) {
      var r2 = e2.className;
      e2.className = r2 ? r2 + " " + n2 : n2;
    }
  } }, { key: "removeClass", value: function(t14, e2) {
    if (t14 && Mn(t14) && jn(e2) && 1 === t14.nodeType && "string" == typeof t14.className) {
      e2 = e2.trim();
      for (var n2 = t14.className.trim().split(" "), r2 = n2.length - 1; r2 >= 0; r2--)
        n2[r2] = n2[r2].trim(), n2[r2] && n2[r2] !== e2 || n2.splice(r2, 1);
      t14.className = n2.join(" ");
    }
  } }, { key: "toggleClass", value: function(t14, e2, n2) {
    t14 && Mn(t14) && jn(e2) && 1 === t14.nodeType && t14.classList.toggle(e2, n2);
  } }, { key: "replaceClass", value: function(e2, n2, r2) {
    e2 && Mn(e2) && jn(n2) && jn(r2) && 1 === e2.nodeType && (n2 = n2.trim(), r2 = r2.trim(), t13.removeClass(e2, n2), t13.addClass(e2, r2));
  } }, { key: "getScrollTop", value: function(t14) {
    var e2 = "scrollTop" in t14 ? t14.scrollTop : t14.pageYOffset;
    return Math.max(e2, 0);
  } }, { key: "setScrollTop", value: function(t14, e2) {
    "scrollTop" in t14 ? t14.scrollTop = e2 : t14.scrollTo(t14.scrollX, e2);
  } }, { key: "getRootScrollTop", value: function() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  } }, { key: "setRootScrollTop", value: function(e2) {
    t13.setScrollTop(window, e2), t13.setScrollTop(document.body, e2);
  } }, { key: "getElementTop", value: function(e2, n2) {
    if (t13.isWindow(e2))
      return 0;
    var r2 = n2 ? t13.getScrollTop(n2) : t13.getRootScrollTop();
    return e2.getBoundingClientRect().top + r2;
  } }, { key: "getVisibleHeight", value: function(e2) {
    return t13.isWindow(e2) ? e2.innerHeight : e2.getBoundingClientRect().height;
  } }, { key: "isHidden", value: function(t14) {
    if (!t14)
      return false;
    var e2 = window.getComputedStyle(t14), n2 = "none" === e2.display, r2 = null === t14.offsetParent && "fixed" !== e2.position;
    return n2 || r2;
  } }, { key: "triggerEvent", value: function(t14, e2) {
    if ("createEvent" in document) {
      var n2 = document.createEvent("HTMLEvents");
      n2.initEvent(e2, false, true), t14.dispatchEvent(n2);
    }
  } }, { key: "calcAngle", value: function(t14, e2) {
    var n2 = t14.getBoundingClientRect(), r2 = n2.left + n2.width / 2, o2 = n2.top + n2.height / 2, i2 = Math.abs(r2 - e2.clientX), u2 = Math.abs(o2 - e2.clientY), a3 = u2 / Math.sqrt(Math.pow(i2, 2) + Math.pow(u2, 2)), c2 = Math.acos(a3), l2 = Math.floor(180 / (Math.PI / c2));
    return e2.clientX > r2 && e2.clientY > o2 && (l2 = 180 - l2), e2.clientX == r2 && e2.clientY > o2 && (l2 = 180), e2.clientX > r2 && e2.clientY == o2 && (l2 = 90), e2.clientX < r2 && e2.clientY > o2 && (l2 = 180 + l2), e2.clientX < r2 && e2.clientY == o2 && (l2 = 270), e2.clientX < r2 && e2.clientY < o2 && (l2 = 360 - l2), l2;
  } }, { key: "querySelector", value: function(t14, e2) {
    return e2 ? e2.querySelector(t14) : document.querySelector(t14);
  } }, { key: "createElement", value: function(t14) {
    for (var e2 = document.createElement(t14), n2 = arguments.length, r2 = new Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++)
      r2[o2 - 1] = arguments[o2];
    for (var i2 = 0; i2 < r2.length; i2++)
      r2[i2] && e2.classList.add(r2[i2]);
    return e2;
  } }, { key: "appendChild", value: function(t14) {
    for (var e2 = 0; e2 < (arguments.length <= 1 ? 0 : arguments.length - 1); e2++)
      t14.appendChild(e2 + 1 < 1 || arguments.length <= e2 + 1 ? void 0 : arguments[e2 + 1]);
  } }, { key: "getWindow", value: function(t14) {
    if ("[object Window]" !== t14.toString()) {
      var e2 = t14.ownerDocument;
      return e2 && e2.defaultView || window;
    }
    return t14;
  } }, { key: "isElement", value: function(t14) {
    return t14 instanceof this.getWindow(t14).Element || t14 instanceof Element;
  } }, { key: "isHTMLElement", value: function(t14) {
    return t14 instanceof this.getWindow(t14).HTMLElement || t14 instanceof HTMLElement;
  } }, { key: "isShadowRoot", value: function(t14) {
    return "undefined" != typeof ShadowRoot && (t14 instanceof this.getWindow(t14).ShadowRoot || t14 instanceof ShadowRoot);
  } }, { key: "getWindowScroll", value: function(t14) {
    var e2 = this.getWindow(t14);
    return { scrollLeft: e2.pageXOffset || 0, scrollTop: e2.pageYOffset || 0 };
  } }]), t13;
}(), Kn = Math.floor, qn = "".replace, Qn = /\$([$&'`]|\d\d?|<[^>]*>)/g, Jn = /\$([$&'`]|\d\d?)/g, Zn = function(t13, e2, n2, r2, o2, i2) {
  var u2 = n2 + t13.length, a3 = r2.length, c2 = Jn;
  return void 0 !== o2 && (o2 = Kt(o2), c2 = Qn), qn.call(i2, c2, function(i3, c3) {
    var l2;
    switch (c3.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return t13;
      case "`":
        return e2.slice(0, n2);
      case "'":
        return e2.slice(u2);
      case "<":
        l2 = o2[c3.slice(1, -1)];
        break;
      default:
        var f2 = +c3;
        if (0 === f2)
          return i3;
        if (f2 > a3) {
          var s3 = Kn(f2 / 10);
          return 0 === s3 ? i3 : s3 <= a3 ? void 0 === r2[s3 - 1] ? c3.charAt(1) : r2[s3 - 1] + c3.charAt(1) : i3;
        }
        l2 = r2[f2 - 1];
    }
    return void 0 === l2 ? "" : l2;
  });
}, tr = Math.max, er = Math.min;
Ge("replace", 2, function(t13, e2, n2, r2) {
  var o2 = r2.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, i2 = r2.REPLACE_KEEPS_$0, u2 = o2 ? "$" : "$0";
  return [function(n3, r3) {
    var o3 = p(this), i3 = null == n3 ? void 0 : n3[t13];
    return void 0 !== i3 ? i3.call(n3, o3, r3) : e2.call(String(o3), n3, r3);
  }, function(t14, r3) {
    if (!o2 && i2 || "string" == typeof r3 && -1 === r3.indexOf(u2)) {
      var a3 = n2(e2, t14, this, r3);
      if (a3.done)
        return a3.value;
    }
    var c2 = A2(t14), l2 = String(this), f2 = "function" == typeof r3;
    f2 || (r3 = String(r3));
    var s3 = c2.global;
    if (s3) {
      var d3 = c2.unicode;
      c2.lastIndex = 0;
    }
    for (var v2 = []; ; ) {
      var p2 = tn(c2, l2);
      if (null === p2)
        break;
      if (v2.push(p2), !s3)
        break;
      "" === String(p2[0]) && (c2.lastIndex = Ze(l2, at(c2.lastIndex), d3));
    }
    for (var g2, h3 = "", y2 = 0, m3 = 0; m3 < v2.length; m3++) {
      p2 = v2[m3];
      for (var S3 = String(p2[0]), x2 = tr(er(it(p2.index), l2.length), 0), b2 = [], E2 = 1; E2 < p2.length; E2++)
        b2.push(void 0 === (g2 = p2[E2]) ? g2 : String(g2));
      var w2 = p2.groups;
      if (f2) {
        var O2 = [S3].concat(b2, x2, l2);
        void 0 !== w2 && O2.push(w2);
        var T2 = String(r3.apply(void 0, O2));
      } else
        T2 = Zn(S3, l2, x2, b2, w2, r3);
      x2 >= y2 && (h3 += l2.slice(y2, x2) + T2, y2 = x2 + S3.length);
    }
    return h3 + l2.slice(y2);
  }];
});
(function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "camelize", value: function(t14) {
    return t14.replace(/-(\w)/g, function(t15, e2) {
      return e2 ? e2.toUpperCase() : "";
    });
  } }, { key: "capitalize", value: function(t14) {
    return t14.charAt(0).toUpperCase() + t14.slice(1);
  } }]), t13;
})();
(function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "_clone", value: function() {
  } }]), t13;
})();
var or = ne("isConcatSpreadable"), ir = fe >= 51 || !o(function() {
  var t13 = [];
  return t13[or] = false, t13.concat()[0] !== t13;
}), ur = de("concat"), ar = function(t13) {
  if (!h2(t13))
    return false;
  var e2 = t13[or];
  return void 0 !== e2 ? !!e2 : qt(t13);
};
It({ target: "Array", proto: true, forced: !ir || !ur }, { concat: function(t13) {
  var e2, n2, r2, o2, i2, u2 = Kt(this), a3 = oe(u2, 0), c2 = 0;
  for (e2 = -1, r2 = arguments.length; e2 < r2; e2++)
    if (ar(i2 = -1 === e2 ? u2 : arguments[e2])) {
      if (c2 + (o2 = at(i2.length)) > 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      for (n2 = 0; n2 < o2; n2++, c2++)
        n2 in i2 && ie(a3, c2, i2[n2]);
    } else {
      if (c2 >= 9007199254740991)
        throw TypeError("Maximum allowed index exceeded");
      ie(a3, c2++, i2);
    }
  return a3.length = c2, a3;
} });
var cr, lr = function(t13, e2, n2) {
  if (Ve(t13), void 0 === e2)
    return t13;
  switch (n2) {
    case 0:
      return function() {
        return t13.call(e2);
      };
    case 1:
      return function(n3) {
        return t13.call(e2, n3);
      };
    case 2:
      return function(n3, r2) {
        return t13.call(e2, n3, r2);
      };
    case 3:
      return function(n3, r2, o2) {
        return t13.call(e2, n3, r2, o2);
      };
  }
  return function() {
    return t13.apply(e2, arguments);
  };
}, fr = [].push, sr = function(t13) {
  var e2 = 1 == t13, n2 = 2 == t13, r2 = 3 == t13, o2 = 4 == t13, i2 = 6 == t13, u2 = 7 == t13, a3 = 5 == t13 || i2;
  return function(c2, l2, f2, s3) {
    for (var d3, p2, g2 = Kt(c2), h3 = v(g2), y2 = lr(l2, f2, 3), m3 = at(h3.length), S3 = 0, x2 = s3 || oe, b2 = e2 ? x2(c2, m3) : n2 || u2 ? x2(c2, 0) : void 0; m3 > S3; S3++)
      if ((a3 || S3 in h3) && (p2 = y2(d3 = h3[S3], S3, g2), t13))
        if (e2)
          b2[S3] = p2;
        else if (p2)
          switch (t13) {
            case 3:
              return true;
            case 5:
              return d3;
            case 6:
              return S3;
            case 2:
              fr.call(b2, d3);
          }
        else
          switch (t13) {
            case 4:
              return false;
            case 7:
              fr.call(b2, d3);
          }
    return i2 ? -1 : r2 || o2 ? o2 : b2;
  };
}, dr = { forEach: sr(0), map: sr(1), filter: sr(2), some: sr(3), every: sr(4), find: sr(5), findIndex: sr(6), filterOut: sr(7) }, vr = i ? Object.defineProperties : function(t13, e2) {
  A2(t13);
  for (var n2, r2 = yn(e2), o2 = r2.length, i2 = 0; o2 > i2; )
    R.f(t13, n2 = r2[i2++], e2[n2]);
  return t13;
}, pr = nt("document", "documentElement"), gr = Y("IE_PROTO"), hr = function() {
}, yr = function(t13) {
  return "<script>" + t13 + "<\/script>";
}, mr = function() {
  try {
    cr = document.domain && new ActiveXObject("htmlfile");
  } catch (t14) {
  }
  var t13, e2;
  mr = cr ? function(t14) {
    t14.write(yr("")), t14.close();
    var e3 = t14.parentWindow.Object;
    return t14 = null, e3;
  }(cr) : ((e2 = E("iframe")).style.display = "none", pr.appendChild(e2), e2.src = String("javascript:"), (t13 = e2.contentWindow.document).open(), t13.write(yr("document.F=Object")), t13.close(), t13.F);
  for (var n2 = gt.length; n2--; )
    delete mr.prototype[gt[n2]];
  return mr();
};
G[gr] = true;
var Sr = Object.create || function(t13, e2) {
  var n2;
  return null !== t13 ? (hr.prototype = A2(t13), n2 = new hr(), hr.prototype = null, n2[gr] = t13) : n2 = mr(), void 0 === e2 ? n2 : vr(n2, e2);
}, xr = ne("unscopables"), br = Array.prototype;
null == br[xr] && R.f(br, xr, { configurable: true, value: Sr(null) });
var Er = function(t13) {
  br[xr][t13] = true;
}, wr = dr.find, Or = true, Tr = Mt("find");
"find" in [] && Array(1).find(function() {
  Or = false;
}), It({ target: "Array", proto: true, forced: Or || !Tr }, { find: function(t13) {
  return wr(this, t13, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("find");
var Ar = dr.findIndex, kr = true, Rr = Mt("findIndex");
"findIndex" in [] && Array(1).findIndex(function() {
  kr = false;
}), It({ target: "Array", proto: true, forced: kr || !Rr }, { findIndex: function(t13) {
  return Ar(this, t13, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("findIndex");
var Ir = function(t13, e2, n2, r2, o2, i2, u2, a3) {
  for (var c2, l2 = o2, f2 = 0, s3 = !!u2 && lr(u2, a3, 3); f2 < r2; ) {
    if (f2 in n2) {
      if (c2 = s3 ? s3(n2[f2], f2, e2) : n2[f2], i2 > 0 && qt(c2))
        l2 = Ir(t13, e2, c2, at(c2.length), l2, i2 - 1) - 1;
      else {
        if (l2 >= 9007199254740991)
          throw TypeError("Exceed the acceptable array length");
        t13[l2] = c2;
      }
      l2++;
    }
    f2++;
  }
  return l2;
}, jr = Ir;
It({ target: "Array", proto: true }, { flat: function() {
  var t13 = arguments.length ? arguments[0] : void 0, e2 = Kt(this), n2 = at(e2.length), r2 = oe(e2, 0);
  return r2.length = jr(r2, e2, e2, n2, 0, void 0 === t13 ? 1 : it(t13)), r2;
} });
var Cr = function(t13) {
  var e2 = t13.return;
  if (void 0 !== e2)
    return A2(e2.call(t13)).value;
}, Lr = function(t13, e2, n2, r2) {
  try {
    return r2 ? e2(A2(n2)[0], n2[1]) : e2(n2);
  } catch (e3) {
    throw Cr(t13), e3;
  }
}, Pr = {}, Mr = ne("iterator"), _r = Array.prototype, Dr = function(t13) {
  return void 0 !== t13 && (Pr.Array === t13 || _r[Mr] === t13);
}, Ur = ne("iterator"), Nr = function(t13) {
  if (null != t13)
    return t13[Ur] || t13["@@iterator"] || Pr[be(t13)];
}, Fr = ne("iterator"), Wr = false;
try {
  var zr = 0, $r = { next: function() {
    return { done: !!zr++ };
  }, return: function() {
    Wr = true;
  } };
  $r[Fr] = function() {
    return this;
  }, Array.from($r, function() {
    throw 2;
  });
} catch (t13) {
}
var Br = function(t13, e2) {
  if (!e2 && !Wr)
    return false;
  var n2 = false;
  try {
    var r2 = {};
    r2[Fr] = function() {
      return { next: function() {
        return { done: n2 = true };
      } };
    }, t13(r2);
  } catch (t14) {
  }
  return n2;
}, Yr = !Br(function(t13) {
  Array.from(t13);
});
It({ target: "Array", stat: true, forced: Yr }, { from: function(t13) {
  var e2, n2, r2, o2, i2, u2, a3 = Kt(t13), c2 = "function" == typeof this ? this : Array, l2 = arguments.length, f2 = l2 > 1 ? arguments[1] : void 0, s3 = void 0 !== f2, d3 = Nr(a3), v2 = 0;
  if (s3 && (f2 = lr(f2, l2 > 2 ? arguments[2] : void 0, 2)), null == d3 || c2 == Array && Dr(d3))
    for (n2 = new c2(e2 = at(a3.length)); e2 > v2; v2++)
      u2 = s3 ? f2(a3[v2], v2) : a3[v2], ie(n2, v2, u2);
  else
    for (i2 = (o2 = d3.call(a3)).next, n2 = new c2(); !(r2 = i2.call(o2)).done; v2++)
      u2 = s3 ? Lr(o2, f2, [r2.value, v2], true) : r2.value, ie(n2, v2, u2);
  return n2.length = v2, n2;
} });
var Gr = function(t13) {
  return function(e2, n2, r2, o2) {
    Ve(n2);
    var i2 = Kt(e2), u2 = v(i2), a3 = at(i2.length), c2 = t13 ? a3 - 1 : 0, l2 = t13 ? -1 : 1;
    if (r2 < 2)
      for (; ; ) {
        if (c2 in u2) {
          o2 = u2[c2], c2 += l2;
          break;
        }
        if (c2 += l2, t13 ? c2 < 0 : a3 <= c2)
          throw TypeError("Reduce of empty array with no initial value");
      }
    for (; t13 ? c2 >= 0 : a3 > c2; c2 += l2)
      c2 in u2 && (o2 = n2(o2, u2[c2], c2, i2));
    return o2;
  };
}, Hr = { left: Gr(false), right: Gr(true) }, Xr = "process" == s2(r.process), Vr = Hr.left, Kr = jt("reduce"), qr = Mt("reduce", { 1: 0 });
It({ target: "Array", proto: true, forced: !Kr || !qr || !Xr && fe > 79 && fe < 83 }, { reduce: function(t13) {
  return Vr(this, t13, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
} }), Er("flat");
var Qr, Jr, Zr, to = !o(function() {
  return Object.isExtensible(Object.preventExtensions({}));
}), eo = e(function(t13) {
  var e2 = R.f, n2 = $("meta"), r2 = 0, o2 = Object.isExtensible || function() {
    return true;
  }, i2 = function(t14) {
    e2(t14, n2, { value: { objectID: "O" + ++r2, weakData: {} } });
  }, u2 = t13.exports = { REQUIRED: false, fastKey: function(t14, e3) {
    if (!h2(t14))
      return "symbol" == typeof t14 ? t14 : ("string" == typeof t14 ? "S" : "P") + t14;
    if (!S2(t14, n2)) {
      if (!o2(t14))
        return "F";
      if (!e3)
        return "E";
      i2(t14);
    }
    return t14[n2].objectID;
  }, getWeakData: function(t14, e3) {
    if (!S2(t14, n2)) {
      if (!o2(t14))
        return true;
      if (!e3)
        return false;
      i2(t14);
    }
    return t14[n2].weakData;
  }, onFreeze: function(t14) {
    return to && u2.REQUIRED && o2(t14) && !S2(t14, n2) && i2(t14), t14;
  } };
  G[n2] = true;
}), no = function(t13, e2) {
  this.stopped = t13, this.result = e2;
}, ro = function(t13, e2, n2) {
  var r2, o2, i2, u2, a3, c2, l2, f2 = n2 && n2.that, s3 = !(!n2 || !n2.AS_ENTRIES), d3 = !(!n2 || !n2.IS_ITERATOR), v2 = !(!n2 || !n2.INTERRUPTED), p2 = lr(e2, f2, 1 + s3 + v2), g2 = function(t14) {
    return r2 && Cr(r2), new no(true, t14);
  }, h3 = function(t14) {
    return s3 ? (A2(t14), v2 ? p2(t14[0], t14[1], g2) : p2(t14[0], t14[1])) : v2 ? p2(t14, g2) : p2(t14);
  };
  if (d3)
    r2 = t13;
  else {
    if ("function" != typeof (o2 = Nr(t13)))
      throw TypeError("Target is not iterable");
    if (Dr(o2)) {
      for (i2 = 0, u2 = at(t13.length); u2 > i2; i2++)
        if ((a3 = h3(t13[i2])) && a3 instanceof no)
          return a3;
      return new no(false);
    }
    r2 = o2.call(t13);
  }
  for (c2 = r2.next; !(l2 = c2.call(r2)).done; ) {
    try {
      a3 = h3(l2.value);
    } catch (t14) {
      throw Cr(r2), t14;
    }
    if ("object" == typeof a3 && a3 && a3 instanceof no)
      return a3;
  }
  return new no(false);
}, oo = function(t13, e2, n2) {
  if (!(t13 instanceof e2))
    throw TypeError("Incorrect " + (n2 ? n2 + " " : "") + "invocation");
  return t13;
}, io = R.f, uo = ne("toStringTag"), ao = function(t13, e2, n2) {
  t13 && !S2(t13 = n2 ? t13 : t13.prototype, uo) && io(t13, uo, { configurable: true, value: e2 });
}, co = Object.setPrototypeOf || ("__proto__" in {} ? function() {
  var t13, e2 = false, n2 = {};
  try {
    (t13 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n2, []), e2 = n2 instanceof Array;
  } catch (t14) {
  }
  return function(n3, r2) {
    return A2(n3), function(t14) {
      if (!h2(t14) && null !== t14)
        throw TypeError("Can't set " + String(t14) + " as a prototype");
    }(r2), e2 ? t13.call(n3, r2) : n3.__proto__ = r2, n3;
  };
}() : void 0), lo = function(t13, e2, n2) {
  for (var r2 in e2)
    Z2(t13, r2, e2[r2], n2);
  return t13;
}, fo = !o(function() {
  function t13() {
  }
  return t13.prototype.constructor = null, Object.getPrototypeOf(new t13()) !== t13.prototype;
}), so = Y("IE_PROTO"), vo = Object.prototype, po = fo ? Object.getPrototypeOf : function(t13) {
  return t13 = Kt(t13), S2(t13, so) ? t13[so] : "function" == typeof t13.constructor && t13 instanceof t13.constructor ? t13.constructor.prototype : t13 instanceof Object ? vo : null;
}, go = ne("iterator"), ho = false;
[].keys && ("next" in (Zr = [].keys()) ? (Jr = po(po(Zr))) !== Object.prototype && (Qr = Jr) : ho = true), (null == Qr || o(function() {
  var t13 = {};
  return Qr[go].call(t13) !== t13;
})) && (Qr = {}), S2(Qr, go) || I(Qr, go, function() {
  return this;
});
var yo = { IteratorPrototype: Qr, BUGGY_SAFARI_ITERATORS: ho }, mo = yo.IteratorPrototype, So = function() {
  return this;
}, xo = yo.IteratorPrototype, bo = yo.BUGGY_SAFARI_ITERATORS, Eo = ne("iterator"), wo = function() {
  return this;
}, Oo = function(t13, e2, n2, r2, o2, i2, u2) {
  !function(t14, e3, n3) {
    var r3 = e3 + " Iterator";
    t14.prototype = Sr(mo, { next: l(1, n3) }), ao(t14, r3, false), Pr[r3] = So;
  }(n2, e2, r2);
  var a3, c2, f2, s3 = function(t14) {
    if (t14 === o2 && h3)
      return h3;
    if (!bo && t14 in p2)
      return p2[t14];
    switch (t14) {
      case "keys":
      case "values":
      case "entries":
        return function() {
          return new n2(this, t14);
        };
    }
    return function() {
      return new n2(this);
    };
  }, d3 = e2 + " Iterator", v2 = false, p2 = t13.prototype, g2 = p2[Eo] || p2["@@iterator"] || o2 && p2[o2], h3 = !bo && g2 || s3(o2), y2 = "Array" == e2 && p2.entries || g2;
  if (y2 && (a3 = po(y2.call(new t13())), xo !== Object.prototype && a3.next && (po(a3) !== xo && (co ? co(a3, xo) : "function" != typeof a3[Eo] && I(a3, Eo, wo)), ao(a3, d3, true))), "values" == o2 && g2 && "values" !== g2.name && (v2 = true, h3 = function() {
    return g2.call(this);
  }), p2[Eo] !== h3 && I(p2, Eo, h3), Pr[e2] = h3, o2)
    if (c2 = { values: s3("values"), keys: i2 ? h3 : s3("keys"), entries: s3("entries") }, u2)
      for (f2 in c2)
        (bo || v2 || !(f2 in p2)) && Z2(p2, f2, c2[f2]);
    else
      It({ target: e2, proto: true, forced: bo || v2 }, c2);
  return c2;
}, To = ne("species"), Ao = R.f, ko = eo.fastKey, Ro = J.set, Io = J.getterFor;
!function(t13, e2, n2) {
  var i2 = -1 !== t13.indexOf("Map"), u2 = -1 !== t13.indexOf("Weak"), a3 = i2 ? "set" : "add", c2 = r[t13], l2 = c2 && c2.prototype, f2 = c2, s3 = {}, d3 = function(t14) {
    var e3 = l2[t14];
    Z2(l2, t14, "add" == t14 ? function(t15) {
      return e3.call(this, 0 === t15 ? 0 : t15), this;
    } : "delete" == t14 ? function(t15) {
      return !(u2 && !h2(t15)) && e3.call(this, 0 === t15 ? 0 : t15);
    } : "get" == t14 ? function(t15) {
      return u2 && !h2(t15) ? void 0 : e3.call(this, 0 === t15 ? 0 : t15);
    } : "has" == t14 ? function(t15) {
      return !(u2 && !h2(t15)) && e3.call(this, 0 === t15 ? 0 : t15);
    } : function(t15, n3) {
      return e3.call(this, 0 === t15 ? 0 : t15, n3), this;
    });
  };
  if (kt(t13, "function" != typeof c2 || !(u2 || l2.forEach && !o(function() {
    new c2().entries().next();
  }))))
    f2 = n2.getConstructor(e2, t13, i2, a3), eo.REQUIRED = true;
  else if (kt(t13, true)) {
    var v2 = new f2(), p2 = v2[a3](u2 ? {} : -0, 1) != v2, g2 = o(function() {
      v2.has(1);
    }), y2 = Br(function(t14) {
      new c2(t14);
    }), m3 = !u2 && o(function() {
      for (var t14 = new c2(), e3 = 5; e3--; )
        t14[a3](e3, e3);
      return !t14.has(-0);
    });
    y2 || ((f2 = e2(function(e3, n3) {
      oo(e3, f2, t13);
      var r2 = function(t14, e4, n4) {
        var r3, o2;
        return co && "function" == typeof (r3 = e4.constructor) && r3 !== n4 && h2(o2 = r3.prototype) && o2 !== n4.prototype && co(t14, o2), t14;
      }(new c2(), e3, f2);
      return null != n3 && ro(n3, r2[a3], { that: r2, AS_ENTRIES: i2 }), r2;
    })).prototype = l2, l2.constructor = f2), (g2 || m3) && (d3("delete"), d3("has"), i2 && d3("get")), (m3 || p2) && d3(a3), u2 && l2.clear && delete l2.clear;
  }
  s3[t13] = f2, It({ global: true, forced: f2 != c2 }, s3), ao(f2, t13), u2 || n2.setStrong(f2, t13, i2);
}("Set", function(t13) {
  return function() {
    return t13(this, arguments.length ? arguments[0] : void 0);
  };
}, { getConstructor: function(t13, e2, n2, r2) {
  var o2 = t13(function(t14, u3) {
    oo(t14, o2, e2), Ro(t14, { type: e2, index: Sr(null), first: void 0, last: void 0, size: 0 }), i || (t14.size = 0), null != u3 && ro(u3, t14[r2], { that: t14, AS_ENTRIES: n2 });
  }), u2 = Io(e2), a3 = function(t14, e3, n3) {
    var r3, o3, a4 = u2(t14), l2 = c2(t14, e3);
    return l2 ? l2.value = n3 : (a4.last = l2 = { index: o3 = ko(e3, true), key: e3, value: n3, previous: r3 = a4.last, next: void 0, removed: false }, a4.first || (a4.first = l2), r3 && (r3.next = l2), i ? a4.size++ : t14.size++, "F" !== o3 && (a4.index[o3] = l2)), t14;
  }, c2 = function(t14, e3) {
    var n3, r3 = u2(t14), o3 = ko(e3);
    if ("F" !== o3)
      return r3.index[o3];
    for (n3 = r3.first; n3; n3 = n3.next)
      if (n3.key == e3)
        return n3;
  };
  return lo(o2.prototype, { clear: function() {
    for (var t14 = u2(this), e3 = t14.index, n3 = t14.first; n3; )
      n3.removed = true, n3.previous && (n3.previous = n3.previous.next = void 0), delete e3[n3.index], n3 = n3.next;
    t14.first = t14.last = void 0, i ? t14.size = 0 : this.size = 0;
  }, delete: function(t14) {
    var e3 = this, n3 = u2(e3), r3 = c2(e3, t14);
    if (r3) {
      var o3 = r3.next, a4 = r3.previous;
      delete n3.index[r3.index], r3.removed = true, a4 && (a4.next = o3), o3 && (o3.previous = a4), n3.first == r3 && (n3.first = o3), n3.last == r3 && (n3.last = a4), i ? n3.size-- : e3.size--;
    }
    return !!r3;
  }, forEach: function(t14) {
    for (var e3, n3 = u2(this), r3 = lr(t14, arguments.length > 1 ? arguments[1] : void 0, 3); e3 = e3 ? e3.next : n3.first; )
      for (r3(e3.value, e3.key, this); e3 && e3.removed; )
        e3 = e3.previous;
  }, has: function(t14) {
    return !!c2(this, t14);
  } }), lo(o2.prototype, n2 ? { get: function(t14) {
    var e3 = c2(this, t14);
    return e3 && e3.value;
  }, set: function(t14, e3) {
    return a3(this, 0 === t14 ? 0 : t14, e3);
  } } : { add: function(t14) {
    return a3(this, t14 = 0 === t14 ? 0 : t14, t14);
  } }), i && Ao(o2.prototype, "size", { get: function() {
    return u2(this).size;
  } }), o2;
}, setStrong: function(t13, e2, n2) {
  var r2 = e2 + " Iterator", o2 = Io(e2), u2 = Io(r2);
  Oo(t13, e2, function(t14, e3) {
    Ro(this, { type: r2, target: t14, state: o2(t14), kind: e3, last: void 0 });
  }, function() {
    for (var t14 = u2(this), e3 = t14.kind, n3 = t14.last; n3 && n3.removed; )
      n3 = n3.previous;
    return t14.target && (t14.last = n3 = n3 ? n3.next : t14.state.first) ? "keys" == e3 ? { value: n3.key, done: false } : "values" == e3 ? { value: n3.value, done: false } : { value: [n3.key, n3.value], done: false } : (t14.target = void 0, { value: void 0, done: true });
  }, n2 ? "entries" : "values", !n2, true), function(t14) {
    var e3 = nt(t14), n3 = R.f;
    i && e3 && !e3[To] && n3(e3, To, { configurable: true, get: function() {
      return this;
    } });
  }(e2);
} });
var jo = Qe.charAt, Co = J.set, Lo = J.getterFor("String Iterator");
Oo(String, "String", function(t13) {
  Co(this, { type: "String Iterator", string: String(t13), index: 0 });
}, function() {
  var t13, e2 = Lo(this), n2 = e2.string, r2 = e2.index;
  return r2 >= n2.length ? { value: void 0, done: true } : (t13 = jo(n2, r2), e2.index += t13.length, { value: t13, done: false });
});
var Po = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 }, Mo = J.set, _o = J.getterFor("Array Iterator"), Do2 = Oo(Array, "Array", function(t13, e2) {
  Mo(this, { type: "Array Iterator", target: g(t13), index: 0, kind: e2 });
}, function() {
  var t13 = _o(this), e2 = t13.target, n2 = t13.kind, r2 = t13.index++;
  return !e2 || r2 >= e2.length ? (t13.target = void 0, { value: void 0, done: true }) : "keys" == n2 ? { value: r2, done: false } : "values" == n2 ? { value: e2[r2], done: false } : { value: [r2, e2[r2]], done: false };
}, "values");
Pr.Arguments = Pr.Array, Er("keys"), Er("values"), Er("entries");
var Uo = ne("iterator"), No = ne("toStringTag"), Fo = Do2.values;
for (var Wo in Po) {
  var zo = r[Wo], $o = zo && zo.prototype;
  if ($o) {
    if ($o[Uo] !== Fo)
      try {
        I($o, Uo, Fo);
      } catch (t13) {
        $o[Uo] = Fo;
      }
    if ($o[No] || I($o, No, Wo), Po[Wo]) {
      for (var Bo in Do2)
        if ($o[Bo] !== Do2[Bo])
          try {
            I($o, Bo, Do2[Bo]);
          } catch (t13) {
            $o[Bo] = Do2[Bo];
          }
    }
  }
}
(function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "deduplicate", value: function(t14) {
    return Array.from(new Set(t14));
  } }, { key: "flat", value: function(e2) {
    return e2.reduce(function(e3, n2) {
      var r2 = Array.isArray(n2) ? t13.flat(n2) : n2;
      return e3.concat(r2);
    }, []);
  } }, { key: "find", value: function(t14, e2) {
    return t14.find(e2);
  } }, { key: "findIndex", value: function(t14, e2) {
    return t14.findIndex(e2);
  } }]), t13;
})();
(function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "today", value: function() {
    return new Date();
  } }]), t13;
})();
(function() {
  function t13() {
    Wt(this, t13);
  }
  return $t(t13, null, [{ key: "range", value: function(t14, e2, n2) {
    return Math.min(Math.max(t14, e2), n2);
  } }, { key: "clamp", value: function(t14, e2, n2) {
    return e2 < n2 ? t14 < e2 ? e2 : t14 > n2 ? n2 : t14 : t14 < n2 ? n2 : t14 > e2 ? e2 : t14;
  } }]), t13;
})();
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
const freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
const root$1 = root;
var Symbol$1 = root$1.Symbol;
const Symbol$2 = Symbol$1;
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var nativeObjectToString$1 = objectProto$a.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value2) {
  var isOwn = hasOwnProperty$8.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
  try {
    value2[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value2);
  if (unmasked) {
    if (isOwn) {
      value2[symToStringTag$1] = tag;
    } else {
      delete value2[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$9 = Object.prototype;
var nativeObjectToString = objectProto$9.toString;
function objectToString(value2) {
  return nativeObjectToString.call(value2);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value2) {
  if (value2 == null) {
    return value2 === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
}
function isObjectLike(value2) {
  return value2 != null && typeof value2 == "object";
}
var isArray = Array.isArray;
const isArray$1 = isArray;
function isObject(value2) {
  var type = typeof value2;
  return value2 != null && (type == "object" || type == "function");
}
function identity(value2) {
  return value2;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value2) {
  if (!isObject(value2)) {
    return false;
  }
  var tag = baseGetTag(value2);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
const coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$8 = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value2) {
  if (!isObject(value2) || isMasked(value2)) {
    return false;
  }
  var pattern = isFunction(value2) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value2));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value2 = getValue(object, key);
  return baseIsNative(value2) ? value2 : void 0;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
const baseCreate$1 = baseCreate;
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source, array) {
  var index2 = -1, length = source.length;
  array || (array = Array(length));
  while (++index2 < length) {
    array[index2] = source[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count3 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count3 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count3 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value2) {
  return function() {
    return value2;
  };
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e2) {
  }
}();
const defineProperty$1 = defineProperty;
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
const setToString$1 = setToString;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value2, length) {
  var type = typeof value2;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
}
function baseAssignValue(object, key, value2) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value2,
      "writable": true
    });
  } else {
    object[key] = value2;
  }
}
function eq(value2, other) {
  return value2 === other || value2 !== value2 && other !== other;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function assignValue(object, key, value2) {
  var objValue = object[key];
  if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
    baseAssignValue(object, key, value2);
  }
}
function copyObject(source, props2, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length = props2.length;
  while (++index2 < length) {
    var key = props2[index2];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start2, 0), array = Array(length);
    while (++index2 < length) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString$1(overRest(func, start2, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value2) {
  return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
}
function isArrayLike(value2) {
  return value2 != null && isLength(value2.length) && !isFunction(value2);
}
function isIterateeCall(value2, index2, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value2);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$6 = Object.prototype;
function isPrototype(value2) {
  var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value2 === proto;
}
function baseTimes(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$1 = "[object Arguments]";
function baseIsArguments(value2) {
  return isObjectLike(value2) && baseGetTag(value2) == argsTag$1;
}
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value2) {
  return isObjectLike(value2) && hasOwnProperty$5.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
};
const isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer2 = nativeIsBuffer || stubFalse;
const isBuffer$1 = isBuffer2;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag$1 = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value2) {
  return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
}
function baseUnary(func) {
  return function(value2) {
    return func(value2);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e2) {
  }
}();
const nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
const isTypedArray$1 = isTypedArray;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function arrayLikeKeys(value2, inherited) {
  var isArr = isArray$1(value2), isArg = !isArr && isArguments$1(value2), isBuff = !isArr && !isArg && isBuffer$1(value2), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
  for (var key in value2) {
    if ((inherited || hasOwnProperty$4.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var nativeCreate = getNative(Object, "create");
const nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function hashGet(key) {
  var data9 = this.__data__;
  if (nativeCreate$1) {
    var result = data9[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$2.call(data9, key) ? data9[key] : void 0;
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashHas(key) {
  var data9 = this.__data__;
  return nativeCreate$1 ? data9[key] !== void 0 : hasOwnProperty$1.call(data9, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value2) {
  var data9 = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data9[key] = nativeCreate$1 && value2 === void 0 ? HASH_UNDEFINED : value2;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data9 = this.__data__, index2 = assocIndexOf(data9, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data9.length - 1;
  if (index2 == lastIndex) {
    data9.pop();
  } else {
    splice.call(data9, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data9 = this.__data__, index2 = assocIndexOf(data9, key);
  return index2 < 0 ? void 0 : data9[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value2) {
  var data9 = this.__data__, index2 = assocIndexOf(data9, key);
  if (index2 < 0) {
    ++this.size;
    data9.push([key, value2]);
  } else {
    data9[index2][1] = value2;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
const Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value2) {
  var type = typeof value2;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
}
function getMapData(map2, key) {
  var data9 = map2.__data__;
  return isKeyable(key) ? data9[typeof key == "string" ? "string" : "hash"] : data9.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value2) {
  var data9 = getMapData(this, key), size = data9.size;
  data9.set(key, value2);
  this.size += data9.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var getPrototype = overArg(Object.getPrototypeOf, Object);
const getPrototype$1 = getPrototype;
var objectTag = "[object Object]";
var funcProto = Function.prototype, objectProto = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty = objectProto.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value2) {
  if (!isObjectLike(value2) || baseGetTag(value2) != objectTag) {
    return false;
  }
  var proto = getPrototype$1(value2);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data9 = this.__data__, result = data9["delete"](key);
  this.size = data9.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value2) {
  var data9 = this.__data__;
  if (data9 instanceof ListCache) {
    var pairs = data9.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value2]);
      this.size = ++data9.size;
      return this;
    }
    data9 = this.__data__ = new MapCache(pairs);
  }
  data9.set(key, value2);
  this.size = data9.size;
  return this;
}
function Stack(entries) {
  var data9 = this.__data__ = new ListCache(entries);
  this.size = data9.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
const Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props2 = keysFunc(object), length = props2.length;
    while (length--) {
      var key = props2[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function assignMergeValue(object, key, value2) {
  if (value2 !== void 0 && !eq(object[key], value2) || value2 === void 0 && !(key in object)) {
    baseAssignValue(object, key, value2);
  }
}
function isArrayLikeObject(value2) {
  return isObjectLike(value2) && isArrayLike(value2);
}
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
function toPlainObject(value2) {
  return copyObject(value2, keysIn(value2));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
var merge2 = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
const merge$1 = merge2;
const calcAngle = (element, event) => {
  const rect = element.getBoundingClientRect();
  const originX = rect.left + rect.width / 2;
  const originY = rect.top + rect.height / 2;
  const x2 = Math.abs(originX - event.clientX);
  const y2 = Math.abs(originY - event.clientY);
  const z2 = Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
  const cos = y2 / z2;
  const rad = Math.acos(cos);
  let angle = Math.floor(180 / (Math.PI / rad));
  if (event.clientX > originX && event.clientY > originY) {
    angle = 180 - angle;
  }
  if (event.clientX == originX && event.clientY > originY) {
    angle = 180;
  }
  if (event.clientX > originX && event.clientY == originY) {
    angle = 90;
  }
  if (event.clientX < originX && event.clientY > originY) {
    angle = 180 + angle;
  }
  if (event.clientX < originX && event.clientY == originY) {
    angle = 270;
  }
  if (event.clientX < originX && event.clientY < originY) {
    angle = 360 - angle;
  }
  return angle;
};
let isDragging2 = false;
const triggerDragEvent = (element, options) => {
  const moveFn = function(event) {
    var _a;
    (_a = options.drag) == null ? void 0 : _a.call(options, event);
  };
  const upFn = function(event) {
    var _a;
    document.removeEventListener("mousemove", moveFn, false);
    document.removeEventListener("mouseup", upFn, false);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging2 = false;
    (_a = options.end) == null ? void 0 : _a.call(options, event);
  };
  if (element) {
    element.addEventListener("mousedown", (event) => {
      var _a;
      if (isDragging2)
        return;
      document.onselectstart = () => false;
      document.ondragstart = () => false;
      document.addEventListener("mousemove", moveFn, false);
      document.addEventListener("mouseup", upFn, false);
      isDragging2 = true;
      (_a = options.start) == null ? void 0 : _a.call(options, event);
    });
  }
  return;
};
const angleProps = {
  angle: {
    type: Number,
    default: 0
  },
  size: {
    type: Number,
    default: 16,
    validator: (value2) => {
      return value2 >= 16;
    }
  },
  borderWidth: {
    type: Number,
    default: 1,
    validator: (value2) => {
      return value2 >= 1;
    }
  },
  borderColor: {
    type: String,
    default: "#666"
  }
};
var Angle = defineComponent({
  name: "Angle",
  props: angleProps,
  emits: ["update:angle", "change"],
  setup(props2, {
    emit: emit2
  }) {
    const angleRef = ref(null);
    const rotate = ref(props2.angle);
    watch(() => props2.angle, (angle) => {
      rotate.value = angle;
    });
    const updateAngle = () => {
      let value2 = Number(rotate.value);
      if (!isNaN(value2)) {
        value2 = value2 > 360 || value2 < 0 ? props2.angle : value2;
        rotate.value = value2 === 360 ? 0 : value2;
        emit2("update:angle", rotate.value);
        emit2("change", rotate.value);
      }
    };
    const getStyle = computed(() => {
      return {
        width: props2.size + "px",
        height: props2.size + "px",
        borderWidth: props2.borderWidth + "px",
        borderColor: props2.borderColor,
        transform: `rotate(${rotate.value}deg)`
      };
    });
    const handleDrag = (event) => {
      if (angleRef.value) {
        rotate.value = calcAngle(angleRef.value, event) % 360;
        updateAngle();
      }
    };
    onMounted(() => {
      const dragConfig = {
        drag: (event) => {
          handleDrag(event);
        },
        end: (event) => {
          handleDrag(event);
        }
      };
      if (angleRef.value) {
        triggerDragEvent(angleRef.value, dragConfig);
      }
    });
    return () => {
      return createVNode("div", {
        "class": "bee-angle"
      }, [createVNode("div", {
        "class": "bee-angle__round",
        "ref": angleRef,
        "style": getStyle.value
      }, null)]);
    };
  }
});
const style$1 = "";
var GradientParser = GradientParser || {};
GradientParser.stringify = function() {
  var visitor = {
    "visit_linear-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_repeating-linear-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_radial-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_repeating-radial-gradient": function(node) {
      return visitor.visit_gradient(node);
    },
    "visit_gradient": function(node) {
      var orientation = visitor.visit(node.orientation);
      if (orientation) {
        orientation += ", ";
      }
      return node.type + "(" + orientation + visitor.visit(node.colorStops) + ")";
    },
    "visit_shape": function(node) {
      var result = node.value, at2 = visitor.visit(node.at), style2 = visitor.visit(node.style);
      if (style2) {
        result += " " + style2;
      }
      if (at2) {
        result += " at " + at2;
      }
      return result;
    },
    "visit_default-radial": function(node) {
      var result = "", at2 = visitor.visit(node.at);
      if (at2) {
        result += at2;
      }
      return result;
    },
    "visit_extent-keyword": function(node) {
      var result = node.value, at2 = visitor.visit(node.at);
      if (at2) {
        result += " at " + at2;
      }
      return result;
    },
    "visit_position-keyword": function(node) {
      return node.value;
    },
    "visit_position": function(node) {
      return visitor.visit(node.value.x) + " " + visitor.visit(node.value.y);
    },
    "visit_%": function(node) {
      return node.value + "%";
    },
    "visit_em": function(node) {
      return node.value + "em";
    },
    "visit_px": function(node) {
      return node.value + "px";
    },
    "visit_literal": function(node) {
      return visitor.visit_color(node.value, node);
    },
    "visit_hex": function(node) {
      return visitor.visit_color("#" + node.value, node);
    },
    "visit_rgb": function(node) {
      return visitor.visit_color("rgb(" + node.value.join(", ") + ")", node);
    },
    "visit_rgba": function(node) {
      return visitor.visit_color("rgba(" + node.value.join(", ") + ")", node);
    },
    "visit_color": function(resultColor, node) {
      var result = resultColor, length = visitor.visit(node.length);
      if (length) {
        result += " " + length;
      }
      return result;
    },
    "visit_angular": function(node) {
      return node.value + "deg";
    },
    "visit_directional": function(node) {
      return "to " + node.value;
    },
    "visit_array": function(elements) {
      var result = "", size = elements.length;
      elements.forEach(function(element, i2) {
        result += visitor.visit(element);
        if (i2 < size - 1) {
          result += ", ";
        }
      });
      return result;
    },
    "visit": function(element) {
      if (!element) {
        return "";
      }
      var result = "";
      if (element instanceof Array) {
        return visitor.visit_array(element, result);
      } else if (element.type) {
        var nodeVisitor = visitor["visit_" + element.type];
        if (nodeVisitor) {
          return nodeVisitor(element);
        } else {
          throw Error("Missing visitor visit_" + element.type);
        }
      } else {
        throw Error("Invalid node.");
      }
    }
  };
  return function(root2) {
    return visitor.visit(root2);
  };
}();
var GradientParser = GradientParser || {};
GradientParser.parse = function() {
  var tokens = {
    linearGradient: /^(\-(webkit|o|ms|moz)\-)?(linear\-gradient)/i,
    repeatingLinearGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-linear\-gradient)/i,
    radialGradient: /^(\-(webkit|o|ms|moz)\-)?(radial\-gradient)/i,
    repeatingRadialGradient: /^(\-(webkit|o|ms|moz)\-)?(repeating\-radial\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /^\#([0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^rgb/i,
    rgbaColor: /^rgba/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  var input2 = "";
  function error(msg) {
    var err = new Error(input2 + ": " + msg);
    err.source = input2;
    throw err;
  }
  function getAST() {
    var ast = matchListDefinitions();
    if (input2.length > 0) {
      error("Invalid input not EOF");
    }
    return ast;
  }
  function matchListDefinitions() {
    return matchListing(matchDefinition);
  }
  function matchDefinition() {
    return matchGradient(
      "linear-gradient",
      tokens.linearGradient,
      matchLinearOrientation
    ) || matchGradient(
      "repeating-linear-gradient",
      tokens.repeatingLinearGradient,
      matchLinearOrientation
    ) || matchGradient(
      "radial-gradient",
      tokens.radialGradient,
      matchListRadialOrientations
    ) || matchGradient(
      "repeating-radial-gradient",
      tokens.repeatingRadialGradient,
      matchListRadialOrientations
    );
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return matchCall(pattern, function(captures) {
      var orientation = orientationMatcher();
      if (orientation) {
        if (!scan(tokens.comma)) {
          error("Missing comma before color stops");
        }
      }
      return {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchCall(pattern, callback) {
    var captures = scan(pattern);
    if (captures) {
      if (!scan(tokens.startCall)) {
        error("Missing (");
      }
      var result = callback(captures);
      if (!scan(tokens.endCall)) {
        error("Missing )");
      }
      return result;
    }
  }
  function matchLinearOrientation() {
    return matchSideOrCorner() || matchAngle();
  }
  function matchSideOrCorner() {
    return match("directional", tokens.sideOrCorner, 1);
  }
  function matchAngle() {
    return match("angular", tokens.angleValue, 1);
  }
  function matchListRadialOrientations() {
    var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
    if (radialOrientation) {
      radialOrientations = [];
      radialOrientations.push(radialOrientation);
      lookaheadCache = input2;
      if (scan(tokens.comma)) {
        radialOrientation = matchRadialOrientation();
        if (radialOrientation) {
          radialOrientations.push(radialOrientation);
        } else {
          input2 = lookaheadCache;
        }
      }
    }
    return radialOrientations;
  }
  function matchRadialOrientation() {
    var radialType = matchCircle() || matchEllipse();
    if (radialType) {
      radialType.at = matchAtPosition();
    } else {
      var extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        var positionAt = matchAtPosition();
        if (positionAt) {
          radialType.at = positionAt;
        }
      } else {
        var defaultPosition = matchPositioning();
        if (defaultPosition) {
          radialType = {
            type: "default-radial",
            at: defaultPosition
          };
        }
      }
    }
    return radialType;
  }
  function matchCircle() {
    var circle = match("shape", /^(circle)/i, 0);
    if (circle) {
      circle.style = matchLength() || matchExtentKeyword();
    }
    return circle;
  }
  function matchEllipse() {
    var ellipse = match("shape", /^(ellipse)/i, 0);
    if (ellipse) {
      ellipse.style = matchDistance() || matchExtentKeyword();
    }
    return ellipse;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      var positioning = matchPositioning();
      if (!positioning) {
        error("Missing positioning value");
      }
      return positioning;
    }
  }
  function matchPositioning() {
    var location2 = matchCoordinates();
    if (location2.x || location2.y) {
      return {
        type: "position",
        value: location2
      };
    }
  }
  function matchCoordinates() {
    return {
      x: matchDistance(),
      y: matchDistance()
    };
  }
  function matchListing(matcher) {
    var captures = matcher(), result = [];
    if (captures) {
      result.push(captures);
      while (scan(tokens.comma)) {
        captures = matcher();
        if (captures) {
          result.push(captures);
        } else {
          error("One extra comma");
        }
      }
    }
    return result;
  }
  function matchColorStop() {
    var color = matchColor();
    if (!color) {
      error("Expected color definition");
    }
    color.length = matchDistance();
    return color;
  }
  function matchColor() {
    return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
  }
  function matchLiteralColor() {
    return match("literal", tokens.literalColor, 0);
  }
  function matchHexColor() {
    return match("hex", tokens.hexColor, 1);
  }
  function matchRGBColor() {
    return matchCall(tokens.rgbColor, function() {
      return {
        type: "rgb",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchRGBAColor() {
    return matchCall(tokens.rgbaColor, function() {
      return {
        type: "rgba",
        value: matchListing(matchNumber)
      };
    });
  }
  function matchNumber() {
    return scan(tokens.number)[1];
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || matchPositionKeyword() || matchLength();
  }
  function matchPositionKeyword() {
    return match("position-keyword", tokens.positionKeywords, 1);
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    var captures = scan(pattern);
    if (captures) {
      return {
        type,
        value: captures[captureIndex]
      };
    }
  }
  function scan(regexp) {
    var captures, blankCaptures;
    blankCaptures = /^[\n\r\t\s]+/.exec(input2);
    if (blankCaptures) {
      consume(blankCaptures[0].length);
    }
    captures = regexp.exec(input2);
    if (captures) {
      consume(captures[0].length);
    }
    return captures;
  }
  function consume(size) {
    input2 = input2.substr(size);
  }
  return function(code) {
    input2 = code.toString();
    return getAST();
  };
}();
var parse = GradientParser.parse;
var stringify2 = GradientParser.stringify;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a3, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a3, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a3, prop, b2[prop]);
    }
  return a3;
};
var __spreadProps = (a3, b2) => __defProps(a3, __getOwnPropDescs(b2));
var __publicField = (obj, key, value2) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
  return value2;
};
const double = (num) => {
  return Math.round(num * 100) / 100;
};
class Color {
  constructor(input2) {
    __publicField(this, "instance");
    __publicField(this, "alphaValue", 0);
    __publicField(this, "redValue", 0);
    __publicField(this, "greenValue", 0);
    __publicField(this, "blueValue", 0);
    __publicField(this, "hueValue", 0);
    __publicField(this, "saturationValue", 0);
    __publicField(this, "brightnessValue", 0);
    __publicField(this, "hslSaturationValue", 0);
    __publicField(this, "lightnessValue", 0);
    __publicField(this, "initAlpha", () => {
      const initAlpha = this.instance.getAlpha();
      this.alphaValue = Math.min(1, initAlpha) * 100;
    });
    __publicField(this, "initLightness", () => {
      const { s: s3, l: l2 } = this.instance.toHsl();
      this.hslSaturationValue = double(s3);
      this.lightnessValue = double(l2);
    });
    __publicField(this, "initRgb", () => {
      const { r: r2, g: g2, b: b2 } = this.instance.toRgb();
      this.redValue = double(r2);
      this.greenValue = double(g2);
      this.blueValue = double(b2);
    });
    __publicField(this, "initHsb", () => {
      const { h: h3, s: s3, v: v2 } = this.instance.toHsv();
      this.hueValue = Math.min(360, Math.ceil(h3));
      this.saturationValue = double(s3);
      this.brightnessValue = double(v2);
    });
    __publicField(this, "toHexString", () => {
      return this.instance.toHexString();
    });
    __publicField(this, "toRgbString", () => {
      return this.instance.toRgbString();
    });
    this.instance = tinycolor(input2);
    this.initRgb();
    this.initHsb();
    this.initLightness();
    this.initAlpha();
  }
  toString(format3) {
    return this.instance.toString(format3);
  }
  get hex() {
    return this.instance.toHex();
  }
  set hex(hexString) {
    this.instance = tinycolor(hexString);
    this.initHsb();
    this.initRgb();
    this.initAlpha();
    this.initLightness();
  }
  set hue(value2) {
    if (this.saturation === 0 && this.brightness === 0) {
      this.saturationValue = 1;
      this.brightnessValue = 1;
    }
    this.instance = tinycolor({
      h: double(value2),
      s: this.saturation,
      v: this.brightness,
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.hueValue = double(value2);
  }
  get hue() {
    return this.hueValue;
  }
  set saturation(value2) {
    this.instance = tinycolor({
      h: this.hue,
      s: double(value2),
      v: this.brightness,
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.saturationValue = double(value2);
  }
  get saturation() {
    return this.saturationValue;
  }
  set brightness(value2) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.saturation,
      v: double(value2),
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initLightness();
    this.brightnessValue = double(value2);
  }
  get brightness() {
    return this.brightnessValue;
  }
  set lightness(value2) {
    this.instance = tinycolor({
      h: this.hue,
      s: this.hslSaturationValue,
      l: double(value2),
      a: this.alphaValue / 100
    });
    this.initRgb();
    this.initHsb();
    this.lightnessValue = double(value2);
  }
  get lightness() {
    return this.lightnessValue;
  }
  set red(value2) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      r: double(value2),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.redValue = double(value2);
  }
  get red() {
    return this.redValue;
  }
  set green(value2) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      g: double(value2),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.greenValue = double(value2);
  }
  get green() {
    return this.greenValue;
  }
  set blue(value2) {
    const rgb = this.instance.toRgb();
    this.instance = tinycolor(__spreadProps(__spreadValues({}, rgb), {
      b: double(value2),
      a: this.alphaValue / 100
    }));
    this.initHsb();
    this.initLightness();
    this.blueValue = double(value2);
  }
  get blue() {
    return this.blueValue;
  }
  set alpha(value2) {
    this.instance.setAlpha(value2 / 100);
    this.alphaValue = value2;
  }
  get alpha() {
    return this.alphaValue;
  }
  get RGB() {
    return [this.red, this.green, this.blue, this.alpha / 100];
  }
  get HSB() {
    return [this.hue, this.saturation, this.brightness, this.alpha / 100];
  }
  get HSL() {
    return [this.hue, this.hslSaturationValue, this.lightness, this.alpha / 100];
  }
}
function rgbaColor(r2, g2, b2, a3) {
  return `rgba(${[r2, g2, b2, a3 / 100].join(",")})`;
}
const clamp = (value2, min2, max2) => {
  return min2 < max2 ? value2 < min2 ? min2 : value2 > max2 ? max2 : value2 : value2 < max2 ? max2 : value2 > min2 ? min2 : value2;
};
const HistoryColorKey = "color-history";
const MAX_STORAGE_LENGTH = 8;
var _export_sfc = (sfc, props2) => {
  for (const [key, val] of props2) {
    sfc[key] = val;
  }
  return sfc;
};
const _sfc_main$b = defineComponent({
  name: "Alpha",
  props: {
    color: z$1.instanceOf(Color),
    size: z$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props2.color || new Color();
    const state2 = reactive({
      red: color.red,
      green: color.green,
      blue: color.blue,
      alpha: color.alpha
    });
    watch(() => props2.color, (value2) => {
      if (value2) {
        color = value2;
        merge$1(state2, {
          red: value2.red,
          green: value2.green,
          blue: value2.blue,
          alpha: value2.alpha
        });
      }
    }, { deep: true });
    const getBackgroundStyle = computed(() => {
      const startColor = rgbaColor(state2.red, state2.green, state2.blue, 0);
      const endColor = rgbaColor(state2.red, state2.green, state2.blue, 100);
      return {
        background: `linear-gradient(to right, ${startColor} , ${endColor})`
      };
    });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const alpha = state2.alpha / 100;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left2 = getCursorLeft();
      return {
        left: left2 + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left2 = event.clientX - rect.left;
        left2 = Math.max(offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - offsetWidth / 2);
        const alpha = Math.round((left2 - offsetWidth / 2) / (rect.width - offsetWidth) * 100);
        color.alpha = alpha;
        state2.alpha = alpha;
        emit2("change", alpha);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        Vn.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
  }
});
const _withScopeId$5 = (n2) => (pushScopeId("data-v-18925ba6"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$a = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-alpha-slider__bar-handle" }, null, -1));
const _hoisted_2$a = [
  _hoisted_1$a
];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-alpha-slider", "transparent", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-alpha-slider__bar",
      style: normalizeStyle(_ctx.getBackgroundStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-alpha-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$a, 6)
    ], 4)
  ], 2);
}
var Alpha = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b], ["__scopeId", "data-v-18925ba6"]]);
const defaultColors = [
  [
    "#fcc02e",
    "#f67c01",
    "#e64a19",
    "#d81b43",
    "#8e24aa",
    "#512da7",
    "#1f87e8",
    "#008781",
    "#05a045"
  ],
  [
    "#fed835",
    "#fb8c00",
    "#f5511e",
    "#eb1d4e",
    "#9c28b1",
    "#5d35b0",
    "#2097f3",
    "#029688",
    "#4cb050"
  ],
  [
    "#ffeb3c",
    "#ffa727",
    "#fe5722",
    "#eb4165",
    "#aa47bc",
    "#673bb7",
    "#42a5f6",
    "#26a59a",
    "#83c683"
  ],
  [
    "#fff176",
    "#ffb74e",
    "#ff8a66",
    "#f1627e",
    "#b968c7",
    "#7986cc",
    "#64b5f6",
    "#80cbc4",
    "#a5d6a7"
  ],
  [
    "#fff59c",
    "#ffcc80",
    "#ffab91",
    "#fb879e",
    "#cf93d9",
    "#9ea8db",
    "#90caf8",
    "#b2dfdc",
    "#c8e6ca"
  ],
  [
    "transparent",
    "#ffffff",
    "#dedede",
    "#a9a9a9",
    "#4b4b4b",
    "#353535",
    "#212121",
    "#000000",
    "advance"
  ]
];
const _sfc_main$a = defineComponent({
  name: "Palette",
  emits: ["change"],
  setup(_props, { emit: emit2 }) {
    const computedBgStyle = (color) => {
      if (color === "transparent") {
        return color;
      }
      if (color === "advance") {
        return {};
      }
      return { background: tinycolor(color).toRgbString() };
    };
    const onColorChange = (color) => {
      emit2("change", color);
    };
    return { palettes: defaultColors, computedBgStyle, onColorChange };
  }
});
const _hoisted_1$9 = { class: "vc-compact" };
const _hoisted_2$9 = ["onClick"];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.palettes, (v2, i2) => {
      return openBlock(), createElementBlock("div", {
        key: i2,
        class: "vc-compact__row"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(v2, (v1, k2) => {
          return openBlock(), createElementBlock("div", {
            key: k2,
            class: "vc-compact__color-cube--wrap",
            onClick: ($event) => _ctx.onColorChange(v1)
          }, [
            createElementVNode("div", {
              class: normalizeClass([
                "vc-compact__color_cube",
                {
                  advance: v1 === "advance",
                  transparent: v1 === "transparent"
                }
              ]),
              style: normalizeStyle(_ctx.computedBgStyle(v1))
            }, null, 6)
          ], 8, _hoisted_2$9);
        }), 128))
      ]);
    }), 128))
  ]);
}
var Palette = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a], ["__scopeId", "data-v-b969fd48"]]);
const _sfc_main$9 = defineComponent({
  name: "Board",
  props: {
    color: z$1.instanceOf(Color),
    round: z$1.bool.def(false),
    hide: z$1.bool.def(true)
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    var _a, _b, _c;
    const instance = getCurrentInstance();
    const hueHsv = {
      h: ((_a = props2.color) == null ? void 0 : _a.hue) || 0,
      s: 1,
      v: 1
    };
    const hueColor = new Color(hueHsv).toHexString();
    const state2 = reactive({
      hueColor,
      saturation: ((_b = props2.color) == null ? void 0 : _b.saturation) || 0,
      brightness: ((_c = props2.color) == null ? void 0 : _c.brightness) || 0
    });
    const cursorTop = ref(0);
    const cursorLeft = ref(0);
    const cursorElement = ref();
    const boardElement = ref();
    const getCursorStyle = computed(() => {
      return {
        top: cursorTop.value + "px",
        left: cursorLeft.value + "px"
      };
    });
    const updatePosition = () => {
      if (instance) {
        const el = instance.vnode.el;
        cursorLeft.value = state2.saturation * (el == null ? void 0 : el.clientWidth);
        cursorTop.value = (1 - state2.brightness) * (el == null ? void 0 : el.clientHeight);
      }
    };
    const onClickBoard = (event) => {
      const target = event.target;
      if (target !== boardElement.value) {
        handleDrag(event);
      }
    };
    const handleDrag = (event) => {
      if (instance) {
        const el = instance.vnode.el;
        const rect = el == null ? void 0 : el.getBoundingClientRect();
        let left2 = event.clientX - rect.left;
        let top2 = event.clientY - rect.top;
        left2 = clamp(left2, 0, rect.width);
        top2 = clamp(top2, 0, rect.height);
        const saturation = left2 / rect.width;
        const bright = clamp(-(top2 / rect.height) + 1, 0, 1);
        cursorLeft.value = left2;
        cursorTop.value = top2;
        state2.saturation = saturation;
        state2.brightness = bright;
        emit2("change", saturation, bright);
      }
    };
    tryOnMounted(() => {
      if (instance && instance.vnode.el && cursorElement.value) {
        Vn.triggerDragEvent(cursorElement.value, {
          drag: (event) => {
            handleDrag(event);
          },
          end: (event) => {
            handleDrag(event);
          }
        });
        updatePosition();
      }
    });
    whenever(() => props2.color, (value2) => {
      merge$1(state2, {
        hueColor: new Color({ h: value2.hue, s: 1, v: 1 }).toHexString(),
        saturation: value2.saturation,
        brightness: value2.brightness
      });
      updatePosition();
    }, { deep: true });
    return { state: state2, cursorElement, getCursorStyle, onClickBoard };
  }
});
const _withScopeId$4 = (n2) => (pushScopeId("data-v-63803390"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__white" }, null, -1));
const _hoisted_2$8 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-saturation__black" }, null, -1));
const _hoisted_3$6 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("div", null, null, -1));
const _hoisted_4$5 = [
  _hoisted_3$6
];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "boardElement",
    class: normalizeClass(["vc-saturation", { "vc-saturation__chrome": _ctx.round, "vc-saturation__hidden": _ctx.hide }]),
    style: normalizeStyle({ backgroundColor: _ctx.state.hueColor }),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickBoard && _ctx.onClickBoard(...args))
  }, [
    _hoisted_1$8,
    _hoisted_2$8,
    createElementVNode("div", {
      class: "vc-saturation__cursor",
      ref: "cursorElement",
      style: normalizeStyle(_ctx.getCursorStyle)
    }, _hoisted_4$5, 4)
  ], 6);
}
var Board = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9], ["__scopeId", "data-v-63803390"]]);
const _sfc_main$8 = defineComponent({
  name: "Hue",
  props: {
    color: z$1.instanceOf(Color),
    size: z$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props2.color || new Color();
    const state2 = reactive({
      hue: color.hue || 0
    });
    watch(() => props2.color, (value2) => {
      if (value2) {
        color = value2;
        merge$1(state2, { hue: color.hue });
      }
    }, { deep: true });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        if (state2.hue === 360) {
          return rect.width - offsetWidth / 2;
        }
        return state2.hue % 360 * (rect.width - offsetWidth) / 360 + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left2 = getCursorLeft();
      return {
        left: left2 + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left2 = event.clientX - rect.left;
        left2 = Math.min(left2, rect.width - offsetWidth / 2);
        left2 = Math.max(offsetWidth / 2, left2);
        const hue = Math.round((left2 - offsetWidth / 2) / (rect.width - offsetWidth) * 360);
        color.hue = hue;
        state2.hue = hue;
        emit2("change", hue);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        Vn.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, onClickSider };
  }
});
const _withScopeId$3 = (n2) => (pushScopeId("data-v-5c4cae5b"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$7 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-hue-slider__bar-handle" }, null, -1));
const _hoisted_2$7 = [
  _hoisted_1$7
];
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-hue-slider", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-hue-slider__bar",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-hue-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$7, 6)
    ], 512)
  ], 2);
}
var Hue = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8], ["__scopeId", "data-v-5c4cae5b"]]);
const _sfc_main$7 = defineComponent({
  name: "Lightness",
  props: {
    color: z$1.instanceOf(Color),
    size: z$1.oneOf(["small", "default"]).def("default")
  },
  emits: ["change"],
  setup(props2, { emit: emit2 }) {
    const barElement = ref(null);
    const cursorElement = ref(null);
    let color = props2.color || new Color();
    const [h3, s3, l2] = color.HSL;
    const state2 = reactive({
      hue: h3,
      saturation: s3,
      lightness: l2
    });
    watch(() => props2.color, (value2) => {
      if (value2) {
        color = value2;
        const [hue, saturation, lightness] = color.HSL;
        merge$1(state2, {
          hue,
          saturation,
          lightness
        });
      }
    }, { deep: true });
    const getBackgroundStyle = computed(() => {
      const color1 = tinycolor({
        h: state2.hue,
        s: state2.saturation,
        l: 0.8
      }).toPercentageRgbString();
      const color2 = tinycolor({
        h: state2.hue,
        s: state2.saturation,
        l: 0.6
      }).toPercentageRgbString();
      const color3 = tinycolor({
        h: state2.hue,
        s: state2.saturation,
        l: 0.4
      }).toPercentageRgbString();
      const color4 = tinycolor({
        h: state2.hue,
        s: state2.saturation,
        l: 0.2
      }).toPercentageRgbString();
      return {
        background: [
          `-webkit-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
          `-moz-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`,
          `-ms-linear-gradient(left, rgb(255, 255, 255), ${color1}, ${color2}, ${color3}, ${color4}, rgb(0, 0, 0))`
        ]
      };
    });
    const getCursorLeft = () => {
      if (barElement.value && cursorElement.value) {
        const lightness = state2.lightness;
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        return (1 - lightness) * (rect.width - offsetWidth) + offsetWidth / 2;
      }
      return 0;
    };
    const getCursorStyle = computed(() => {
      const left2 = getCursorLeft();
      return {
        left: left2 + "px",
        top: 0
      };
    });
    const onClickSider = (event) => {
      const target = event.target;
      if (target !== barElement.value) {
        onMoveBar(event);
      }
    };
    const onMoveBar = (event) => {
      event.stopPropagation();
      if (barElement.value && cursorElement.value) {
        const rect = barElement.value.getBoundingClientRect();
        const offsetWidth = cursorElement.value.offsetWidth;
        let left2 = event.clientX - rect.left;
        left2 = Math.max(offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - offsetWidth / 2);
        const light = 1 - (left2 - offsetWidth / 2) / (rect.width - offsetWidth);
        color.lightness = light;
        emit2("change", light);
      }
    };
    tryOnMounted(() => {
      const dragConfig = {
        drag: (event) => {
          onMoveBar(event);
        },
        end: (event) => {
          onMoveBar(event);
        }
      };
      if (barElement.value && cursorElement.value) {
        Vn.triggerDragEvent(barElement.value, dragConfig);
      }
    });
    return { barElement, cursorElement, getCursorStyle, getBackgroundStyle, onClickSider };
  }
});
const _withScopeId$2 = (n2) => (pushScopeId("data-v-6156acb7"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$6 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("div", { class: "vc-lightness-slider__bar-handle" }, null, -1));
const _hoisted_2$6 = [
  _hoisted_1$6
];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["vc-lightness-slider", { "small-slider": _ctx.size === "small" }])
  }, [
    createElementVNode("div", {
      ref: "barElement",
      class: "vc-lightness-slider__bar",
      style: normalizeStyle(_ctx.getBackgroundStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickSider && _ctx.onClickSider(...args))
    }, [
      createElementVNode("div", {
        class: normalizeClass(["vc-lightness-slider__bar-pointer", { "small-bar": _ctx.size === "small" }]),
        ref: "cursorElement",
        style: normalizeStyle(_ctx.getCursorStyle)
      }, _hoisted_2$6, 6)
    ], 4)
  ], 2);
}
var Lightness = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7], ["__scopeId", "data-v-6156acb7"]]);
const _sfc_main$6 = defineComponent({
  name: "History",
  props: {
    colors: z$1.arrayOf(String).def(() => []),
    round: z$1.bool.def(false)
  },
  emits: ["change"],
  setup(_props, { emit: emit2 }) {
    const onColorSelect = (v2) => {
      emit2("change", v2);
    };
    return { onColorSelect };
  }
});
const _hoisted_1$5 = {
  key: 0,
  class: "vc-colorPicker__record"
};
const _hoisted_2$5 = { class: "color-list" };
const _hoisted_3$5 = ["onClick"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.colors && _ctx.colors.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$5, [
    createElementVNode("div", _hoisted_2$5, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colors, (v2, i2) => {
        return openBlock(), createElementBlock("div", {
          key: i2,
          class: normalizeClass(["color-item", "transparent", { "color-item__round": _ctx.round }]),
          onClick: ($event) => _ctx.onColorSelect(v2)
        }, [
          createElementVNode("div", {
            class: "color-item__display",
            style: normalizeStyle({ backgroundColor: v2 })
          }, null, 4)
        ], 10, _hoisted_3$5);
      }), 128))
    ])
  ])) : createCommentVNode("", true);
}
var History = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6], ["__scopeId", "data-v-7e6b67ca"]]);
const _sfc_main$5 = defineComponent({
  name: "Display",
  props: {
    color: z$1.instanceOf(Color),
    disableAlpha: z$1.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(props2, { emit: emit2 }) {
    var _a, _b, _c;
    const state2 = reactive({
      color: props2.color,
      previewBgColor: (_a = props2.color) == null ? void 0 : _a.toRgbString(),
      alpha: ((_b = props2.color) == null ? void 0 : _b.alpha) || 100,
      hex: (_c = props2.color) == null ? void 0 : _c.hex
    });
    const getBgColorStyle = computed(() => {
      return {
        background: state2.previewBgColor
      };
    });
    const onAlphaBlur = (evt) => {
      const target = evt.target;
      const opacity = parseInt(target.value.replace("%", ""));
      if (!isNaN(opacity) && state2.color) {
        state2.alpha = opacity;
        state2.color.alpha = opacity;
      }
    };
    const onInputChange2 = (event) => {
      const target = event.target;
      const hex = target.value.replace("#", "");
      if (tinycolor(hex).isValid() && state2.color) {
        state2.color.hex = hex;
      }
    };
    whenever(() => props2.color, (value2) => {
      if (value2) {
        state2.color = value2;
      }
    }, { deep: true });
    whenever(() => state2.color, () => {
      if (state2.color) {
        state2.previewBgColor = state2.color.toRgbString();
        state2.alpha = state2.color.alpha;
        state2.hex = state2.color.hex;
        emit2("update:color", state2.color);
        emit2("change", state2.color);
      }
    }, { deep: true });
    return { state: state2, getBgColorStyle, onAlphaBlur, onInputChange: onInputChange2 };
  }
});
const _hoisted_1$4 = { class: "vc-display" };
const _hoisted_2$4 = { class: "vc-current-color vc-transparent" };
const _hoisted_3$4 = { class: "vc-color-input" };
const _hoisted_4$4 = ["value"];
const _hoisted_5$4 = {
  key: 0,
  class: "vc-alpha-input"
};
const _hoisted_6$2 = ["value"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createElementVNode("div", _hoisted_2$4, [
      createElementVNode("div", {
        class: "color-cube",
        style: normalizeStyle(_ctx.getBgColorStyle)
      }, null, 4)
    ]),
    createElementVNode("div", _hoisted_3$4, [
      createElementVNode("input", {
        value: _ctx.state.hex,
        onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.onInputChange && _ctx.onInputChange(...args))
      }, null, 40, _hoisted_4$4)
    ]),
    !_ctx.disableAlpha ? (openBlock(), createElementBlock("div", _hoisted_5$4, [
      createElementVNode("input", {
        class: "vc-alpha-input__inner",
        value: _ctx.state.alpha + "%",
        onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onAlphaBlur && _ctx.onAlphaBlur(...args))
      }, null, 40, _hoisted_6$2)
    ])) : createCommentVNode("", true)
  ]);
}
var Display = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-0067da1d"]]);
const _sfc_main$4 = defineComponent({
  name: "FkColorPicker",
  components: { Display, Alpha, Palette, Board, Hue, Lightness, History },
  props: {
    color: z$1.instanceOf(Color),
    disableHistory: z$1.bool.def(false),
    roundHistory: z$1.bool.def(false),
    disableAlpha: z$1.bool.def(false)
  },
  emits: ["update:color", "change", "advanceChange"],
  setup(props2, { emit: emit2 }) {
    const colorInstance = props2.color || new Color();
    const state2 = reactive({
      color: colorInstance,
      hex: colorInstance.toHexString(),
      rgb: colorInstance.toRgbString()
    });
    const advancePanelShow = ref(false);
    const previewStyle = computed(() => {
      return { background: state2.rgb };
    });
    const onBack = () => {
      advancePanelShow.value = false;
      emit2("advanceChange", false);
    };
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props2.disableHistory) {
        return;
      }
      const rgbString = state2.color.toRgbString();
      historyColors.value = historyColors.value.filter((value2) => {
        return !tinycolor.equals(value2, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    const onCompactChange = (color) => {
      if (color === "advance") {
        advancePanelShow.value = true;
        emit2("advanceChange", true);
      } else {
        state2.color.hex = color;
        emit2("advanceChange", false);
      }
    };
    const onAlphaChange = (alpha) => {
      state2.color.alpha = alpha;
    };
    const onHueChange = (hue) => {
      state2.color.hue = hue;
    };
    const onBoardChange = (saturation, brightness) => {
      state2.color.saturation = saturation;
      state2.color.brightness = brightness;
    };
    const onLightChange = (light) => {
      state2.color.lightness = light;
    };
    const onInputChange2 = (event) => {
      const target = event.target;
      const hex = target.value.replace("#", "");
      if (tinycolor(hex).isValid()) {
        state2.color.hex = hex;
      }
    };
    whenever(() => props2.color, (value2) => {
      if (value2) {
        state2.color = value2;
      }
    }, { deep: true });
    whenever(() => state2.color, () => {
      state2.hex = state2.color.hex;
      state2.rgb = state2.color.toRgbString();
      updateColorHistoryFn();
      emit2("update:color", state2.color);
      emit2("change", state2.color);
    }, { deep: true });
    return {
      state: state2,
      advancePanelShow,
      onBack,
      onCompactChange,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onLightChange,
      onInputChange: onInputChange2,
      previewStyle,
      historyColors
    };
  }
});
const _withScopeId$1 = (n2) => (pushScopeId("data-v-592a5ec3"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$3 = { class: "vc-fk-colorPicker" };
const _hoisted_2$3 = { class: "vc-fk-colorPicker__inner" };
const _hoisted_3$3 = { class: "vc-fk-colorPicker__header" };
const _hoisted_4$3 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
const _hoisted_5$3 = [
  _hoisted_4$3
];
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Palette = resolveComponent("Palette");
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Lightness = resolveComponent("Lightness");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createElementVNode("div", _hoisted_2$3, [
      createElementVNode("div", _hoisted_3$3, [
        _ctx.advancePanelShow ? (openBlock(), createElementBlock("span", {
          key: 0,
          style: { "cursor": "pointer" },
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
        }, _hoisted_5$3)) : createCommentVNode("", true)
      ]),
      !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
        key: 0,
        onChange: _ctx.onCompactChange
      }, null, 8, ["onChange"])) : createCommentVNode("", true),
      _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
        key: 1,
        color: _ctx.state.color,
        onChange: _ctx.onBoardChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
        key: 2,
        color: _ctx.state.color,
        onChange: _ctx.onHueChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
        key: 3,
        color: _ctx.state.color,
        onChange: _ctx.onLightChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
        key: 4,
        color: _ctx.state.color,
        onChange: _ctx.onAlphaChange
      }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
      createVNode(_component_Display, {
        color: _ctx.state.color,
        "disable-alpha": _ctx.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
        key: 5,
        round: _ctx.roundHistory,
        colors: _ctx.historyColors,
        onChange: _ctx.onCompactChange
      }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
    ])
  ]);
}
var FkColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-592a5ec3"]]);
const _sfc_main$3 = defineComponent({
  name: "ChromeColorPicker",
  components: { Display, Alpha, Board, Hue, History },
  props: {
    color: z$1.instanceOf(Color),
    disableHistory: z$1.bool.def(false),
    roundHistory: z$1.bool.def(false),
    disableAlpha: z$1.bool.def(false)
  },
  emits: ["update:color", "change"],
  setup(props2, { emit: emit2 }) {
    const colorInstance = props2.color || new Color();
    const state2 = reactive({
      color: colorInstance,
      hex: colorInstance.toHexString(),
      rgb: colorInstance.toRgbString()
    });
    const previewStyle = computed(() => {
      return { background: state2.rgb };
    });
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props2.disableHistory) {
        return;
      }
      const rgbString = state2.color.toRgbString();
      historyColors.value = historyColors.value.filter((value2) => {
        return !tinycolor.equals(value2, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    const onAlphaChange = (alpha) => {
      state2.color.alpha = alpha;
    };
    const onHueChange = (hue) => {
      state2.color.hue = hue;
    };
    const onBoardChange = (saturation, brightness) => {
      state2.color.saturation = saturation;
      state2.color.brightness = brightness;
    };
    const onCompactChange = (color) => {
      if (color !== "advance") {
        state2.color.hex = color;
      }
    };
    whenever(() => props2.color, (value2) => {
      if (value2) {
        state2.color = value2;
      }
    }, { deep: true });
    whenever(() => state2.color, () => {
      state2.hex = state2.color.hex;
      state2.rgb = state2.color.toRgbString();
      updateColorHistoryFn();
      emit2("update:color", state2.color);
      emit2("change", state2.color);
    }, { deep: true });
    return {
      state: state2,
      previewStyle,
      historyColors,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onCompactChange
    };
  }
});
const _hoisted_1$2 = { class: "vc-chrome-colorPicker" };
const _hoisted_2$2 = { class: "vc-chrome-colorPicker-body" };
const _hoisted_3$2 = { class: "chrome-controls" };
const _hoisted_4$2 = { class: "chrome-color-wrap transparent" };
const _hoisted_5$2 = { class: "chrome-sliders" };
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    createVNode(_component_Board, {
      round: true,
      hide: false,
      color: _ctx.state.color,
      onChange: _ctx.onBoardChange
    }, null, 8, ["color", "onChange"]),
    createElementVNode("div", _hoisted_2$2, [
      createElementVNode("div", _hoisted_3$2, [
        createElementVNode("div", _hoisted_4$2, [
          createElementVNode("div", {
            class: "current-color",
            style: normalizeStyle(_ctx.previewStyle)
          }, null, 4)
        ]),
        createElementVNode("div", _hoisted_5$2, [
          createVNode(_component_Hue, {
            size: "small",
            color: _ctx.state.color,
            onChange: _ctx.onHueChange
          }, null, 8, ["color", "onChange"]),
          !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
            key: 0,
            size: "small",
            color: _ctx.state.color,
            onChange: _ctx.onAlphaChange
          }, null, 8, ["color", "onChange"])) : createCommentVNode("", true)
        ])
      ]),
      createVNode(_component_Display, {
        color: _ctx.state.color,
        "disable-alpha": _ctx.disableAlpha
      }, null, 8, ["color", "disable-alpha"]),
      !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
        key: 0,
        round: _ctx.roundHistory,
        colors: _ctx.historyColors,
        onChange: _ctx.onCompactChange
      }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
    ])
  ]);
}
var ChromeColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-61d7303b"]]);
const ColorPickerProviderKey = "Vue3ColorPickerProvider";
const _sfc_main$2 = defineComponent({
  name: "GradientColorPicker",
  components: { Angle, Display, Alpha, Palette, Board, Hue, Lightness, History },
  props: {
    startColor: z$1.instanceOf(Color).isRequired,
    endColor: z$1.instanceOf(Color).isRequired,
    startColorStop: z$1.number.def(0),
    endColorStop: z$1.number.def(100),
    angle: z$1.number.def(0),
    disableHistory: z$1.bool.def(false),
    roundHistory: z$1.bool.def(false),
    disableAlpha: z$1.bool.def(false)
  },
  emits: [
    "update:startColor",
    "update:endColor",
    "update:angle",
    "update:startColorStop",
    "update:endColorStop",
    "startColorChange",
    "endColorChange",
    "advanceChange",
    "angleChange",
    "startColorStopChange",
    "endColorStopChange"
  ],
  setup(props2, { emit: emit2 }) {
    const state2 = reactive({
      startActive: true,
      startColor: props2.startColor,
      endColor: props2.endColor,
      startColorStop: props2.startColorStop,
      endColorStop: props2.endColorStop,
      angle: props2.angle,
      startColorRgba: props2.startColor.toRgbString(),
      endColorRgba: props2.endColor.toRgbString()
    });
    const parent2 = inject(ColorPickerProviderKey);
    const advancePanelShow = ref(false);
    const startGradientRef = ref();
    const stopGradientRef = ref();
    const colorRangeRef = ref();
    const currentColor = computed({
      get: () => {
        return state2.startActive ? state2.startColor : state2.endColor;
      },
      set: (v2) => {
        if (state2.startActive) {
          state2.startColor = v2;
          return;
        }
        state2.endColor = v2;
      }
    });
    const getStartColorLeft = computed(() => {
      if (colorRangeRef.value && startGradientRef.value) {
        const alpha = state2.startColorStop / 100;
        const rect = colorRangeRef.value.getBoundingClientRect();
        const offsetWidth = startGradientRef.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const getEndColorLeft = computed(() => {
      if (colorRangeRef.value && stopGradientRef.value) {
        const alpha = state2.endColorStop / 100;
        const rect = colorRangeRef.value.getBoundingClientRect();
        const offsetWidth = stopGradientRef.value.offsetWidth;
        return Math.round(alpha * (rect.width - offsetWidth) + offsetWidth / 2);
      }
      return 0;
    });
    const gradientBg = computed(() => {
      return {
        background: `linear-gradient(${state2.angle}deg, ${state2.startColorRgba} ${state2.startColorStop}%, ${state2.endColorRgba} ${state2.endColorStop}%)`
      };
    });
    const dragStartRange = (evt) => {
      var _a;
      state2.startActive = true;
      if (colorRangeRef.value && startGradientRef.value) {
        const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
        let left2 = evt.clientX - rect.left;
        left2 = Math.max(startGradientRef.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - startGradientRef.value.offsetWidth / 2);
        state2.startColorStop = Math.round((left2 - startGradientRef.value.offsetWidth / 2) / (rect.width - startGradientRef.value.offsetWidth) * 100);
        emit2("update:startColorStop", state2.startColorStop);
        emit2("startColorStopChange", state2.startColorStop);
      }
    };
    const dragEndRange = (evt) => {
      var _a;
      state2.startActive = false;
      if (colorRangeRef.value && stopGradientRef.value) {
        const rect = (_a = colorRangeRef.value) == null ? void 0 : _a.getBoundingClientRect();
        let left2 = evt.clientX - rect.left;
        left2 = Math.max(stopGradientRef.value.offsetWidth / 2, left2);
        left2 = Math.min(left2, rect.width - stopGradientRef.value.offsetWidth / 2);
        state2.endColorStop = Math.round((left2 - stopGradientRef.value.offsetWidth / 2) / (rect.width - stopGradientRef.value.offsetWidth) * 100);
        emit2("update:endColorStop", state2.endColorStop);
        emit2("endColorStopChange", state2.endColorStop);
      }
    };
    const onDegreeBlur = (evt) => {
      const target = evt.target;
      const degree = parseInt(target.value.replace("\xB0", ""));
      if (!isNaN(degree)) {
        state2.angle = degree % 360;
      }
      emit2("update:angle", state2.angle);
      emit2("angleChange", state2.angle);
    };
    const onDegreeChange = (angle) => {
      state2.angle = angle;
      emit2("update:angle", state2.angle);
      emit2("angleChange", state2.angle);
    };
    const onCompactChange = (color) => {
      if (color === "advance") {
        advancePanelShow.value = true;
        emit2("advanceChange", true);
      } else {
        currentColor.value.hex = color;
        emit2("advanceChange", false);
      }
      doColorChange();
    };
    const onAlphaChange = (alpha) => {
      currentColor.value.alpha = alpha;
      doColorChange();
    };
    const onHueChange = (hue) => {
      currentColor.value.hue = hue;
      doColorChange();
    };
    const onBoardChange = (saturation, brightness) => {
      currentColor.value.saturation = saturation;
      currentColor.value.brightness = brightness;
      doColorChange();
    };
    const onLightChange = (light) => {
      currentColor.value.lightness = light;
      doColorChange();
    };
    const doColorChange = () => {
      if (state2.startActive) {
        emit2("update:startColor", state2.startColor);
        emit2("startColorChange", state2.startColor);
      } else {
        emit2("update:endColor", state2.endColor);
        emit2("endColorChange", state2.endColor);
      }
    };
    const onBack = () => {
      advancePanelShow.value = false;
      emit2("advanceChange", false);
    };
    const historyColors = useLocalStorage(HistoryColorKey, [], {});
    const updateColorHistoryFn = useDebounceFn(() => {
      if (props2.disableHistory) {
        return;
      }
      const rgbString = currentColor.value.toRgbString();
      historyColors.value = historyColors.value.filter((value2) => {
        return !tinycolor.equals(value2, rgbString);
      });
      if (historyColors.value.includes(rgbString)) {
        return;
      }
      while (historyColors.value.length > MAX_STORAGE_LENGTH) {
        historyColors.value.pop();
      }
      historyColors.value.unshift(rgbString);
    }, 500);
    tryOnMounted(() => {
      if (stopGradientRef.value && startGradientRef.value) {
        Vn.triggerDragEvent(stopGradientRef.value, {
          drag: (event) => {
            dragEndRange(event);
          },
          end: (event) => {
            dragEndRange(event);
          }
        });
        Vn.triggerDragEvent(startGradientRef.value, {
          drag: (event) => {
            dragStartRange(event);
          },
          end: (event) => {
            dragStartRange(event);
          }
        });
      }
    });
    whenever(() => state2.startColor, (value2) => {
      state2.startColorRgba = value2.toRgbString();
    }, { deep: true });
    whenever(() => state2.endColor, (value2) => {
      state2.endColorRgba = value2.toRgbString();
    }, { deep: true });
    whenever(() => currentColor.value, () => {
      updateColorHistoryFn();
    }, { deep: true });
    return {
      startGradientRef,
      stopGradientRef,
      colorRangeRef,
      state: state2,
      currentColor,
      getStartColorLeft,
      getEndColorLeft,
      gradientBg,
      advancePanelShow,
      onDegreeBlur,
      onCompactChange,
      onAlphaChange,
      onHueChange,
      onBoardChange,
      onLightChange,
      historyColors,
      onBack,
      onDegreeChange,
      lang: parent2 == null ? void 0 : parent2.lang
    };
  }
});
const _withScopeId = (n2) => (pushScopeId("data-v-f63daa7a"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$1 = { class: "vc-gradient-picker" };
const _hoisted_2$1 = { class: "vc-gradient-picker__header" };
const _hoisted_3$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("div", { class: "back" }, null, -1));
const _hoisted_4$1 = [
  _hoisted_3$1
];
const _hoisted_5$1 = { class: "vc-gradient-picker__body" };
const _hoisted_6$1 = {
  class: "vc-color-range",
  ref: "colorRangeRef"
};
const _hoisted_7 = { class: "vc-color-range__container" };
const _hoisted_8 = { class: "vc-gradient__stop__container" };
const _hoisted_9 = ["title"];
const _hoisted_10 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
const _hoisted_11 = [
  _hoisted_10
];
const _hoisted_12 = ["title"];
const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("span", { class: "vc-gradient__stop--inner" }, null, -1));
const _hoisted_14 = [
  _hoisted_13
];
const _hoisted_15 = { class: "vc-picker-degree-input vc-degree-input" };
const _hoisted_16 = { class: "vc-degree-input__control" };
const _hoisted_17 = ["value"];
const _hoisted_18 = { class: "vc-degree-input__panel" };
const _hoisted_19 = { class: "vc-degree-input__disk" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Angle = resolveComponent("Angle");
  const _component_Palette = resolveComponent("Palette");
  const _component_Board = resolveComponent("Board");
  const _component_Hue = resolveComponent("Hue");
  const _component_Lightness = resolveComponent("Lightness");
  const _component_Alpha = resolveComponent("Alpha");
  const _component_Display = resolveComponent("Display");
  const _component_History = resolveComponent("History");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    withDirectives(createElementVNode("div", _hoisted_2$1, [
      createElementVNode("span", {
        style: { "cursor": "pointer" },
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onBack && _ctx.onBack(...args))
      }, _hoisted_4$1)
    ], 512), [
      [vShow, _ctx.advancePanelShow]
    ]),
    createElementVNode("div", _hoisted_5$1, [
      createElementVNode("div", _hoisted_6$1, [
        createElementVNode("div", _hoisted_7, [
          createElementVNode("div", {
            class: "vc-background",
            style: normalizeStyle(_ctx.gradientBg)
          }, null, 4),
          createElementVNode("div", _hoisted_8, [
            createElementVNode("div", {
              class: normalizeClass([
                "vc-gradient__stop",
                {
                  "vc-gradient__stop--current": _ctx.state.startActive
                }
              ]),
              ref: "startGradientRef",
              title: _ctx.lang === "ZH-cn" ? "\u5F00\u59CB" : "Start",
              style: normalizeStyle({ left: _ctx.getStartColorLeft + "px" })
            }, _hoisted_11, 14, _hoisted_9),
            createElementVNode("div", {
              class: normalizeClass([
                "vc-gradient__stop",
                {
                  "vc-gradient__stop--current": !_ctx.state.startActive
                }
              ]),
              ref: "stopGradientRef",
              title: _ctx.lang === "ZH-cn" ? "\u7ED3\u675F" : "End",
              style: normalizeStyle({ left: _ctx.getEndColorLeft + "px" })
            }, _hoisted_14, 14, _hoisted_12)
          ])
        ])
      ], 512),
      createElementVNode("div", _hoisted_15, [
        createElementVNode("div", _hoisted_16, [
          createElementVNode("input", {
            value: _ctx.state.angle,
            onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.onDegreeBlur && _ctx.onDegreeBlur(...args))
          }, null, 40, _hoisted_17)
        ]),
        createElementVNode("div", _hoisted_18, [
          createElementVNode("div", _hoisted_19, [
            createVNode(_component_Angle, {
              angle: _ctx.state.angle,
              "onUpdate:angle": _cache[2] || (_cache[2] = ($event) => _ctx.state.angle = $event),
              size: 40,
              onChange: _ctx.onDegreeChange
            }, null, 8, ["angle", "onChange"])
          ])
        ])
      ])
    ]),
    !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Palette, {
      key: 0,
      onChange: _ctx.onCompactChange
    }, null, 8, ["onChange"])) : createCommentVNode("", true),
    _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Board, {
      key: 1,
      color: _ctx.currentColor,
      onChange: _ctx.onBoardChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    _ctx.advancePanelShow ? (openBlock(), createBlock(_component_Hue, {
      key: 2,
      color: _ctx.currentColor,
      onChange: _ctx.onHueChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    !_ctx.advancePanelShow ? (openBlock(), createBlock(_component_Lightness, {
      key: 3,
      color: _ctx.currentColor,
      onChange: _ctx.onLightChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    !_ctx.disableAlpha ? (openBlock(), createBlock(_component_Alpha, {
      key: 4,
      color: _ctx.currentColor,
      onChange: _ctx.onAlphaChange
    }, null, 8, ["color", "onChange"])) : createCommentVNode("", true),
    createVNode(_component_Display, {
      color: _ctx.currentColor,
      "disable-alpha": _ctx.disableAlpha
    }, null, 8, ["color", "disable-alpha"]),
    !_ctx.disableHistory ? (openBlock(), createBlock(_component_History, {
      key: 5,
      round: _ctx.roundHistory,
      colors: _ctx.historyColors,
      onChange: _ctx.onCompactChange
    }, null, 8, ["round", "colors", "onChange"])) : createCommentVNode("", true)
  ]);
}
var GradientColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2], ["__scopeId", "data-v-f63daa7a"]]);
const _sfc_main$1 = defineComponent({
  name: "WrapContainer",
  props: {
    showTab: z$1.bool.def(false),
    activeKey: z$1.oneOf(["pure", "gradient"]).def("pure")
  },
  emits: ["update:activeKey", "change"],
  setup(props2, { emit: emit2 }) {
    const state2 = reactive({
      activeKey: props2.activeKey
    });
    const parent2 = inject(ColorPickerProviderKey);
    const onActiveKeyChange = (key) => {
      state2.activeKey = key;
      emit2("update:activeKey", key);
      emit2("change", key);
    };
    whenever(() => props2.activeKey, (value2) => {
      state2.activeKey = value2;
    });
    return { state: state2, onActiveKeyChange, lang: parent2 == null ? void 0 : parent2.lang };
  }
});
const _hoisted_1 = { class: "vc-colorpicker" };
const _hoisted_2 = { class: "vc-colorpicker--container" };
const _hoisted_3 = {
  key: 0,
  class: "vc-colorpicker--tabs"
};
const _hoisted_4 = { class: "vc-colorpicker--tabs__inner" };
const _hoisted_5 = { class: "vc-btn__content" };
const _hoisted_6 = { class: "vc-btn__content" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    createElementVNode("div", _hoisted_2, [
      _ctx.showTab ? (openBlock(), createElementBlock("div", _hoisted_3, [
        createElementVNode("div", _hoisted_4, [
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _ctx.state.activeKey === "pure"
              }
            ]),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.onActiveKeyChange("pure"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", _hoisted_5, toDisplayString(_ctx.lang === "ZH-cn" ? "\u7EAF\u8272" : "Pure"), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: normalizeClass([
              "vc-colorpicker--tabs__btn",
              {
                "vc-btn-active": _ctx.state.activeKey === "gradient"
              }
            ]),
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.onActiveKeyChange("gradient"))
          }, [
            createElementVNode("button", null, [
              createElementVNode("div", _hoisted_6, toDisplayString(_ctx.lang === "ZH-cn" ? "\u6E10\u53D8\u8272" : "Gradient"), 1)
            ])
          ], 2),
          createElementVNode("div", {
            class: "vc-colorpicker--tabs__bg",
            style: normalizeStyle({
              width: `50%`,
              left: `calc(${_ctx.state.activeKey === "gradient" ? 50 : 0}%)`
            })
          }, null, 4)
        ])
      ])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])
  ]);
}
var WrapContainer = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-4afdf3bb"]]);
const colorPickerProps = {
  isWidget: z$1.bool.def(false),
  pickerType: z$1.oneOf(["fk", "chrome"]).def("fk"),
  shape: z$1.oneOf(["circle", "square"]).def("square"),
  pureColor: {
    type: [String, Object],
    default: "#000000"
  },
  gradientColor: z$1.string.def("#000"),
  format: {
    type: String,
    default: "rgb"
  },
  disableAlpha: z$1.bool.def(false),
  disableHistory: z$1.bool.def(false),
  roundHistory: z$1.bool.def(false),
  useType: z$1.oneOf(["pure", "gradient", "both"]).def("pure"),
  activeKey: z$1.oneOf(["pure", "gradient"]).def("pure"),
  lang: {
    type: String,
    default: "ZH-cn"
  },
  zIndex: z$1.number.def(9999)
};
const _sfc_main = defineComponent({
  name: "ColorPicker",
  components: { FkColorPicker, ChromeColorPicker, GradientColorPicker, WrapContainer },
  inheritAttrs: false,
  props: colorPickerProps,
  emits: [
    "update:pureColor",
    "pureColorChange",
    "update:gradientColor",
    "gradientColorChange",
    "update:activeKey",
    "activeKeyChange"
  ],
  setup(props2, { emit: emit2 }) {
    const state2 = reactive({
      pureColor: props2.pureColor || "",
      activeKey: props2.useType === "gradient" ? "gradient" : "pure",
      isAdvanceMode: false
    });
    provide(ColorPickerProviderKey, {
      lang: computed(() => props2.lang || "ZH-cn")
    });
    const instance = new Color(state2.pureColor);
    const colorInstance = ref(instance);
    const startColor = new Color("#000");
    const endColor = new Color("#000");
    const gradientState = reactive({
      startColor,
      endColor,
      startColorStop: 0,
      endColorStop: 100,
      angle: 0,
      gradientColor: props2.gradientColor
    });
    const showPicker = ref(false);
    const colorCubeRef = ref(null);
    const pickerRef = ref(null);
    const getBgColorStyle = computed(() => {
      const bgColor = state2.activeKey !== "gradient" ? tinycolor(state2.pureColor).toRgbString() : gradientState.gradientColor;
      return {
        background: bgColor
      };
    });
    const getComponentName = computed(() => {
      if (state2.activeKey === "gradient") {
        return GradientColorPicker.name;
      }
      return props2.pickerType === "fk" ? FkColorPicker.name : ChromeColorPicker.name;
    });
    const getBindArgs = computed(() => {
      if (state2.activeKey === "gradient") {
        return {
          startColor: gradientState.startColor,
          endColor: gradientState.endColor,
          onStartColorChange: (v2) => {
            gradientState.startColor = v2;
            onGradientChange();
          },
          onEndColorChange: (v2) => {
            gradientState.endColor = v2;
            onGradientChange();
          },
          angle: gradientState.angle,
          startColorStop: gradientState.startColorStop,
          endColorStop: gradientState.endColorStop,
          onStartColorStopChange: (v2) => {
            gradientState.startColorStop = v2;
            onGradientChange();
          },
          onEndColorStopChange: (v2) => {
            gradientState.endColorStop = v2;
            onGradientChange();
          },
          onAngleChange: (v2) => {
            gradientState.angle = v2;
            onGradientChange();
          },
          onAdvanceChange: (v2) => {
            state2.isAdvanceMode = v2;
          }
        };
      }
      return {
        disableAlpha: props2.disableAlpha,
        disableHistory: props2.disableHistory,
        roundHistory: props2.roundHistory,
        color: colorInstance.value,
        onChange: onColorChange,
        onAdvanceChange
      };
    });
    const onAdvanceChange = (isAdvance) => {
      state2.isAdvanceMode = isAdvance;
    };
    const onShowPicker = () => {
      showPicker.value = true;
    };
    const onHidePicker = () => {
      showPicker.value = false;
    };
    const parseGradientColor = () => {
      var _a, _b, _c, _d;
      try {
        const [colorNode] = parse(gradientState.gradientColor);
        if (colorNode && colorNode.type === "linear-gradient" && ((_a = colorNode.orientation) == null ? void 0 : _a.type) === "angular" && colorNode.colorStops.length >= 2) {
          const startColorVal = colorNode.colorStops[0];
          const endColorVal = colorNode.colorStops[1];
          gradientState.startColorStop = Number((_b = startColorVal.length) == null ? void 0 : _b.value) || 0;
          gradientState.endColorStop = Number((_c = endColorVal.length) == null ? void 0 : _c.value) || 0;
          gradientState.angle = Number((_d = colorNode.orientation) == null ? void 0 : _d.value) || 0;
          const [r2, g2, b2, a3] = startColorVal.value;
          const [r1, g1, b1, a1] = startColorVal.value;
          gradientState.startColor = new Color({
            r: Number(r2),
            g: Number(g2),
            b: Number(b2),
            a: Number(a3)
          });
          gradientState.startColor = new Color({
            r: Number(r1),
            g: Number(g1),
            b: Number(b1),
            a: Number(a1)
          });
        }
      } catch (e2) {
        console.log(`[Parse Color]: ${e2}`);
      }
    };
    const onGradientChange = () => {
      const nodes = color2GradientNode();
      try {
        gradientState.gradientColor = stringify2(nodes);
        emit2("update:gradientColor", gradientState.gradientColor);
        emit2("gradientColorChange", gradientState.gradientColor);
      } catch (e2) {
        console.log(e2);
      }
    };
    const color2GradientNode = () => {
      const nodes = [];
      const startColorArr = gradientState.startColor.RGB.map((v2) => v2.toString());
      const endColorArr = gradientState.endColor.RGB.map((v2) => v2.toString());
      nodes.push({
        type: "linear-gradient",
        orientation: { type: "angular", value: gradientState.angle + "" },
        colorStops: [
          {
            type: "rgba",
            value: [startColorArr[0], startColorArr[1], startColorArr[2], startColorArr[3]],
            length: { value: gradientState.startColorStop + "", type: "%" }
          },
          {
            type: "rgba",
            value: [endColorArr[0], endColorArr[1], endColorArr[2], endColorArr[3]],
            length: { value: gradientState.endColorStop + "", type: "%" }
          }
        ]
      });
      return nodes;
    };
    const onInit = () => {
      if (colorCubeRef.value && pickerRef.value) {
        createPopper(colorCubeRef.value, pickerRef.value, {
          placement: "auto",
          modifiers: [
            {
              name: "flip",
              options: {
                fallbackPlacements: ["top", "left"]
              }
            }
          ]
        });
      }
    };
    const onColorChange = (v2) => {
      colorInstance.value = v2;
      state2.pureColor = v2.toString(props2.format);
      emitColorChange();
    };
    const emitColorChange = () => {
      emit2("update:pureColor", state2.pureColor);
      emit2("pureColorChange", state2.pureColor);
    };
    onClickOutside(pickerRef, () => {
      onHidePicker();
    });
    const onActiveKeyChange = (key) => {
      state2.activeKey = key;
      emit2("update:activeKey", key);
      emit2("activeKeyChange", key);
    };
    tryOnMounted(() => {
      onInit();
      emitColorChange();
      parseGradientColor();
      onGradientChange();
    });
    whenever(() => props2.gradientColor, (value2) => {
      if (value2 != gradientState.gradientColor) {
        gradientState.gradientColor = value2;
      }
    });
    whenever(() => gradientState.gradientColor, () => {
      parseGradientColor();
    });
    whenever(() => props2.activeKey, (value2) => {
      state2.activeKey = value2;
    });
    whenever(() => props2.useType, (value2) => {
      if (state2.activeKey !== "gradient" && value2 === "gradient") {
        state2.activeKey = "gradient";
      } else {
        state2.activeKey = "pure";
      }
    });
    whenever(() => props2.pureColor, (value2) => {
      const equal2 = tinycolor.equals(value2, state2.pureColor);
      if (!equal2) {
        state2.pureColor = value2;
        colorInstance.value = new Color(value2);
        emitColorChange();
      }
    }, { deep: true });
    return {
      colorCubeRef,
      pickerRef,
      showPicker,
      colorInstance,
      getBgColorStyle,
      onColorChange,
      onShowPicker,
      onActiveKeyChange,
      getComponentName,
      getBindArgs,
      state: state2
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_WrapContainer = resolveComponent("WrapContainer");
  return openBlock(), createElementBlock(Fragment, null, [
    !_ctx.isWidget ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["vc-color-wrap", "transparent", { round: _ctx.shape === "circle" }]),
      ref: "colorCubeRef"
    }, [
      createElementVNode("div", {
        class: "current-color",
        style: normalizeStyle(_ctx.getBgColorStyle),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onShowPicker && _ctx.onShowPicker(...args))
      }, null, 4)
    ], 2)) : createCommentVNode("", true),
    _ctx.isWidget ? (openBlock(), createBlock(_component_WrapContainer, {
      key: 1,
      "active-key": _ctx.state.activeKey,
      "onUpdate:active-key": _cache[1] || (_cache[1] = ($event) => _ctx.state.activeKey = $event),
      "show-tab": _ctx.useType === "both",
      onChange: _ctx.onActiveKeyChange,
      style: normalizeStyle({ zIndex: _ctx.zIndex })
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
      ]),
      _: 1
    }, 8, ["active-key", "show-tab", "onChange", "style"])) : createCommentVNode("", true),
    !_ctx.isWidget ? (openBlock(), createBlock(Teleport, {
      key: 2,
      to: "body"
    }, [
      withDirectives(createElementVNode("div", {
        ref: "pickerRef",
        style: normalizeStyle({ zIndex: _ctx.zIndex })
      }, [
        _ctx.showPicker ? (openBlock(), createBlock(_component_WrapContainer, {
          key: 0,
          "show-tab": _ctx.useType === "both" && !_ctx.state.isAdvanceMode,
          "active-key": _ctx.state.activeKey,
          "onUpdate:active-key": _cache[2] || (_cache[2] = ($event) => _ctx.state.activeKey = $event),
          onChange: _ctx.onActiveKeyChange
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.getComponentName), mergeProps({ key: _ctx.getComponentName }, _ctx.getBindArgs), null, 16))
          ]),
          _: 1
        }, 8, ["show-tab", "active-key", "onChange"])) : createCommentVNode("", true)
      ], 4), [
        [vShow, _ctx.showPicker]
      ])
    ])) : createCommentVNode("", true)
  ], 64);
}
var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-0aa3a75d"]]);
const Vue3ColorPicker = {
  install: (app) => {
    app.component(ColorPicker.name, ColorPicker);
    app.component("Vue3" + ColorPicker.name, ColorPicker);
  }
};
const vue3PerfectScrollbar = "";
const index = "";
const style = "";
const custom = "";
const vueLifecycles = u$5({
  createApp,
  appOptions: {
    render() {
      return h$5(
        App,
        {
          customProps: {
            kanbanData: this.kanbanData
          }
        }
      );
    }
  },
  handleInstance: (app) => {
    app.directive("focus", {
      mounted(el) {
        el.focus();
      }
    });
    app.directive("autosize", {
      mounted(el) {
        if (el.tagName === "TEXTAREA")
          d$5(el);
      }
    });
    app.use(store);
    app.use(index$2);
    app.use(setup2, {}).component("DatePicker", script);
    app.use(src_default, {
      timeout: 4e3,
      hideProgressBar: true,
      showCloseButtonOnHover: true,
      icon: false
    });
    app.use(Vue3ColorPicker);
    {
      console.log({ "BASE_URL": "/", "MODE": "development", "DEV": true, "PROD": false });
    }
  }
});
defineRule("minLength", (value2, [limit]) => {
  if (value2.length < parseInt(limit)) {
    return `This field must be at least ${limit} character`;
  }
  return true;
});
const bootstrap = vueLifecycles.bootstrap;
const mount2 = vueLifecycles.mount;
const unmount = vueLifecycles.unmount;
export {
  bootstrap,
  mount2 as mount,
  unmount
};
//# sourceMappingURL=vue-mf-kanban.min.js.map
